Act as a senior TypeScript/Node/Next.js engineer. Improve my YouTube-to-shorts pipeline so all clips have excellent visual quality. Follow these rules strictly: never put comments in code, always wrap single if conditions in brackets with line breaks, keep code self-documenting.

Do the following changes exactly:

Install packages

npm i ffmpeg-static ffprobe-static


Add env var

YT_DLP_PATH=/usr/bin/yt-dlp


Replace the downloader with a function that always pulls the highest real quality (bestvideo+bestaudio up to 1080p60) and returns file path and selected format info. Create or update src/youtube.ts with this content:

import { spawn } from "node:child_process"
import { tmpdir } from "node:os"
import { join } from "node:path"

type DownloadInfo = {
  file: string
  height: number
  fps: number
  tbr: number
  vcodec: string
  acodec: string
}

function run(cmd: string, args: string[]): Promise<{ stdout: string, stderr: string }> {
  return new Promise((resolve, reject) => {
    const p = spawn(cmd, args, { stdio: ["ignore", "pipe", "pipe"] })
    let out = ""
    let err = ""
    p.stdout.on("data", d => out += d.toString())
    p.stderr.on("data", d => err += d.toString())
    p.on("close", code => {
      if (code === 0) {
        resolve({ stdout: out, stderr: err })
      } else {
        reject(new Error(err || `exit ${code}`))
      }
    })
  })
}

export async function downloadBest(url: string, cookiesPath?: string): Promise<DownloadInfo> {
  const outDir = tmpdir()
  const outTpl = join(outDir, "%(id)s.%(ext)s")
  const ytdlp = process.env.YT_DLP_PATH || "yt-dlp"
  const args = [
    "-j",
    "--no-simulate",
    "-f", "bv*[height<=1080][fps<=60]+ba/b",
    "-S", "res:1080,fps:60,br,codec",
    "--merge-output-format", "mkv,mp4",
    "-o", outTpl,
    url
  ]
  if (cookiesPath && cookiesPath.length > 0) {
    args.splice(1, 0, "--cookies", cookiesPath)
  }
  const { stdout } = await run(ytdlp, args)
  const lines = stdout.trim().split("\n")
  const last = JSON.parse(lines[lines.length - 1])
  const file = last["_filename"]
  const rf = (last["requested_formats"] && last["requested_formats"][0]) || last
  const height = Number(rf["height"] || 0)
  const fps = Number(rf["fps"] || 0)
  const tbr = Number(rf["tbr"] || 0)
  const vcodec = String(rf["vcodec"] || "")
  const acodec = String(rf["acodec"] || "")
  return { file, height, fps, tbr, vcodec, acodec }
}


Replace the rendering path with a high-quality 9:16 cut, no unnecessary upscaling, Lanczos scaling, x264 preset slow and CRF 16, AAC 192k, optional SRT burn-in. Create or update src/ffmpeg.ts with this content:

import ffmpegPath from "ffmpeg-static"
import ffprobePath from "ffprobe-static"
import { spawn } from "node:child_process"
import { promises as fs } from "node:fs"

type Probe = { width: number, height: number, fps: number }

function run(cmd: string, args: string[]): Promise<{ stdout: string, stderr: string }> {
  return new Promise((resolve, reject) => {
    const p = spawn(cmd, args, { stdio: ["ignore", "pipe", "pipe"] })
    let out = ""
    let err = ""
    p.stdout.on("data", d => out += d.toString())
    p.stderr.on("data", d => err += d.toString())
    p.on("close", code => {
      if (code === 0) {
        resolve({ stdout: out, stderr: err })
      } else {
        reject(new Error(err || `exit ${code}`))
      }
    })
  })
}

export async function probeVideo(file: string): Promise<Probe> {
  const args = [
    "-v", "error",
    "-select_streams", "v:0",
    "-show_entries", "stream=width,height,avg_frame_rate",
    "-of", "json",
    file
  ]
  const { stdout } = await run(ffprobePath as string, args)
  const j = JSON.parse(stdout)
  const s = j.streams[0]
  const fpsParts = String(s.avg_frame_rate || "0/1").split("/")
  const fps = Number(fpsParts[1] === "0" ? 0 : Number(fpsParts[0]) / Number(fpsParts[1]))
  return { width: Number(s.width), height: Number(s.height), fps }
}

function even(n: number): number {
  if (n % 2 === 0) {
    return n
  }
  return n - 1
}

function chooseTargetSize(srcW: number, srcH: number): { w: number, h: number } {
  let h = srcH
  if (h > 1920) {
    h = 1920
  }
  if (h < 720) {
    h = srcH
  }
  const w = even(Math.round(h * 9 / 16))
  return { w, h: even(h) }
}

function buildFilters(targetW: number, targetH: number): string {
  const scaleW = "if(gt(a,9/16),-2," + targetW + ")"
  const scaleH = "if(gt(a,9/16)," + targetH + ",-2)"
  const chain = [
    "scale=" + scaleW + ":" + scaleH + ":flags=lanczos+accurate_rnd+full_chroma_int",
    "crop=" + targetW + ":" + targetH + ":(in_w-out_w)/2:(in_h-out_h)/2",
    "format=yuv420p"
  ]
  return chain.join(",")
}

export async function renderClip(input: string, startSec: number, endSec: number, srtPath: string | null, outFile: string): Promise<void> {
  const p = await probeVideo(input)
  const tgt = chooseTargetSize(p.width, p.height)
  const filters = buildFilters(tgt.w, tgt.h)
  const vf = srtPath && srtPath.length > 0 ? filters + ",subtitles='" + srtPath.replace(/'/g, "\\'") + "'" : filters
  const dur = Math.max(0, endSec - startSec)
  const args = [
    "-ss", String(startSec),
    "-t", String(dur),
    "-i", input,
    "-vf", vf,
    "-c:v", "libx264",
    "-profile:v", "high",
    "-preset", "slow",
    "-crf", "16",
    "-pix_fmt", "yuv420p",
    "-c:a", "aac",
    "-b:a", "192k",
    "-movflags", "+faststart",
    outFile
  ]
  await run(ffmpegPath as string, args)
  await fs.stat(outFile)
}

export async function probeBitrate(file: string): Promise<{ size: number, seconds: number, kbps: number }> {
  const { stdout } = await run(ffprobePath as string, [
    "-v", "error",
    "-show_entries", "format=duration,size",
    "-of", "json",
    file
  ])
  const j = JSON.parse(stdout)
  const size = Number(j.format.size || 0)
  const seconds = Number(j.format.duration || 0)
  const kbps = seconds > 0 ? (size * 8) / seconds / 1000 : 0
  return { size, seconds, kbps }
}


Use these APIs inside the worker wherever we download and render clips. Update src/worker.ts to call the new functions in place of the old ones. Example usage:

import { downloadBest } from "./youtube"
import { renderClip, probeBitrate } from "./ffmpeg"

async function processOne(url: string, cookiesPath: string, segStart: number, segEnd: number, srtPath: string, outFile: string) {
  const info = await downloadBest(url, cookiesPath)
  if (info.file.length === 0) {
    throw new Error("no file")
  }
  const br = await probeBitrate(info.file)
  if (br.kbps < 1500) {
    throw new Error("low source bitrate")
  }
  await renderClip(info.file, segStart, segEnd, srtPath, outFile)
}


Acceptance criteria

For 1080p sources, the downloaded file reports multiple Mbps in probeBitrate.

Rendered vertical clips show crisp text and edges, with no banding, and file sizes consistent with CRF 16 and preset slow.

No double re-encode steps anywhere in the pipeline.

End of instructions.