{"file_contents":{"next-env.d.ts":{"content":"/// <reference types=\"next\" />\n/// <reference types=\"next/image-types/global\" />\n\n// NOTE: This file should not be edited\n// see https://nextjs.org/docs/basic-features/typescript for more information.\n","size_bytes":201},"next.config.js":{"content":"/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    serverActions: {\n      bodySizeLimit: '2mb'\n    }\n  },\n  eslint: {\n    ignoreDuringBuilds: true\n  }\n}\n\nmodule.exports = nextConfig\n","size_bytes":215},"postcss.config.js":{"content":"module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":82},"replit.md":{"content":"# YT Shortsmith\n\n## Overview\n\nYT Shortsmith is an AI-powered service that automatically generates short-form video clips from YouTube videos. It accepts a YouTube URL, downloads the source video, transcribes the audio, detects optimal segments for short-form content (20-60 seconds), converts them to 9:16 vertical format, adds subtitles, and scores each clip using AI criteria. The system is designed for creating engaging social media shorts optimized for platforms like TikTok, Instagram Reels, and YouTube Shorts.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\nCode style constraints:\n- Never add comments to code\n- Always put single if conditions inside brackets with line breaks\n- Focus on clean, self-documenting code\n\n## System Architecture\n\n### Frontend Architecture\n\n**Framework**: Next.js 14 with App Router\n- Server-side rendering and API routes integrated in a single application\n- TypeScript for type safety\n- TailwindCSS for styling with dark theme (gray-900 background)\n- Client-side state management using React hooks\n- API communication via fetch with RESTful endpoints\n\n**Routing Structure**:\n- `/` - Main dashboard listing all videos\n- `/videos/[id]` - Video detail page with generated clips\n- `/api/submit` - Accepts YouTube URLs and creates processing jobs\n- `/api/videos` - Lists videos with pagination and search\n- `/api/videos/[id]` - Returns video details with clips\n\n**Design Pattern**: The frontend uses client-side components ('use client') that communicate with Next.js API routes, which in turn interact with the backend services. No authentication is implemented.\n\n### Backend Architecture\n\n**Core Framework**: Node.js 20 with TypeScript\n\n**API Layer**: Next.js API routes under `/app/api` serving as REST endpoints\n\n**Worker Pattern**: Separate worker process (`src/worker.ts`) that processes video jobs asynchronously using BullMQ. The worker is run independently via `npm run worker` and handles the heavy video processing tasks.\n\n**Service Layer Architecture**:\n- `youtube.ts` - Handles video metadata extraction and downloading via yt-dlp/youtube-dl\n- `ffmpeg.ts` - Video processing (audio extraction, scene detection, vertical clip rendering, subtitle burning)\n- `openai.ts` - Whisper transcription and GPT-based clip scoring/categorization\n- `segmentation.ts` - Intelligent segment detection combining pause detection, scene changes, and duration constraints\n- `s3.ts` - File uploads to S3-compatible storage\n- `queue.ts` - BullMQ queue configuration with Redis connection\n- `prisma.ts` - Database client singleton\n\n**Processing Pipeline**:\n1. User submits YouTube URL → API creates video record → Job enqueued\n2. Worker picks up job → Downloads video with yt-dlp → Saves to temp directory\n3. Extract audio → Transcribe with Whisper API (word-level timestamps)\n4. Detect segments using:\n   - Voice activity and pause gaps (0.35-0.9s gaps between words)\n   - Scene changes from ffmpeg (threshold > 0.3)\n   - Duration constraints (20-60 seconds, preferring 25-45 seconds)\n   - Hook quality (first 3 seconds of speech)\n5. For each segment:\n   - Convert to 9:16 vertical format with smart cropping\n   - Burn subtitles from transcript\n   - Generate and overlay hook text\n   - Extract thumbnail\n   - Create SRT file\n   - Upload all assets to S3\n6. Score clips with AI rubric (hook, retention, clarity, shareability)\n7. Store clip metadata in database\n\n**Data Models** (Prisma):\n- `Video` - Source video metadata (title, URL, duration, status)\n- `Clip` - Generated short clips with scores, categories, S3 keys, and timing information\n\n### External Dependencies\n\n**Database**: \n- PostgreSQL via Prisma ORM\n- Schema managed through Prisma migrations\n- Connection via DATABASE_URL environment variable\n\n**Queue System**:\n- Redis for BullMQ job queue\n- Handles asynchronous video processing jobs\n- Connection via REDIS_URL environment variable\n\n**AI Services** (OpenAI):\n- Whisper API for audio transcription with word-level timestamps\n- GPT-4o (or better) for clip categorization and scoring\n- Requires OPENAI_API_KEY environment variable\n\n**Video Processing**:\n- ffmpeg via fluent-ffmpeg library for video manipulation\n- ffmpeg-static provides bundled ffmpeg binary\n- yt-dlp (or youtube-dl fallback) for downloading YouTube videos\n- Configurable via YT_DLP_PATH environment variable\n\n**Object Storage** (S3-compatible):\n- AWS SDK v3 (@aws-sdk/client-s3)\n- Supports AWS S3, Cloudflare R2, or any S3-compatible service\n- Stores rendered clips, thumbnails, and SRT subtitle files\n- Configuration via S3_ENDPOINT, S3_REGION, S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY, S3_BUCKET\n\n**Required Environment Variables**:\n```\nOPENAI_API_KEY\nREDIS_URL\nDATABASE_URL\nS3_ENDPOINT\nS3_REGION\nS3_ACCESS_KEY_ID\nS3_SECRET_ACCESS_KEY\nS3_BUCKET\nYT_DLP_PATH (optional, defaults to system PATH)\n```\n\n**Deployment Considerations**:\n- Next.js app runs on port 5000 (configurable)\n- Worker process runs separately and must be started independently\n- ESLint disabled during builds for faster deployment\n- Server actions body size limit set to 2MB\n- TypeScript strict mode enabled","size_bytes":5122},"tailwind.config.ts":{"content":"import type { Config } from 'tailwindcss'\n\nconst config: Config = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\nexport default config\n","size_bytes":280},"app/globals.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\nbody {\n  @apply bg-gray-900 text-white;\n}\n","size_bytes":102},"app/layout.tsx":{"content":"import type { Metadata } from 'next'\nimport { Inter } from 'next/font/google'\nimport './globals.css'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata: Metadata = {\n  title: 'YT Shortsmith',\n  description: 'AI-powered short-form video clip generator',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>{children}</body>\n    </html>\n  )\n}\n","size_bytes":468},"app/page.tsx":{"content":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport Link from 'next/link'\nimport { useRouter } from 'next/navigation'\n\ninterface Video {\n  id: string\n  title: string\n  sourceUrl: string\n  status: string\n  durationSec: number\n  createdAt: string\n  _count: {\n    clips: number\n  }\n}\n\nexport default function Home() {\n  const [url, setUrl] = useState('')\n  const [loading, setLoading] = useState(false)\n  const [videos, setVideos] = useState<Video[]>([])\n  const [error, setError] = useState('')\n  const [authStatus, setAuthStatus] = useState<any>(null)\n  const router = useRouter()\n\n  useEffect(() => {\n    checkAuth()\n  }, [])\n\n  async function checkAuth() {\n    try {\n      const res = await fetch('/api/auth/status')\n      const data = await res.json()\n      setAuthStatus(data)\n      \n      if (!data.isAuthenticated || !data.youtubeConnected)\n      {\n        router.push('/login')\n      }\n      else\n      {\n        fetchVideos()\n      }\n    }\n    catch (err) {\n      console.error('Failed to check auth:', err)\n      router.push('/login')\n    }\n  }\n\n  async function fetchVideos() {\n    try {\n      const response = await fetch('/api/videos')\n      const data = await response.json()\n      \n      if (response.ok) {\n        setVideos(data.videos)\n      }\n    }\n    catch (err) {\n      console.error('Error fetching videos:', err)\n    }\n  }\n\n  async function handleSubmit(e: React.FormEvent) {\n    e.preventDefault()\n    setLoading(true)\n    setError('')\n\n    try {\n      const response = await fetch('/api/submit', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ url })\n      })\n\n      const data = await response.json()\n\n      if (response.ok) {\n        setUrl('')\n        fetchVideos()\n      }\n      else {\n        setError(data.error || 'Failed to submit video')\n      }\n    }\n    catch (err) {\n      setError('Failed to submit video')\n    }\n    finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleLogout() {\n    try {\n      await fetch('/api/auth/logout', { method: 'POST' })\n      router.push('/login')\n    }\n    catch (err) {\n      console.error('Failed to logout:', err)\n    }\n  }\n\n  if (!authStatus)\n  {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"text-gray-400\">Loading...</div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-h-screen p-8\">\n      <div className=\"max-w-6xl mx-auto\">\n        <div className=\"flex justify-between items-center mb-8\">\n          <h1 className=\"text-4xl font-bold\">YT Shortsmith</h1>\n          <div className=\"flex items-center gap-4\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-2 h-2 bg-green-500 rounded-full\"></div>\n              <span className=\"text-sm text-gray-400\">YouTube Connected</span>\n            </div>\n            <button\n              onClick={handleLogout}\n              className=\"px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm\"\n            >\n              Logout\n            </button>\n          </div>\n        </div>\n        \n        <div className=\"bg-gray-800 p-6 rounded-lg mb-8\">\n          <h2 className=\"text-xl font-semibold mb-4\">Submit YouTube Video</h2>\n          <form onSubmit={handleSubmit} className=\"flex gap-4\">\n            <input\n              type=\"text\"\n              value={url}\n              onChange={(e) => setUrl(e.target.value)}\n              placeholder=\"Enter YouTube URL\"\n              className=\"flex-1 px-4 py-2 bg-gray-700 rounded border border-gray-600 focus:outline-none focus:border-blue-500\"\n              disabled={loading}\n            />\n            <button\n              type=\"submit\"\n              disabled={loading || !url}\n              className=\"px-6 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded font-semibold\"\n            >\n              {\n                loading ? 'Submitting...' : 'Submit'\n              }\n            </button>\n          </form>\n          {\n            error && (\n              <p className=\"text-red-500 mt-2\">{error}</p>\n            )\n          }\n        </div>\n\n        <div className=\"bg-gray-800 p-6 rounded-lg\">\n          <h2 className=\"text-xl font-semibold mb-4\">Videos</h2>\n          <div className=\"overflow-x-auto\">\n            <table className=\"w-full\">\n              <thead>\n                <tr className=\"border-b border-gray-700\">\n                  <th className=\"text-left py-2 px-4\">Title</th>\n                  <th className=\"text-left py-2 px-4\">Status</th>\n                  <th className=\"text-left py-2 px-4\">Clips</th>\n                  <th className=\"text-left py-2 px-4\">Duration</th>\n                  <th className=\"text-left py-2 px-4\">Created</th>\n                  <th className=\"text-left py-2 px-4\">Actions</th>\n                </tr>\n              </thead>\n              <tbody>\n                {\n                  videos.map((video) => (\n                    <tr key={video.id} className=\"border-b border-gray-700\">\n                      <td className=\"py-3 px-4\">{video.title}</td>\n                      <td className=\"py-3 px-4\">\n                        <span className={`px-2 py-1 rounded text-xs ${\n                          video.status === 'completed' ? 'bg-green-600' :\n                          video.status === 'processing' ? 'bg-blue-600' :\n                          video.status === 'failed' ? 'bg-red-600' :\n                          'bg-gray-600'\n                        }`}>\n                          {video.status}\n                        </span>\n                      </td>\n                      <td className=\"py-3 px-4\">{video._count.clips}</td>\n                      <td className=\"py-3 px-4\">{Math.floor(video.durationSec / 60)}m</td>\n                      <td className=\"py-3 px-4\">\n                        {new Date(video.createdAt).toLocaleDateString()}\n                      </td>\n                      <td className=\"py-3 px-4\">\n                        <Link\n                          href={`/videos/${video.id}`}\n                          className=\"text-blue-400 hover:text-blue-300\"\n                        >\n                          View\n                        </Link>\n                      </td>\n                    </tr>\n                  ))\n                }\n              </tbody>\n            </table>\n            {\n              videos.length === 0 && (\n                <div className=\"text-center py-8 text-gray-400\">\n                  No videos yet. Submit a YouTube URL to get started.\n                </div>\n              )\n            }\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","size_bytes":6654},"src/worker.ts":{"content":"import { Worker, Job } from 'bullmq'\nimport { connection } from './lib/queue'\nimport { prisma } from './lib/prisma'\nimport { getVideoMetadata, downloadVideo } from './services/youtube'\nimport { extractAudio, renderVerticalClip, extractThumbnail, createSrtFile, detectScenes } from './services/ffmpeg'\nimport { transcribeAudio } from './services/openai'\nimport { scoreClip } from './services/openai'\nimport { detectSegments } from './services/segmentation'\nimport { uploadFile } from './services/s3'\nimport { join } from 'path'\nimport { mkdirSync, existsSync, rmSync } from 'fs'\nimport { tmpdir } from 'os'\n\ninterface VideoJob {\n  videoId: string\n}\n\nasync function processVideo(job: Job<VideoJob>) {\n  const { videoId } = job.data\n  \n  await prisma.video.update({\n    where: { id: videoId },\n    data: { status: 'processing' }\n  })\n  \n  const video = await prisma.video.findUnique({\n    where: { id: videoId }\n  })\n  \n  if (!video)\n  {\n    throw new Error(`Video ${videoId} not found`)\n  }\n  \n  const workDir = join(tmpdir(), `video_${videoId}`)\n  \n  if (!existsSync(workDir))\n  {\n    mkdirSync(workDir, { recursive: true })\n  }\n  \n  try {\n    const videoPath = join(workDir, 'source.mp4')\n    const audioPath = join(workDir, 'audio.mp3')\n    \n    console.log(`Downloading video: ${video.sourceUrl}`)\n    await downloadVideo(video.sourceUrl, videoPath)\n    \n    console.log(`Extracting audio`)\n    await extractAudio(videoPath, audioPath)\n    \n    console.log(`Transcribing audio`)\n    const transcript = await transcribeAudio(audioPath)\n    \n    await prisma.video.update({\n      where: { id: videoId },\n      data: { transcript: transcript as any }\n    })\n    \n    console.log(`Detecting scene changes`)\n    const sceneChanges = await detectScenes(videoPath)\n    console.log(`Found ${sceneChanges.length} scene changes`)\n    \n    console.log(`Detecting segments`)\n    const segments = detectSegments(transcript, sceneChanges)\n    \n    console.log(`Found ${segments.length} candidate segments`)\n    \n    for (let i = 0; i < segments.length; i++)\n    {\n      const segment = segments[i]\n      \n      console.log(`Processing segment ${i + 1}/${segments.length}`)\n      \n      const clipId = `${videoId}_${i}`\n      const clipDir = join(workDir, `clip_${i}`)\n      \n      if (!existsSync(clipDir))\n      {\n        mkdirSync(clipDir, { recursive: true })\n      }\n      \n      const clipPath = join(clipDir, 'clip.mp4')\n      const thumbPath = join(clipDir, 'thumb.jpg')\n      const srtPath = join(clipDir, 'clip.srt')\n      \n      createSrtFile(segment.words, srtPath)\n      \n      await renderVerticalClip({\n        inputPath: videoPath,\n        outputPath: clipPath,\n        startTime: segment.startSec,\n        duration: segment.durationSec,\n        srtPath,\n        hookText: segment.hook\n      })\n      \n      await extractThumbnail(clipPath, thumbPath, 1)\n      \n      console.log(`Scoring segment ${i + 1}`)\n      const scores = await scoreClip(video.title, segment.hook, segment.text)\n      \n      const s3VideoKey = `videos/${videoId}/clips/${clipId}/clip.mp4`\n      const s3ThumbKey = `videos/${videoId}/clips/${clipId}/thumb.jpg`\n      const s3SrtKey = `videos/${videoId}/clips/${clipId}/clip.srt`\n      \n      console.log(`Uploading to S3`)\n      await uploadFile(s3VideoKey, clipPath, 'video/mp4')\n      await uploadFile(s3ThumbKey, thumbPath, 'image/jpeg')\n      await uploadFile(s3SrtKey, srtPath, 'text/plain')\n      \n      await prisma.clip.create({\n        data: {\n          id: clipId,\n          videoId,\n          startSec: Math.floor(segment.startSec),\n          endSec: Math.floor(segment.endSec),\n          durationSec: Math.floor(segment.durationSec),\n          category: scores.category,\n          tags: scores.tags,\n          scoreHook: scores.scores.hook_strength,\n          scoreRetention: scores.scores.retention_likelihood,\n          scoreClarity: scores.scores.clarity,\n          scoreShare: scores.scores.shareability,\n          scoreOverall: scores.scores.overall,\n          rationale: scores.rationale,\n          s3VideoKey,\n          s3ThumbKey,\n          s3SrtKey\n        }\n      })\n      \n      console.log(`Segment ${i + 1} completed`)\n    }\n    \n    await prisma.video.update({\n      where: { id: videoId },\n      data: { status: 'completed' }\n    })\n    \n    console.log(`Video ${videoId} processing completed`)\n  }\n  catch (error) {\n    console.error(`Error processing video ${videoId}:`, error)\n    \n    await prisma.video.update({\n      where: { id: videoId },\n      data: { status: 'failed' }\n    })\n    \n    throw error\n  }\n  finally {\n    if (existsSync(workDir))\n    {\n      rmSync(workDir, { recursive: true, force: true })\n    }\n  }\n}\n\nconst worker = new Worker<VideoJob>('video.process', processVideo, {\n  connection,\n  concurrency: 1\n})\n\nworker.on('completed', (job) => {\n  console.log(`Job ${job.id} completed`)\n})\n\nworker.on('failed', (job, err) => {\n  console.error(`Job ${job?.id} failed:`, err)\n})\n\nconsole.log('Worker started')\n","size_bytes":4981},"app/login/page.tsx":{"content":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\n\nexport default function LoginPage() {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState('')\n  const [status, setStatus] = useState<any>(null)\n  const router = useRouter()\n\n  useEffect(() => {\n    checkStatus()\n  }, [])\n\n  async function checkStatus() {\n    try {\n      const res = await fetch('/api/auth/status')\n      const data = await res.json()\n      setStatus(data)\n      \n      if (data.isAuthenticated)\n      {\n        router.push('/')\n      }\n    }\n    catch (err) {\n      console.error('Failed to check auth status:', err)\n    }\n  }\n\n  async function handleLogin() {\n    setLoading(true)\n    setError('')\n    \n    try {\n      const res = await fetch('/api/auth/login', {\n        method: 'POST'\n      })\n      \n      const data = await res.json()\n      \n      if (!res.ok)\n      {\n        throw new Error(data.error || 'Login failed')\n      }\n      \n      router.push('/')\n    }\n    catch (err: any) {\n      setError(err.message || 'Failed to login with YouTube')\n    }\n    finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-900 text-white flex items-center justify-center p-4\">\n      <div className=\"max-w-md w-full bg-gray-800 rounded-lg shadow-xl p-8\">\n        <h1 className=\"text-3xl font-bold mb-2\">YT Shortsmith</h1>\n        <p className=\"text-gray-400 mb-8\">Sign in to continue</p>\n        \n        {status && !status.youtubeConnected && (\n          <div className=\"mb-6 p-4 bg-yellow-900/50 border border-yellow-700 rounded-lg\">\n            <p className=\"text-yellow-200 text-sm\">\n              YouTube connector not set up. Please configure the YouTube integration in your Replit project settings.\n            </p>\n          </div>\n        )}\n        \n        {error && (\n          <div className=\"mb-6 p-4 bg-red-900/50 border border-red-700 rounded-lg\">\n            <p className=\"text-red-200 text-sm\">{error}</p>\n          </div>\n        )}\n        \n        <button\n          onClick={handleLogin}\n          disabled={loading || (status && !status.youtubeConnected)}\n          className=\"w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2\"\n        >\n          {loading ? (\n            'Signing in...'\n          ) : (\n            <>\n              <svg className=\"w-5 h-5\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                <path d=\"M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z\"/>\n              </svg>\n              Sign in with YouTube\n            </>\n          )}\n        </button>\n        \n        <div className=\"mt-8 pt-6 border-t border-gray-700\">\n          <h2 className=\"font-semibold mb-2\">Privacy Notice</h2>\n          <p className=\"text-sm text-gray-400 mb-3\">\n            This application uses YouTube OAuth 2.0 for secure authentication. We:\n          </p>\n          <ul className=\"text-sm text-gray-400 space-y-1 list-disc list-inside\">\n            <li>Never ask for or store your Google password</li>\n            <li>Only access YouTube data with your permission</li>\n            <li>Store authentication tokens securely</li>\n            <li>Use HTTPS for all communications</li>\n          </ul>\n        </div>\n      </div>\n    </div>\n  )\n}\n","size_bytes":3706},"src/lib/prisma.ts":{"content":"import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma\n}\n","size_bytes":285},"src/lib/queue.ts":{"content":"import { Queue, QueueOptions } from 'bullmq'\nimport IORedis from 'ioredis'\n\nconst connection = new IORedis(process.env.REDIS_URL || 'redis://localhost:6379', {\n  maxRetriesPerRequest: null\n})\n\nconst queueOptions: QueueOptions = {\n  connection\n}\n\nexport const videoQueue = new Queue('video.process', queueOptions)\n\nexport { connection }\n","size_bytes":336},"src/lib/rate-limit.ts":{"content":"import rateLimit from 'express-rate-limit'\n\nexport const apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  standardHeaders: true,\n  legacyHeaders: false,\n  message: 'Too many requests from this IP, please try again later.'\n})\n\nexport const authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  standardHeaders: true,\n  legacyHeaders: false,\n  message: 'Too many authentication attempts, please try again later.'\n})\n","size_bytes":444},"src/lib/session.ts":{"content":"import { getIronSession } from 'iron-session'\nimport { cookies } from 'next/headers'\n\nexport interface SessionData {\n  isAuthenticated: boolean\n  userId?: string\n  email?: string\n}\n\nexport async function getSession() {\n  const sessionCookies = await cookies()\n  \n  return getIronSession<SessionData>(sessionCookies, {\n    password: process.env.SESSION_SECRET || 'complex_password_at_least_32_characters_long_for_session_security',\n    cookieName: 'yt_shortsmith_session',\n    cookieOptions: {\n      secure: process.env.NODE_ENV === 'production',\n      httpOnly: true,\n      sameSite: 'lax',\n      maxAge: 60 * 60 * 24 * 7,\n      path: '/'\n    }\n  })\n}\n\nexport async function requireAuth() {\n  const session = await getSession()\n  \n  if (!session.isAuthenticated)\n  {\n    throw new Error('Authentication required')\n  }\n  \n  return session\n}\n","size_bytes":840},"src/lib/youtube-client.ts":{"content":"import { google } from 'googleapis'\n\nlet connectionSettings: any\n\nasync function getAccessToken() {\n  if (connectionSettings && connectionSettings.settings.expires_at && new Date(connectionSettings.settings.expires_at).getTime() > Date.now())\n  {\n    return connectionSettings.settings.access_token\n  }\n  \n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME\n  const xReplitToken = process.env.REPL_IDENTITY \n    ? 'repl ' + process.env.REPL_IDENTITY \n    : process.env.WEB_REPL_RENEWAL \n    ? 'depl ' + process.env.WEB_REPL_RENEWAL \n    : null\n\n  if (!xReplitToken)\n  {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl')\n  }\n\n  connectionSettings = await fetch(\n    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=youtube',\n    {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    }\n  ).then(res => res.json()).then(data => data.items?.[0])\n\n  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token\n\n  if (!connectionSettings || !accessToken)\n  {\n    throw new Error('YouTube not connected')\n  }\n  return accessToken\n}\n\nexport async function getYouTubeClient() {\n  const accessToken = await getAccessToken()\n  return google.youtube({ version: 'v3', auth: accessToken })\n}\n\nexport async function checkYouTubeConnection(): Promise<boolean> {\n  try {\n    await getAccessToken()\n    return true\n  }\n  catch {\n    return false\n  }\n}\n","size_bytes":1506},"src/services/ffmpeg.ts":{"content":"import ffmpeg from 'fluent-ffmpeg'\nimport ffmpegStatic from 'ffmpeg-static'\nimport { promisify } from 'util'\nimport { exec } from 'child_process'\nimport { writeFileSync, readFileSync } from 'fs'\nimport { join } from 'path'\n\nconst execPromise = promisify(exec)\n\nif (ffmpegStatic)\n{\n  ffmpeg.setFfmpegPath(ffmpegStatic)\n}\n\nexport interface SceneChange {\n  time: number\n  score: number\n}\n\nexport async function detectScenes(videoPath: string): Promise<SceneChange[]> {\n  try {\n    const ffmpegPath = ffmpegStatic || 'ffmpeg'\n    const cmd = `${ffmpegPath} -i \"${videoPath}\" -vf \"select='gt(scene,0.3)',showinfo\" -f null - 2>&1 | grep showinfo`\n    const { stdout } = await execPromise(cmd)\n    \n    const scenes: SceneChange[] = []\n    const lines = stdout.split('\\n')\n    \n    for (const line of lines)\n    {\n      const timeMatch = line.match(/pts_time:([\\d.]+)/)\n      \n      if (timeMatch)\n      {\n        scenes.push({\n          time: parseFloat(timeMatch[1]),\n          score: 0.4\n        })\n      }\n    }\n    \n    return scenes\n  }\n  catch (error) {\n    return []\n  }\n}\n\nexport async function extractAudio(videoPath: string, outputPath: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    ffmpeg(videoPath)\n      .output(outputPath)\n      .audioCodec('libmp3lame')\n      .noVideo()\n      .on('end', () => resolve())\n      .on('error', reject)\n      .run()\n  })\n}\n\nexport async function splitAudioIntoChunks(audioPath: string, chunkDurationSeconds: number): Promise<string[]> {\n  const chunks: string[] = []\n  const audioDir = audioPath.substring(0, audioPath.lastIndexOf('/'))\n  const audioExt = audioPath.substring(audioPath.lastIndexOf('.'))\n  \n  const ffmpegPath = ffmpegStatic || 'ffmpeg'\n  const getDurationCmd = `${ffmpegPath} -i \"${audioPath}\" 2>&1 | grep \"Duration\" | cut -d ' ' -f 4 | sed s/,//`\n  \n  try {\n    const { stdout: durationStr } = await execPromise(getDurationCmd)\n    const [hours, minutes, seconds] = durationStr.trim().split(':').map(parseFloat)\n    const totalDuration = hours * 3600 + minutes * 60 + seconds\n    \n    const numChunks = Math.ceil(totalDuration / chunkDurationSeconds)\n    \n    for (let i = 0; i < numChunks; i++) {\n      const startTime = i * chunkDurationSeconds\n      const chunkPath = join(audioDir, `chunk_${i}${audioExt}`)\n      \n      await new Promise<void>((resolve, reject) => {\n        ffmpeg(audioPath)\n          .setStartTime(startTime)\n          .duration(chunkDurationSeconds)\n          .audioCodec('libmp3lame')\n          .output(chunkPath)\n          .on('end', () => resolve())\n          .on('error', reject)\n          .run()\n      })\n      \n      chunks.push(chunkPath)\n    }\n    \n    return chunks\n  } catch (error) {\n    throw new Error(`Failed to split audio: ${error}`)\n  }\n}\n\nexport interface RenderOptions {\n  inputPath: string\n  outputPath: string\n  startTime: number\n  duration: number\n  srtPath: string\n  hookText: string\n}\n\nexport async function renderVerticalClip(options: RenderOptions): Promise<void> {\n  const { inputPath, outputPath, startTime, duration, srtPath, hookText } = options\n  \n  const escapedSrtPath = srtPath.replace(/\\\\/g, '/').replace(/:/g, '\\\\:')\n  const escapedHookText = hookText.replace(/'/g, \"'\\\\''\").replace(/:/g, '\\\\:')\n  \n  return new Promise((resolve, reject) => {\n    ffmpeg(inputPath)\n      .setStartTime(startTime)\n      .duration(duration)\n      .size('1080x1920')\n      .fps(30)\n      .videoBitrate('4000k')\n      .videoCodec('libx264')\n      .outputOptions([\n        '-preset', 'veryfast',\n        '-crf', '23',\n        '-pix_fmt', 'yuv420p',\n        '-vf', `scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,subtitles=${escapedSrtPath}:force_style='Fontsize=24,PrimaryColour=&HFFFFFF,OutlineColour=&H000000,BorderStyle=3,Outline=2,Shadow=0,MarginV=80',drawtext=text='${escapedHookText}':fontsize=32:fontcolor=white:borderw=3:bordercolor=black:x=(w-text_w)/2:y=72`,\n        '-af', 'loudnorm=I=-14:LRA=11:TP=-1.5'\n      ])\n      .audioCodec('aac')\n      .audioBitrate('128k')\n      .output(outputPath)\n      .on('end', () => resolve())\n      .on('error', reject)\n      .run()\n  })\n}\n\nexport async function extractThumbnail(videoPath: string, outputPath: string, timestamp: number): Promise<void> {\n  return new Promise((resolve, reject) => {\n    ffmpeg(videoPath)\n      .screenshots({\n        timestamps: [timestamp],\n        filename: outputPath.split('/').pop()!,\n        folder: outputPath.substring(0, outputPath.lastIndexOf('/')),\n        size: '1080x1920'\n      })\n      .on('end', () => resolve())\n      .on('error', reject)\n  })\n}\n\nexport function createSrtFile(words: Array<{ word: string; start: number; end: number }>, outputPath: string): void {\n  let srtContent = ''\n  \n  for (let i = 0; i < words.length; i++)\n  {\n    const word = words[i]\n    const startTime = formatSrtTime(word.start)\n    const endTime = formatSrtTime(word.end)\n    \n    srtContent += `${i + 1}\\n`\n    srtContent += `${startTime} --> ${endTime}\\n`\n    srtContent += `${word.word}\\n\\n`\n  }\n  \n  writeFileSync(outputPath, srtContent)\n}\n\nfunction formatSrtTime(seconds: number): string {\n  const hours = Math.floor(seconds / 3600)\n  const minutes = Math.floor((seconds % 3600) / 60)\n  const secs = Math.floor(seconds % 60)\n  const millis = Math.floor((seconds % 1) * 1000)\n  \n  return `${pad(hours)}:${pad(minutes)}:${pad(secs)},${pad(millis, 3)}`\n}\n\nfunction pad(num: number, size: number = 2): string {\n  let s = num.toString()\n  while (s.length < size)\n  {\n    s = '0' + s\n  }\n  return s\n}\n","size_bytes":5518},"src/services/openai.ts":{"content":"import OpenAI from 'openai'\nimport { createReadStream, statSync } from 'fs'\nimport { splitAudioIntoChunks } from './ffmpeg'\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  timeout: 600000,\n  maxRetries: 3\n})\n\nexport interface TranscriptWord {\n  word: string\n  start: number\n  end: number\n}\n\nexport interface TranscriptSegment {\n  text: string\n  start: number\n  end: number\n  words: TranscriptWord[]\n}\n\nconst MAX_FILE_SIZE = 20 * 1024 * 1024\n\nasync function transcribeAudioFile(audioPath: string, timeOffset: number = 0): Promise<TranscriptWord[]> {\n  const response = await openai.audio.transcriptions.create({\n    file: createReadStream(audioPath),\n    model: 'whisper-1',\n    response_format: 'verbose_json',\n    timestamp_granularities: ['word']\n  })\n\n  const words: TranscriptWord[] = []\n  \n  if (response.words) {\n    for (const word of response.words) {\n      words.push({\n        word: word.word,\n        start: word.start + timeOffset,\n        end: word.end + timeOffset\n      })\n    }\n  }\n  \n  return words\n}\n\nexport async function transcribeAudio(audioPath: string): Promise<TranscriptSegment[]> {\n  const fileSize = statSync(audioPath).size\n  let allWords: TranscriptWord[] = []\n  \n  if (fileSize > MAX_FILE_SIZE) {\n    console.log(`Audio file is ${(fileSize / 1024 / 1024).toFixed(1)}MB, splitting into chunks...`)\n    const chunkDuration = 600\n    const chunks = await splitAudioIntoChunks(audioPath, chunkDuration)\n    \n    for (let i = 0; i < chunks.length; i++) {\n      console.log(`Transcribing chunk ${i + 1}/${chunks.length}`)\n      const chunkWords = await transcribeAudioFile(chunks[i], i * chunkDuration)\n      allWords = allWords.concat(chunkWords)\n    }\n  } else {\n    allWords = await transcribeAudioFile(audioPath)\n  }\n\n  const segments: TranscriptSegment[] = []\n  let currentSegment: TranscriptWord[] = []\n  let segmentStart = 0\n  let segmentText = ''\n  \n  for (let i = 0; i < allWords.length; i++)\n  {\n    const word = allWords[i]\n    \n    if (currentSegment.length === 0)\n    {\n      segmentStart = word.start\n    }\n    \n    currentSegment.push(word)\n    segmentText += word.word + ' '\n    \n    if (i < allWords.length - 1)\n    {\n      const gap = allWords[i + 1].start - word.end\n      \n      if (gap > 0.9 || currentSegment.length >= 50)\n      {\n        segments.push({\n          text: segmentText.trim(),\n          start: segmentStart,\n          end: word.end,\n          words: currentSegment\n        })\n        \n        currentSegment = []\n        segmentText = ''\n      }\n    }\n  }\n  \n  if (currentSegment.length > 0)\n  {\n    segments.push({\n      text: segmentText.trim(),\n      start: segmentStart,\n      end: currentSegment[currentSegment.length - 1].end,\n      words: currentSegment\n    })\n  }\n  \n  return segments\n}\n\nexport interface ScoreResult {\n  category: string\n  tags: string[]\n  scores: {\n    hook_strength: number\n    retention_likelihood: number\n    clarity: number\n    shareability: number\n    overall: number\n  }\n  rationale: string\n}\n\nexport async function scoreClip(title: string, hook: string, transcript: string): Promise<ScoreResult> {\n  const response = await openai.chat.completions.create({\n    model: 'gpt-4o',\n    messages: [\n      {\n        role: 'system',\n        content: 'You score short-form video clips for viral potential.'\n      },\n      {\n        role: 'user',\n        content: `Given the transcript segment, the first-3-second hook text, and context title, return a JSON object with:\ncategory in [Education, Motivation, Humor, Commentary, Tech, Lifestyle, News, Finance, Health, Sports, Gaming, Other]\ntags as an array of 3–7 short tags\nscores as integers: hook_strength 0–10, retention_likelihood 0–10, clarity 0–10, shareability 0–10, overall 0–100\nrationale as one sentence\nEnsure the hook is compelling for a cold audience.\n\ninput:\ntitle: ${title}\nhook: ${hook}\ntranscript: ${transcript}\n\nJSON only.`\n      }\n    ],\n    response_format: { type: 'json_object' },\n    temperature: 0.7\n  })\n  \n  const content = response.choices[0].message.content || '{}'\n  return JSON.parse(content) as ScoreResult\n}\n","size_bytes":4106},"src/services/s3.ts":{"content":"import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3'\nimport { readFileSync } from 'fs'\n\nconst s3Client = new S3Client({\n  endpoint: process.env.S3_ENDPOINT,\n  region: process.env.S3_REGION || 'auto',\n  credentials: process.env.S3_ACCESS_KEY_ID && process.env.S3_SECRET_ACCESS_KEY ? {\n    accessKeyId: process.env.S3_ACCESS_KEY_ID,\n    secretAccessKey: process.env.S3_SECRET_ACCESS_KEY\n  } : undefined\n})\n\nconst bucket = process.env.S3_BUCKET!\n\nexport async function uploadFile(key: string, filePath: string, contentType: string): Promise<string> {\n  const fileContent = readFileSync(filePath)\n  \n  await s3Client.send(new PutObjectCommand({\n    Bucket: bucket,\n    Key: key,\n    Body: fileContent,\n    ContentType: contentType\n  }))\n  \n  if (process.env.S3_ENDPOINT)\n  {\n    return `${process.env.S3_ENDPOINT}/${bucket}/${key}`\n  }\n  return `https://${bucket}.s3.${process.env.S3_REGION}.amazonaws.com/${key}`\n}\n\nexport async function uploadBuffer(key: string, buffer: Buffer, contentType: string): Promise<string> {\n  await s3Client.send(new PutObjectCommand({\n    Bucket: bucket,\n    Key: key,\n    Body: buffer,\n    ContentType: contentType\n  }))\n  \n  if (process.env.S3_ENDPOINT)\n  {\n    return `${process.env.S3_ENDPOINT}/${bucket}/${key}`\n  }\n  return `https://${bucket}.s3.${process.env.S3_REGION}.amazonaws.com/${key}`\n}\n\nexport function getS3Url(key: string): string {\n  if (process.env.S3_ENDPOINT)\n  {\n    return `${process.env.S3_ENDPOINT}/${bucket}/${key}`\n  }\n  return `https://${bucket}.s3.${process.env.S3_REGION}.amazonaws.com/${key}`\n}\n","size_bytes":1582},"src/services/segmentation.ts":{"content":"import { TranscriptSegment, TranscriptWord } from './openai'\nimport { SceneChange } from './ffmpeg'\n\nexport interface Segment {\n  startSec: number\n  endSec: number\n  durationSec: number\n  words: TranscriptWord[]\n  text: string\n  hook: string\n  score: number\n}\n\nexport function detectSegments(transcript: TranscriptSegment[], sceneChanges: SceneChange[]): Segment[] {\n  const allWords: TranscriptWord[] = []\n  \n  for (const segment of transcript)\n  {\n    for (const word of segment.words)\n    {\n      allWords.push(word)\n    }\n  }\n  \n  if (allWords.length === 0)\n  {\n    return []\n  }\n  \n  const pauseBoundaries: number[] = []\n  \n  for (let i = 0; i < allWords.length - 1; i++)\n  {\n    const gap = allWords[i + 1].start - allWords[i].end\n    \n    if (gap >= 0.35 && gap <= 0.9)\n    {\n      pauseBoundaries.push(i + 1)\n    }\n  }\n  \n  const candidates: Segment[] = []\n  \n  for (let i = 0; i < pauseBoundaries.length; i++)\n  {\n    const startIdx = pauseBoundaries[i]\n    \n    for (let j = i + 1; j < pauseBoundaries.length; j++)\n    {\n      const endIdx = pauseBoundaries[j]\n      const segmentWords = allWords.slice(startIdx, endIdx)\n      \n      if (segmentWords.length === 0)\n      {\n        continue\n      }\n      \n      const startSec = segmentWords[0].start\n      const endSec = segmentWords[segmentWords.length - 1].end\n      const duration = endSec - startSec\n      \n      if (duration >= 20 && duration <= 60)\n      {\n        const speechDuration = segmentWords.reduce((sum, w) => sum + (w.end - w.start), 0)\n        \n        if (speechDuration >= 8)\n        {\n          const text = segmentWords.map(w => w.word).join(' ')\n          const hookWords = segmentWords.filter(w => w.start - startSec < 3)\n          const hook = hookWords.map(w => w.word).join(' ').trim()\n          \n          const wordsPerSec = segmentWords.length / duration\n          const pauseDensity = (duration - speechDuration) / duration\n          const highEnergyWords = segmentWords.filter(w => \n            w.word.length > 6 || /[!?]/.test(w.word)\n          ).length\n          \n          const sceneChangesInSegment = sceneChanges.filter(scene => \n            scene.time >= startSec && scene.time <= endSec\n          ).length\n          \n          const startsNearScene = sceneChanges.some(scene =>\n            Math.abs(scene.time - startSec) <= 1.0\n          )\n          \n          const endsNearScene = sceneChanges.some(scene =>\n            Math.abs(scene.time - endSec) <= 1.0\n          )\n          \n          let sceneBonus = 0\n          \n          if (startsNearScene)\n          {\n            sceneBonus += 5\n          }\n          \n          if (endsNearScene)\n          {\n            sceneBonus += 5\n          }\n          \n          if (sceneChangesInSegment > 2)\n          {\n            sceneBonus += sceneChangesInSegment * 2\n          }\n          \n          const score = wordsPerSec * 10 + pauseDensity * 5 + highEnergyWords + sceneBonus\n          \n          candidates.push({\n            startSec,\n            endSec,\n            durationSec: duration,\n            words: segmentWords,\n            text,\n            hook: hook || text.substring(0, 50),\n            score\n          })\n        }\n      }\n    }\n  }\n  \n  candidates.sort((a, b) => b.score - a.score)\n  \n  const preferredCandidates = candidates.filter(c => c.durationSec >= 25 && c.durationSec <= 45)\n  \n  if (preferredCandidates.length > 0)\n  {\n    return preferredCandidates.slice(0, 12)\n  }\n  \n  return candidates.slice(0, 12)\n}\n","size_bytes":3484},"src/services/youtube.ts":{"content":"import { spawn } from 'child_process'\nimport { promisify } from 'util'\nimport { exec } from 'child_process'\nimport { existsSync, writeFileSync, mkdirSync, chmodSync, unlinkSync } from 'fs'\nimport { join } from 'path'\nimport { tmpdir } from 'os'\nimport { prisma } from '@/src/lib/prisma'\nimport { decrypt } from '@/src/lib/encryption'\n\nconst execPromise = promisify(exec)\n\nexport async function createUserCookiesFile(userId: string): Promise<string | null> {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: { youtubeCookies: true }\n  })\n  \n  if (!user || !user.youtubeCookies)\n  {\n    return null\n  }\n  \n  const cookiesDir = join(tmpdir(), 'yt-cookies')\n  \n  if (!existsSync(cookiesDir))\n  {\n    mkdirSync(cookiesDir, { recursive: true })\n  }\n  \n  const cookiesPath = join(cookiesDir, `${userId}.txt`)\n  const decryptedCookies = decrypt(user.youtubeCookies)\n  \n  writeFileSync(cookiesPath, decryptedCookies)\n  chmodSync(cookiesPath, 0o600)\n  \n  await prisma.user.update({\n    where: { id: userId },\n    data: { youtubeCookiesLastUsedAt: new Date() }\n  })\n  \n  return cookiesPath\n}\n\nexport function cleanupUserCookiesFile(userId: string): void {\n  const cookiesPath = join(tmpdir(), 'yt-cookies', `${userId}.txt`)\n  \n  try {\n    if (existsSync(cookiesPath))\n    {\n      unlinkSync(cookiesPath)\n    }\n  }\n  catch (error) {\n    console.error('Failed to cleanup cookies file:', error)\n  }\n}\n\nasync function findYtDlp(): Promise<string> {\n  if (process.env.YT_DLP_PATH && existsSync(process.env.YT_DLP_PATH))\n  {\n    return process.env.YT_DLP_PATH\n  }\n  \n  try {\n    await execPromise('which yt-dlp')\n    return 'yt-dlp'\n  }\n  catch {\n    try {\n      await execPromise('which youtube-dl')\n      return 'youtube-dl'\n    }\n    catch {\n      throw new Error('yt-dlp or youtube-dl not found in PATH')\n    }\n  }\n}\n\nexport interface VideoMetadata {\n  title: string\n  duration: number\n  url: string\n}\n\nexport async function getVideoMetadata(url: string, userId: string): Promise<VideoMetadata> {\n  const ytDlp = await findYtDlp()\n  const cookiesPath = await createUserCookiesFile(userId)\n  \n  if (!cookiesPath)\n  {\n    throw new Error('YouTube cookies not configured. Please upload your YouTube cookies.')\n  }\n  \n  try {\n    const strategies = [\n      { client: 'ios', skipAvailabilityCheck: false },\n      { client: 'android', skipAvailabilityCheck: false },\n      { client: 'web', skipAvailabilityCheck: true },\n      { client: 'mweb', skipAvailabilityCheck: true }\n    ]\n    \n    let lastError: Error | null = null\n    \n    for (const strategy of strategies)\n    {\n      try {\n        let extractorArgs = `youtube:player_client=${strategy.client}`\n        \n        if (strategy.skipAvailabilityCheck)\n        {\n          extractorArgs += `;skip=authcheck`\n        }\n        \n        const args = [\n          '--dump-json',\n          '--no-download',\n          '--force-ipv4',\n          '--sleep-requests', '1',\n          '--extractor-args', extractorArgs,\n          '--cookies', cookiesPath,\n          url\n        ]\n        \n        const result = await new Promise<string>((resolve, reject) => {\n          let stdout = ''\n          let stderr = ''\n          \n          const process = spawn(ytDlp, args)\n          \n          process.stdout.on('data', (data) => {\n            stdout += data.toString()\n          })\n          \n          process.stderr.on('data', (data) => {\n            stderr += data.toString()\n          })\n          \n          process.on('close', (code) => {\n            if (code === 0)\n            {\n              resolve(stdout)\n            }\n            else\n            {\n              reject(new Error(`yt-dlp exited with code ${code}: ${stderr}`))\n            }\n          })\n          \n          process.on('error', reject)\n        })\n        \n        const data = JSON.parse(result)\n        \n        return {\n          title: data.title,\n          duration: Math.floor(data.duration),\n          url: data.url\n        }\n      }\n      catch (error: any) {\n        lastError = error\n        continue\n      }\n    }\n    \n    throw lastError || new Error('Failed to fetch video metadata')\n  }\n  finally {\n    cleanupUserCookiesFile(userId)\n  }\n}\n\nexport async function downloadVideo(url: string, outputPath: string, userId: string): Promise<void> {\n  const ytDlp = await findYtDlp()\n  const cookiesPath = await createUserCookiesFile(userId)\n  \n  if (!cookiesPath)\n  {\n    throw new Error('YouTube cookies not configured. Please upload your YouTube cookies.')\n  }\n  \n  try {\n    const strategies = [\n      { client: 'ios', skipAvailabilityCheck: false },\n      { client: 'android', skipAvailabilityCheck: false },\n      { client: 'web', skipAvailabilityCheck: true },\n      { client: 'mweb', skipAvailabilityCheck: true }\n    ]\n    \n    let lastError: Error | null = null\n    \n    for (const strategy of strategies) {\n      try {\n        await new Promise<void>((resolve, reject) => {\n          let errorOutput = ''\n          \n          let extractorArgs = `youtube:player_client=${strategy.client}`\n          \n          if (strategy.skipAvailabilityCheck)\n          {\n            extractorArgs += `;skip=authcheck`\n          }\n          \n          const args = [\n            '-f', 'bestvideo[height>=1080][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height>=1080]+bestaudio/bestvideo[height>=720]+bestaudio/best',\n            '--merge-output-format', 'mp4',\n            '--format-sort', 'res:1080,codec:h264,br',\n            '--force-ipv4',\n            '--sleep-requests', '1',\n            '--min-sleep-interval', '1',\n            '--max-sleep-interval', '5',\n            '--extractor-args', extractorArgs,\n            '--cookies', cookiesPath,\n            '-o', outputPath,\n            url\n          ]\n          \n          const process = spawn(ytDlp, args)\n          \n          process.stderr.on('data', (data) => {\n            errorOutput += data.toString()\n          })\n          \n          process.stdout.on('data', (data) => {\n            console.log(data.toString())\n          })\n          \n          process.on('close', (code) => {\n            if (code === 0)\n            {\n              resolve()\n            }\n            else\n            {\n              reject(new Error(`yt-dlp exited with code ${code}: ${errorOutput}`))\n            }\n          })\n          \n          process.on('error', reject)\n        })\n        \n        return\n      }\n      catch (error: any) {\n        lastError = error\n        console.log(`Failed with client ${strategy.client}, trying next...`)\n        continue\n      }\n    }\n    \n    throw lastError || new Error('Failed to download video with all player clients')\n  }\n  finally {\n    cleanupUserCookiesFile(userId)\n  }\n}\n","size_bytes":6702},"app/api/submit/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/src/lib/prisma'\nimport { videoQueue } from '@/src/lib/queue'\nimport { getVideoMetadata } from '@/src/services/youtube'\nimport { requireAuth } from '@/src/lib/session'\n\nfunction sanitizeUrl(url: string): string {\n  const trimmed = url.trim()\n  const urlPattern = /^(https?:\\/\\/)?(www\\.)?(youtube\\.com|youtu\\.be)\\/.+$/i\n  \n  if (!urlPattern.test(trimmed))\n  {\n    throw new Error('Invalid YouTube URL')\n  }\n  \n  return trimmed\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    await requireAuth()\n    \n    const body = await request.json()\n    const { url } = body\n    \n    if (!url)\n    {\n      return NextResponse.json(\n        { error: 'URL is required' },\n        { status: 400 }\n      )\n    }\n    \n    const sanitizedUrl = sanitizeUrl(url)\n    \n    const metadata = await getVideoMetadata(sanitizedUrl)\n    \n    const video = await prisma.video.create({\n      data: {\n        sourceUrl: sanitizedUrl,\n        title: metadata.title,\n        durationSec: metadata.duration,\n        status: 'queued'\n      }\n    })\n    \n    await videoQueue.add('process', {\n      videoId: video.id\n    })\n    \n    return NextResponse.json({\n      videoId: video.id,\n      status: 'queued'\n    })\n  }\n  catch (error: any) {\n    console.error('Error submitting video:', error)\n    \n    if (error.message === 'Authentication required')\n    {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      )\n    }\n    \n    if (error.message === 'Invalid YouTube URL')\n    {\n      return NextResponse.json(\n        { error: 'Invalid YouTube URL' },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: 'Failed to submit video' },\n      { status: 500 }\n    )\n  }\n}\n","size_bytes":1821},"app/api/videos/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/src/lib/prisma'\nimport { requireAuth } from '@/src/lib/session'\n\nexport async function GET(request: NextRequest) {\n  try {\n    await requireAuth()\n    \n    const searchParams = request.nextUrl.searchParams\n    const q = searchParams.get('q') || ''\n    const page = Math.max(1, parseInt(searchParams.get('page') || '1'))\n    const pageSize = Math.min(100, Math.max(1, parseInt(searchParams.get('pageSize') || '20')))\n    const sort = searchParams.get('sort') || 'createdAt'\n    \n    const where = q ? {\n      OR: [\n        { title: { contains: q, mode: 'insensitive' as const } },\n        { sourceUrl: { contains: q, mode: 'insensitive' as const } }\n      ]\n    } : {}\n    \n    const orderBy = sort === 'createdAt' ? { createdAt: 'desc' as const } : { updatedAt: 'desc' as const }\n    \n    const [videos, total] = await Promise.all([\n      prisma.video.findMany({\n        where,\n        orderBy,\n        skip: (page - 1) * pageSize,\n        take: pageSize,\n        include: {\n          _count: {\n            select: { clips: true }\n          }\n        }\n      }),\n      prisma.video.count({ where })\n    ])\n    \n    return NextResponse.json({\n      videos,\n      total,\n      page,\n      pageSize,\n      totalPages: Math.ceil(total / pageSize)\n    })\n  }\n  catch (error: any) {\n    console.error('Error fetching videos:', error)\n    \n    if (error.message === 'Authentication required')\n    {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: 'Failed to fetch videos' },\n      { status: 500 }\n    )\n  }\n}\n","size_bytes":1702},"app/videos/[id]/page.tsx":{"content":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useParams } from 'next/navigation'\nimport Link from 'next/link'\n\ninterface Clip {\n  id: string\n  startSec: number\n  endSec: number\n  durationSec: number\n  category: string\n  tags: string[]\n  scoreHook: number\n  scoreRetention: number\n  scoreClarity: number\n  scoreShare: number\n  scoreOverall: number\n  rationale: string\n  videoUrl: string\n  thumbUrl: string\n  srtUrl: string\n}\n\ninterface Video {\n  id: string\n  title: string\n  sourceUrl: string\n  status: string\n  durationSec: number\n  clips: Clip[]\n}\n\nexport default function VideoDetail() {\n  const params = useParams()\n  const [video, setVideo] = useState<Video | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [selectedCategory, setSelectedCategory] = useState<string>('all')\n  const [minScore, setMinScore] = useState<number>(0)\n\n  useEffect(() => {\n    if (params.id) {\n      fetchVideo()\n    }\n  }, [params.id])\n\n  async function fetchVideo() {\n    try {\n      const response = await fetch(`/api/videos/${params.id}`)\n      const data = await response.json()\n      \n      if (response.ok) {\n        setVideo(data)\n      }\n    }\n    catch (err) {\n      console.error('Error fetching video:', err)\n    }\n    finally {\n      setLoading(false)\n    }\n  }\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen p-8\">\n        <div className=\"max-w-7xl mx-auto\">\n          <div className=\"text-center\">Loading...</div>\n        </div>\n      </div>\n    )\n  }\n\n  if (!video) {\n    return (\n      <div className=\"min-h-screen p-8\">\n        <div className=\"max-w-7xl mx-auto\">\n          <div className=\"text-center\">Video not found</div>\n        </div>\n      </div>\n    )\n  }\n\n  const categories = ['all', ...Array.from(new Set(video.clips.map(c => c.category)))]\n  \n  const filteredClips = video.clips.filter(clip => {\n    if (selectedCategory !== 'all' && clip.category !== selectedCategory) {\n      return false\n    }\n    \n    if (clip.scoreOverall < minScore) {\n      return false\n    }\n    \n    return true\n  })\n\n  return (\n    <div className=\"min-h-screen p-8\">\n      <div className=\"max-w-7xl mx-auto\">\n        <Link href=\"/\" className=\"text-blue-400 hover:text-blue-300 mb-4 inline-block\">\n          ← Back to Videos\n        </Link>\n\n        <div className=\"bg-gray-800 p-6 rounded-lg mb-8\">\n          <h1 className=\"text-3xl font-bold mb-4\">{video.title}</h1>\n          <div className=\"flex gap-4 text-sm text-gray-400\">\n            <span>Status: <span className={`${\n              video.status === 'completed' ? 'text-green-500' :\n              video.status === 'processing' ? 'text-blue-500' :\n              video.status === 'failed' ? 'text-red-500' :\n              'text-gray-500'\n            }`}>{video.status}</span></span>\n            <span>Duration: {Math.floor(video.durationSec / 60)}m</span>\n            <span>Clips: {video.clips.length}</span>\n          </div>\n        </div>\n\n        <div className=\"bg-gray-800 p-6 rounded-lg mb-8\">\n          <h2 className=\"text-xl font-semibold mb-4\">Filters</h2>\n          <div className=\"flex gap-4 flex-wrap\">\n            <div>\n              <label className=\"block text-sm mb-2\">Category</label>\n              <select\n                value={selectedCategory}\n                onChange={(e) => setSelectedCategory(e.target.value)}\n                className=\"px-4 py-2 bg-gray-700 rounded border border-gray-600\"\n              >\n                {\n                  categories.map(cat => (\n                    <option key={cat} value={cat}>\n                      {cat === 'all' ? 'All Categories' : cat}\n                    </option>\n                  ))\n                }\n              </select>\n            </div>\n            <div>\n              <label className=\"block text-sm mb-2\">Min Score: {minScore}</label>\n              <input\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                value={minScore}\n                onChange={(e) => setMinScore(parseInt(e.target.value))}\n                className=\"w-48\"\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {\n            filteredClips.map((clip) => (\n              <div key={clip.id} className=\"bg-gray-800 rounded-lg overflow-hidden\">\n                <div className=\"relative pb-[177.77%]\">\n                  <video\n                    src={clip.videoUrl}\n                    poster={clip.thumbUrl}\n                    controls\n                    className=\"absolute inset-0 w-full h-full object-cover\"\n                  />\n                </div>\n                <div className=\"p-4\">\n                  <div className=\"flex justify-between items-center mb-2\">\n                    <span className=\"px-2 py-1 bg-blue-600 rounded text-xs\">{clip.category}</span>\n                    <span className=\"text-2xl font-bold text-green-400\">{clip.scoreOverall}</span>\n                  </div>\n                  <div className=\"flex flex-wrap gap-1 mb-2\">\n                    {\n                      clip.tags.map((tag, i) => (\n                        <span key={i} className=\"px-2 py-0.5 bg-gray-700 rounded text-xs\">\n                          {tag}\n                        </span>\n                      ))\n                    }\n                  </div>\n                  <div className=\"text-sm text-gray-400 mb-2\">\n                    <div>Hook: {clip.scoreHook}/10</div>\n                    <div>Retention: {clip.scoreRetention}/10</div>\n                    <div>Clarity: {clip.scoreClarity}/10</div>\n                    <div>Shareability: {clip.scoreShare}/10</div>\n                  </div>\n                  <p className=\"text-sm text-gray-300 mb-3\">{clip.rationale}</p>\n                  <div className=\"text-xs text-gray-500 mb-3\">\n                    {Math.floor(clip.startSec)}s - {Math.floor(clip.endSec)}s ({clip.durationSec}s)\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <a\n                      href={clip.videoUrl}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                      className=\"flex-1 text-center px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm\"\n                    >\n                      Video\n                    </a>\n                    <a\n                      href={clip.srtUrl}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                      className=\"flex-1 text-center px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm\"\n                    >\n                      SRT\n                    </a>\n                  </div>\n                </div>\n              </div>\n            ))\n          }\n        </div>\n        {\n          filteredClips.length === 0 && (\n            <div className=\"text-center py-8 text-gray-400\">\n              No clips match the current filters.\n            </div>\n          )\n        }\n      </div>\n    </div>\n  )\n}\n","size_bytes":7024},"app/api/auth/login/route.ts":{"content":"import { NextResponse } from 'next/server'\nimport { getSession } from '@/src/lib/session'\nimport { checkYouTubeConnection } from '@/src/lib/youtube-client'\n\nexport async function POST() {\n  try {\n    const youtubeConnected = await checkYouTubeConnection()\n    \n    if (!youtubeConnected)\n    {\n      return NextResponse.json(\n        { error: 'YouTube connection not configured. Please set up the YouTube connector first.' },\n        { status: 401 }\n      )\n    }\n    \n    const session = await getSession()\n    session.isAuthenticated = true\n    session.userId = 'youtube_user'\n    await session.save()\n    \n    return NextResponse.json({ success: true })\n  }\n  catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to authenticate with YouTube' },\n      { status: 500 }\n    )\n  }\n}\n","size_bytes":799},"app/api/auth/logout/route.ts":{"content":"import { NextResponse } from 'next/server'\nimport { getSession } from '@/src/lib/session'\n\nexport async function POST() {\n  try {\n    const session = await getSession()\n    session.destroy()\n    \n    return NextResponse.json({ success: true })\n  }\n  catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to logout' },\n      { status: 500 }\n    )\n  }\n}\n","size_bytes":367},"app/api/auth/status/route.ts":{"content":"import { NextResponse } from 'next/server'\nimport { getSession } from '@/src/lib/session'\nimport { checkYouTubeConnection } from '@/src/lib/youtube-client'\n\nexport async function GET() {\n  try {\n    const session = await getSession()\n    const youtubeConnected = await checkYouTubeConnection()\n    \n    return NextResponse.json({\n      isAuthenticated: session.isAuthenticated || false,\n      youtubeConnected,\n      email: session.email || null\n    })\n  }\n  catch (error) {\n    return NextResponse.json({\n      isAuthenticated: false,\n      youtubeConnected: false,\n      email: null\n    })\n  }\n}\n","size_bytes":598},"app/api/videos/[id]/route.ts":{"content":"import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/src/lib/prisma'\nimport { getS3Url } from '@/src/services/s3'\nimport { requireAuth } from '@/src/lib/session'\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    await requireAuth()\n    \n    const video = await prisma.video.findUnique({\n      where: { id: params.id },\n      include: {\n        clips: {\n          orderBy: { scoreOverall: 'desc' }\n        }\n      }\n    })\n    \n    if (!video)\n    {\n      return NextResponse.json(\n        { error: 'Video not found' },\n        { status: 404 }\n      )\n    }\n    \n    const clipsWithUrls = video.clips.map(clip => ({\n      ...clip,\n      videoUrl: getS3Url(clip.s3VideoKey),\n      thumbUrl: getS3Url(clip.s3ThumbKey),\n      srtUrl: getS3Url(clip.s3SrtKey)\n    }))\n    \n    return NextResponse.json({\n      ...video,\n      clips: clipsWithUrls\n    })\n  }\n  catch (error: any) {\n    console.error('Error fetching video:', error)\n    \n    if (error.message === 'Authentication required')\n    {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: 'Failed to fetch video' },\n      { status: 500 }\n    )\n  }\n}\n","size_bytes":1304},".next/server/server-reference-manifest.js":{"content":"self.__RSC_SERVER_MANIFEST=\"{\\n  \\\"node\\\": {},\\n  \\\"edge\\\": {},\\n  \\\"encryptionKey\\\": \\\"R3lez4/LwQU/5qUDq1OexkqG8qdHgtY150ER4Ff5qHU=\\\"\\n}\"","size_bytes":138}},"version":1}