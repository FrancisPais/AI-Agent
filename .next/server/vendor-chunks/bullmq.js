"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bullmq";
exports.ids = ["vendor-chunks/bullmq"];
exports.modules = {

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* binding */ AsyncFifoQueue)\n/* harmony export */ });\nclass Node {\n    constructor(value) {\n        this.value = undefined;\n        this.next = null;\n        this.value = value;\n    }\n}\nclass LinkedList {\n    constructor() {\n        this.length = 0;\n        this.head = null;\n        this.tail = null;\n    }\n    push(value) {\n        const newNode = new Node(value);\n        if (!this.length) {\n            this.head = newNode;\n        }\n        else {\n            this.tail.next = newNode;\n        }\n        this.tail = newNode;\n        this.length += 1;\n        return newNode;\n    }\n    shift() {\n        if (!this.length) {\n            return null;\n        }\n        else {\n            const head = this.head;\n            this.head = this.head.next;\n            this.length -= 1;\n            return head;\n        }\n    }\n}\n/**\n * AsyncFifoQueue\n *\n * A minimal FIFO queue for asynchronous operations. Allows adding asynchronous operations\n * and consume them in the order they are resolved.\n */\nclass AsyncFifoQueue {\n    constructor(ignoreErrors = false) {\n        this.ignoreErrors = ignoreErrors;\n        /**\n         * A queue of completed promises. As the pending\n         * promises are resolved, they are added to this queue.\n         */\n        this.queue = new LinkedList();\n        /**\n         * A set of pending promises.\n         */\n        this.pending = new Set();\n        this.newPromise();\n    }\n    add(promise) {\n        this.pending.add(promise);\n        promise\n            .then(data => {\n            this.pending.delete(promise);\n            if (this.queue.length === 0) {\n                this.resolvePromise(data);\n            }\n            this.queue.push(data);\n        })\n            .catch(err => {\n            // Ignore errors\n            if (this.ignoreErrors) {\n                this.queue.push(undefined);\n            }\n            this.pending.delete(promise);\n            this.rejectPromise(err);\n        });\n    }\n    async waitAll() {\n        await Promise.all(this.pending);\n    }\n    numTotal() {\n        return this.pending.size + this.queue.length;\n    }\n    numPending() {\n        return this.pending.size;\n    }\n    numQueued() {\n        return this.queue.length;\n    }\n    resolvePromise(data) {\n        this.resolve(data);\n        this.newPromise();\n    }\n    rejectPromise(err) {\n        this.reject(err);\n        this.newPromise();\n    }\n    newPromise() {\n        this.nextPromise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    async wait() {\n        return this.nextPromise;\n    }\n    async fetch() {\n        var _a;\n        if (this.pending.size === 0 && this.queue.length === 0) {\n            return;\n        }\n        while (this.queue.length === 0) {\n            try {\n                await this.wait();\n            }\n            catch (err) {\n                // Ignore errors\n                if (!this.ignoreErrors) {\n                    console.error('Unexpected Error in AsyncFifoQueue', err);\n                }\n            }\n        }\n        return (_a = this.queue.shift()) === null || _a === void 0 ? void 0 : _a.value;\n    }\n}\n//# sourceMappingURL=async-fifo-queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvYXN5bmMtZmlmby1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvYXN5bmMtZmlmby1xdWV1ZS5qcz8yNTMyIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBMaW5rZWRMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIH1cbiAgICBwdXNoKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZSh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWlsID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuICAgIHNoaWZ0KCkge1xuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXN5bmNGaWZvUXVldWVcbiAqXG4gKiBBIG1pbmltYWwgRklGTyBxdWV1ZSBmb3IgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuIEFsbG93cyBhZGRpbmcgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnNcbiAqIGFuZCBjb25zdW1lIHRoZW0gaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHJlc29sdmVkLlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNGaWZvUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGlnbm9yZUVycm9ycyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBxdWV1ZSBvZiBjb21wbGV0ZWQgcHJvbWlzZXMuIEFzIHRoZSBwZW5kaW5nXG4gICAgICAgICAqIHByb21pc2VzIGFyZSByZXNvbHZlZCwgdGhleSBhcmUgYWRkZWQgdG8gdGhpcyBxdWV1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXQgb2YgcGVuZGluZyBwcm9taXNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5uZXdQcm9taXNlKCk7XG4gICAgfVxuICAgIGFkZChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMucGVuZGluZy5hZGQocHJvbWlzZSk7XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZShlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdEFsbCgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5wZW5kaW5nKTtcbiAgICB9XG4gICAgbnVtVG90YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmcuc2l6ZSArIHRoaXMucXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBudW1QZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nLnNpemU7XG4gICAgfVxuICAgIG51bVF1ZXVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICByZXNvbHZlUHJvbWlzZShkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgdGhpcy5uZXdQcm9taXNlKCk7XG4gICAgfVxuICAgIHJlamVjdFByb21pc2UoZXJyKSB7XG4gICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgIHRoaXMubmV3UHJvbWlzZSgpO1xuICAgIH1cbiAgICBuZXdQcm9taXNlKCkge1xuICAgICAgICB0aGlzLm5leHRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FpdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcuc2l6ZSA9PT0gMCAmJiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndhaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIEVycm9yIGluIEFzeW5jRmlmb1F1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucXVldWUuc2hpZnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWZpZm8tcXVldWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/backoffs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Backoffs: () => (/* binding */ Backoffs)\n/* harmony export */ });\nclass Backoffs {\n    static normalize(backoff) {\n        if (Number.isFinite(backoff)) {\n            return {\n                type: 'fixed',\n                delay: backoff,\n            };\n        }\n        else if (backoff) {\n            return backoff;\n        }\n    }\n    static calculate(backoff, attemptsMade, err, job, customStrategy) {\n        if (backoff) {\n            const strategy = lookupStrategy(backoff, customStrategy);\n            return strategy(attemptsMade, backoff.type, err, job);\n        }\n    }\n}\nBackoffs.builtinStrategies = {\n    fixed: function (delay, jitter = 0) {\n        return function () {\n            if (jitter > 0) {\n                const minDelay = delay * (1 - jitter);\n                return Math.floor(Math.random() * delay * jitter + minDelay);\n            }\n            else {\n                return delay;\n            }\n        };\n    },\n    exponential: function (delay, jitter = 0) {\n        return function (attemptsMade) {\n            if (jitter > 0) {\n                const maxDelay = Math.round(Math.pow(2, attemptsMade - 1) * delay);\n                const minDelay = maxDelay * (1 - jitter);\n                return Math.floor(Math.random() * maxDelay * jitter + minDelay);\n            }\n            else {\n                return Math.round(Math.pow(2, attemptsMade - 1) * delay);\n            }\n        };\n    },\n};\nfunction lookupStrategy(backoff, customStrategy) {\n    if (backoff.type in Backoffs.builtinStrategies) {\n        return Backoffs.builtinStrategies[backoff.type](backoff.delay, backoff.jitter);\n    }\n    else if (customStrategy) {\n        return customStrategy;\n    }\n    else {\n        throw new Error(`Unknown backoff strategy ${backoff.type}.\n      If a custom backoff strategy is used, specify it when the queue is created.`);\n    }\n}\n//# sourceMappingURL=backoffs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvYmFja29mZnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9iYWNrb2Zmcy5qcz8yYmRkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBCYWNrb2ZmcyB7XG4gICAgc3RhdGljIG5vcm1hbGl6ZShiYWNrb2ZmKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYmFja29mZikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICBkZWxheTogYmFja29mZixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFja29mZikge1xuICAgICAgICAgICAgcmV0dXJuIGJhY2tvZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNhbGN1bGF0ZShiYWNrb2ZmLCBhdHRlbXB0c01hZGUsIGVyciwgam9iLCBjdXN0b21TdHJhdGVneSkge1xuICAgICAgICBpZiAoYmFja29mZikge1xuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBsb29rdXBTdHJhdGVneShiYWNrb2ZmLCBjdXN0b21TdHJhdGVneSk7XG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koYXR0ZW1wdHNNYWRlLCBiYWNrb2ZmLnR5cGUsIGVyciwgam9iKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkJhY2tvZmZzLmJ1aWx0aW5TdHJhdGVnaWVzID0ge1xuICAgIGZpeGVkOiBmdW5jdGlvbiAoZGVsYXksIGppdHRlciA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChqaXR0ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluRGVsYXkgPSBkZWxheSAqICgxIC0gaml0dGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGVsYXkgKiBqaXR0ZXIgKyBtaW5EZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBleHBvbmVudGlhbDogZnVuY3Rpb24gKGRlbGF5LCBqaXR0ZXIgPSAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0ZW1wdHNNYWRlKSB7XG4gICAgICAgICAgICBpZiAoaml0dGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heERlbGF5ID0gTWF0aC5yb3VuZChNYXRoLnBvdygyLCBhdHRlbXB0c01hZGUgLSAxKSAqIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5EZWxheSA9IG1heERlbGF5ICogKDEgLSBqaXR0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhEZWxheSAqIGppdHRlciArIG1pbkRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucG93KDIsIGF0dGVtcHRzTWFkZSAtIDEpICogZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gbG9va3VwU3RyYXRlZ3koYmFja29mZiwgY3VzdG9tU3RyYXRlZ3kpIHtcbiAgICBpZiAoYmFja29mZi50eXBlIGluIEJhY2tvZmZzLmJ1aWx0aW5TdHJhdGVnaWVzKSB7XG4gICAgICAgIHJldHVybiBCYWNrb2Zmcy5idWlsdGluU3RyYXRlZ2llc1tiYWNrb2ZmLnR5cGVdKGJhY2tvZmYuZGVsYXksIGJhY2tvZmYuaml0dGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VzdG9tU3RyYXRlZ3kpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbVN0cmF0ZWd5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJhY2tvZmYgc3RyYXRlZ3kgJHtiYWNrb2ZmLnR5cGV9LlxuICAgICAgSWYgYSBjdXN0b20gYmFja29mZiBzdHJhdGVneSBpcyB1c2VkLCBzcGVjaWZ5IGl0IHdoZW4gdGhlIHF1ZXVlIGlzIGNyZWF0ZWQuYCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child-pool.js ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildPool: () => (/* binding */ ChildPool)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _child__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./child */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\nconst CHILD_KILL_TIMEOUT = 30000;\nconst supportCJS = () => {\n    return ( true &&\n        typeof module.exports === 'object');\n};\nclass ChildPool {\n    constructor({ mainFile = supportCJS()\n        ? path__WEBPACK_IMPORTED_MODULE_0__.join(process.cwd(), 'dist/cjs/classes/main.js')\n        : path__WEBPACK_IMPORTED_MODULE_0__.join(process.cwd(), 'dist/esm/classes/main.js'), useWorkerThreads, workerForkOptions, workerThreadsOptions, }) {\n        this.retained = {};\n        this.free = {};\n        this.opts = {\n            mainFile,\n            useWorkerThreads,\n            workerForkOptions,\n            workerThreadsOptions,\n        };\n    }\n    async retain(processFile) {\n        let child = this.getFree(processFile).pop();\n        if (child) {\n            this.retained[child.pid] = child;\n            return child;\n        }\n        child = new _child__WEBPACK_IMPORTED_MODULE_1__.Child(this.opts.mainFile, processFile, {\n            useWorkerThreads: this.opts.useWorkerThreads,\n            workerForkOptions: this.opts.workerForkOptions,\n            workerThreadsOptions: this.opts.workerThreadsOptions,\n        });\n        child.on('exit', this.remove.bind(this, child));\n        try {\n            await child.init();\n            // Check status here as well, in case the child exited before we could\n            // retain it.\n            if (child.exitCode !== null || child.signalCode !== null) {\n                throw new Error('Child exited before it could be retained');\n            }\n            this.retained[child.pid] = child;\n            return child;\n        }\n        catch (err) {\n            console.error(err);\n            this.release(child);\n            throw err;\n        }\n    }\n    release(child) {\n        delete this.retained[child.pid];\n        this.getFree(child.processFile).push(child);\n    }\n    remove(child) {\n        delete this.retained[child.pid];\n        const free = this.getFree(child.processFile);\n        const childIndex = free.indexOf(child);\n        if (childIndex > -1) {\n            free.splice(childIndex, 1);\n        }\n    }\n    async kill(child, signal = 'SIGKILL') {\n        this.remove(child);\n        return child.kill(signal, CHILD_KILL_TIMEOUT);\n    }\n    async clean() {\n        const children = Object.values(this.retained).concat(this.getAllFree());\n        this.retained = {};\n        this.free = {};\n        await Promise.all(children.map(c => this.kill(c, 'SIGTERM')));\n    }\n    getFree(id) {\n        return (this.free[id] = this.free[id] || []);\n    }\n    getAllFree() {\n        return Object.values(this.free).reduce((first, second) => first.concat(second), []);\n    }\n}\n//# sourceMappingURL=child-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQtcG9vbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDO0FBQ0E7QUFDQSxZQUFZLEtBQ3NCO0FBQ2xDO0FBQ0E7QUFDTztBQUNQLGtCQUFrQjtBQUNsQixVQUFVLHNDQUFTO0FBQ25CLFVBQVUsc0NBQVMseUdBQXlHO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQtcG9vbC5qcz81NDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBDaGlsZCB9IGZyb20gJy4vY2hpbGQnO1xuY29uc3QgQ0hJTERfS0lMTF9USU1FT1VUID0gMzAwMDA7XG5jb25zdCBzdXBwb3J0Q0pTID0gKCkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jyk7XG59O1xuZXhwb3J0IGNsYXNzIENoaWxkUG9vbCB7XG4gICAgY29uc3RydWN0b3IoeyBtYWluRmlsZSA9IHN1cHBvcnRDSlMoKVxuICAgICAgICA/IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnZGlzdC9janMvY2xhc3Nlcy9tYWluLmpzJylcbiAgICAgICAgOiBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2Rpc3QvZXNtL2NsYXNzZXMvbWFpbi5qcycpLCB1c2VXb3JrZXJUaHJlYWRzLCB3b3JrZXJGb3JrT3B0aW9ucywgd29ya2VyVGhyZWFkc09wdGlvbnMsIH0pIHtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmZyZWUgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgICAgbWFpbkZpbGUsXG4gICAgICAgICAgICB1c2VXb3JrZXJUaHJlYWRzLFxuICAgICAgICAgICAgd29ya2VyRm9ya09wdGlvbnMsXG4gICAgICAgICAgICB3b3JrZXJUaHJlYWRzT3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmV0YWluKHByb2Nlc3NGaWxlKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0RnJlZShwcm9jZXNzRmlsZSkucG9wKCk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdID0gY2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBuZXcgQ2hpbGQodGhpcy5vcHRzLm1haW5GaWxlLCBwcm9jZXNzRmlsZSwge1xuICAgICAgICAgICAgdXNlV29ya2VyVGhyZWFkczogdGhpcy5vcHRzLnVzZVdvcmtlclRocmVhZHMsXG4gICAgICAgICAgICB3b3JrZXJGb3JrT3B0aW9uczogdGhpcy5vcHRzLndvcmtlckZvcmtPcHRpb25zLFxuICAgICAgICAgICAgd29ya2VyVGhyZWFkc09wdGlvbnM6IHRoaXMub3B0cy53b3JrZXJUaHJlYWRzT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkLm9uKCdleGl0JywgdGhpcy5yZW1vdmUuYmluZCh0aGlzLCBjaGlsZCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgY2hpbGQuaW5pdCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgc3RhdHVzIGhlcmUgYXMgd2VsbCwgaW4gY2FzZSB0aGUgY2hpbGQgZXhpdGVkIGJlZm9yZSB3ZSBjb3VsZFxuICAgICAgICAgICAgLy8gcmV0YWluIGl0LlxuICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXRDb2RlICE9PSBudWxsIHx8IGNoaWxkLnNpZ25hbENvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIGV4aXRlZCBiZWZvcmUgaXQgY291bGQgYmUgcmV0YWluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmV0YWluZWRbY2hpbGQucGlkXSA9IGNoaWxkO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZShjaGlsZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsZWFzZShjaGlsZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5yZXRhaW5lZFtjaGlsZC5waWRdO1xuICAgICAgICB0aGlzLmdldEZyZWUoY2hpbGQucHJvY2Vzc0ZpbGUpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZW1vdmUoY2hpbGQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmV0YWluZWRbY2hpbGQucGlkXTtcbiAgICAgICAgY29uc3QgZnJlZSA9IHRoaXMuZ2V0RnJlZShjaGlsZC5wcm9jZXNzRmlsZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBmcmVlLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBmcmVlLnNwbGljZShjaGlsZEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBraWxsKGNoaWxkLCBzaWduYWwgPSAnU0lHS0lMTCcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQua2lsbChzaWduYWwsIENISUxEX0tJTExfVElNRU9VVCk7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE9iamVjdC52YWx1ZXModGhpcy5yZXRhaW5lZCkuY29uY2F0KHRoaXMuZ2V0QWxsRnJlZSgpKTtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmZyZWUgPSB7fTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2hpbGRyZW4ubWFwKGMgPT4gdGhpcy5raWxsKGMsICdTSUdURVJNJykpKTtcbiAgICB9XG4gICAgZ2V0RnJlZShpZCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZnJlZVtpZF0gPSB0aGlzLmZyZWVbaWRdIHx8IFtdKTtcbiAgICB9XG4gICAgZ2V0QWxsRnJlZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5mcmVlKS5yZWR1Y2UoKGZpcnN0LCBzZWNvbmQpID0+IGZpcnN0LmNvbmNhdChzZWNvbmQpLCBbXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGQtcG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child-processor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildProcessor: () => (/* binding */ ChildProcessor)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n\n\nvar ChildStatus;\n(function (ChildStatus) {\n    ChildStatus[ChildStatus[\"Idle\"] = 0] = \"Idle\";\n    ChildStatus[ChildStatus[\"Started\"] = 1] = \"Started\";\n    ChildStatus[ChildStatus[\"Terminating\"] = 2] = \"Terminating\";\n    ChildStatus[ChildStatus[\"Errored\"] = 3] = \"Errored\";\n})(ChildStatus || (ChildStatus = {}));\nconst RESPONSE_TIMEOUT =  false ? 0 : 5000;\n/**\n * ChildProcessor\n *\n * This class acts as the interface between a child process and it parent process\n * so that jobs can be processed in different processes.\n *\n */\nclass ChildProcessor {\n    constructor(send, receiver) {\n        this.send = send;\n        this.receiver = receiver;\n    }\n    async init(processorFile) {\n        let processor;\n        try {\n            const { default: processorFn } = await __webpack_require__(\"(rsc)/./node_modules/bullmq/dist/esm/classes lazy recursive referencedExports: default\")(processorFile);\n            processor = processorFn;\n            if (processor.default) {\n                // support es2015 module.\n                processor = processor.default;\n            }\n            if (typeof processor !== 'function') {\n                throw new Error('No function is exported in processor file');\n            }\n        }\n        catch (err) {\n            this.status = ChildStatus.Errored;\n            return this.send({\n                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.InitFailed,\n                err: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(err),\n            });\n        }\n        const origProcessor = processor;\n        processor = function (job, token) {\n            try {\n                return Promise.resolve(origProcessor(job, token));\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        };\n        this.processor = processor;\n        this.status = ChildStatus.Idle;\n        await this.send({\n            cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.InitCompleted,\n        });\n    }\n    async start(jobJson, token) {\n        if (this.status !== ChildStatus.Idle) {\n            return this.send({\n                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Error,\n                err: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(new Error('cannot start a not idling child process')),\n            });\n        }\n        this.status = ChildStatus.Started;\n        this.currentJobPromise = (async () => {\n            try {\n                const job = this.wrapJob(jobJson, this.send);\n                const result = await this.processor(job, token);\n                await this.send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Completed,\n                    value: typeof result === 'undefined' ? null : result,\n                });\n            }\n            catch (err) {\n                await this.send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Failed,\n                    value: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.errorToJSON)(!err.message ? new Error(err) : err),\n                });\n            }\n            finally {\n                this.status = ChildStatus.Idle;\n                this.currentJobPromise = undefined;\n            }\n        })();\n    }\n    async stop() { }\n    async waitForCurrentJobAndExit() {\n        this.status = ChildStatus.Terminating;\n        try {\n            await this.currentJobPromise;\n        }\n        finally {\n            process.exit(process.exitCode || 0);\n        }\n    }\n    /**\n     * Enhance the given job argument with some functions\n     * that can be called from the sandboxed job processor.\n     *\n     * Note, the `job` argument is a JSON deserialized message\n     * from the main node process to this forked child process,\n     * the functions on the original job object are not in tact.\n     * The wrapped job adds back some of those original functions.\n     */\n    wrapJob(job, send) {\n        const wrappedJob = Object.assign(Object.assign({}, job), { queueQualifiedName: job.queueQualifiedName, data: JSON.parse(job.data || '{}'), opts: job.opts, returnValue: JSON.parse(job.returnvalue || '{}'), \n            /*\n             * Proxy `updateProgress` function, should works as `progress` function.\n             */\n            async updateProgress(progress) {\n                // Locally store reference to new progress value\n                // so that we can return it from this process synchronously.\n                this.progress = progress;\n                // Send message to update job progress.\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Progress,\n                    value: progress,\n                });\n            }, \n            /*\n             * Proxy job `log` function.\n             */\n            log: async (row) => {\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Log,\n                    value: row,\n                });\n            }, \n            /*\n             * Proxy `moveToDelayed` function.\n             */\n            moveToDelayed: async (timestamp, token) => {\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToDelayed,\n                    value: { timestamp, token },\n                });\n            }, \n            /*\n             * Proxy `moveToWait` function.\n             */\n            moveToWait: async (token) => {\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToWait,\n                    value: { token },\n                });\n            }, \n            /*\n             * Proxy `moveToWaitingChildren` function.\n             */\n            moveToWaitingChildren: async (token, opts) => {\n                const requestId = Math.random().toString(36).substring(2, 15);\n                await send({\n                    requestId,\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToWaitingChildren,\n                    value: { token, opts },\n                });\n                return waitResponse(requestId, this.receiver, RESPONSE_TIMEOUT, 'moveToWaitingChildren');\n            }, \n            /*\n             * Proxy `updateData` function.\n             */\n            updateData: async (data) => {\n                await send({\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Update,\n                    value: data,\n                });\n                wrappedJob.data = data;\n            }, \n            /**\n             * Proxy `getChildrenValues` function.\n             */\n            getChildrenValues: async () => {\n                const requestId = Math.random().toString(36).substring(2, 15);\n                await send({\n                    requestId,\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.GetChildrenValues,\n                });\n                return waitResponse(requestId, this.receiver, RESPONSE_TIMEOUT, 'getChildrenValues');\n            }, \n            /**\n             * Proxy `getIgnoredChildrenFailures` function.\n             *\n             * This method sends a request to retrieve the failures of ignored children\n             * and waits for a response from the parent process.\n             *\n             * @returns - A promise that resolves with the ignored children failures.\n             * The exact structure of the returned data depends on the parent process implementation.\n             */\n            getIgnoredChildrenFailures: async () => {\n                const requestId = Math.random().toString(36).substring(2, 15);\n                await send({\n                    requestId,\n                    cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.GetIgnoredChildrenFailures,\n                });\n                return waitResponse(requestId, this.receiver, RESPONSE_TIMEOUT, 'getIgnoredChildrenFailures');\n            } });\n        return wrappedJob;\n    }\n}\nconst waitResponse = async (requestId, receiver, timeout, cmd) => {\n    return new Promise((resolve, reject) => {\n        const listener = (msg) => {\n            if (msg.requestId === requestId) {\n                resolve(msg.value);\n                receiver.off('message', listener);\n            }\n        };\n        receiver.on('message', listener);\n        setTimeout(() => {\n            receiver.off('message', listener);\n            reject(new Error(`TimeoutError: ${cmd} timed out in (${timeout}ms)`));\n        }, timeout);\n    });\n};\n//# sourceMappingURL=child-processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQtcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNGO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DLHlCQUF5QixNQUErQixHQUFHLENBQUc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixRQUFRLDhHQUFPLGFBQWEsQ0FBQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQWE7QUFDbEMscUJBQXFCLG1EQUFXO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpREFBYTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQWE7QUFDbEMscUJBQXFCLG1EQUFXO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBYTtBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWE7QUFDdEMsMkJBQTJCLG1EQUFXO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVLDRFQUE0RSxrRUFBa0U7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFhO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFhO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFhO0FBQ3RDLDZCQUE2QixrQkFBa0I7QUFDL0MsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFhO0FBQ3RDLDZCQUE2QixPQUFPO0FBQ3BDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWE7QUFDdEMsNkJBQTZCLGFBQWE7QUFDMUMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWE7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWE7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFhO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUssZ0JBQWdCLFFBQVE7QUFDM0UsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9jaGlsZC1wcm9jZXNzb3IuanM/Zjc4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJlbnRDb21tYW5kIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgZXJyb3JUb0pTT04gfSBmcm9tICcuLi91dGlscyc7XG52YXIgQ2hpbGRTdGF0dXM7XG4oZnVuY3Rpb24gKENoaWxkU3RhdHVzKSB7XG4gICAgQ2hpbGRTdGF0dXNbQ2hpbGRTdGF0dXNbXCJJZGxlXCJdID0gMF0gPSBcIklkbGVcIjtcbiAgICBDaGlsZFN0YXR1c1tDaGlsZFN0YXR1c1tcIlN0YXJ0ZWRcIl0gPSAxXSA9IFwiU3RhcnRlZFwiO1xuICAgIENoaWxkU3RhdHVzW0NoaWxkU3RhdHVzW1wiVGVybWluYXRpbmdcIl0gPSAyXSA9IFwiVGVybWluYXRpbmdcIjtcbiAgICBDaGlsZFN0YXR1c1tDaGlsZFN0YXR1c1tcIkVycm9yZWRcIl0gPSAzXSA9IFwiRXJyb3JlZFwiO1xufSkoQ2hpbGRTdGF0dXMgfHwgKENoaWxkU3RhdHVzID0ge30pKTtcbmNvbnN0IFJFU1BPTlNFX1RJTUVPVVQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnID8gNTAwIDogNTAwMDtcbi8qKlxuICogQ2hpbGRQcm9jZXNzb3JcbiAqXG4gKiBUaGlzIGNsYXNzIGFjdHMgYXMgdGhlIGludGVyZmFjZSBiZXR3ZWVuIGEgY2hpbGQgcHJvY2VzcyBhbmQgaXQgcGFyZW50IHByb2Nlc3NcbiAqIHNvIHRoYXQgam9icyBjYW4gYmUgcHJvY2Vzc2VkIGluIGRpZmZlcmVudCBwcm9jZXNzZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hpbGRQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlbmQsIHJlY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuc2VuZCA9IHNlbmQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB9XG4gICAgYXN5bmMgaW5pdChwcm9jZXNzb3JGaWxlKSB7XG4gICAgICAgIGxldCBwcm9jZXNzb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IHByb2Nlc3NvckZuIH0gPSBhd2FpdCBpbXBvcnQocHJvY2Vzc29yRmlsZSk7XG4gICAgICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3JGbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3IuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgZXMyMDE1IG1vZHVsZS5cbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmdW5jdGlvbiBpcyBleHBvcnRlZCBpbiBwcm9jZXNzb3IgZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQ2hpbGRTdGF0dXMuRXJyb3JlZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5Jbml0RmFpbGVkLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JUb0pTT04oZXJyKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdQcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHByb2Nlc3NvciA9IGZ1bmN0aW9uIChqb2IsIHRva2VuKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3JpZ1Byb2Nlc3Nvcihqb2IsIHRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLklkbGU7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuSW5pdENvbXBsZXRlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KGpvYkpzb24sIHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hpbGRTdGF0dXMuSWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLkVycm9yLFxuICAgICAgICAgICAgICAgIGVycjogZXJyb3JUb0pTT04obmV3IEVycm9yKCdjYW5ub3Qgc3RhcnQgYSBub3QgaWRsaW5nIGNoaWxkIHByb2Nlc3MnKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLlN0YXJ0ZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudEpvYlByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLndyYXBKb2Ioam9iSnNvbiwgdGhpcy5zZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb2Nlc3Nvcihqb2IsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuQ29tcGxldGVkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJvclRvSlNPTighZXJyLm1lc3NhZ2UgPyBuZXcgRXJyb3IoZXJyKSA6IGVyciksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IENoaWxkU3RhdHVzLklkbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Sm9iUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcCgpIHsgfVxuICAgIGFzeW5jIHdhaXRGb3JDdXJyZW50Sm9iQW5kRXhpdCgpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDaGlsZFN0YXR1cy5UZXJtaW5hdGluZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudEpvYlByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQocHJvY2Vzcy5leGl0Q29kZSB8fCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHRoZSBnaXZlbiBqb2IgYXJndW1lbnQgd2l0aCBzb21lIGZ1bmN0aW9uc1xuICAgICAqIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzYW5kYm94ZWQgam9iIHByb2Nlc3Nvci5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBgam9iYCBhcmd1bWVudCBpcyBhIEpTT04gZGVzZXJpYWxpemVkIG1lc3NhZ2VcbiAgICAgKiBmcm9tIHRoZSBtYWluIG5vZGUgcHJvY2VzcyB0byB0aGlzIGZvcmtlZCBjaGlsZCBwcm9jZXNzLFxuICAgICAqIHRoZSBmdW5jdGlvbnMgb24gdGhlIG9yaWdpbmFsIGpvYiBvYmplY3QgYXJlIG5vdCBpbiB0YWN0LlxuICAgICAqIFRoZSB3cmFwcGVkIGpvYiBhZGRzIGJhY2sgc29tZSBvZiB0aG9zZSBvcmlnaW5hbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgd3JhcEpvYihqb2IsIHNlbmQpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEpvYiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgam9iKSwgeyBxdWV1ZVF1YWxpZmllZE5hbWU6IGpvYi5xdWV1ZVF1YWxpZmllZE5hbWUsIGRhdGE6IEpTT04ucGFyc2Uoam9iLmRhdGEgfHwgJ3t9JyksIG9wdHM6IGpvYi5vcHRzLCByZXR1cm5WYWx1ZTogSlNPTi5wYXJzZShqb2IucmV0dXJudmFsdWUgfHwgJ3t9JyksIFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFByb3h5IGB1cGRhdGVQcm9ncmVzc2AgZnVuY3Rpb24sIHNob3VsZCB3b3JrcyBhcyBgcHJvZ3Jlc3NgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhc3luYyB1cGRhdGVQcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIC8vIExvY2FsbHkgc3RvcmUgcmVmZXJlbmNlIHRvIG5ldyBwcm9ncmVzcyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIHJldHVybiBpdCBmcm9tIHRoaXMgcHJvY2VzcyBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICAvLyBTZW5kIG1lc3NhZ2UgdG8gdXBkYXRlIGpvYiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLlByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBQcm94eSBqb2IgYGxvZ2AgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxvZzogYXN5bmMgKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuTG9nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcm93LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogUHJveHkgYG1vdmVUb0RlbGF5ZWRgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtb3ZlVG9EZWxheWVkOiBhc3luYyAodGltZXN0YW1wLCB0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuTW92ZVRvRGVsYXllZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgdGltZXN0YW1wLCB0b2tlbiB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogUHJveHkgYG1vdmVUb1dhaXRgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtb3ZlVG9XYWl0OiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLk1vdmVUb1dhaXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBQcm94eSBgbW92ZVRvV2FpdGluZ0NoaWxkcmVuYCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbW92ZVRvV2FpdGluZ0NoaWxkcmVuOiBhc3luYyAodG9rZW4sIG9wdHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIGNtZDogUGFyZW50Q29tbWFuZC5Nb3ZlVG9XYWl0aW5nQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHRva2VuLCBvcHRzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhaXRSZXNwb25zZShyZXF1ZXN0SWQsIHRoaXMucmVjZWl2ZXIsIFJFU1BPTlNFX1RJTUVPVVQsICdtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4nKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFByb3h5IGB1cGRhdGVEYXRhYCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdXBkYXRlRGF0YTogYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLlVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEpvYi5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm94eSBgZ2V0Q2hpbGRyZW5WYWx1ZXNgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRDaGlsZHJlblZhbHVlczogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgY21kOiBQYXJlbnRDb21tYW5kLkdldENoaWxkcmVuVmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWl0UmVzcG9uc2UocmVxdWVzdElkLCB0aGlzLnJlY2VpdmVyLCBSRVNQT05TRV9USU1FT1VULCAnZ2V0Q2hpbGRyZW5WYWx1ZXMnKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm94eSBgZ2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXNgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIHNlbmRzIGEgcmVxdWVzdCB0byByZXRyaWV2ZSB0aGUgZmFpbHVyZXMgb2YgaWdub3JlZCBjaGlsZHJlblxuICAgICAgICAgICAgICogYW5kIHdhaXRzIGZvciBhIHJlc3BvbnNlIGZyb20gdGhlIHBhcmVudCBwcm9jZXNzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgaWdub3JlZCBjaGlsZHJlbiBmYWlsdXJlcy5cbiAgICAgICAgICAgICAqIFRoZSBleGFjdCBzdHJ1Y3R1cmUgb2YgdGhlIHJldHVybmVkIGRhdGEgZGVwZW5kcyBvbiB0aGUgcGFyZW50IHByb2Nlc3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldElnbm9yZWRDaGlsZHJlbkZhaWx1cmVzOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBjbWQ6IFBhcmVudENvbW1hbmQuR2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhaXRSZXNwb25zZShyZXF1ZXN0SWQsIHRoaXMucmVjZWl2ZXIsIFJFU1BPTlNFX1RJTUVPVVQsICdnZXRJZ25vcmVkQ2hpbGRyZW5GYWlsdXJlcycpO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRKb2I7XG4gICAgfVxufVxuY29uc3Qgd2FpdFJlc3BvbnNlID0gYXN5bmMgKHJlcXVlc3RJZCwgcmVjZWl2ZXIsIHRpbWVvdXQsIGNtZCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKG1zZy5yZXF1ZXN0SWQgPT09IHJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5vZmYoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlY2VpdmVyLm9mZignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXRFcnJvcjogJHtjbWR9IHRpbWVkIG91dCBpbiAoJHt0aW1lb3V0fW1zKWApKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGQtcHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/child.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/child.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Child: () => (/* binding */ Child)\n/* harmony export */ });\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(net__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var worker_threads__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n/* harmony import */ var worker_threads__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(worker_threads__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n/**\n * @see https://nodejs.org/api/process.html#process_exit_codes\n */\nconst exitCodesErrors = {\n    1: 'Uncaught Fatal Exception',\n    2: 'Unused',\n    3: 'Internal JavaScript Parse Error',\n    4: 'Internal JavaScript Evaluation Failure',\n    5: 'Fatal Error',\n    6: 'Non-function Internal Exception Handler',\n    7: 'Internal Exception Handler Run-Time Failure',\n    8: 'Unused',\n    9: 'Invalid Argument',\n    10: 'Internal JavaScript Run-Time Failure',\n    12: 'Invalid Debug Argument',\n    13: 'Unfinished Top-Level Await',\n};\n/**\n * Child class\n *\n * This class is used to create a child process or worker thread, and allows using\n * isolated processes or threads for processing jobs.\n *\n */\nclass Child extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n    constructor(mainFile, processFile, opts = {\n        useWorkerThreads: false,\n    }) {\n        super();\n        this.mainFile = mainFile;\n        this.processFile = processFile;\n        this.opts = opts;\n        this._exitCode = null;\n        this._signalCode = null;\n        this._killed = false;\n    }\n    get pid() {\n        if (this.childProcess) {\n            return this.childProcess.pid;\n        }\n        else if (this.worker) {\n            // Worker threads pids can become negative when they are terminated\n            // so we need to use the absolute value to index the retained object\n            return Math.abs(this.worker.threadId);\n        }\n        else {\n            throw new Error('No child process or worker thread');\n        }\n    }\n    get exitCode() {\n        return this._exitCode;\n    }\n    get signalCode() {\n        return this._signalCode;\n    }\n    get killed() {\n        if (this.childProcess) {\n            return this.childProcess.killed;\n        }\n        return this._killed;\n    }\n    async init() {\n        const execArgv = await convertExecArgv(process.execArgv);\n        let parent;\n        if (this.opts.useWorkerThreads) {\n            this.worker = parent = new worker_threads__WEBPACK_IMPORTED_MODULE_2__.Worker(this.mainFile, Object.assign({ execArgv, stdin: true, stdout: true, stderr: true }, (this.opts.workerThreadsOptions\n                ? this.opts.workerThreadsOptions\n                : {})));\n        }\n        else {\n            this.childProcess = parent = (0,child_process__WEBPACK_IMPORTED_MODULE_0__.fork)(this.mainFile, [], Object.assign({ execArgv, stdio: 'pipe' }, (this.opts.workerForkOptions ? this.opts.workerForkOptions : {})));\n        }\n        parent.on('exit', (exitCode, signalCode) => {\n            this._exitCode = exitCode;\n            // Coerce to null if undefined for backwards compatibility\n            signalCode = typeof signalCode === 'undefined' ? null : signalCode;\n            this._signalCode = signalCode;\n            this._killed = true;\n            this.emit('exit', exitCode, signalCode);\n            // Clean all listeners, we do not expect any more events after \"exit\"\n            parent.removeAllListeners();\n            this.removeAllListeners();\n        });\n        parent.on('error', (...args) => this.emit('error', ...args));\n        parent.on('message', (...args) => this.emit('message', ...args));\n        parent.on('close', (...args) => this.emit('close', ...args));\n        parent.stdout.pipe(process.stdout);\n        parent.stderr.pipe(process.stderr);\n        await this.initChild();\n    }\n    async send(msg) {\n        return new Promise((resolve, reject) => {\n            if (this.childProcess) {\n                this.childProcess.send(msg, (err) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            }\n            else if (this.worker) {\n                resolve(this.worker.postMessage(msg));\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    killProcess(signal = 'SIGKILL') {\n        if (this.childProcess) {\n            this.childProcess.kill(signal);\n        }\n        else if (this.worker) {\n            this.worker.terminate();\n        }\n    }\n    async kill(signal = 'SIGKILL', timeoutMs) {\n        if (this.hasProcessExited()) {\n            return;\n        }\n        const onExit = onExitOnce(this.childProcess || this.worker);\n        this.killProcess(signal);\n        if (timeoutMs !== undefined && (timeoutMs === 0 || isFinite(timeoutMs))) {\n            const timeoutHandle = setTimeout(() => {\n                if (!this.hasProcessExited()) {\n                    this.killProcess('SIGKILL');\n                }\n            }, timeoutMs);\n            await onExit;\n            clearTimeout(timeoutHandle);\n        }\n        await onExit;\n    }\n    async initChild() {\n        const onComplete = new Promise((resolve, reject) => {\n            const onMessageHandler = (msg) => {\n                if (msg.cmd === _enums__WEBPACK_IMPORTED_MODULE_3__.ParentCommand.InitCompleted) {\n                    resolve();\n                }\n                else if (msg.cmd === _enums__WEBPACK_IMPORTED_MODULE_3__.ParentCommand.InitFailed) {\n                    const err = new Error();\n                    err.stack = msg.err.stack;\n                    err.message = msg.err.message;\n                    reject(err);\n                }\n                this.off('message', onMessageHandler);\n                this.off('close', onCloseHandler);\n            };\n            const onCloseHandler = (code, signal) => {\n                if (code > 128) {\n                    code -= 128;\n                }\n                const msg = exitCodesErrors[code] || `Unknown exit code ${code}`;\n                reject(new Error(`Error initializing child: ${msg} and signal ${signal}`));\n                this.off('message', onMessageHandler);\n                this.off('close', onCloseHandler);\n            };\n            this.on('message', onMessageHandler);\n            this.on('close', onCloseHandler);\n        });\n        await this.send({\n            cmd: _enums__WEBPACK_IMPORTED_MODULE_3__.ChildCommand.Init,\n            value: this.processFile,\n        });\n        await onComplete;\n    }\n    hasProcessExited() {\n        return !!(this.exitCode !== null || this.signalCode);\n    }\n}\nfunction onExitOnce(child) {\n    return new Promise(resolve => {\n        child.once('exit', () => resolve());\n    });\n}\nconst getFreePort = async () => {\n    return new Promise(resolve => {\n        const server = (0,net__WEBPACK_IMPORTED_MODULE_1__.createServer)();\n        server.listen(0, () => {\n            const { port } = server.address();\n            server.close(() => resolve(port));\n        });\n    });\n};\nconst convertExecArgv = async (execArgv) => {\n    const standard = [];\n    const convertedArgs = [];\n    for (let i = 0; i < execArgv.length; i++) {\n        const arg = execArgv[i];\n        if (arg.indexOf('--inspect') === -1) {\n            standard.push(arg);\n        }\n        else {\n            const argName = arg.split('=')[0];\n            const port = await getFreePort();\n            convertedArgs.push(`${argName}=${port}`);\n        }\n    }\n    return standard.concat(convertedArgs);\n};\n//# sourceMappingURL=child.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvY2hpbGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNGO0FBQ0s7QUFDZTtBQUNqQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQkFBb0IsZ0RBQVk7QUFDdkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBTSxnQ0FBZ0MsbURBQW1EO0FBQ2hJO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx5Q0FBeUMsbURBQUksb0NBQW9DLHlCQUF5QixpRUFBaUU7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpREFBYTtBQUM3QztBQUNBO0FBQ0EscUNBQXFDLGlEQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxLQUFLO0FBQy9FLDhEQUE4RCxLQUFLLGFBQWEsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLGdEQUFZO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVk7QUFDbkM7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVEsR0FBRyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2NoaWxkLmpzPzQyNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9yayB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSAnbmV0JztcbmltcG9ydCB7IFdvcmtlciB9IGZyb20gJ3dvcmtlcl90aHJlYWRzJztcbmltcG9ydCB7IENoaWxkQ29tbWFuZCwgUGFyZW50Q29tbWFuZCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19leGl0X2NvZGVzXG4gKi9cbmNvbnN0IGV4aXRDb2Rlc0Vycm9ycyA9IHtcbiAgICAxOiAnVW5jYXVnaHQgRmF0YWwgRXhjZXB0aW9uJyxcbiAgICAyOiAnVW51c2VkJyxcbiAgICAzOiAnSW50ZXJuYWwgSmF2YVNjcmlwdCBQYXJzZSBFcnJvcicsXG4gICAgNDogJ0ludGVybmFsIEphdmFTY3JpcHQgRXZhbHVhdGlvbiBGYWlsdXJlJyxcbiAgICA1OiAnRmF0YWwgRXJyb3InLFxuICAgIDY6ICdOb24tZnVuY3Rpb24gSW50ZXJuYWwgRXhjZXB0aW9uIEhhbmRsZXInLFxuICAgIDc6ICdJbnRlcm5hbCBFeGNlcHRpb24gSGFuZGxlciBSdW4tVGltZSBGYWlsdXJlJyxcbiAgICA4OiAnVW51c2VkJyxcbiAgICA5OiAnSW52YWxpZCBBcmd1bWVudCcsXG4gICAgMTA6ICdJbnRlcm5hbCBKYXZhU2NyaXB0IFJ1bi1UaW1lIEZhaWx1cmUnLFxuICAgIDEyOiAnSW52YWxpZCBEZWJ1ZyBBcmd1bWVudCcsXG4gICAgMTM6ICdVbmZpbmlzaGVkIFRvcC1MZXZlbCBBd2FpdCcsXG59O1xuLyoqXG4gKiBDaGlsZCBjbGFzc1xuICpcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgYSBjaGlsZCBwcm9jZXNzIG9yIHdvcmtlciB0aHJlYWQsIGFuZCBhbGxvd3MgdXNpbmdcbiAqIGlzb2xhdGVkIHByb2Nlc3NlcyBvciB0aHJlYWRzIGZvciBwcm9jZXNzaW5nIGpvYnMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hpbGQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG1haW5GaWxlLCBwcm9jZXNzRmlsZSwgb3B0cyA9IHtcbiAgICAgICAgdXNlV29ya2VyVGhyZWFkczogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1haW5GaWxlID0gbWFpbkZpbGU7XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZpbGUgPSBwcm9jZXNzRmlsZTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fZXhpdENvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduYWxDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2lsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBwaWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkUHJvY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQcm9jZXNzLnBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgLy8gV29ya2VyIHRocmVhZHMgcGlkcyBjYW4gYmVjb21lIG5lZ2F0aXZlIHdoZW4gdGhleSBhcmUgdGVybWluYXRlZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byB1c2UgdGhlIGFic29sdXRlIHZhbHVlIHRvIGluZGV4IHRoZSByZXRhaW5lZCBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLndvcmtlci50aHJlYWRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNoaWxkIHByb2Nlc3Mgb3Igd29ya2VyIHRocmVhZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBleGl0Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXRDb2RlO1xuICAgIH1cbiAgICBnZXQgc2lnbmFsQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbENvZGU7XG4gICAgfVxuICAgIGdldCBraWxsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkUHJvY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQcm9jZXNzLmtpbGxlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fa2lsbGVkO1xuICAgIH1cbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICBjb25zdCBleGVjQXJndiA9IGF3YWl0IGNvbnZlcnRFeGVjQXJndihwcm9jZXNzLmV4ZWNBcmd2KTtcbiAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgaWYgKHRoaXMub3B0cy51c2VXb3JrZXJUaHJlYWRzKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlciA9IHBhcmVudCA9IG5ldyBXb3JrZXIodGhpcy5tYWluRmlsZSwgT2JqZWN0LmFzc2lnbih7IGV4ZWNBcmd2LCBzdGRpbjogdHJ1ZSwgc3Rkb3V0OiB0cnVlLCBzdGRlcnI6IHRydWUgfSwgKHRoaXMub3B0cy53b3JrZXJUaHJlYWRzT3B0aW9uc1xuICAgICAgICAgICAgICAgID8gdGhpcy5vcHRzLndvcmtlclRocmVhZHNPcHRpb25zXG4gICAgICAgICAgICAgICAgOiB7fSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRQcm9jZXNzID0gcGFyZW50ID0gZm9yayh0aGlzLm1haW5GaWxlLCBbXSwgT2JqZWN0LmFzc2lnbih7IGV4ZWNBcmd2LCBzdGRpbzogJ3BpcGUnIH0sICh0aGlzLm9wdHMud29ya2VyRm9ya09wdGlvbnMgPyB0aGlzLm9wdHMud29ya2VyRm9ya09wdGlvbnMgOiB7fSkpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQub24oJ2V4aXQnLCAoZXhpdENvZGUsIHNpZ25hbENvZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2V4aXRDb2RlID0gZXhpdENvZGU7XG4gICAgICAgICAgICAvLyBDb2VyY2UgdG8gbnVsbCBpZiB1bmRlZmluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBzaWduYWxDb2RlID0gdHlwZW9mIHNpZ25hbENvZGUgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHNpZ25hbENvZGU7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxDb2RlID0gc2lnbmFsQ29kZTtcbiAgICAgICAgICAgIHRoaXMuX2tpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2V4aXQnLCBleGl0Q29kZSwgc2lnbmFsQ29kZSk7XG4gICAgICAgICAgICAvLyBDbGVhbiBhbGwgbGlzdGVuZXJzLCB3ZSBkbyBub3QgZXhwZWN0IGFueSBtb3JlIGV2ZW50cyBhZnRlciBcImV4aXRcIlxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5vbignZXJyb3InLCAoLi4uYXJncykgPT4gdGhpcy5lbWl0KCdlcnJvcicsIC4uLmFyZ3MpKTtcbiAgICAgICAgcGFyZW50Lm9uKCdtZXNzYWdlJywgKC4uLmFyZ3MpID0+IHRoaXMuZW1pdCgnbWVzc2FnZScsIC4uLmFyZ3MpKTtcbiAgICAgICAgcGFyZW50Lm9uKCdjbG9zZScsICguLi5hcmdzKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJywgLi4uYXJncykpO1xuICAgICAgICBwYXJlbnQuc3Rkb3V0LnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgICAgICBwYXJlbnQuc3RkZXJyLnBpcGUocHJvY2Vzcy5zdGRlcnIpO1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRDaGlsZCgpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRQcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZFByb2Nlc3Muc2VuZChtc2csIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtpbGxQcm9jZXNzKHNpZ25hbCA9ICdTSUdLSUxMJykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZFByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRQcm9jZXNzLmtpbGwoc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMga2lsbChzaWduYWwgPSAnU0lHS0lMTCcsIHRpbWVvdXRNcykge1xuICAgICAgICBpZiAodGhpcy5oYXNQcm9jZXNzRXhpdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkV4aXQgPSBvbkV4aXRPbmNlKHRoaXMuY2hpbGRQcm9jZXNzIHx8IHRoaXMud29ya2VyKTtcbiAgICAgICAgdGhpcy5raWxsUHJvY2VzcyhzaWduYWwpO1xuICAgICAgICBpZiAodGltZW91dE1zICE9PSB1bmRlZmluZWQgJiYgKHRpbWVvdXRNcyA9PT0gMCB8fCBpc0Zpbml0ZSh0aW1lb3V0TXMpKSkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNQcm9jZXNzRXhpdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5raWxsUHJvY2VzcygnU0lHS0lMTCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICAgICAgICBhd2FpdCBvbkV4aXQ7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgb25FeGl0O1xuICAgIH1cbiAgICBhc3luYyBpbml0Q2hpbGQoKSB7XG4gICAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbk1lc3NhZ2VIYW5kbGVyID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuY21kID09PSBQYXJlbnRDb21tYW5kLkluaXRDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtc2cuY21kID09PSBQYXJlbnRDb21tYW5kLkluaXRGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IG1zZy5lcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbXNnLmVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ21lc3NhZ2UnLCBvbk1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignY2xvc2UnLCBvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZUhhbmRsZXIgPSAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPiAxMjgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSAtPSAxMjg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGV4aXRDb2Rlc0Vycm9yc1tjb2RlXSB8fCBgVW5rbm93biBleGl0IGNvZGUgJHtjb2RlfWA7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRXJyb3IgaW5pdGlhbGl6aW5nIGNoaWxkOiAke21zZ30gYW5kIHNpZ25hbCAke3NpZ25hbH1gKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ21lc3NhZ2UnLCBvbk1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignY2xvc2UnLCBvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbignbWVzc2FnZScsIG9uTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5vbignY2xvc2UnLCBvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgY21kOiBDaGlsZENvbW1hbmQuSW5pdCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnByb2Nlc3NGaWxlLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgb25Db21wbGV0ZTtcbiAgICB9XG4gICAgaGFzUHJvY2Vzc0V4aXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZXhpdENvZGUgIT09IG51bGwgfHwgdGhpcy5zaWduYWxDb2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbkV4aXRPbmNlKGNoaWxkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjaGlsZC5vbmNlKCdleGl0JywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICB9KTtcbn1cbmNvbnN0IGdldEZyZWVQb3J0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3Qgc2VydmVyID0gY3JlYXRlU2VydmVyKCk7XG4gICAgICAgIHNlcnZlci5saXN0ZW4oMCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwb3J0IH0gPSBzZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHJlc29sdmUocG9ydCkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCBjb252ZXJ0RXhlY0FyZ3YgPSBhc3luYyAoZXhlY0FyZ3YpID0+IHtcbiAgICBjb25zdCBzdGFuZGFyZCA9IFtdO1xuICAgIGNvbnN0IGNvbnZlcnRlZEFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4ZWNBcmd2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGV4ZWNBcmd2W2ldO1xuICAgICAgICBpZiAoYXJnLmluZGV4T2YoJy0taW5zcGVjdCcpID09PSAtMSkge1xuICAgICAgICAgICAgc3RhbmRhcmQucHVzaChhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXJnTmFtZSA9IGFyZy5zcGxpdCgnPScpWzBdO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IGF3YWl0IGdldEZyZWVQb3J0KCk7XG4gICAgICAgICAgICBjb252ZXJ0ZWRBcmdzLnB1c2goYCR7YXJnTmFtZX09JHtwb3J0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFuZGFyZC5jb25jYXQoY29udmVydGVkQXJncyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/child.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELAYED_ERROR: () => (/* binding */ DELAYED_ERROR),\n/* harmony export */   DelayedError: () => (/* binding */ DelayedError)\n/* harmony export */ });\nconst DELAYED_ERROR = 'bullmq:movedToDelayed';\n/**\n * DelayedError\n *\n * Error to be thrown when job is moved to delayed state\n * from job in active state.\n *\n */\nclass DelayedError extends Error {\n    constructor(message = DELAYED_ERROR) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=delayed-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL2RlbGF5ZWQtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL2RlbGF5ZWQtZXJyb3IuanM/MDU0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREVMQVlFRF9FUlJPUiA9ICdidWxsbXE6bW92ZWRUb0RlbGF5ZWQnO1xuLyoqXG4gKiBEZWxheWVkRXJyb3JcbiAqXG4gKiBFcnJvciB0byBiZSB0aHJvd24gd2hlbiBqb2IgaXMgbW92ZWQgdG8gZGVsYXllZCBzdGF0ZVxuICogZnJvbSBqb2IgaW4gYWN0aXZlIHN0YXRlLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERlbGF5ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gREVMQVlFRF9FUlJPUikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5ZWQtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELAYED_ERROR: () => (/* reexport safe */ _delayed_error__WEBPACK_IMPORTED_MODULE_0__.DELAYED_ERROR),\n/* harmony export */   DelayedError: () => (/* reexport safe */ _delayed_error__WEBPACK_IMPORTED_MODULE_0__.DelayedError),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _rate_limit_error__WEBPACK_IMPORTED_MODULE_1__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _rate_limit_error__WEBPACK_IMPORTED_MODULE_1__.RateLimitError),\n/* harmony export */   UNRECOVERABLE_ERROR: () => (/* reexport safe */ _unrecoverable_error__WEBPACK_IMPORTED_MODULE_2__.UNRECOVERABLE_ERROR),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _unrecoverable_error__WEBPACK_IMPORTED_MODULE_2__.UnrecoverableError),\n/* harmony export */   WAITING_CHILDREN_ERROR: () => (/* reexport safe */ _waiting_children_error__WEBPACK_IMPORTED_MODULE_3__.WAITING_CHILDREN_ERROR),\n/* harmony export */   WAITING_ERROR: () => (/* reexport safe */ _waiting_error__WEBPACK_IMPORTED_MODULE_4__.WAITING_ERROR),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _waiting_children_error__WEBPACK_IMPORTED_MODULE_3__.WaitingChildrenError),\n/* harmony export */   WaitingError: () => (/* reexport safe */ _waiting_error__WEBPACK_IMPORTED_MODULE_4__.WaitingError)\n/* harmony export */ });\n/* harmony import */ var _delayed_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./delayed-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/delayed-error.js\");\n/* harmony import */ var _rate_limit_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rate-limit-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js\");\n/* harmony import */ var _unrecoverable_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unrecoverable-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\");\n/* harmony import */ var _waiting_children_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./waiting-children-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js\");\n/* harmony import */ var _waiting_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./waiting-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-error.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNHO0FBQ0c7QUFDRztBQUNUO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9lcnJvcnMvaW5kZXguanM/M2MwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2RlbGF5ZWQtZXJyb3InO1xuZXhwb3J0ICogZnJvbSAnLi9yYXRlLWxpbWl0LWVycm9yJztcbmV4cG9ydCAqIGZyb20gJy4vdW5yZWNvdmVyYWJsZS1lcnJvcic7XG5leHBvcnQgKiBmcm9tICcuL3dhaXRpbmctY2hpbGRyZW4tZXJyb3InO1xuZXhwb3J0ICogZnJvbSAnLi93YWl0aW5nLWVycm9yJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* binding */ RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError)\n/* harmony export */ });\nconst RATE_LIMIT_ERROR = 'bullmq:rateLimitExceeded';\n/**\n * RateLimitError\n *\n * Error to be thrown when queue reaches a rate limit.\n *\n */\nclass RateLimitError extends Error {\n    constructor(message = RATE_LIMIT_ERROR) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=rate-limit-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3JhdGUtbGltaXQtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2Vycm9ycy9yYXRlLWxpbWl0LWVycm9yLmpzPzJkNzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFJBVEVfTElNSVRfRVJST1IgPSAnYnVsbG1xOnJhdGVMaW1pdEV4Y2VlZGVkJztcbi8qKlxuICogUmF0ZUxpbWl0RXJyb3JcbiAqXG4gKiBFcnJvciB0byBiZSB0aHJvd24gd2hlbiBxdWV1ZSByZWFjaGVzIGEgcmF0ZSBsaW1pdC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gUkFURV9MSU1JVF9FUlJPUikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGUtbGltaXQtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/rate-limit-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UNRECOVERABLE_ERROR: () => (/* binding */ UNRECOVERABLE_ERROR),\n/* harmony export */   UnrecoverableError: () => (/* binding */ UnrecoverableError)\n/* harmony export */ });\nconst UNRECOVERABLE_ERROR = 'bullmq:unrecoverable';\n/**\n * UnrecoverableError\n *\n * Error to move a job to failed even if the attemptsMade\n * are lower than the expected limit.\n *\n */\nclass UnrecoverableError extends Error {\n    constructor(message = UNRECOVERABLE_ERROR) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=unrecoverable-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3VucmVjb3ZlcmFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3VucmVjb3ZlcmFibGUtZXJyb3IuanM/OTQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVU5SRUNPVkVSQUJMRV9FUlJPUiA9ICdidWxsbXE6dW5yZWNvdmVyYWJsZSc7XG4vKipcbiAqIFVucmVjb3ZlcmFibGVFcnJvclxuICpcbiAqIEVycm9yIHRvIG1vdmUgYSBqb2IgdG8gZmFpbGVkIGV2ZW4gaWYgdGhlIGF0dGVtcHRzTWFkZVxuICogYXJlIGxvd2VyIHRoYW4gdGhlIGV4cGVjdGVkIGxpbWl0LlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFVucmVjb3ZlcmFibGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gVU5SRUNPVkVSQUJMRV9FUlJPUikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVucmVjb3ZlcmFibGUtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WAITING_CHILDREN_ERROR: () => (/* binding */ WAITING_CHILDREN_ERROR),\n/* harmony export */   WaitingChildrenError: () => (/* binding */ WaitingChildrenError)\n/* harmony export */ });\nconst WAITING_CHILDREN_ERROR = 'bullmq:movedToWaitingChildren';\n/**\n * WaitingChildrenError\n *\n * Error to be thrown when job is moved to waiting-children state\n * from job in active state.\n *\n */\nclass WaitingChildrenError extends Error {\n    constructor(message = WAITING_CHILDREN_ERROR) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=waiting-children-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3dhaXRpbmctY2hpbGRyZW4tZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3dhaXRpbmctY2hpbGRyZW4tZXJyb3IuanM/YmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgV0FJVElOR19DSElMRFJFTl9FUlJPUiA9ICdidWxsbXE6bW92ZWRUb1dhaXRpbmdDaGlsZHJlbic7XG4vKipcbiAqIFdhaXRpbmdDaGlsZHJlbkVycm9yXG4gKlxuICogRXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gam9iIGlzIG1vdmVkIHRvIHdhaXRpbmctY2hpbGRyZW4gc3RhdGVcbiAqIGZyb20gam9iIGluIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWl0aW5nQ2hpbGRyZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gV0FJVElOR19DSElMRFJFTl9FUlJPUikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhaXRpbmctY2hpbGRyZW4tZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-children-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/errors/waiting-error.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WAITING_ERROR: () => (/* binding */ WAITING_ERROR),\n/* harmony export */   WaitingError: () => (/* binding */ WaitingError)\n/* harmony export */ });\nconst WAITING_ERROR = 'bullmq:movedToWait';\n/**\n * WaitingError\n *\n * Error to be thrown when job is moved to wait or prioritized state\n * from job in active state.\n */\nclass WaitingError extends Error {\n    constructor(message = WAITING_ERROR) {\n        super(message);\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=waiting-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZXJyb3JzL3dhaXRpbmctZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2Vycm9ycy93YWl0aW5nLWVycm9yLmpzPzRkYzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFdBSVRJTkdfRVJST1IgPSAnYnVsbG1xOm1vdmVkVG9XYWl0Jztcbi8qKlxuICogV2FpdGluZ0Vycm9yXG4gKlxuICogRXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gam9iIGlzIG1vdmVkIHRvIHdhaXQgb3IgcHJpb3JpdGl6ZWQgc3RhdGVcbiAqIGZyb20gam9iIGluIGFjdGl2ZSBzdGF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdhaXRpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gV0FJVElOR19FUlJPUikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhaXRpbmctZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/errors/waiting-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/flow-producer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowProducer: () => (/* binding */ FlowProducer)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm/v4.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n\n\n\n\n\n\n\n/**\n * This class allows to add jobs with dependencies between them in such\n * a way that it is possible to build complex flows.\n * Note: A flow is a tree-like structure of jobs that depend on each other.\n * Whenever the children of a given parent are completed, the parent\n * will be processed, being able to access the children's result data.\n * All Jobs can be in different queues, either children or parents,\n */\nclass FlowProducer extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(opts = { connection: {} }, Connection = _redis_connection__WEBPACK_IMPORTED_MODULE_4__.RedisConnection) {\n        super();\n        this.opts = opts;\n        this.opts = Object.assign({ prefix: 'bull' }, opts);\n        this.connection = new Connection(opts.connection, {\n            shared: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isRedisInstance)(opts.connection),\n            blocking: false,\n            skipVersionCheck: opts.skipVersionCheck,\n            skipWaitingForReady: opts.skipWaitingForReady,\n        });\n        this.connection.on('error', (error) => this.emit('error', error));\n        this.connection.on('close', () => {\n            if (!this.closing) {\n                this.emit('ioredis:close');\n            }\n        });\n        this.queueKeys = new _queue_keys__WEBPACK_IMPORTED_MODULE_3__.QueueKeys(opts.prefix);\n        if (opts === null || opts === void 0 ? void 0 : opts.telemetry) {\n            this.telemetry = opts.telemetry;\n        }\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Returns a promise that resolves to a redis client. Normally used only by subclasses.\n     */\n    get client() {\n        return this.connection.client;\n    }\n    /**\n     * Helper to easily extend Job class calls.\n     */\n    get Job() {\n        return _job__WEBPACK_IMPORTED_MODULE_2__.Job;\n    }\n    waitUntilReady() {\n        return this.client;\n    }\n    /**\n     * Adds a flow.\n     *\n     * This call would be atomic, either it fails and no jobs will\n     * be added to the queues, or it succeeds and all jobs will be added.\n     *\n     * @param flow - an object with a tree-like structure where children jobs\n     * will be processed before their parents.\n     * @param opts - options that will be applied to the flow object.\n     */\n    async add(flow, opts) {\n        var _a;\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const multi = client.multi();\n        const parentOpts = (_a = flow === null || flow === void 0 ? void 0 : flow.opts) === null || _a === void 0 ? void 0 : _a.parent;\n        const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParentKey)(parentOpts);\n        const parentDependenciesKey = parentKey\n            ? `${parentKey}:dependencies`\n            : undefined;\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.trace)(this.telemetry, _enums__WEBPACK_IMPORTED_MODULE_5__.SpanKind.PRODUCER, flow.queueName, 'addFlow', flow.queueName, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_5__.TelemetryAttributes.FlowName]: flow.name,\n            });\n            const jobsTree = await this.addNode({\n                multi,\n                node: flow,\n                queuesOpts: opts === null || opts === void 0 ? void 0 : opts.queuesOptions,\n                parent: {\n                    parentOpts,\n                    parentDependenciesKey,\n                },\n            });\n            await multi.exec();\n            return jobsTree;\n        });\n    }\n    /**\n     * Get a flow.\n     *\n     * @param opts - an object with options for getting a JobNode.\n     */\n    async getFlow(opts) {\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const updatedOpts = Object.assign({\n            depth: 10,\n            maxChildren: 20,\n            prefix: this.opts.prefix,\n        }, opts);\n        const jobsTree = this.getNode(client, updatedOpts);\n        return jobsTree;\n    }\n    /**\n     * Adds multiple flows.\n     *\n     * A flow is a tree-like structure of jobs that depend on each other.\n     * Whenever the children of a given parent are completed, the parent\n     * will be processed, being able to access the children's result data.\n     *\n     * All Jobs can be in different queues, either children or parents,\n     * however this call would be atomic, either it fails and no jobs will\n     * be added to the queues, or it succeeds and all jobs will be added.\n     *\n     * @param flows - an array of objects with a tree-like structure where children jobs\n     * will be processed before their parents.\n     */\n    async addBulk(flows) {\n        if (this.closing) {\n            return;\n        }\n        const client = await this.connection.client;\n        const multi = client.multi();\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.trace)(this.telemetry, _enums__WEBPACK_IMPORTED_MODULE_5__.SpanKind.PRODUCER, '', 'addBulkFlows', '', async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_5__.TelemetryAttributes.BulkCount]: flows.length,\n                [_enums__WEBPACK_IMPORTED_MODULE_5__.TelemetryAttributes.BulkNames]: flows\n                    .map(flow => flow.name)\n                    .join(','),\n            });\n            const jobsTrees = await this.addNodes(multi, flows);\n            await multi.exec();\n            return jobsTrees;\n        });\n    }\n    /**\n     * Add a node (job) of a flow to the queue. This method will recursively\n     * add all its children as well. Note that a given job can potentially be\n     * a parent and a child job at the same time depending on where it is located\n     * in the tree hierarchy.\n     *\n     * @param multi - ioredis ChainableCommander\n     * @param node - the node representing a job to be added to some queue\n     * @param parent - parent data sent to children to create the \"links\" to their parent\n     * @returns\n     */\n    async addNode({ multi, node, parent, queuesOpts, }) {\n        var _a, _b;\n        const prefix = node.prefix || this.opts.prefix;\n        const queue = this.queueFromNode(node, new _queue_keys__WEBPACK_IMPORTED_MODULE_3__.QueueKeys(prefix), prefix);\n        const queueOpts = queuesOpts && queuesOpts[node.queueName];\n        const jobsOpts = (_a = queueOpts === null || queueOpts === void 0 ? void 0 : queueOpts.defaultJobOptions) !== null && _a !== void 0 ? _a : {};\n        const jobId = ((_b = node.opts) === null || _b === void 0 ? void 0 : _b.jobId) || (0,uuid__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.trace)(this.telemetry, _enums__WEBPACK_IMPORTED_MODULE_5__.SpanKind.PRODUCER, node.queueName, 'addNode', node.queueName, async (span, srcPropagationMedatada) => {\n            var _a, _b;\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_5__.TelemetryAttributes.JobName]: node.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_5__.TelemetryAttributes.JobId]: jobId,\n            });\n            const opts = node.opts;\n            let telemetry = opts === null || opts === void 0 ? void 0 : opts.telemetry;\n            if (srcPropagationMedatada && opts) {\n                const omitContext = (_a = opts.telemetry) === null || _a === void 0 ? void 0 : _a.omitContext;\n                const telemetryMetadata = ((_b = opts.telemetry) === null || _b === void 0 ? void 0 : _b.metadata) ||\n                    (!omitContext && srcPropagationMedatada);\n                if (telemetryMetadata || omitContext) {\n                    telemetry = {\n                        metadata: telemetryMetadata,\n                        omitContext,\n                    };\n                }\n            }\n            const job = new this.Job(queue, node.name, node.data, Object.assign(Object.assign(Object.assign({}, jobsOpts), opts), { parent: parent === null || parent === void 0 ? void 0 : parent.parentOpts, telemetry }), jobId);\n            const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParentKey)(parent === null || parent === void 0 ? void 0 : parent.parentOpts);\n            if (node.children && node.children.length > 0) {\n                // Create the parent job, it will be a job in status \"waiting-children\".\n                const parentId = jobId;\n                const queueKeysParent = new _queue_keys__WEBPACK_IMPORTED_MODULE_3__.QueueKeys(node.prefix || this.opts.prefix);\n                const waitChildrenKey = queueKeysParent.toKey(node.queueName, 'waiting-children');\n                await job.addJob(multi, {\n                    parentDependenciesKey: parent === null || parent === void 0 ? void 0 : parent.parentDependenciesKey,\n                    waitChildrenKey,\n                    parentKey,\n                });\n                const parentDependenciesKey = `${queueKeysParent.toKey(node.queueName, parentId)}:dependencies`;\n                const children = await this.addChildren({\n                    multi,\n                    nodes: node.children,\n                    parent: {\n                        parentOpts: {\n                            id: parentId,\n                            queue: queueKeysParent.getQueueQualifiedName(node.queueName),\n                        },\n                        parentDependenciesKey,\n                    },\n                    queuesOpts,\n                });\n                return { job, children };\n            }\n            else {\n                await job.addJob(multi, {\n                    parentDependenciesKey: parent === null || parent === void 0 ? void 0 : parent.parentDependenciesKey,\n                    parentKey,\n                });\n                return { job };\n            }\n        });\n    }\n    /**\n     * Adds nodes (jobs) of multiple flows to the queue. This method will recursively\n     * add all its children as well. Note that a given job can potentially be\n     * a parent and a child job at the same time depending on where it is located\n     * in the tree hierarchy.\n     *\n     * @param multi - ioredis ChainableCommander\n     * @param nodes - the nodes representing jobs to be added to some queue\n     * @returns\n     */\n    addNodes(multi, nodes) {\n        return Promise.all(nodes.map(node => {\n            var _a;\n            const parentOpts = (_a = node === null || node === void 0 ? void 0 : node.opts) === null || _a === void 0 ? void 0 : _a.parent;\n            const parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParentKey)(parentOpts);\n            const parentDependenciesKey = parentKey\n                ? `${parentKey}:dependencies`\n                : undefined;\n            return this.addNode({\n                multi,\n                node,\n                parent: {\n                    parentOpts,\n                    parentDependenciesKey,\n                },\n            });\n        }));\n    }\n    async getNode(client, node) {\n        const queue = this.queueFromNode(node, new _queue_keys__WEBPACK_IMPORTED_MODULE_3__.QueueKeys(node.prefix), node.prefix);\n        const job = await this.Job.fromId(queue, node.id);\n        if (job) {\n            const { processed = {}, unprocessed = [], failed = [], ignored = {}, } = await job.getDependencies({\n                failed: {\n                    count: node.maxChildren,\n                },\n                processed: {\n                    count: node.maxChildren,\n                },\n                unprocessed: {\n                    count: node.maxChildren,\n                },\n                ignored: {\n                    count: node.maxChildren,\n                },\n            });\n            const processedKeys = Object.keys(processed);\n            const ignoredKeys = Object.keys(ignored);\n            const childrenCount = processedKeys.length +\n                unprocessed.length +\n                ignoredKeys.length +\n                failed.length;\n            const newDepth = node.depth - 1;\n            if (childrenCount > 0 && newDepth) {\n                const children = await this.getChildren(client, [...processedKeys, ...unprocessed, ...failed, ...ignoredKeys], newDepth, node.maxChildren);\n                return { job, children };\n            }\n            else {\n                return { job };\n            }\n        }\n    }\n    addChildren({ multi, nodes, parent, queuesOpts }) {\n        return Promise.all(nodes.map(node => this.addNode({ multi, node, parent, queuesOpts })));\n    }\n    getChildren(client, childrenKeys, depth, maxChildren) {\n        const getChild = (key) => {\n            const [prefix, queueName, id] = key.split(':');\n            return this.getNode(client, {\n                id,\n                queueName,\n                prefix,\n                depth,\n                maxChildren,\n            });\n        };\n        return Promise.all([...childrenKeys.map(getChild)]);\n    }\n    /**\n     * Helper factory method that creates a queue-like object\n     * required to create jobs in any queue.\n     *\n     * @param node -\n     * @param queueKeys -\n     * @returns\n     */\n    queueFromNode(node, queueKeys, prefix) {\n        return {\n            client: this.connection.client,\n            name: node.queueName,\n            keys: queueKeys.getKeys(node.queueName),\n            toKey: (type) => queueKeys.toKey(node.queueName, type),\n            opts: { prefix, connection: {} },\n            qualifiedName: queueKeys.getQueueQualifiedName(node.queueName),\n            closing: this.closing,\n            waitUntilReady: async () => this.connection.client,\n            removeListener: this.removeListener.bind(this),\n            emit: this.emit.bind(this),\n            on: this.on.bind(this),\n            redisVersion: this.connection.redisVersion,\n            trace: async () => { },\n        };\n    }\n    /**\n     *\n     * Closes the connection and returns a promise that resolves when the connection is closed.\n     */\n    async close() {\n        if (!this.closing) {\n            this.closing = this.connection.close();\n        }\n        await this.closing;\n    }\n    /**\n     *\n     * Force disconnects a connection.\n     */\n    disconnect() {\n        return this.connection.disconnect();\n    }\n}\n//# sourceMappingURL=flow-producer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvZmxvdy1wcm9kdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBc0M7QUFDWjtBQUNzQztBQUNwQztBQUNhO0FBQ1k7QUFDSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLGdEQUFZO0FBQzlDLHlCQUF5QixnQkFBZ0IsZUFBZSw4REFBZTtBQUN2RTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLG9CQUFvQix1REFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkIsa0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQVk7QUFDdEM7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBLGVBQWUsNkNBQUssaUJBQWlCLDRDQUFRO0FBQzdDO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFLLGlCQUFpQiw0Q0FBUTtBQUM3QztBQUNBLGlCQUFpQix1REFBbUI7QUFDcEMsaUJBQWlCLHVEQUFtQjtBQUNwQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQSxtREFBbUQsa0RBQVM7QUFDNUQ7QUFDQTtBQUNBLDBGQUEwRixnREFBRTtBQUM1RixlQUFlLDZDQUFLLGlCQUFpQiw0Q0FBUTtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxpQkFBaUIsdURBQW1CO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxzQkFBc0Isc0ZBQXNGO0FBQzFOLDhCQUE4QixvREFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0RBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpREFBaUQsZ0RBQWdEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQVk7QUFDMUM7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxtREFBbUQsa0RBQVM7QUFDNUQ7QUFDQTtBQUNBLG9CQUFvQixjQUFjLDZDQUE2QyxJQUFJO0FBQ25GO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsNERBQTRELGlDQUFpQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2Zsb3ctcHJvZHVjZXIuanM/ZTY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IGdldFBhcmVudEtleSwgaXNSZWRpc0luc3RhbmNlLCB0cmFjZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IFF1ZXVlS2V5cyB9IGZyb20gJy4vcXVldWUta2V5cyc7XG5pbXBvcnQgeyBSZWRpc0Nvbm5lY3Rpb24gfSBmcm9tICcuL3JlZGlzLWNvbm5lY3Rpb24nO1xuaW1wb3J0IHsgU3BhbktpbmQsIFRlbGVtZXRyeUF0dHJpYnV0ZXMgfSBmcm9tICcuLi9lbnVtcyc7XG4vKipcbiAqIFRoaXMgY2xhc3MgYWxsb3dzIHRvIGFkZCBqb2JzIHdpdGggZGVwZW5kZW5jaWVzIGJldHdlZW4gdGhlbSBpbiBzdWNoXG4gKiBhIHdheSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGJ1aWxkIGNvbXBsZXggZmxvd3MuXG4gKiBOb3RlOiBBIGZsb3cgaXMgYSB0cmVlLWxpa2Ugc3RydWN0dXJlIG9mIGpvYnMgdGhhdCBkZXBlbmQgb24gZWFjaCBvdGhlci5cbiAqIFdoZW5ldmVyIHRoZSBjaGlsZHJlbiBvZiBhIGdpdmVuIHBhcmVudCBhcmUgY29tcGxldGVkLCB0aGUgcGFyZW50XG4gKiB3aWxsIGJlIHByb2Nlc3NlZCwgYmVpbmcgYWJsZSB0byBhY2Nlc3MgdGhlIGNoaWxkcmVuJ3MgcmVzdWx0IGRhdGEuXG4gKiBBbGwgSm9icyBjYW4gYmUgaW4gZGlmZmVyZW50IHF1ZXVlcywgZWl0aGVyIGNoaWxkcmVuIG9yIHBhcmVudHMsXG4gKi9cbmV4cG9ydCBjbGFzcyBGbG93UHJvZHVjZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7IGNvbm5lY3Rpb246IHt9IH0sIENvbm5lY3Rpb24gPSBSZWRpc0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7IHByZWZpeDogJ2J1bGwnIH0sIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihvcHRzLmNvbm5lY3Rpb24sIHtcbiAgICAgICAgICAgIHNoYXJlZDogaXNSZWRpc0luc3RhbmNlKG9wdHMuY29ubmVjdGlvbiksXG4gICAgICAgICAgICBibG9ja2luZzogZmFsc2UsXG4gICAgICAgICAgICBza2lwVmVyc2lvbkNoZWNrOiBvcHRzLnNraXBWZXJzaW9uQ2hlY2ssXG4gICAgICAgICAgICBza2lwV2FpdGluZ0ZvclJlYWR5OiBvcHRzLnNraXBXYWl0aW5nRm9yUmVhZHksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpb3JlZGlzOmNsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlS2V5cyA9IG5ldyBRdWV1ZUtleXMob3B0cy5wcmVmaXgpO1xuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnRlbGVtZXRyeSkge1xuICAgICAgICAgICAgdGhpcy50ZWxlbWV0cnkgPSBvcHRzLnRlbGVtZXRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgcmVkaXMgY2xpZW50LiBOb3JtYWxseSB1c2VkIG9ubHkgYnkgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIGVhc2lseSBleHRlbmQgSm9iIGNsYXNzIGNhbGxzLlxuICAgICAqL1xuICAgIGdldCBKb2IoKSB7XG4gICAgICAgIHJldHVybiBKb2I7XG4gICAgfVxuICAgIHdhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmbG93LlxuICAgICAqXG4gICAgICogVGhpcyBjYWxsIHdvdWxkIGJlIGF0b21pYywgZWl0aGVyIGl0IGZhaWxzIGFuZCBubyBqb2JzIHdpbGxcbiAgICAgKiBiZSBhZGRlZCB0byB0aGUgcXVldWVzLCBvciBpdCBzdWNjZWVkcyBhbmQgYWxsIGpvYnMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbG93IC0gYW4gb2JqZWN0IHdpdGggYSB0cmVlLWxpa2Ugc3RydWN0dXJlIHdoZXJlIGNoaWxkcmVuIGpvYnNcbiAgICAgKiB3aWxsIGJlIHByb2Nlc3NlZCBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZsb3cgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGFkZChmbG93LCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudE9wdHMgPSAoX2EgPSBmbG93ID09PSBudWxsIHx8IGZsb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZsb3cub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudDtcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KHBhcmVudE9wdHMpO1xuICAgICAgICBjb25zdCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBwYXJlbnRLZXlcbiAgICAgICAgICAgID8gYCR7cGFyZW50S2V5fTpkZXBlbmRlbmNpZXNgXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRyYWNlKHRoaXMudGVsZW1ldHJ5LCBTcGFuS2luZC5QUk9EVUNFUiwgZmxvdy5xdWV1ZU5hbWUsICdhZGRGbG93JywgZmxvdy5xdWV1ZU5hbWUsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuRmxvd05hbWVdOiBmbG93Lm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGpvYnNUcmVlID0gYXdhaXQgdGhpcy5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICBtdWx0aSxcbiAgICAgICAgICAgICAgICBub2RlOiBmbG93LFxuICAgICAgICAgICAgICAgIHF1ZXVlc09wdHM6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5xdWV1ZXNPcHRpb25zLFxuICAgICAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPcHRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbXVsdGkuZXhlYygpO1xuICAgICAgICAgICAgcmV0dXJuIGpvYnNUcmVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucyBmb3IgZ2V0dGluZyBhIEpvYk5vZGUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmxvdyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY2xpZW50O1xuICAgICAgICBjb25zdCB1cGRhdGVkT3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZGVwdGg6IDEwLFxuICAgICAgICAgICAgbWF4Q2hpbGRyZW46IDIwLFxuICAgICAgICAgICAgcHJlZml4OiB0aGlzLm9wdHMucHJlZml4LFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgY29uc3Qgam9ic1RyZWUgPSB0aGlzLmdldE5vZGUoY2xpZW50LCB1cGRhdGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBqb2JzVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtdWx0aXBsZSBmbG93cy5cbiAgICAgKlxuICAgICAqIEEgZmxvdyBpcyBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgb2Ygam9icyB0aGF0IGRlcGVuZCBvbiBlYWNoIG90aGVyLlxuICAgICAqIFdoZW5ldmVyIHRoZSBjaGlsZHJlbiBvZiBhIGdpdmVuIHBhcmVudCBhcmUgY29tcGxldGVkLCB0aGUgcGFyZW50XG4gICAgICogd2lsbCBiZSBwcm9jZXNzZWQsIGJlaW5nIGFibGUgdG8gYWNjZXNzIHRoZSBjaGlsZHJlbidzIHJlc3VsdCBkYXRhLlxuICAgICAqXG4gICAgICogQWxsIEpvYnMgY2FuIGJlIGluIGRpZmZlcmVudCBxdWV1ZXMsIGVpdGhlciBjaGlsZHJlbiBvciBwYXJlbnRzLFxuICAgICAqIGhvd2V2ZXIgdGhpcyBjYWxsIHdvdWxkIGJlIGF0b21pYywgZWl0aGVyIGl0IGZhaWxzIGFuZCBubyBqb2JzIHdpbGxcbiAgICAgKiBiZSBhZGRlZCB0byB0aGUgcXVldWVzLCBvciBpdCBzdWNjZWVkcyBhbmQgYWxsIGpvYnMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbG93cyAtIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgd2hlcmUgY2hpbGRyZW4gam9ic1xuICAgICAqIHdpbGwgYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGVpciBwYXJlbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZEJ1bGsoZmxvd3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIHJldHVybiB0cmFjZSh0aGlzLnRlbGVtZXRyeSwgU3BhbktpbmQuUFJPRFVDRVIsICcnLCAnYWRkQnVsa0Zsb3dzJywgJycsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuQnVsa0NvdW50XTogZmxvd3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkJ1bGtOYW1lc106IGZsb3dzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZmxvdyA9PiBmbG93Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGpvYnNUcmVlcyA9IGF3YWl0IHRoaXMuYWRkTm9kZXMobXVsdGksIGZsb3dzKTtcbiAgICAgICAgICAgIGF3YWl0IG11bHRpLmV4ZWMoKTtcbiAgICAgICAgICAgIHJldHVybiBqb2JzVHJlZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIChqb2IpIG9mIGEgZmxvdyB0byB0aGUgcXVldWUuIFRoaXMgbWV0aG9kIHdpbGwgcmVjdXJzaXZlbHlcbiAgICAgKiBhZGQgYWxsIGl0cyBjaGlsZHJlbiBhcyB3ZWxsLiBOb3RlIHRoYXQgYSBnaXZlbiBqb2IgY2FuIHBvdGVudGlhbGx5IGJlXG4gICAgICogYSBwYXJlbnQgYW5kIGEgY2hpbGQgam9iIGF0IHRoZSBzYW1lIHRpbWUgZGVwZW5kaW5nIG9uIHdoZXJlIGl0IGlzIGxvY2F0ZWRcbiAgICAgKiBpbiB0aGUgdHJlZSBoaWVyYXJjaHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXVsdGkgLSBpb3JlZGlzIENoYWluYWJsZUNvbW1hbmRlclxuICAgICAqIEBwYXJhbSBub2RlIC0gdGhlIG5vZGUgcmVwcmVzZW50aW5nIGEgam9iIHRvIGJlIGFkZGVkIHRvIHNvbWUgcXVldWVcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gcGFyZW50IGRhdGEgc2VudCB0byBjaGlsZHJlbiB0byBjcmVhdGUgdGhlIFwibGlua3NcIiB0byB0aGVpciBwYXJlbnRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGFkZE5vZGUoeyBtdWx0aSwgbm9kZSwgcGFyZW50LCBxdWV1ZXNPcHRzLCB9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5vZGUucHJlZml4IHx8IHRoaXMub3B0cy5wcmVmaXg7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZUZyb21Ob2RlKG5vZGUsIG5ldyBRdWV1ZUtleXMocHJlZml4KSwgcHJlZml4KTtcbiAgICAgICAgY29uc3QgcXVldWVPcHRzID0gcXVldWVzT3B0cyAmJiBxdWV1ZXNPcHRzW25vZGUucXVldWVOYW1lXTtcbiAgICAgICAgY29uc3Qgam9ic09wdHMgPSAoX2EgPSBxdWV1ZU9wdHMgPT09IG51bGwgfHwgcXVldWVPcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBxdWV1ZU9wdHMuZGVmYXVsdEpvYk9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICBjb25zdCBqb2JJZCA9ICgoX2IgPSBub2RlLm9wdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2JJZCkgfHwgdjQoKTtcbiAgICAgICAgcmV0dXJuIHRyYWNlKHRoaXMudGVsZW1ldHJ5LCBTcGFuS2luZC5QUk9EVUNFUiwgbm9kZS5xdWV1ZU5hbWUsICdhZGROb2RlJywgbm9kZS5xdWV1ZU5hbWUsIGFzeW5jIChzcGFuLCBzcmNQcm9wYWdhdGlvbk1lZGF0YWRhKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYk5hbWVdOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iSWRdOiBqb2JJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IG5vZGUub3B0cztcbiAgICAgICAgICAgIGxldCB0ZWxlbWV0cnkgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudGVsZW1ldHJ5O1xuICAgICAgICAgICAgaWYgKHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEgJiYgb3B0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9taXRDb250ZXh0ID0gKF9hID0gb3B0cy50ZWxlbWV0cnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbWl0Q29udGV4dDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZWxlbWV0cnlNZXRhZGF0YSA9ICgoX2IgPSBvcHRzLnRlbGVtZXRyeSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1ldGFkYXRhKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIW9taXRDb250ZXh0ICYmIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpO1xuICAgICAgICAgICAgICAgIGlmICh0ZWxlbWV0cnlNZXRhZGF0YSB8fCBvbWl0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGVsZW1ldHJ5TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbWl0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqb2IgPSBuZXcgdGhpcy5Kb2IocXVldWUsIG5vZGUubmFtZSwgbm9kZS5kYXRhLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgam9ic09wdHMpLCBvcHRzKSwgeyBwYXJlbnQ6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnRPcHRzLCB0ZWxlbWV0cnkgfSksIGpvYklkKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IGdldFBhcmVudEtleShwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQucGFyZW50T3B0cyk7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHBhcmVudCBqb2IsIGl0IHdpbGwgYmUgYSBqb2IgaW4gc3RhdHVzIFwid2FpdGluZy1jaGlsZHJlblwiLlxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gam9iSWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVLZXlzUGFyZW50ID0gbmV3IFF1ZXVlS2V5cyhub2RlLnByZWZpeCB8fCB0aGlzLm9wdHMucHJlZml4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0Q2hpbGRyZW5LZXkgPSBxdWV1ZUtleXNQYXJlbnQudG9LZXkobm9kZS5xdWV1ZU5hbWUsICd3YWl0aW5nLWNoaWxkcmVuJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgam9iLmFkZEpvYihtdWx0aSwge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXk6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgIHdhaXRDaGlsZHJlbktleSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudERlcGVuZGVuY2llc0tleSA9IGAke3F1ZXVlS2V5c1BhcmVudC50b0tleShub2RlLnF1ZXVlTmFtZSwgcGFyZW50SWQpfTpkZXBlbmRlbmNpZXNgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgdGhpcy5hZGRDaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpLFxuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRPcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlOiBxdWV1ZUtleXNQYXJlbnQuZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5vZGUucXVldWVOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlc09wdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgam9iLCBjaGlsZHJlbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgam9iLmFkZEpvYihtdWx0aSwge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXk6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5wYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBqb2IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbm9kZXMgKGpvYnMpIG9mIG11bHRpcGxlIGZsb3dzIHRvIHRoZSBxdWV1ZS4gVGhpcyBtZXRob2Qgd2lsbCByZWN1cnNpdmVseVxuICAgICAqIGFkZCBhbGwgaXRzIGNoaWxkcmVuIGFzIHdlbGwuIE5vdGUgdGhhdCBhIGdpdmVuIGpvYiBjYW4gcG90ZW50aWFsbHkgYmVcbiAgICAgKiBhIHBhcmVudCBhbmQgYSBjaGlsZCBqb2IgYXQgdGhlIHNhbWUgdGltZSBkZXBlbmRpbmcgb24gd2hlcmUgaXQgaXMgbG9jYXRlZFxuICAgICAqIGluIHRoZSB0cmVlIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtdWx0aSAtIGlvcmVkaXMgQ2hhaW5hYmxlQ29tbWFuZGVyXG4gICAgICogQHBhcmFtIG5vZGVzIC0gdGhlIG5vZGVzIHJlcHJlc2VudGluZyBqb2JzIHRvIGJlIGFkZGVkIHRvIHNvbWUgcXVldWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFkZE5vZGVzKG11bHRpLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50T3B0cyA9IChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5vcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50O1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KHBhcmVudE9wdHMpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5XG4gICAgICAgICAgICAgICAgPyBgJHtwYXJlbnRLZXl9OmRlcGVuZGVuY2llc2BcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGUoe1xuICAgICAgICAgICAgICAgIG11bHRpLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9wdHMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9kZShjbGllbnQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlRnJvbU5vZGUobm9kZSwgbmV3IFF1ZXVlS2V5cyhub2RlLnByZWZpeCksIG5vZGUucHJlZml4KTtcbiAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5Kb2IuZnJvbUlkKHF1ZXVlLCBub2RlLmlkKTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9jZXNzZWQgPSB7fSwgdW5wcm9jZXNzZWQgPSBbXSwgZmFpbGVkID0gW10sIGlnbm9yZWQgPSB7fSwgfSA9IGF3YWl0IGpvYi5nZXREZXBlbmRlbmNpZXMoe1xuICAgICAgICAgICAgICAgIGZhaWxlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogbm9kZS5tYXhDaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogbm9kZS5tYXhDaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBub2RlLm1heENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWdub3JlZDoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogbm9kZS5tYXhDaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRLZXlzID0gT2JqZWN0LmtleXMocHJvY2Vzc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZWRLZXlzID0gT2JqZWN0LmtleXMoaWdub3JlZCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkNvdW50ID0gcHJvY2Vzc2VkS2V5cy5sZW5ndGggK1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgaWdub3JlZEtleXMubGVuZ3RoICtcbiAgICAgICAgICAgICAgICBmYWlsZWQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmV3RGVwdGggPSBub2RlLmRlcHRoIC0gMTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbkNvdW50ID4gMCAmJiBuZXdEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgdGhpcy5nZXRDaGlsZHJlbihjbGllbnQsIFsuLi5wcm9jZXNzZWRLZXlzLCAuLi51bnByb2Nlc3NlZCwgLi4uZmFpbGVkLCAuLi5pZ25vcmVkS2V5c10sIG5ld0RlcHRoLCBub2RlLm1heENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBqb2IsIGNoaWxkcmVuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBqb2IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDaGlsZHJlbih7IG11bHRpLCBub2RlcywgcGFyZW50LCBxdWV1ZXNPcHRzIH0pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5vZGVzLm1hcChub2RlID0+IHRoaXMuYWRkTm9kZSh7IG11bHRpLCBub2RlLCBwYXJlbnQsIHF1ZXVlc09wdHMgfSkpKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oY2xpZW50LCBjaGlsZHJlbktleXMsIGRlcHRoLCBtYXhDaGlsZHJlbikge1xuICAgICAgICBjb25zdCBnZXRDaGlsZCA9IChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtwcmVmaXgsIHF1ZXVlTmFtZSwgaWRdID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROb2RlKGNsaWVudCwge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHF1ZXVlTmFtZSxcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICAgICAgbWF4Q2hpbGRyZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jaGlsZHJlbktleXMubWFwKGdldENoaWxkKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZmFjdG9yeSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgcXVldWUtbGlrZSBvYmplY3RcbiAgICAgKiByZXF1aXJlZCB0byBjcmVhdGUgam9icyBpbiBhbnkgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtXG4gICAgICogQHBhcmFtIHF1ZXVlS2V5cyAtXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBxdWV1ZUZyb21Ob2RlKG5vZGUsIHF1ZXVlS2V5cywgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY29ubmVjdGlvbi5jbGllbnQsXG4gICAgICAgICAgICBuYW1lOiBub2RlLnF1ZXVlTmFtZSxcbiAgICAgICAgICAgIGtleXM6IHF1ZXVlS2V5cy5nZXRLZXlzKG5vZGUucXVldWVOYW1lKSxcbiAgICAgICAgICAgIHRvS2V5OiAodHlwZSkgPT4gcXVldWVLZXlzLnRvS2V5KG5vZGUucXVldWVOYW1lLCB0eXBlKSxcbiAgICAgICAgICAgIG9wdHM6IHsgcHJlZml4LCBjb25uZWN0aW9uOiB7fSB9LFxuICAgICAgICAgICAgcXVhbGlmaWVkTmFtZTogcXVldWVLZXlzLmdldFF1ZXVlUXVhbGlmaWVkTmFtZShub2RlLnF1ZXVlTmFtZSksXG4gICAgICAgICAgICBjbG9zaW5nOiB0aGlzLmNsb3NpbmcsXG4gICAgICAgICAgICB3YWl0VW50aWxSZWFkeTogYXN5bmMgKCkgPT4gdGhpcy5jb25uZWN0aW9uLmNsaWVudCxcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyOiB0aGlzLnJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uOiB0aGlzLm9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWRpc1ZlcnNpb246IHRoaXMuY29ubmVjdGlvbi5yZWRpc1ZlcnNpb24sXG4gICAgICAgICAgICB0cmFjZTogYXN5bmMgKCkgPT4geyB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2luZztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGb3JjZSBkaXNjb25uZWN0cyBhIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy1wcm9kdWNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* reexport safe */ _async_fifo_queue__WEBPACK_IMPORTED_MODULE_0__.AsyncFifoQueue),\n/* harmony export */   Backoffs: () => (/* reexport safe */ _backoffs__WEBPACK_IMPORTED_MODULE_1__.Backoffs),\n/* harmony export */   Child: () => (/* reexport safe */ _child__WEBPACK_IMPORTED_MODULE_2__.Child),\n/* harmony export */   ChildPool: () => (/* reexport safe */ _child_pool__WEBPACK_IMPORTED_MODULE_3__.ChildPool),\n/* harmony export */   ChildProcessor: () => (/* reexport safe */ _child_processor__WEBPACK_IMPORTED_MODULE_4__.ChildProcessor),\n/* harmony export */   DELAYED_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.DELAYED_ERROR),\n/* harmony export */   DelayedError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.DelayedError),\n/* harmony export */   FlowProducer: () => (/* reexport safe */ _flow_producer__WEBPACK_IMPORTED_MODULE_6__.FlowProducer),\n/* harmony export */   Job: () => (/* reexport safe */ _job__WEBPACK_IMPORTED_MODULE_7__.Job),\n/* harmony export */   JobScheduler: () => (/* reexport safe */ _job_scheduler__WEBPACK_IMPORTED_MODULE_8__.JobScheduler),\n/* harmony export */   PRIORITY_LIMIT: () => (/* reexport safe */ _job__WEBPACK_IMPORTED_MODULE_7__.PRIORITY_LIMIT),\n/* harmony export */   Queue: () => (/* reexport safe */ _queue__WEBPACK_IMPORTED_MODULE_14__.Queue),\n/* harmony export */   QueueBase: () => (/* reexport safe */ _queue_base__WEBPACK_IMPORTED_MODULE_9__.QueueBase),\n/* harmony export */   QueueEvents: () => (/* reexport safe */ _queue_events__WEBPACK_IMPORTED_MODULE_10__.QueueEvents),\n/* harmony export */   QueueEventsProducer: () => (/* reexport safe */ _queue_events_producer__WEBPACK_IMPORTED_MODULE_11__.QueueEventsProducer),\n/* harmony export */   QueueGetters: () => (/* reexport safe */ _queue_getters__WEBPACK_IMPORTED_MODULE_12__.QueueGetters),\n/* harmony export */   QueueKeys: () => (/* reexport safe */ _queue_keys__WEBPACK_IMPORTED_MODULE_13__.QueueKeys),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.RateLimitError),\n/* harmony export */   RedisConnection: () => (/* reexport safe */ _redis_connection__WEBPACK_IMPORTED_MODULE_15__.RedisConnection),\n/* harmony export */   Repeat: () => (/* reexport safe */ _repeat__WEBPACK_IMPORTED_MODULE_16__.Repeat),\n/* harmony export */   Scripts: () => (/* reexport safe */ _scripts__WEBPACK_IMPORTED_MODULE_18__.Scripts),\n/* harmony export */   UNRECOVERABLE_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.UNRECOVERABLE_ERROR),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.UnrecoverableError),\n/* harmony export */   WAITING_CHILDREN_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.WAITING_CHILDREN_ERROR),\n/* harmony export */   WAITING_ERROR: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.WAITING_ERROR),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.WaitingChildrenError),\n/* harmony export */   WaitingError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.WaitingError),\n/* harmony export */   Worker: () => (/* reexport safe */ _worker__WEBPACK_IMPORTED_MODULE_19__.Worker),\n/* harmony export */   defaultRepeatStrategy: () => (/* reexport safe */ _job_scheduler__WEBPACK_IMPORTED_MODULE_8__.defaultRepeatStrategy),\n/* harmony export */   getNextMillis: () => (/* reexport safe */ _repeat__WEBPACK_IMPORTED_MODULE_16__.getNextMillis),\n/* harmony export */   raw2NextJobData: () => (/* reexport safe */ _scripts__WEBPACK_IMPORTED_MODULE_18__.raw2NextJobData)\n/* harmony export */ });\n/* harmony import */ var _async_fifo_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async-fifo-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\");\n/* harmony import */ var _backoffs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./backoffs */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\");\n/* harmony import */ var _child__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./child */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child.js\");\n/* harmony import */ var _child_pool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./child-pool */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\");\n/* harmony import */ var _child_processor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./child-processor */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-processor.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\");\n/* harmony import */ var _flow_producer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flow-producer */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/flow-producer.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _job_scheduler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./job-scheduler */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job-scheduler.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _queue_events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./queue-events */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js\");\n/* harmony import */ var _queue_events_producer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./queue-events-producer */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events-producer.js\");\n/* harmony import */ var _queue_getters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./queue-getters */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n/* harmony import */ var _queue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n/* harmony import */ var _sandbox__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\");\n/* harmony import */ var _worker__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./worker */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js\");\n\n\n\n\n\n\n\n\n\n// export * from './main'; this file must not be exported\n// export * from './main-worker'; this file must not be exported\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNSO0FBQ0g7QUFDSztBQUNLO0FBQ1Q7QUFDTztBQUNWO0FBQ1U7QUFDaEMsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNMO0FBQ0U7QUFDUztBQUNSO0FBQ0g7QUFDTDtBQUNXO0FBQ1Y7QUFDQztBQUNBO0FBQ0Q7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL2luZGV4LmpzPzgzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hc3luYy1maWZvLXF1ZXVlJztcbmV4cG9ydCAqIGZyb20gJy4vYmFja29mZnMnO1xuZXhwb3J0ICogZnJvbSAnLi9jaGlsZCc7XG5leHBvcnQgKiBmcm9tICcuL2NoaWxkLXBvb2wnO1xuZXhwb3J0ICogZnJvbSAnLi9jaGlsZC1wcm9jZXNzb3InO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9mbG93LXByb2R1Y2VyJztcbmV4cG9ydCAqIGZyb20gJy4vam9iJztcbmV4cG9ydCAqIGZyb20gJy4vam9iLXNjaGVkdWxlcic7XG4vLyBleHBvcnQgKiBmcm9tICcuL21haW4nOyB0aGlzIGZpbGUgbXVzdCBub3QgYmUgZXhwb3J0ZWRcbi8vIGV4cG9ydCAqIGZyb20gJy4vbWFpbi13b3JrZXInOyB0aGlzIGZpbGUgbXVzdCBub3QgYmUgZXhwb3J0ZWRcbmV4cG9ydCAqIGZyb20gJy4vcXVldWUtYmFzZSc7XG5leHBvcnQgKiBmcm9tICcuL3F1ZXVlLWV2ZW50cyc7XG5leHBvcnQgKiBmcm9tICcuL3F1ZXVlLWV2ZW50cy1wcm9kdWNlcic7XG5leHBvcnQgKiBmcm9tICcuL3F1ZXVlLWdldHRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9xdWV1ZS1rZXlzJztcbmV4cG9ydCAqIGZyb20gJy4vcXVldWUnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWRpcy1jb25uZWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwZWF0JztcbmV4cG9ydCAqIGZyb20gJy4vc2FuZGJveCc7XG5leHBvcnQgKiBmcm9tICcuL3NjcmlwdHMnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/job-scheduler.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/job-scheduler.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobScheduler: () => (/* binding */ JobScheduler),\n/* harmony export */   defaultRepeatStrategy: () => (/* binding */ defaultRepeatStrategy)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cron-parser */ \"(rsc)/./node_modules/cron-parser/lib/parser.js\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cron_parser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n\n\n\n\n\n\nclass JobScheduler extends _queue_base__WEBPACK_IMPORTED_MODULE_2__.QueueBase {\n    constructor(name, opts, Connection) {\n        super(name, opts, Connection);\n        this.repeatStrategy =\n            (opts.settings && opts.settings.repeatStrategy) || defaultRepeatStrategy;\n    }\n    async upsertJobScheduler(jobSchedulerId, repeatOpts, jobName, jobData, opts, { override, producerId }) {\n        const { every, limit, pattern, offset } = repeatOpts;\n        if (pattern && every) {\n            throw new Error('Both .pattern and .every options are defined for this repeatable job');\n        }\n        if (!pattern && !every) {\n            throw new Error('Either .pattern or .every options must be defined for this repeatable job');\n        }\n        if (repeatOpts.immediately && repeatOpts.startDate) {\n            throw new Error('Both .immediately and .startDate options are defined for this repeatable job');\n        }\n        if (repeatOpts.immediately && repeatOpts.every) {\n            console.warn(\"Using option immediately with every does not affect the job's schedule. Job will run immediately anyway.\");\n        }\n        // Check if we reached the limit of the repeatable job's iterations\n        const iterationCount = repeatOpts.count ? repeatOpts.count + 1 : 1;\n        if (typeof repeatOpts.limit !== 'undefined' &&\n            iterationCount > repeatOpts.limit) {\n            return;\n        }\n        // Check if we reached the end date of the repeatable job\n        let now = Date.now();\n        const { endDate } = repeatOpts;\n        if (endDate && now > new Date(endDate).getTime()) {\n            return;\n        }\n        const prevMillis = opts.prevMillis || 0;\n        now = prevMillis < now ? now : prevMillis;\n        // Check if we have a start date for the repeatable job\n        const { immediately } = repeatOpts, filteredRepeatOpts = (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__rest)(repeatOpts, [\"immediately\"]);\n        let nextMillis;\n        const newOffset = null;\n        if (pattern) {\n            nextMillis = await this.repeatStrategy(now, repeatOpts, jobName);\n            if (nextMillis < now) {\n                nextMillis = now;\n            }\n        }\n        if (nextMillis || every) {\n            return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.PRODUCER, 'add', `${this.name}.${jobName}`, async (span, srcPropagationMedatada) => {\n                var _a, _b;\n                let telemetry = opts.telemetry;\n                if (srcPropagationMedatada) {\n                    const omitContext = (_a = opts.telemetry) === null || _a === void 0 ? void 0 : _a.omitContext;\n                    const telemetryMetadata = ((_b = opts.telemetry) === null || _b === void 0 ? void 0 : _b.metadata) ||\n                        (!omitContext && srcPropagationMedatada);\n                    if (telemetryMetadata || omitContext) {\n                        telemetry = {\n                            metadata: telemetryMetadata,\n                            omitContext,\n                        };\n                    }\n                }\n                const mergedOpts = this.getNextJobOpts(nextMillis, jobSchedulerId, Object.assign(Object.assign({}, opts), { repeat: filteredRepeatOpts, telemetry }), iterationCount, newOffset);\n                if (override) {\n                    // Clamp nextMillis to now if it's in the past\n                    if (nextMillis < now) {\n                        nextMillis = now;\n                    }\n                    const [jobId, delay] = await this.scripts.addJobScheduler(jobSchedulerId, nextMillis, JSON.stringify(typeof jobData === 'undefined' ? {} : jobData), _job__WEBPACK_IMPORTED_MODULE_1__.Job.optsAsJSON(opts), {\n                        name: jobName,\n                        startDate: repeatOpts.startDate\n                            ? new Date(repeatOpts.startDate).getTime()\n                            : undefined,\n                        endDate: endDate ? new Date(endDate).getTime() : undefined,\n                        tz: repeatOpts.tz,\n                        pattern,\n                        every,\n                        limit,\n                        offset: newOffset,\n                    }, _job__WEBPACK_IMPORTED_MODULE_1__.Job.optsAsJSON(mergedOpts), producerId);\n                    // Ensure delay is a number (Dragonflydb may return it as a string)\n                    const numericDelay = typeof delay === 'string' ? parseInt(delay, 10) : delay;\n                    const job = new this.Job(this, jobName, jobData, Object.assign(Object.assign({}, mergedOpts), { delay: numericDelay }), jobId);\n                    job.id = jobId;\n                    span === null || span === void 0 ? void 0 : span.setAttributes({\n                        [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobSchedulerId]: jobSchedulerId,\n                        [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: job.id,\n                    });\n                    return job;\n                }\n                else {\n                    const jobId = await this.scripts.updateJobSchedulerNextMillis(jobSchedulerId, nextMillis, JSON.stringify(typeof jobData === 'undefined' ? {} : jobData), _job__WEBPACK_IMPORTED_MODULE_1__.Job.optsAsJSON(mergedOpts), producerId);\n                    if (jobId) {\n                        const job = new this.Job(this, jobName, jobData, mergedOpts, jobId);\n                        job.id = jobId;\n                        span === null || span === void 0 ? void 0 : span.setAttributes({\n                            [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobSchedulerId]: jobSchedulerId,\n                            [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: job.id,\n                        });\n                        return job;\n                    }\n                }\n            });\n        }\n    }\n    getNextJobOpts(nextMillis, jobSchedulerId, opts, currentCount, offset) {\n        var _a, _b;\n        //\n        // Generate unique job id for this iteration.\n        //\n        const jobId = this.getSchedulerNextJobId({\n            jobSchedulerId,\n            nextMillis,\n        });\n        const now = Date.now();\n        const delay = nextMillis + offset - now;\n        const mergedOpts = Object.assign(Object.assign({}, opts), { jobId, delay: delay < 0 ? 0 : delay, timestamp: now, prevMillis: nextMillis, repeatJobKey: jobSchedulerId });\n        mergedOpts.repeat = Object.assign(Object.assign({}, opts.repeat), { offset, count: currentCount, startDate: ((_a = opts.repeat) === null || _a === void 0 ? void 0 : _a.startDate)\n                ? new Date(opts.repeat.startDate).getTime()\n                : undefined, endDate: ((_b = opts.repeat) === null || _b === void 0 ? void 0 : _b.endDate)\n                ? new Date(opts.repeat.endDate).getTime()\n                : undefined });\n        return mergedOpts;\n    }\n    async removeJobScheduler(jobSchedulerId) {\n        return this.scripts.removeJobScheduler(jobSchedulerId);\n    }\n    async getSchedulerData(client, key, next) {\n        const jobData = await client.hgetall(this.toKey('repeat:' + key));\n        return this.transformSchedulerData(key, jobData, next);\n    }\n    transformSchedulerData(key, jobData, next) {\n        if (jobData) {\n            const jobSchedulerData = {\n                key,\n                name: jobData.name,\n                next,\n            };\n            if (jobData.ic) {\n                jobSchedulerData.iterationCount = parseInt(jobData.ic);\n            }\n            if (jobData.limit) {\n                jobSchedulerData.limit = parseInt(jobData.limit);\n            }\n            if (jobData.startDate) {\n                jobSchedulerData.startDate = parseInt(jobData.startDate);\n            }\n            if (jobData.endDate) {\n                jobSchedulerData.endDate = parseInt(jobData.endDate);\n            }\n            if (jobData.tz) {\n                jobSchedulerData.tz = jobData.tz;\n            }\n            if (jobData.pattern) {\n                jobSchedulerData.pattern = jobData.pattern;\n            }\n            if (jobData.every) {\n                jobSchedulerData.every = parseInt(jobData.every);\n            }\n            if (jobData.offset) {\n                jobSchedulerData.offset = parseInt(jobData.offset);\n            }\n            if (jobData.data || jobData.opts) {\n                jobSchedulerData.template = this.getTemplateFromJSON(jobData.data, jobData.opts);\n            }\n            return jobSchedulerData;\n        }\n        // TODO: remove this check and keyToData as it is here only to support legacy code\n        if (key.includes(':')) {\n            return this.keyToData(key, next);\n        }\n    }\n    keyToData(key, next) {\n        const data = key.split(':');\n        const pattern = data.slice(4).join(':') || null;\n        return {\n            key,\n            name: data[0],\n            id: data[1] || null,\n            endDate: parseInt(data[2]) || null,\n            tz: data[3] || null,\n            pattern,\n            next,\n        };\n    }\n    async getScheduler(id) {\n        const [rawJobData, next] = await this.scripts.getJobScheduler(id);\n        return this.transformSchedulerData(id, rawJobData ? (0,_utils__WEBPACK_IMPORTED_MODULE_4__.array2obj)(rawJobData) : null, next ? parseInt(next) : null);\n    }\n    getTemplateFromJSON(rawData, rawOpts) {\n        const template = {};\n        if (rawData) {\n            template.data = JSON.parse(rawData);\n        }\n        if (rawOpts) {\n            template.opts = _job__WEBPACK_IMPORTED_MODULE_1__.Job.optsFromJSON(rawOpts);\n        }\n        return template;\n    }\n    async getJobSchedulers(start = 0, end = -1, asc = false) {\n        const client = await this.client;\n        const jobSchedulersKey = this.keys.repeat;\n        const result = asc\n            ? await client.zrange(jobSchedulersKey, start, end, 'WITHSCORES')\n            : await client.zrevrange(jobSchedulersKey, start, end, 'WITHSCORES');\n        const jobs = [];\n        for (let i = 0; i < result.length; i += 2) {\n            jobs.push(this.getSchedulerData(client, result[i], parseInt(result[i + 1])));\n        }\n        return Promise.all(jobs);\n    }\n    async getSchedulersCount() {\n        const jobSchedulersKey = this.keys.repeat;\n        const client = await this.client;\n        return client.zcard(jobSchedulersKey);\n    }\n    getSchedulerNextJobId({ nextMillis, jobSchedulerId, }) {\n        return `repeat:${jobSchedulerId}:${nextMillis}`;\n    }\n}\nconst defaultRepeatStrategy = (millis, opts) => {\n    const { pattern } = opts;\n    const dateFromMillis = new Date(millis);\n    const startDate = opts.startDate && new Date(opts.startDate);\n    const currentDate = startDate > dateFromMillis ? startDate : dateFromMillis;\n    const interval = (0,cron_parser__WEBPACK_IMPORTED_MODULE_0__.parseExpression)(pattern, Object.assign(Object.assign({}, opts), { currentDate }));\n    try {\n        if (opts.immediately) {\n            return new Date().getTime();\n        }\n        else {\n            return interval.next().getTime();\n        }\n    }\n    catch (e) {\n        // Ignore error\n    }\n};\n//# sourceMappingURL=job-scheduler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvam9iLXNjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0I7QUFDZTtBQUNsQjtBQUNhO0FBQ2dCO0FBQ3BCO0FBQzlCLDJCQUEyQixrREFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHNCQUFzQjtBQUN6RyxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyxtQ0FBbUMsNkNBQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRDQUFRLHFCQUFxQixVQUFVLEdBQUcsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCxXQUFXLHVDQUF1QztBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkpBQTZKLFlBQVkscUNBQUc7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxxQ0FBRztBQUMxQjtBQUNBO0FBQ0EsbUdBQW1HLGlCQUFpQixxQkFBcUI7QUFDekk7QUFDQTtBQUNBLHlCQUF5Qix1REFBbUI7QUFDNUMseUJBQXlCLHVEQUFtQjtBQUM1QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLLFlBQVkscUNBQUc7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQW1CO0FBQ2hELDZCQUE2Qix1REFBbUI7QUFDaEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQXlELFdBQVcsMkdBQTJHO0FBQy9LLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaURBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUNBQUc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQseUJBQXlCLGVBQWUsR0FBRyxXQUFXO0FBQ3REO0FBQ0E7QUFDTztBQUNQLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWUsd0NBQXdDLFdBQVcsYUFBYTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvam9iLXNjaGVkdWxlci5qcz8xYTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAnY3Jvbi1wYXJzZXInO1xuaW1wb3J0IHsgSm9iIH0gZnJvbSAnLi9qb2InO1xuaW1wb3J0IHsgUXVldWVCYXNlIH0gZnJvbSAnLi9xdWV1ZS1iYXNlJztcbmltcG9ydCB7IFNwYW5LaW5kLCBUZWxlbWV0cnlBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgYXJyYXkyb2JqIH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGNsYXNzIEpvYlNjaGVkdWxlciBleHRlbmRzIFF1ZXVlQmFzZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0cywgQ29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcihuYW1lLCBvcHRzLCBDb25uZWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZXBlYXRTdHJhdGVneSA9XG4gICAgICAgICAgICAob3B0cy5zZXR0aW5ncyAmJiBvcHRzLnNldHRpbmdzLnJlcGVhdFN0cmF0ZWd5KSB8fCBkZWZhdWx0UmVwZWF0U3RyYXRlZ3k7XG4gICAgfVxuICAgIGFzeW5jIHVwc2VydEpvYlNjaGVkdWxlcihqb2JTY2hlZHVsZXJJZCwgcmVwZWF0T3B0cywgam9iTmFtZSwgam9iRGF0YSwgb3B0cywgeyBvdmVycmlkZSwgcHJvZHVjZXJJZCB9KSB7XG4gICAgICAgIGNvbnN0IHsgZXZlcnksIGxpbWl0LCBwYXR0ZXJuLCBvZmZzZXQgfSA9IHJlcGVhdE9wdHM7XG4gICAgICAgIGlmIChwYXR0ZXJuICYmIGV2ZXJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggLnBhdHRlcm4gYW5kIC5ldmVyeSBvcHRpb25zIGFyZSBkZWZpbmVkIGZvciB0aGlzIHJlcGVhdGFibGUgam9iJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuICYmICFldmVyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgLnBhdHRlcm4gb3IgLmV2ZXJ5IG9wdGlvbnMgbXVzdCBiZSBkZWZpbmVkIGZvciB0aGlzIHJlcGVhdGFibGUgam9iJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGVhdE9wdHMuaW1tZWRpYXRlbHkgJiYgcmVwZWF0T3B0cy5zdGFydERhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCAuaW1tZWRpYXRlbHkgYW5kIC5zdGFydERhdGUgb3B0aW9ucyBhcmUgZGVmaW5lZCBmb3IgdGhpcyByZXBlYXRhYmxlIGpvYicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXRPcHRzLmltbWVkaWF0ZWx5ICYmIHJlcGVhdE9wdHMuZXZlcnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVzaW5nIG9wdGlvbiBpbW1lZGlhdGVseSB3aXRoIGV2ZXJ5IGRvZXMgbm90IGFmZmVjdCB0aGUgam9iJ3Mgc2NoZWR1bGUuIEpvYiB3aWxsIHJ1biBpbW1lZGlhdGVseSBhbnl3YXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGxpbWl0IG9mIHRoZSByZXBlYXRhYmxlIGpvYidzIGl0ZXJhdGlvbnNcbiAgICAgICAgY29uc3QgaXRlcmF0aW9uQ291bnQgPSByZXBlYXRPcHRzLmNvdW50ID8gcmVwZWF0T3B0cy5jb3VudCArIDEgOiAxO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGVhdE9wdHMubGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBpdGVyYXRpb25Db3VudCA+IHJlcGVhdE9wdHMubGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQgZGF0ZSBvZiB0aGUgcmVwZWF0YWJsZSBqb2JcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHsgZW5kRGF0ZSB9ID0gcmVwZWF0T3B0cztcbiAgICAgICAgaWYgKGVuZERhdGUgJiYgbm93ID4gbmV3IERhdGUoZW5kRGF0ZSkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldk1pbGxpcyA9IG9wdHMucHJldk1pbGxpcyB8fCAwO1xuICAgICAgICBub3cgPSBwcmV2TWlsbGlzIDwgbm93ID8gbm93IDogcHJldk1pbGxpcztcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHN0YXJ0IGRhdGUgZm9yIHRoZSByZXBlYXRhYmxlIGpvYlxuICAgICAgICBjb25zdCB7IGltbWVkaWF0ZWx5IH0gPSByZXBlYXRPcHRzLCBmaWx0ZXJlZFJlcGVhdE9wdHMgPSBfX3Jlc3QocmVwZWF0T3B0cywgW1wiaW1tZWRpYXRlbHlcIl0pO1xuICAgICAgICBsZXQgbmV4dE1pbGxpcztcbiAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIG5leHRNaWxsaXMgPSBhd2FpdCB0aGlzLnJlcGVhdFN0cmF0ZWd5KG5vdywgcmVwZWF0T3B0cywgam9iTmFtZSk7XG4gICAgICAgICAgICBpZiAobmV4dE1pbGxpcyA8IG5vdykge1xuICAgICAgICAgICAgICAgIG5leHRNaWxsaXMgPSBub3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRNaWxsaXMgfHwgZXZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNlKFNwYW5LaW5kLlBST0RVQ0VSLCAnYWRkJywgYCR7dGhpcy5uYW1lfS4ke2pvYk5hbWV9YCwgYXN5bmMgKHNwYW4sIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGxldCB0ZWxlbWV0cnkgPSBvcHRzLnRlbGVtZXRyeTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjUHJvcGFnYXRpb25NZWRhdGFkYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbWl0Q29udGV4dCA9IChfYSA9IG9wdHMudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub21pdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbGVtZXRyeU1ldGFkYXRhID0gKChfYiA9IG9wdHMudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWV0YWRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIW9taXRDb250ZXh0ICYmIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVsZW1ldHJ5TWV0YWRhdGEgfHwgb21pdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGVsZW1ldHJ5TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb21pdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZE9wdHMgPSB0aGlzLmdldE5leHRKb2JPcHRzKG5leHRNaWxsaXMsIGpvYlNjaGVkdWxlcklkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHJlcGVhdDogZmlsdGVyZWRSZXBlYXRPcHRzLCB0ZWxlbWV0cnkgfSksIGl0ZXJhdGlvbkNvdW50LCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcCBuZXh0TWlsbGlzIHRvIG5vdyBpZiBpdCdzIGluIHRoZSBwYXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TWlsbGlzIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TWlsbGlzID0gbm93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtqb2JJZCwgZGVsYXldID0gYXdhaXQgdGhpcy5zY3JpcHRzLmFkZEpvYlNjaGVkdWxlcihqb2JTY2hlZHVsZXJJZCwgbmV4dE1pbGxpcywgSlNPTi5zdHJpbmdpZnkodHlwZW9mIGpvYkRhdGEgPT09ICd1bmRlZmluZWQnID8ge30gOiBqb2JEYXRhKSwgSm9iLm9wdHNBc0pTT04ob3B0cyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGpvYk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGU6IHJlcGVhdE9wdHMuc3RhcnREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShyZXBlYXRPcHRzLnN0YXJ0RGF0ZSkuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiBlbmREYXRlID8gbmV3IERhdGUoZW5kRGF0ZSkuZ2V0VGltZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHo6IHJlcGVhdE9wdHMudHosXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbmV3T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB9LCBKb2Iub3B0c0FzSlNPTihtZXJnZWRPcHRzKSwgcHJvZHVjZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBkZWxheSBpcyBhIG51bWJlciAoRHJhZ29uZmx5ZGIgbWF5IHJldHVybiBpdCBhcyBhIHN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtZXJpY0RlbGF5ID0gdHlwZW9mIGRlbGF5ID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KGRlbGF5LCAxMCkgOiBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgam9iID0gbmV3IHRoaXMuSm9iKHRoaXMsIGpvYk5hbWUsIGpvYkRhdGEsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkT3B0cyksIHsgZGVsYXk6IG51bWVyaWNEZWxheSB9KSwgam9iSWQpO1xuICAgICAgICAgICAgICAgICAgICBqb2IuaWQgPSBqb2JJZDtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iU2NoZWR1bGVySWRdOiBqb2JTY2hlZHVsZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkXTogam9iLmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpvYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpvYklkID0gYXdhaXQgdGhpcy5zY3JpcHRzLnVwZGF0ZUpvYlNjaGVkdWxlck5leHRNaWxsaXMoam9iU2NoZWR1bGVySWQsIG5leHRNaWxsaXMsIEpTT04uc3RyaW5naWZ5KHR5cGVvZiBqb2JEYXRhID09PSAndW5kZWZpbmVkJyA/IHt9IDogam9iRGF0YSksIEpvYi5vcHRzQXNKU09OKG1lcmdlZE9wdHMpLCBwcm9kdWNlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvYklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSBuZXcgdGhpcy5Kb2IodGhpcywgam9iTmFtZSwgam9iRGF0YSwgbWVyZ2VkT3B0cywgam9iSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgam9iLmlkID0gam9iSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iU2NoZWR1bGVySWRdOiBqb2JTY2hlZHVsZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Kb2JJZF06IGpvYi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpvYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHRKb2JPcHRzKG5leHRNaWxsaXMsIGpvYlNjaGVkdWxlcklkLCBvcHRzLCBjdXJyZW50Q291bnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvL1xuICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgam9iIGlkIGZvciB0aGlzIGl0ZXJhdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgY29uc3Qgam9iSWQgPSB0aGlzLmdldFNjaGVkdWxlck5leHRKb2JJZCh7XG4gICAgICAgICAgICBqb2JTY2hlZHVsZXJJZCxcbiAgICAgICAgICAgIG5leHRNaWxsaXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBkZWxheSA9IG5leHRNaWxsaXMgKyBvZmZzZXQgLSBub3c7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IGpvYklkLCBkZWxheTogZGVsYXkgPCAwID8gMCA6IGRlbGF5LCB0aW1lc3RhbXA6IG5vdywgcHJldk1pbGxpczogbmV4dE1pbGxpcywgcmVwZWF0Sm9iS2V5OiBqb2JTY2hlZHVsZXJJZCB9KTtcbiAgICAgICAgbWVyZ2VkT3B0cy5yZXBlYXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMucmVwZWF0KSwgeyBvZmZzZXQsIGNvdW50OiBjdXJyZW50Q291bnQsIHN0YXJ0RGF0ZTogKChfYSA9IG9wdHMucmVwZWF0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnREYXRlKVxuICAgICAgICAgICAgICAgID8gbmV3IERhdGUob3B0cy5yZXBlYXQuc3RhcnREYXRlKS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgZW5kRGF0ZTogKChfYiA9IG9wdHMucmVwZWF0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW5kRGF0ZSlcbiAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKG9wdHMucmVwZWF0LmVuZERhdGUpLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkT3B0cztcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlSm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMucmVtb3ZlSm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2NoZWR1bGVyRGF0YShjbGllbnQsIGtleSwgbmV4dCkge1xuICAgICAgICBjb25zdCBqb2JEYXRhID0gYXdhaXQgY2xpZW50LmhnZXRhbGwodGhpcy50b0tleSgncmVwZWF0OicgKyBrZXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU2NoZWR1bGVyRGF0YShrZXksIGpvYkRhdGEsIG5leHQpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1TY2hlZHVsZXJEYXRhKGtleSwgam9iRGF0YSwgbmV4dCkge1xuICAgICAgICBpZiAoam9iRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgam9iU2NoZWR1bGVyRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmFtZTogam9iRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGpvYkRhdGEuaWMpIHtcbiAgICAgICAgICAgICAgICBqb2JTY2hlZHVsZXJEYXRhLml0ZXJhdGlvbkNvdW50ID0gcGFyc2VJbnQoam9iRGF0YS5pYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9iRGF0YS5saW1pdCkge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEubGltaXQgPSBwYXJzZUludChqb2JEYXRhLmxpbWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2JEYXRhLnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEuc3RhcnREYXRlID0gcGFyc2VJbnQoam9iRGF0YS5zdGFydERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvYkRhdGEuZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEuZW5kRGF0ZSA9IHBhcnNlSW50KGpvYkRhdGEuZW5kRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9iRGF0YS50eikge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEudHogPSBqb2JEYXRhLnR6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvYkRhdGEucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEucGF0dGVybiA9IGpvYkRhdGEucGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqb2JEYXRhLmV2ZXJ5KSB7XG4gICAgICAgICAgICAgICAgam9iU2NoZWR1bGVyRGF0YS5ldmVyeSA9IHBhcnNlSW50KGpvYkRhdGEuZXZlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpvYkRhdGEub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgam9iU2NoZWR1bGVyRGF0YS5vZmZzZXQgPSBwYXJzZUludChqb2JEYXRhLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoam9iRGF0YS5kYXRhIHx8IGpvYkRhdGEub3B0cykge1xuICAgICAgICAgICAgICAgIGpvYlNjaGVkdWxlckRhdGEudGVtcGxhdGUgPSB0aGlzLmdldFRlbXBsYXRlRnJvbUpTT04oam9iRGF0YS5kYXRhLCBqb2JEYXRhLm9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpvYlNjaGVkdWxlckRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgYW5kIGtleVRvRGF0YSBhcyBpdCBpcyBoZXJlIG9ubHkgdG8gc3VwcG9ydCBsZWdhY3kgY29kZVxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleVRvRGF0YShrZXksIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleVRvRGF0YShrZXksIG5leHQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGtleS5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGF0YS5zbGljZSg0KS5qb2luKCc6JykgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICAgICAgICBpZDogZGF0YVsxXSB8fCBudWxsLFxuICAgICAgICAgICAgZW5kRGF0ZTogcGFyc2VJbnQoZGF0YVsyXSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHR6OiBkYXRhWzNdIHx8IG51bGwsXG4gICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2NoZWR1bGVyKGlkKSB7XG4gICAgICAgIGNvbnN0IFtyYXdKb2JEYXRhLCBuZXh0XSA9IGF3YWl0IHRoaXMuc2NyaXB0cy5nZXRKb2JTY2hlZHVsZXIoaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TY2hlZHVsZXJEYXRhKGlkLCByYXdKb2JEYXRhID8gYXJyYXkyb2JqKHJhd0pvYkRhdGEpIDogbnVsbCwgbmV4dCA/IHBhcnNlSW50KG5leHQpIDogbnVsbCk7XG4gICAgfVxuICAgIGdldFRlbXBsYXRlRnJvbUpTT04ocmF3RGF0YSwgcmF3T3B0cykge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHt9O1xuICAgICAgICBpZiAocmF3RGF0YSkge1xuICAgICAgICAgICAgdGVtcGxhdGUuZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhd09wdHMpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlLm9wdHMgPSBKb2Iub3B0c0Zyb21KU09OKHJhd09wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Sm9iU2NoZWR1bGVycyhzdGFydCA9IDAsIGVuZCA9IC0xLCBhc2MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgY29uc3Qgam9iU2NoZWR1bGVyc0tleSA9IHRoaXMua2V5cy5yZXBlYXQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzY1xuICAgICAgICAgICAgPyBhd2FpdCBjbGllbnQuenJhbmdlKGpvYlNjaGVkdWxlcnNLZXksIHN0YXJ0LCBlbmQsICdXSVRIU0NPUkVTJylcbiAgICAgICAgICAgIDogYXdhaXQgY2xpZW50LnpyZXZyYW5nZShqb2JTY2hlZHVsZXJzS2V5LCBzdGFydCwgZW5kLCAnV0lUSFNDT1JFUycpO1xuICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBqb2JzLnB1c2godGhpcy5nZXRTY2hlZHVsZXJEYXRhKGNsaWVudCwgcmVzdWx0W2ldLCBwYXJzZUludChyZXN1bHRbaSArIDFdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2NoZWR1bGVyc0NvdW50KCkge1xuICAgICAgICBjb25zdCBqb2JTY2hlZHVsZXJzS2V5ID0gdGhpcy5rZXlzLnJlcGVhdDtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuemNhcmQoam9iU2NoZWR1bGVyc0tleSk7XG4gICAgfVxuICAgIGdldFNjaGVkdWxlck5leHRKb2JJZCh7IG5leHRNaWxsaXMsIGpvYlNjaGVkdWxlcklkLCB9KSB7XG4gICAgICAgIHJldHVybiBgcmVwZWF0OiR7am9iU2NoZWR1bGVySWR9OiR7bmV4dE1pbGxpc31gO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVwZWF0U3RyYXRlZ3kgPSAobWlsbGlzLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgeyBwYXR0ZXJuIH0gPSBvcHRzO1xuICAgIGNvbnN0IGRhdGVGcm9tTWlsbGlzID0gbmV3IERhdGUobWlsbGlzKTtcbiAgICBjb25zdCBzdGFydERhdGUgPSBvcHRzLnN0YXJ0RGF0ZSAmJiBuZXcgRGF0ZShvcHRzLnN0YXJ0RGF0ZSk7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBzdGFydERhdGUgPiBkYXRlRnJvbU1pbGxpcyA/IHN0YXJ0RGF0ZSA6IGRhdGVGcm9tTWlsbGlzO1xuICAgIGNvbnN0IGludGVydmFsID0gcGFyc2VFeHByZXNzaW9uKHBhdHRlcm4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgY3VycmVudERhdGUgfSkpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRzLmltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWwubmV4dCgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLXNjaGVkdWxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/job-scheduler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/job.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/job.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Job: () => (/* binding */ Job),\n/* harmony export */   PRIORITY_LIMIT: () => (/* binding */ PRIORITY_LIMIT)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _utils_create_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/create-scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/create-scripts.js\");\n/* harmony import */ var _backoffs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./backoffs */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/backoffs.js\");\n/* harmony import */ var _errors_unrecoverable_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors/unrecoverable-error */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/unrecoverable-error.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n\n\n\n\n\n\n\nconst logger = (0,util__WEBPACK_IMPORTED_MODULE_0__.debuglog)('bull');\nconst PRIORITY_LIMIT = 2 ** 21;\n/**\n * Job\n *\n * This class represents a Job in the queue. Normally job are implicitly created when\n * you add a job to the queue with methods such as Queue.addJob( ... )\n *\n * A Job instance is also passed to the Worker's process function.\n *\n */\nclass Job {\n    constructor(queue, \n    /**\n     * The name of the Job\n     */\n    name, \n    /**\n     * The payload for this job.\n     */\n    data, \n    /**\n     * The options object for this job.\n     */\n    opts = {}, id) {\n        this.queue = queue;\n        this.name = name;\n        this.data = data;\n        this.opts = opts;\n        this.id = id;\n        /**\n         * The progress a job has performed so far.\n         * @defaultValue 0\n         */\n        this.progress = 0;\n        /**\n         * The value returned by the processor when processing this job.\n         * @defaultValue null\n         */\n        this.returnvalue = null;\n        /**\n         * Stacktrace for the error (for failed jobs).\n         * @defaultValue null\n         */\n        this.stacktrace = null;\n        /**\n         * An amount of milliseconds to wait until this job can be processed.\n         * @defaultValue 0\n         */\n        this.delay = 0;\n        /**\n         * Ranges from 0 (highest priority) to 2 097 152 (lowest priority). Note that\n         * using priorities has a slight impact on performance,\n         * so do not use it if not required.\n         * @defaultValue 0\n         */\n        this.priority = 0;\n        /**\n         * Number of attempts when job is moved to active.\n         * @defaultValue 0\n         */\n        this.attemptsStarted = 0;\n        /**\n         * Number of attempts after the job has failed.\n         * @defaultValue 0\n         */\n        this.attemptsMade = 0;\n        /**\n         * Number of times where job has stalled.\n         * @defaultValue 0\n         */\n        this.stalledCounter = 0;\n        const _a = this.opts, { repeatJobKey } = _a, restOpts = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(_a, [\"repeatJobKey\"]);\n        this.opts = Object.assign({\n            attempts: 0,\n        }, restOpts);\n        this.delay = this.opts.delay;\n        this.priority = this.opts.priority || 0;\n        this.repeatJobKey = repeatJobKey;\n        this.timestamp = opts.timestamp ? opts.timestamp : Date.now();\n        this.opts.backoff = _backoffs__WEBPACK_IMPORTED_MODULE_3__.Backoffs.normalize(opts.backoff);\n        this.parentKey = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.getParentKey)(opts.parent);\n        if (opts.parent) {\n            this.parent = { id: opts.parent.id, queueKey: opts.parent.queue };\n            if (opts.failParentOnFailure) {\n                this.parent.fpof = true;\n            }\n            if (opts.removeDependencyOnFailure) {\n                this.parent.rdof = true;\n            }\n            if (opts.ignoreDependencyOnFailure) {\n                this.parent.idof = true;\n            }\n            if (opts.continueParentOnFailure) {\n                this.parent.cpof = true;\n            }\n        }\n        this.debounceId = opts.debounce ? opts.debounce.id : undefined;\n        this.deduplicationId = opts.deduplication\n            ? opts.deduplication.id\n            : this.debounceId;\n        this.toKey = queue.toKey.bind(queue);\n        this.createScripts();\n        this.queueQualifiedName = queue.qualifiedName;\n    }\n    /**\n     * Creates a new job and adds it to the queue.\n     *\n     * @param queue - the queue where to add the job.\n     * @param name - the name of the job.\n     * @param data - the payload of the job.\n     * @param opts - the options bag for this job.\n     * @returns\n     */\n    static async create(queue, name, data, opts) {\n        const client = await queue.client;\n        const job = new this(queue, name, data, opts, opts && opts.jobId);\n        job.id = await job.addJob(client, {\n            parentKey: job.parentKey,\n            parentDependenciesKey: job.parentKey\n                ? `${job.parentKey}:dependencies`\n                : '',\n        });\n        return job;\n    }\n    /**\n     * Creates a bulk of jobs and adds them atomically to the given queue.\n     *\n     * @param queue -the queue were to add the jobs.\n     * @param jobs - an array of jobs to be added to the queue.\n     * @returns\n     */\n    static async createBulk(queue, jobs) {\n        const client = await queue.client;\n        const jobInstances = jobs.map(job => { var _a; return new this(queue, job.name, job.data, job.opts, (_a = job.opts) === null || _a === void 0 ? void 0 : _a.jobId); });\n        const pipeline = client.pipeline();\n        for (const job of jobInstances) {\n            job.addJob(pipeline, {\n                parentKey: job.parentKey,\n                parentDependenciesKey: job.parentKey\n                    ? `${job.parentKey}:dependencies`\n                    : '',\n            });\n        }\n        const results = (await pipeline.exec());\n        for (let index = 0; index < results.length; ++index) {\n            const [err, id] = results[index];\n            if (err) {\n                throw err;\n            }\n            jobInstances[index].id = id;\n        }\n        return jobInstances;\n    }\n    /**\n     * Instantiates a Job from a JobJsonRaw object (coming from a deserialized JSON object)\n     *\n     * @param queue - the queue where the job belongs to.\n     * @param json - the plain object containing the job.\n     * @param jobId - an optional job id (overrides the id coming from the JSON object)\n     * @returns\n     */\n    static fromJSON(queue, json, jobId) {\n        const data = JSON.parse(json.data || '{}');\n        const opts = Job.optsFromJSON(json.opts);\n        const job = new this(queue, json.name, data, opts, json.id || jobId);\n        job.progress = JSON.parse(json.progress || '0');\n        job.delay = parseInt(json.delay);\n        job.priority = parseInt(json.priority);\n        job.timestamp = parseInt(json.timestamp);\n        if (json.finishedOn) {\n            job.finishedOn = parseInt(json.finishedOn);\n        }\n        if (json.processedOn) {\n            job.processedOn = parseInt(json.processedOn);\n        }\n        if (json.rjk) {\n            job.repeatJobKey = json.rjk;\n        }\n        if (json.deid) {\n            job.debounceId = json.deid;\n            job.deduplicationId = json.deid;\n        }\n        if (json.failedReason) {\n            job.failedReason = json.failedReason;\n        }\n        job.attemptsStarted = parseInt(json.ats || '0');\n        job.attemptsMade = parseInt(json.attemptsMade || json.atm || '0');\n        job.stalledCounter = parseInt(json.stc || '0');\n        if (json.defa) {\n            job.deferredFailure = json.defa;\n        }\n        job.stacktrace = getTraces(json.stacktrace);\n        if (typeof json.returnvalue === 'string') {\n            job.returnvalue = getReturnValue(json.returnvalue);\n        }\n        if (json.parentKey) {\n            job.parentKey = json.parentKey;\n        }\n        if (json.parent) {\n            job.parent = JSON.parse(json.parent);\n        }\n        if (json.pb) {\n            job.processedBy = json.pb;\n        }\n        if (json.nrjid) {\n            job.nextRepeatableJobId = json.nrjid;\n        }\n        return job;\n    }\n    createScripts() {\n        this.scripts = (0,_utils_create_scripts__WEBPACK_IMPORTED_MODULE_2__.createScripts)(this.queue);\n    }\n    static optsFromJSON(rawOpts, optsDecode = _utils__WEBPACK_IMPORTED_MODULE_1__.optsDecodeMap) {\n        const opts = JSON.parse(rawOpts || '{}');\n        const optionEntries = Object.entries(opts);\n        const options = {};\n        for (const item of optionEntries) {\n            const [attributeName, value] = item;\n            if (optsDecode[attributeName]) {\n                options[optsDecode[attributeName]] =\n                    value;\n            }\n            else {\n                if (attributeName === 'tm') {\n                    options.telemetry = Object.assign(Object.assign({}, options.telemetry), { metadata: value });\n                }\n                else if (attributeName === 'omc') {\n                    options.telemetry = Object.assign(Object.assign({}, options.telemetry), { omitContext: value });\n                }\n                else {\n                    options[attributeName] = value;\n                }\n            }\n        }\n        return options;\n    }\n    /**\n     * Fetches a Job from the queue given the passed job id.\n     *\n     * @param queue - the queue where the job belongs to.\n     * @param jobId - the job id.\n     * @returns\n     */\n    static async fromId(queue, jobId) {\n        // jobId can be undefined if moveJob returns undefined\n        if (jobId) {\n            const client = await queue.client;\n            const jobData = await client.hgetall(queue.toKey(jobId));\n            return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(jobData)\n                ? undefined\n                : this.fromJSON(queue, jobData, jobId);\n        }\n    }\n    /**\n     * addJobLog\n     *\n     * @param queue - A minimal queue instance\n     * @param jobId - Job id\n     * @param logRow - String with a row of log data to be logged\n     * @param keepLogs - The optional amount of log entries to preserve\n     *\n     * @returns The total number of log entries for this job so far.\n     */\n    static addJobLog(queue, jobId, logRow, keepLogs) {\n        const scripts = queue.scripts;\n        return scripts.addLog(jobId, logRow, keepLogs);\n    }\n    toJSON() {\n        const _a = this, { queue, scripts } = _a, withoutQueueAndScripts = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(_a, [\"queue\", \"scripts\"]);\n        return withoutQueueAndScripts;\n    }\n    /**\n     * Prepares a job to be serialized for storage in Redis.\n     * @returns\n     */\n    asJSON() {\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.removeUndefinedFields)({\n            id: this.id,\n            name: this.name,\n            data: JSON.stringify(typeof this.data === 'undefined' ? {} : this.data),\n            opts: Job.optsAsJSON(this.opts),\n            parent: this.parent ? Object.assign({}, this.parent) : undefined,\n            parentKey: this.parentKey,\n            progress: this.progress,\n            attemptsMade: this.attemptsMade,\n            attemptsStarted: this.attemptsStarted,\n            stalledCounter: this.stalledCounter,\n            finishedOn: this.finishedOn,\n            processedOn: this.processedOn,\n            timestamp: this.timestamp,\n            failedReason: JSON.stringify(this.failedReason),\n            stacktrace: JSON.stringify(this.stacktrace),\n            debounceId: this.debounceId,\n            deduplicationId: this.deduplicationId,\n            repeatJobKey: this.repeatJobKey,\n            returnvalue: JSON.stringify(this.returnvalue),\n            nrjid: this.nextRepeatableJobId,\n        });\n    }\n    static optsAsJSON(opts = {}, optsEncode = _utils__WEBPACK_IMPORTED_MODULE_1__.optsEncodeMap) {\n        const optionEntries = Object.entries(opts);\n        const options = {};\n        for (const [attributeName, value] of optionEntries) {\n            if (typeof value === 'undefined') {\n                continue;\n            }\n            if (attributeName in optsEncode) {\n                const compressableAttribute = attributeName;\n                const key = optsEncode[compressableAttribute];\n                options[key] = value;\n            }\n            else {\n                // Handle complex compressable fields separately\n                if (attributeName === 'telemetry') {\n                    if (value.metadata !== undefined) {\n                        options.tm = value.metadata;\n                    }\n                    if (value.omitContext !== undefined) {\n                        options.omc = value.omitContext;\n                    }\n                }\n                else {\n                    options[attributeName] = value;\n                }\n            }\n        }\n        return options;\n    }\n    /**\n     * Prepares a job to be passed to Sandbox.\n     * @returns\n     */\n    asJSONSandbox() {\n        return Object.assign(Object.assign({}, this.asJSON()), { queueName: this.queueName, queueQualifiedName: this.queueQualifiedName, prefix: this.prefix });\n    }\n    /**\n     * Updates a job's data\n     *\n     * @param data - the data that will replace the current jobs data.\n     */\n    updateData(data) {\n        this.data = data;\n        return this.scripts.updateData(this, data);\n    }\n    /**\n     * Updates a job's progress\n     *\n     * @param progress - number or object to be saved as progress.\n     */\n    async updateProgress(progress) {\n        this.progress = progress;\n        await this.scripts.updateProgress(this.id, progress);\n        this.queue.emit('progress', this, progress);\n    }\n    /**\n     * Logs one row of log data.\n     *\n     * @param logRow - string with log data to be logged.\n     * @returns The total number of log entries for this job so far.\n     */\n    async log(logRow) {\n        return Job.addJobLog(this.queue, this.id, logRow, this.opts.keepLogs);\n    }\n    /**\n     * Removes child dependency from parent when child is not yet finished\n     *\n     * @returns True if the relationship existed and if it was removed.\n     */\n    async removeChildDependency() {\n        const childDependencyIsRemoved = await this.scripts.removeChildDependency(this.id, this.parentKey);\n        if (childDependencyIsRemoved) {\n            this.parent = undefined;\n            this.parentKey = undefined;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Clears job's logs\n     *\n     * @param keepLogs - the amount of log entries to preserve\n     */\n    async clearLogs(keepLogs) {\n        const client = await this.queue.client;\n        const logsKey = this.toKey(this.id) + ':logs';\n        if (keepLogs) {\n            await client.ltrim(logsKey, -keepLogs, -1);\n        }\n        else {\n            await client.del(logsKey);\n        }\n    }\n    /**\n     * Completely remove the job from the queue.\n     * Note, this call will throw an exception if the job\n     * is being processed when the call is performed.\n     *\n     * @param opts - Options to remove a job\n     */\n    async remove({ removeChildren = true } = {}) {\n        await this.queue.waitUntilReady();\n        const queue = this.queue;\n        const job = this;\n        const removed = await this.scripts.remove(job.id, removeChildren);\n        if (removed) {\n            queue.emit('removed', job);\n        }\n        else {\n            throw new Error(`Job ${this.id} could not be removed because it is locked by another worker`);\n        }\n    }\n    /**\n     * Remove all children from this job that are not yet processed,\n     * in other words that are in any other state than completed, failed or active.\n     *\n     * @remarks\n     *  - Jobs with locks (most likely active) are ignored.\n     *  - This method can be slow if the number of children is large (\\> 1000).\n     */\n    async removeUnprocessedChildren() {\n        const jobId = this.id;\n        await this.scripts.removeUnprocessedChildren(jobId);\n    }\n    /**\n     * Extend the lock for this job.\n     *\n     * @param token - unique token for the lock\n     * @param duration - lock duration in milliseconds\n     */\n    extendLock(token, duration) {\n        return this.scripts.extendLock(this.id, token, duration);\n    }\n    /**\n     * Moves a job to the completed queue.\n     * Returned job to be used with Queue.prototype.nextJobFromJobData.\n     *\n     * @param returnValue - The jobs success message.\n     * @param token - Worker token used to acquire completed job.\n     * @param fetchNext - True when wanting to fetch the next job.\n     * @returns Returns the jobData of the next job in the waiting queue or void.\n     */\n    async moveToCompleted(returnValue, token, fetchNext = true) {\n        return this.queue.trace(_enums__WEBPACK_IMPORTED_MODULE_5__.SpanKind.INTERNAL, 'complete', this.queue.name, async (span, dstPropagationMedatadata) => {\n            var _a, _b;\n            let tm;\n            if (!((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.telemetry) === null || _b === void 0 ? void 0 : _b.omitContext) && dstPropagationMedatadata) {\n                tm = dstPropagationMedatadata;\n            }\n            await this.queue.waitUntilReady();\n            this.returnvalue = returnValue || void 0;\n            const stringifiedReturnValue = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.tryCatch)(JSON.stringify, JSON, [\n                returnValue,\n            ]);\n            if (stringifiedReturnValue === _utils__WEBPACK_IMPORTED_MODULE_1__.errorObject) {\n                throw _utils__WEBPACK_IMPORTED_MODULE_1__.errorObject.value;\n            }\n            const args = this.scripts.moveToCompletedArgs(this, stringifiedReturnValue, this.opts.removeOnComplete, token, fetchNext);\n            const result = await this.scripts.moveToFinished(this.id, args);\n            this.finishedOn = args[this.scripts.moveToFinishedKeys.length + 1];\n            this.attemptsMade += 1;\n            return result;\n        });\n    }\n    /**\n     * Moves a job to the wait or prioritized state.\n     *\n     * @param token - Worker token used to acquire completed job.\n     * @returns Returns pttl.\n     */\n    moveToWait(token) {\n        return this.scripts.moveJobFromActiveToWait(this.id, token);\n    }\n    async shouldRetryJob(err) {\n        if (this.attemptsMade + 1 < this.opts.attempts &&\n            !this.discarded &&\n            !(err instanceof _errors_unrecoverable_error__WEBPACK_IMPORTED_MODULE_4__.UnrecoverableError || err.name == 'UnrecoverableError')) {\n            const opts = this.queue.opts;\n            const delay = await _backoffs__WEBPACK_IMPORTED_MODULE_3__.Backoffs.calculate(this.opts.backoff, this.attemptsMade + 1, err, this, opts.settings && opts.settings.backoffStrategy);\n            return [delay == -1 ? false : true, delay == -1 ? 0 : delay];\n        }\n        else {\n            return [false, 0];\n        }\n    }\n    /**\n     * Moves a job to the failed queue.\n     *\n     * @param err - the jobs error message.\n     * @param token - token to check job is locked by current worker\n     * @param fetchNext - true when wanting to fetch the next job\n     * @returns Returns the jobData of the next job in the waiting queue or void.\n     */\n    async moveToFailed(err, token, fetchNext = false) {\n        this.failedReason = err === null || err === void 0 ? void 0 : err.message;\n        // Check if an automatic retry should be performed\n        const [shouldRetry, retryDelay] = await this.shouldRetryJob(err);\n        return this.queue.trace(_enums__WEBPACK_IMPORTED_MODULE_5__.SpanKind.INTERNAL, this.getSpanOperation(shouldRetry, retryDelay), this.queue.name, async (span, dstPropagationMedatadata) => {\n            var _a, _b;\n            let tm;\n            if (!((_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.telemetry) === null || _b === void 0 ? void 0 : _b.omitContext) && dstPropagationMedatadata) {\n                tm = dstPropagationMedatadata;\n            }\n            let result;\n            this.updateStacktrace(err);\n            const fieldsToUpdate = {\n                failedReason: this.failedReason,\n                stacktrace: JSON.stringify(this.stacktrace),\n                tm,\n            };\n            let finishedOn;\n            if (shouldRetry) {\n                if (retryDelay) {\n                    // Retry with delay\n                    result = await this.scripts.moveToDelayed(this.id, Date.now(), retryDelay, token, { fieldsToUpdate });\n                }\n                else {\n                    // Retry immediately\n                    result = await this.scripts.retryJob(this.id, this.opts.lifo, token, {\n                        fieldsToUpdate,\n                    });\n                }\n            }\n            else {\n                const args = this.scripts.moveToFailedArgs(this, this.failedReason, this.opts.removeOnFail, token, fetchNext, fieldsToUpdate);\n                result = await this.scripts.moveToFinished(this.id, args);\n                finishedOn = args[this.scripts.moveToFinishedKeys.length + 1];\n            }\n            if (finishedOn && typeof finishedOn === 'number') {\n                this.finishedOn = finishedOn;\n            }\n            if (retryDelay && typeof retryDelay === 'number') {\n                this.delay = retryDelay;\n            }\n            this.attemptsMade += 1;\n            return result;\n        });\n    }\n    getSpanOperation(shouldRetry, retryDelay) {\n        if (shouldRetry) {\n            if (retryDelay) {\n                return 'delay';\n            }\n            return 'retry';\n        }\n        return 'fail';\n    }\n    /**\n     * @returns true if the job has completed.\n     */\n    isCompleted() {\n        return this.isInZSet('completed');\n    }\n    /**\n     * @returns true if the job has failed.\n     */\n    isFailed() {\n        return this.isInZSet('failed');\n    }\n    /**\n     * @returns true if the job is delayed.\n     */\n    isDelayed() {\n        return this.isInZSet('delayed');\n    }\n    /**\n     * @returns true if the job is waiting for children.\n     */\n    isWaitingChildren() {\n        return this.isInZSet('waiting-children');\n    }\n    /**\n     * @returns true of the job is active.\n     */\n    isActive() {\n        return this.isInList('active');\n    }\n    /**\n     * @returns true if the job is waiting.\n     */\n    async isWaiting() {\n        return (await this.isInList('wait')) || (await this.isInList('paused'));\n    }\n    /**\n     * @returns the queue name this job belongs to.\n     */\n    get queueName() {\n        return this.queue.name;\n    }\n    /**\n     * @returns the prefix that is used.\n     */\n    get prefix() {\n        return this.queue.opts.prefix;\n    }\n    /**\n     * Get current state.\n     *\n     * @returns Returns one of these values:\n     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.\n     */\n    getState() {\n        return this.scripts.getState(this.id);\n    }\n    /**\n     * Change delay of a delayed job.\n     *\n     * @param delay - milliseconds to be added to current time.\n     * @returns void\n     */\n    async changeDelay(delay) {\n        await this.scripts.changeDelay(this.id, delay);\n        this.delay = delay;\n    }\n    /**\n     * Change job priority.\n     *\n     * @param opts - options containing priority and lifo values.\n     * @returns void\n     */\n    async changePriority(opts) {\n        await this.scripts.changePriority(this.id, opts.priority, opts.lifo);\n        this.priority = opts.priority || 0;\n    }\n    /**\n     * Get this jobs children result values if any.\n     *\n     * @returns Object mapping children job keys with their values.\n     */\n    async getChildrenValues() {\n        const client = await this.queue.client;\n        const result = (await client.hgetall(this.toKey(`${this.id}:processed`)));\n        if (result) {\n            return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseObjectValues)(result);\n        }\n    }\n    /**\n     * Retrieves the failures of child jobs that were explicitly ignored while using ignoreDependencyOnFailure option.\n     * This method is useful for inspecting which child jobs were intentionally ignored when an error occured.\n     * @see {@link https://docs.bullmq.io/guide/flows/ignore-dependency}\n     *\n     * @returns Object mapping children job keys with their failure values.\n     */\n    async getIgnoredChildrenFailures() {\n        const client = await this.queue.client;\n        return client.hgetall(this.toKey(`${this.id}:failed`));\n    }\n    /**\n     * Get job's children failure values that were ignored if any.\n     *\n     * @deprecated This method is deprecated and will be removed in v6. Use getIgnoredChildrenFailures instead.\n     *\n     * @returns Object mapping children job keys with their failure values.\n     */\n    async getFailedChildrenValues() {\n        const client = await this.queue.client;\n        return client.hgetall(this.toKey(`${this.id}:failed`));\n    }\n    /**\n     * Get children job keys if this job is a parent and has children.\n     * @remarks\n     * Count options before Redis v7.2 works as expected with any quantity of entries\n     * on processed/unprocessed dependencies, since v7.2 you must consider that count\n     * won't have any effect until processed/unprocessed dependencies have a length\n     * greater than 127\n     * @see {@link https://redis.io/docs/management/optimization/memory-optimization/#redis--72}\n     * @see {@link https://docs.bullmq.io/guide/flows#getters}\n     * @returns dependencies separated by processed, unprocessed, ignored and failed.\n     */\n    async getDependencies(opts = {}) {\n        const client = await this.queue.client;\n        const multi = client.multi();\n        if (!opts.processed && !opts.unprocessed && !opts.ignored && !opts.failed) {\n            multi.hgetall(this.toKey(`${this.id}:processed`));\n            multi.smembers(this.toKey(`${this.id}:dependencies`));\n            multi.hgetall(this.toKey(`${this.id}:failed`));\n            multi.zrange(this.toKey(`${this.id}:unsuccessful`), 0, -1);\n            const [[err1, processed], [err2, unprocessed], [err3, ignored], [err4, failed],] = (await multi.exec());\n            return {\n                processed: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseObjectValues)(processed),\n                unprocessed,\n                failed,\n                ignored,\n            };\n        }\n        else {\n            const defaultOpts = {\n                cursor: 0,\n                count: 20,\n            };\n            const childrenResultOrder = [];\n            if (opts.processed) {\n                childrenResultOrder.push('processed');\n                const processedOpts = Object.assign(Object.assign({}, defaultOpts), opts.processed);\n                multi.hscan(this.toKey(`${this.id}:processed`), processedOpts.cursor, 'COUNT', processedOpts.count);\n            }\n            if (opts.unprocessed) {\n                childrenResultOrder.push('unprocessed');\n                const unprocessedOpts = Object.assign(Object.assign({}, defaultOpts), opts.unprocessed);\n                multi.sscan(this.toKey(`${this.id}:dependencies`), unprocessedOpts.cursor, 'COUNT', unprocessedOpts.count);\n            }\n            if (opts.ignored) {\n                childrenResultOrder.push('ignored');\n                const ignoredOpts = Object.assign(Object.assign({}, defaultOpts), opts.ignored);\n                multi.hscan(this.toKey(`${this.id}:failed`), ignoredOpts.cursor, 'COUNT', ignoredOpts.count);\n            }\n            let failedCursor;\n            if (opts.failed) {\n                childrenResultOrder.push('failed');\n                const failedOpts = Object.assign(Object.assign({}, defaultOpts), opts.failed);\n                failedCursor = failedOpts.cursor + failedOpts.count;\n                multi.zrange(this.toKey(`${this.id}:unsuccessful`), failedOpts.cursor, failedOpts.count - 1);\n            }\n            const results = (await multi.exec());\n            let processedCursor, processed, unprocessedCursor, unprocessed, failed, ignoredCursor, ignored;\n            childrenResultOrder.forEach((key, index) => {\n                switch (key) {\n                    case 'processed': {\n                        processedCursor = results[index][1][0];\n                        const rawProcessed = results[index][1][1];\n                        const transformedProcessed = {};\n                        for (let ind = 0; ind < rawProcessed.length; ++ind) {\n                            if (ind % 2) {\n                                transformedProcessed[rawProcessed[ind - 1]] = JSON.parse(rawProcessed[ind]);\n                            }\n                        }\n                        processed = transformedProcessed;\n                        break;\n                    }\n                    case 'failed': {\n                        failed = results[index][1];\n                        break;\n                    }\n                    case 'ignored': {\n                        ignoredCursor = results[index][1][0];\n                        const rawIgnored = results[index][1][1];\n                        const transformedIgnored = {};\n                        for (let ind = 0; ind < rawIgnored.length; ++ind) {\n                            if (ind % 2) {\n                                transformedIgnored[rawIgnored[ind - 1]] = rawIgnored[ind];\n                            }\n                        }\n                        ignored = transformedIgnored;\n                        break;\n                    }\n                    case 'unprocessed': {\n                        unprocessedCursor = results[index][1][0];\n                        unprocessed = results[index][1][1];\n                        break;\n                    }\n                }\n            });\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, (processedCursor\n                ? {\n                    processed,\n                    nextProcessedCursor: Number(processedCursor),\n                }\n                : {})), (ignoredCursor\n                ? {\n                    ignored,\n                    nextIgnoredCursor: Number(ignoredCursor),\n                }\n                : {})), (failedCursor\n                ? {\n                    failed,\n                    nextFailedCursor: failedCursor,\n                }\n                : {})), (unprocessedCursor\n                ? { unprocessed, nextUnprocessedCursor: Number(unprocessedCursor) }\n                : {}));\n        }\n    }\n    /**\n     * Get children job counts if this job is a parent and has children.\n     *\n     * @returns dependencies count separated by processed, unprocessed, ignored and failed.\n     */\n    async getDependenciesCount(opts = {}) {\n        const types = [];\n        Object.entries(opts).forEach(([key, value]) => {\n            if (value) {\n                types.push(key);\n            }\n        });\n        const finalTypes = types.length\n            ? types\n            : ['processed', 'unprocessed', 'ignored', 'failed'];\n        const responses = await this.scripts.getDependencyCounts(this.id, finalTypes);\n        const counts = {};\n        responses.forEach((res, index) => {\n            counts[`${finalTypes[index]}`] = res || 0;\n        });\n        return counts;\n    }\n    /**\n     * Returns a promise the resolves when the job has completed (containing the return value of the job),\n     * or rejects when the job has failed (containing the failedReason).\n     *\n     * @param queueEvents - Instance of QueueEvents.\n     * @param ttl - Time in milliseconds to wait for job to finish before timing out.\n     */\n    async waitUntilFinished(queueEvents, ttl) {\n        await this.queue.waitUntilReady();\n        const jobId = this.id;\n        return new Promise(async (resolve, reject) => {\n            let timeout;\n            if (ttl) {\n                timeout = setTimeout(() => onFailed(\n                /* eslint-disable max-len */\n                `Job wait ${this.name} timed out before finishing, no finish notification arrived after ${ttl}ms (id=${jobId})`), ttl);\n            }\n            function onCompleted(args) {\n                removeListeners();\n                resolve(args.returnvalue);\n            }\n            function onFailed(args) {\n                removeListeners();\n                reject(new Error(args.failedReason || args));\n            }\n            const completedEvent = `completed:${jobId}`;\n            const failedEvent = `failed:${jobId}`;\n            queueEvents.on(completedEvent, onCompleted);\n            queueEvents.on(failedEvent, onFailed);\n            this.queue.on('closing', onFailed);\n            const removeListeners = () => {\n                clearInterval(timeout);\n                queueEvents.removeListener(completedEvent, onCompleted);\n                queueEvents.removeListener(failedEvent, onFailed);\n                this.queue.removeListener('closing', onFailed);\n            };\n            // Poll once right now to see if the job has already finished. The job may have been completed before we were able\n            // to register the event handlers on the QueueEvents, so we check here to make sure we're not waiting for an event\n            // that has already happened. We block checking the job until the queue events object is actually listening to\n            // Redis so there's no chance that it will miss events.\n            await queueEvents.waitUntilReady();\n            const [status, result] = (await this.scripts.isFinished(jobId, true));\n            const finished = status != 0;\n            if (finished) {\n                if (status == -1 || status == 2) {\n                    onFailed({ failedReason: result });\n                }\n                else {\n                    onCompleted({ returnvalue: getReturnValue(result) });\n                }\n            }\n        });\n    }\n    /**\n     * Moves the job to the delay set.\n     *\n     * @param timestamp - timestamp when the job should be moved back to \"wait\"\n     * @param token - token to check job is locked by current worker\n     * @returns\n     */\n    async moveToDelayed(timestamp, token) {\n        const now = Date.now();\n        const delay = timestamp - now;\n        const finalDelay = delay > 0 ? delay : 0;\n        const movedToDelayed = await this.scripts.moveToDelayed(this.id, now, finalDelay, token, { skipAttempt: true });\n        this.delay = finalDelay;\n        return movedToDelayed;\n    }\n    /**\n     * Moves the job to the waiting-children set.\n     *\n     * @param token - Token to check job is locked by current worker\n     * @param opts - The options bag for moving a job to waiting-children.\n     * @returns true if the job was moved\n     */\n    async moveToWaitingChildren(token, opts = {}) {\n        const movedToWaitingChildren = await this.scripts.moveToWaitingChildren(this.id, token, opts);\n        return movedToWaitingChildren;\n    }\n    /**\n     * Promotes a delayed job so that it starts to be processed as soon as possible.\n     */\n    async promote() {\n        const jobId = this.id;\n        await this.scripts.promote(jobId);\n        this.delay = 0;\n    }\n    /**\n     * Attempts to retry the job. Only a job that has failed or completed can be retried.\n     *\n     * @param state - completed / failed\n     * @returns If resolved and return code is 1, then the queue emits a waiting event\n     * otherwise the operation was not a success and throw the corresponding error. If the promise\n     * rejects, it indicates that the script failed to execute\n     */\n    retry(state = 'failed') {\n        this.failedReason = null;\n        this.finishedOn = null;\n        this.processedOn = null;\n        this.returnvalue = null;\n        return this.scripts.reprocessJob(this, state);\n    }\n    /**\n     * Marks a job to not be retried if it fails (even if attempts has been configured)\n     * @deprecated use UnrecoverableError\n     */\n    discard() {\n        this.discarded = true;\n    }\n    async isInZSet(set) {\n        const client = await this.queue.client;\n        const score = await client.zscore(this.queue.toKey(set), this.id);\n        return score !== null;\n    }\n    async isInList(list) {\n        return this.scripts.isJobInList(this.queue.toKey(list), this.id);\n    }\n    /**\n     * Adds the job to Redis.\n     *\n     * @param client -\n     * @param parentOpts -\n     * @returns\n     */\n    addJob(client, parentOpts) {\n        const jobData = this.asJSON();\n        this.validateOptions(jobData);\n        return this.scripts.addJob(client, jobData, jobData.opts, this.id, parentOpts);\n    }\n    validateOptions(jobData) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const exclusiveOptions = [\n            'removeDependencyOnFailure',\n            'failParentOnFailure',\n            'continueParentOnFailure',\n            'ignoreDependencyOnFailure',\n        ];\n        const exceedLimit = this.opts.sizeLimit &&\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.lengthInUtf8Bytes)(jobData.data) > this.opts.sizeLimit;\n        if (exceedLimit) {\n            throw new Error(`The size of job ${this.name} exceeds the limit ${this.opts.sizeLimit} bytes`);\n        }\n        if (this.opts.delay && this.opts.repeat && !((_a = this.opts.repeat) === null || _a === void 0 ? void 0 : _a.count)) {\n            throw new Error(`Delay and repeat options could not be used together`);\n        }\n        const enabledExclusiveOptions = exclusiveOptions.filter(opt => this.opts[opt]);\n        if (enabledExclusiveOptions.length > 1) {\n            const optionsList = enabledExclusiveOptions.join(', ');\n            throw new Error(`The following options cannot be used together: ${optionsList}`);\n        }\n        if ((_b = this.opts) === null || _b === void 0 ? void 0 : _b.jobId) {\n            if (`${parseInt(this.opts.jobId, 10)}` === ((_c = this.opts) === null || _c === void 0 ? void 0 : _c.jobId)) {\n                throw new Error('Custom Id cannot be integers');\n            }\n            // TODO: replace this check in next breaking check with include(':')\n            // By using split we are still keeping compatibility with old repeatable jobs\n            if (((_d = this.opts) === null || _d === void 0 ? void 0 : _d.jobId.includes(':')) &&\n                ((_f = (_e = this.opts) === null || _e === void 0 ? void 0 : _e.jobId) === null || _f === void 0 ? void 0 : _f.split(':').length) !== 3) {\n                throw new Error('Custom Id cannot contain :');\n            }\n        }\n        if (this.opts.priority) {\n            if (Math.trunc(this.opts.priority) !== this.opts.priority) {\n                throw new Error(`Priority should not be float`);\n            }\n            if (this.opts.priority > PRIORITY_LIMIT) {\n                throw new Error(`Priority should be between 0 and ${PRIORITY_LIMIT}`);\n            }\n        }\n        if (this.opts.deduplication) {\n            if (!((_g = this.opts.deduplication) === null || _g === void 0 ? void 0 : _g.id)) {\n                throw new Error('Deduplication id must be provided');\n            }\n        }\n        // TODO: remove in v6\n        if (this.opts.debounce) {\n            if (!((_h = this.opts.debounce) === null || _h === void 0 ? void 0 : _h.id)) {\n                throw new Error('Debounce id must be provided');\n            }\n        }\n        if (typeof this.opts.backoff === 'object' &&\n            typeof this.opts.backoff.jitter === 'number') {\n            if (this.opts.backoff.jitter < 0 || this.opts.backoff.jitter > 1) {\n                throw new Error(`Jitter should be between 0 and 1`);\n            }\n        }\n    }\n    updateStacktrace(err) {\n        this.stacktrace = this.stacktrace || [];\n        if (err === null || err === void 0 ? void 0 : err.stack) {\n            this.stacktrace.push(err.stack);\n            if (this.opts.stackTraceLimit === 0) {\n                this.stacktrace = [];\n            }\n            else if (this.opts.stackTraceLimit) {\n                this.stacktrace = this.stacktrace.slice(-this.opts.stackTraceLimit);\n            }\n        }\n    }\n}\nfunction getTraces(stacktrace) {\n    if (!stacktrace) {\n        return [];\n    }\n    const traces = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.tryCatch)(JSON.parse, JSON, [stacktrace]);\n    if (traces === _utils__WEBPACK_IMPORTED_MODULE_1__.errorObject || !(traces instanceof Array)) {\n        return [];\n    }\n    else {\n        return traces;\n    }\n}\nfunction getReturnValue(_value) {\n    const value = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.tryCatch)(JSON.parse, JSON, [_value]);\n    if (value !== _utils__WEBPACK_IMPORTED_MODULE_1__.errorObject) {\n        return value;\n    }\n    else {\n        logger('corrupted returnvalue: ' + _value, value);\n    }\n}\n//# sourceMappingURL=job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvam9iLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQztBQUNvSTtBQUM1RztBQUNsQjtBQUM0QjtBQUM5QjtBQUNwQyxlQUFlLDhDQUFRO0FBQ2hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlLGlCQUFpQiw2Q0FBTTtBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFRO0FBQ3BDLHlCQUF5QixvREFBWTtBQUNyQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsc0hBQXNIO0FBQzdLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQWE7QUFDcEM7QUFDQSw4Q0FBOEMsaURBQWE7QUFDM0QsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHdCQUF3QixpQkFBaUI7QUFDL0c7QUFDQTtBQUNBLHNFQUFzRSx3QkFBd0Isb0JBQW9CO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLCtCQUErQiw2Q0FBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQXFCO0FBQ3BDO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLGVBQWUsaURBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQiw2RkFBNkY7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0IsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdEQUFRO0FBQ25EO0FBQ0E7QUFDQSwyQ0FBMkMsK0NBQVc7QUFDdEQsc0JBQXNCLCtDQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBa0I7QUFDL0M7QUFDQSxnQ0FBZ0MsK0NBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGdCQUFnQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0EsbUJBQW1CLHlEQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQseUNBQXlDLFFBQVE7QUFDakQsd0NBQXdDLFFBQVE7QUFDaEQsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBLDJCQUEyQix5REFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxtRUFBbUUsSUFBSSxTQUFTLE1BQU07QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxtQkFBbUI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWlCO0FBQzdCO0FBQ0EsK0NBQStDLFdBQVcsb0JBQW9CLHFCQUFxQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxZQUFZO0FBQzFGO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBUTtBQUMzQixtQkFBbUIsK0NBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVE7QUFDMUIsa0JBQWtCLCtDQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9qb2IuanM/MTQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGRlYnVnbG9nIH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBlcnJvck9iamVjdCwgaXNFbXB0eSwgZ2V0UGFyZW50S2V5LCBsZW5ndGhJblV0ZjhCeXRlcywgb3B0c0RlY29kZU1hcCwgb3B0c0VuY29kZU1hcCwgcGFyc2VPYmplY3RWYWx1ZXMsIHRyeUNhdGNoLCByZW1vdmVVbmRlZmluZWRGaWVsZHMsIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlU2NyaXB0cyB9IGZyb20gJy4uL3V0aWxzL2NyZWF0ZS1zY3JpcHRzJztcbmltcG9ydCB7IEJhY2tvZmZzIH0gZnJvbSAnLi9iYWNrb2Zmcyc7XG5pbXBvcnQgeyBVbnJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL2Vycm9ycy91bnJlY292ZXJhYmxlLWVycm9yJztcbmltcG9ydCB7IFNwYW5LaW5kIH0gZnJvbSAnLi4vZW51bXMnO1xuY29uc3QgbG9nZ2VyID0gZGVidWdsb2coJ2J1bGwnKTtcbmV4cG9ydCBjb25zdCBQUklPUklUWV9MSU1JVCA9IDIgKiogMjE7XG4vKipcbiAqIEpvYlxuICpcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIEpvYiBpbiB0aGUgcXVldWUuIE5vcm1hbGx5IGpvYiBhcmUgaW1wbGljaXRseSBjcmVhdGVkIHdoZW5cbiAqIHlvdSBhZGQgYSBqb2IgdG8gdGhlIHF1ZXVlIHdpdGggbWV0aG9kcyBzdWNoIGFzIFF1ZXVlLmFkZEpvYiggLi4uIClcbiAqXG4gKiBBIEpvYiBpbnN0YW5jZSBpcyBhbHNvIHBhc3NlZCB0byB0aGUgV29ya2VyJ3MgcHJvY2VzcyBmdW5jdGlvbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBKb2Ige1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgSm9iXG4gICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgICogVGhlIHBheWxvYWQgZm9yIHRoaXMgam9iLlxuICAgICAqL1xuICAgIGRhdGEsIFxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhpcyBqb2IuXG4gICAgICovXG4gICAgb3B0cyA9IHt9LCBpZCkge1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9ncmVzcyBhIGpvYiBoYXMgcGVyZm9ybWVkIHNvIGZhci5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yIHdoZW4gcHJvY2Vzc2luZyB0aGlzIGpvYi5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJldHVybnZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YWNrdHJhY2UgZm9yIHRoZSBlcnJvciAoZm9yIGZhaWxlZCBqb2JzKS5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrdHJhY2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoaXMgam9iIGNhbiBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAqIEBkZWZhdWx0VmFsdWUgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSYW5nZXMgZnJvbSAwIChoaWdoZXN0IHByaW9yaXR5KSB0byAyIDA5NyAxNTIgKGxvd2VzdCBwcmlvcml0eSkuIE5vdGUgdGhhdFxuICAgICAgICAgKiB1c2luZyBwcmlvcml0aWVzIGhhcyBhIHNsaWdodCBpbXBhY3Qgb24gcGVyZm9ybWFuY2UsXG4gICAgICAgICAqIHNvIGRvIG5vdCB1c2UgaXQgaWYgbm90IHJlcXVpcmVkLlxuICAgICAgICAgKiBAZGVmYXVsdFZhbHVlIDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHdoZW4gam9iIGlzIG1vdmVkIHRvIGFjdGl2ZS5cbiAgICAgICAgICogQGRlZmF1bHRWYWx1ZSAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzU3RhcnRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgYWZ0ZXIgdGhlIGpvYiBoYXMgZmFpbGVkLlxuICAgICAgICAgKiBAZGVmYXVsdFZhbHVlIDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdHNNYWRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiB0aW1lcyB3aGVyZSBqb2IgaGFzIHN0YWxsZWQuXG4gICAgICAgICAqIEBkZWZhdWx0VmFsdWUgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFsbGVkQ291bnRlciA9IDA7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5vcHRzLCB7IHJlcGVhdEpvYktleSB9ID0gX2EsIHJlc3RPcHRzID0gX19yZXN0KF9hLCBbXCJyZXBlYXRKb2JLZXlcIl0pO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGF0dGVtcHRzOiAwLFxuICAgICAgICB9LCByZXN0T3B0cyk7XG4gICAgICAgIHRoaXMuZGVsYXkgPSB0aGlzLm9wdHMuZGVsYXk7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSB0aGlzLm9wdHMucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdGhpcy5yZXBlYXRKb2JLZXkgPSByZXBlYXRKb2JLZXk7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gb3B0cy50aW1lc3RhbXAgPyBvcHRzLnRpbWVzdGFtcCA6IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMub3B0cy5iYWNrb2ZmID0gQmFja29mZnMubm9ybWFsaXplKG9wdHMuYmFja29mZik7XG4gICAgICAgIHRoaXMucGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KG9wdHMucGFyZW50KTtcbiAgICAgICAgaWYgKG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHsgaWQ6IG9wdHMucGFyZW50LmlkLCBxdWV1ZUtleTogb3B0cy5wYXJlbnQucXVldWUgfTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZhaWxQYXJlbnRPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5mcG9mID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZG9mID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmlnbm9yZURlcGVuZGVuY3lPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pZG9mID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmNvbnRpbnVlUGFyZW50T25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY3BvZiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJvdW5jZUlkID0gb3B0cy5kZWJvdW5jZSA/IG9wdHMuZGVib3VuY2UuaWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGVkdXBsaWNhdGlvbklkID0gb3B0cy5kZWR1cGxpY2F0aW9uXG4gICAgICAgICAgICA/IG9wdHMuZGVkdXBsaWNhdGlvbi5pZFxuICAgICAgICAgICAgOiB0aGlzLmRlYm91bmNlSWQ7XG4gICAgICAgIHRoaXMudG9LZXkgPSBxdWV1ZS50b0tleS5iaW5kKHF1ZXVlKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTY3JpcHRzKCk7XG4gICAgICAgIHRoaXMucXVldWVRdWFsaWZpZWROYW1lID0gcXVldWUucXVhbGlmaWVkTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBqb2IgYW5kIGFkZHMgaXQgdG8gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXVlIC0gdGhlIHF1ZXVlIHdoZXJlIHRvIGFkZCB0aGUgam9iLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGpvYi5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIHRoZSBwYXlsb2FkIG9mIHRoZSBqb2IuXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgb3B0aW9ucyBiYWcgZm9yIHRoaXMgam9iLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShxdWV1ZSwgbmFtZSwgZGF0YSwgb3B0cykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGpvYiA9IG5ldyB0aGlzKHF1ZXVlLCBuYW1lLCBkYXRhLCBvcHRzLCBvcHRzICYmIG9wdHMuam9iSWQpO1xuICAgICAgICBqb2IuaWQgPSBhd2FpdCBqb2IuYWRkSm9iKGNsaWVudCwge1xuICAgICAgICAgICAgcGFyZW50S2V5OiBqb2IucGFyZW50S2V5LFxuICAgICAgICAgICAgcGFyZW50RGVwZW5kZW5jaWVzS2V5OiBqb2IucGFyZW50S2V5XG4gICAgICAgICAgICAgICAgPyBgJHtqb2IucGFyZW50S2V5fTpkZXBlbmRlbmNpZXNgXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBqb2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBidWxrIG9mIGpvYnMgYW5kIGFkZHMgdGhlbSBhdG9taWNhbGx5IHRvIHRoZSBnaXZlbiBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZSAtdGhlIHF1ZXVlIHdlcmUgdG8gYWRkIHRoZSBqb2JzLlxuICAgICAqIEBwYXJhbSBqb2JzIC0gYW4gYXJyYXkgb2Ygam9icyB0byBiZSBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlQnVsayhxdWV1ZSwgam9icykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGpvYkluc3RhbmNlcyA9IGpvYnMubWFwKGpvYiA9PiB7IHZhciBfYTsgcmV0dXJuIG5ldyB0aGlzKHF1ZXVlLCBqb2IubmFtZSwgam9iLmRhdGEsIGpvYi5vcHRzLCAoX2EgPSBqb2Iub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvYklkKTsgfSk7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XG4gICAgICAgIGZvciAoY29uc3Qgam9iIG9mIGpvYkluc3RhbmNlcykge1xuICAgICAgICAgICAgam9iLmFkZEpvYihwaXBlbGluZSwge1xuICAgICAgICAgICAgICAgIHBhcmVudEtleTogam9iLnBhcmVudEtleSxcbiAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXk6IGpvYi5wYXJlbnRLZXlcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtqb2IucGFyZW50S2V5fTpkZXBlbmRlbmNpZXNgXG4gICAgICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gKGF3YWl0IHBpcGVsaW5lLmV4ZWMoKSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgW2VyciwgaWRdID0gcmVzdWx0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgam9iSW5zdGFuY2VzW2luZGV4XS5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2JJbnN0YW5jZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIEpvYiBmcm9tIGEgSm9iSnNvblJhdyBvYmplY3QgKGNvbWluZyBmcm9tIGEgZGVzZXJpYWxpemVkIEpTT04gb2JqZWN0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXVlIC0gdGhlIHF1ZXVlIHdoZXJlIHRoZSBqb2IgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ganNvbiAtIHRoZSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgam9iLlxuICAgICAqIEBwYXJhbSBqb2JJZCAtIGFuIG9wdGlvbmFsIGpvYiBpZCAob3ZlcnJpZGVzIHRoZSBpZCBjb21pbmcgZnJvbSB0aGUgSlNPTiBvYmplY3QpXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04ocXVldWUsIGpzb24sIGpvYklkKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24uZGF0YSB8fCAne30nKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IEpvYi5vcHRzRnJvbUpTT04oanNvbi5vcHRzKTtcbiAgICAgICAgY29uc3Qgam9iID0gbmV3IHRoaXMocXVldWUsIGpzb24ubmFtZSwgZGF0YSwgb3B0cywganNvbi5pZCB8fCBqb2JJZCk7XG4gICAgICAgIGpvYi5wcm9ncmVzcyA9IEpTT04ucGFyc2UoanNvbi5wcm9ncmVzcyB8fCAnMCcpO1xuICAgICAgICBqb2IuZGVsYXkgPSBwYXJzZUludChqc29uLmRlbGF5KTtcbiAgICAgICAgam9iLnByaW9yaXR5ID0gcGFyc2VJbnQoanNvbi5wcmlvcml0eSk7XG4gICAgICAgIGpvYi50aW1lc3RhbXAgPSBwYXJzZUludChqc29uLnRpbWVzdGFtcCk7XG4gICAgICAgIGlmIChqc29uLmZpbmlzaGVkT24pIHtcbiAgICAgICAgICAgIGpvYi5maW5pc2hlZE9uID0gcGFyc2VJbnQoanNvbi5maW5pc2hlZE9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5wcm9jZXNzZWRPbikge1xuICAgICAgICAgICAgam9iLnByb2Nlc3NlZE9uID0gcGFyc2VJbnQoanNvbi5wcm9jZXNzZWRPbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24ucmprKSB7XG4gICAgICAgICAgICBqb2IucmVwZWF0Sm9iS2V5ID0ganNvbi5yams7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uZGVpZCkge1xuICAgICAgICAgICAgam9iLmRlYm91bmNlSWQgPSBqc29uLmRlaWQ7XG4gICAgICAgICAgICBqb2IuZGVkdXBsaWNhdGlvbklkID0ganNvbi5kZWlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLmZhaWxlZFJlYXNvbikge1xuICAgICAgICAgICAgam9iLmZhaWxlZFJlYXNvbiA9IGpzb24uZmFpbGVkUmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIGpvYi5hdHRlbXB0c1N0YXJ0ZWQgPSBwYXJzZUludChqc29uLmF0cyB8fCAnMCcpO1xuICAgICAgICBqb2IuYXR0ZW1wdHNNYWRlID0gcGFyc2VJbnQoanNvbi5hdHRlbXB0c01hZGUgfHwganNvbi5hdG0gfHwgJzAnKTtcbiAgICAgICAgam9iLnN0YWxsZWRDb3VudGVyID0gcGFyc2VJbnQoanNvbi5zdGMgfHwgJzAnKTtcbiAgICAgICAgaWYgKGpzb24uZGVmYSkge1xuICAgICAgICAgICAgam9iLmRlZmVycmVkRmFpbHVyZSA9IGpzb24uZGVmYTtcbiAgICAgICAgfVxuICAgICAgICBqb2Iuc3RhY2t0cmFjZSA9IGdldFRyYWNlcyhqc29uLnN0YWNrdHJhY2UpO1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucmV0dXJudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBqb2IucmV0dXJudmFsdWUgPSBnZXRSZXR1cm5WYWx1ZShqc29uLnJldHVybnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5wYXJlbnRLZXkpIHtcbiAgICAgICAgICAgIGpvYi5wYXJlbnRLZXkgPSBqc29uLnBhcmVudEtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGpvYi5wYXJlbnQgPSBKU09OLnBhcnNlKGpzb24ucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5wYikge1xuICAgICAgICAgICAgam9iLnByb2Nlc3NlZEJ5ID0ganNvbi5wYjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5ucmppZCkge1xuICAgICAgICAgICAgam9iLm5leHRSZXBlYXRhYmxlSm9iSWQgPSBqc29uLm5yamlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2I7XG4gICAgfVxuICAgIGNyZWF0ZVNjcmlwdHMoKSB7XG4gICAgICAgIHRoaXMuc2NyaXB0cyA9IGNyZWF0ZVNjcmlwdHModGhpcy5xdWV1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBvcHRzRnJvbUpTT04ocmF3T3B0cywgb3B0c0RlY29kZSA9IG9wdHNEZWNvZGVNYXApIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IEpTT04ucGFyc2UocmF3T3B0cyB8fCAne30nKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9wdHMpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcHRpb25FbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBbYXR0cmlidXRlTmFtZSwgdmFsdWVdID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChvcHRzRGVjb2RlW2F0dHJpYnV0ZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRzRGVjb2RlW2F0dHJpYnV0ZU5hbWVdXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICd0bScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50ZWxlbWV0cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMudGVsZW1ldHJ5KSwgeyBtZXRhZGF0YTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICdvbWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudGVsZW1ldHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnRlbGVtZXRyeSksIHsgb21pdENvbnRleHQ6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1thdHRyaWJ1dGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEpvYiBmcm9tIHRoZSBxdWV1ZSBnaXZlbiB0aGUgcGFzc2VkIGpvYiBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZSAtIHRoZSBxdWV1ZSB3aGVyZSB0aGUgam9iIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIGpvYklkIC0gdGhlIGpvYiBpZC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tSWQocXVldWUsIGpvYklkKSB7XG4gICAgICAgIC8vIGpvYklkIGNhbiBiZSB1bmRlZmluZWQgaWYgbW92ZUpvYiByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICBpZiAoam9iSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHF1ZXVlLmNsaWVudDtcbiAgICAgICAgICAgIGNvbnN0IGpvYkRhdGEgPSBhd2FpdCBjbGllbnQuaGdldGFsbChxdWV1ZS50b0tleShqb2JJZCkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHkoam9iRGF0YSlcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogdGhpcy5mcm9tSlNPTihxdWV1ZSwgam9iRGF0YSwgam9iSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZEpvYkxvZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXVlIC0gQSBtaW5pbWFsIHF1ZXVlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGpvYklkIC0gSm9iIGlkXG4gICAgICogQHBhcmFtIGxvZ1JvdyAtIFN0cmluZyB3aXRoIGEgcm93IG9mIGxvZyBkYXRhIHRvIGJlIGxvZ2dlZFxuICAgICAqIEBwYXJhbSBrZWVwTG9ncyAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbG9nIGVudHJpZXMgdG8gcHJlc2VydmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2YgbG9nIGVudHJpZXMgZm9yIHRoaXMgam9iIHNvIGZhci5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSm9iTG9nKHF1ZXVlLCBqb2JJZCwgbG9nUm93LCBrZWVwTG9ncykge1xuICAgICAgICBjb25zdCBzY3JpcHRzID0gcXVldWUuc2NyaXB0cztcbiAgICAgICAgcmV0dXJuIHNjcmlwdHMuYWRkTG9nKGpvYklkLCBsb2dSb3csIGtlZXBMb2dzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMsIHsgcXVldWUsIHNjcmlwdHMgfSA9IF9hLCB3aXRob3V0UXVldWVBbmRTY3JpcHRzID0gX19yZXN0KF9hLCBbXCJxdWV1ZVwiLCBcInNjcmlwdHNcIl0pO1xuICAgICAgICByZXR1cm4gd2l0aG91dFF1ZXVlQW5kU2NyaXB0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSBqb2IgdG8gYmUgc2VyaWFsaXplZCBmb3Igc3RvcmFnZSBpbiBSZWRpcy5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVVuZGVmaW5lZEZpZWxkcyh7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHR5cGVvZiB0aGlzLmRhdGEgPT09ICd1bmRlZmluZWQnID8ge30gOiB0aGlzLmRhdGEpLFxuICAgICAgICAgICAgb3B0czogSm9iLm9wdHNBc0pTT04odGhpcy5vcHRzKSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmVudCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50S2V5LFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHRoaXMucHJvZ3Jlc3MsXG4gICAgICAgICAgICBhdHRlbXB0c01hZGU6IHRoaXMuYXR0ZW1wdHNNYWRlLFxuICAgICAgICAgICAgYXR0ZW1wdHNTdGFydGVkOiB0aGlzLmF0dGVtcHRzU3RhcnRlZCxcbiAgICAgICAgICAgIHN0YWxsZWRDb3VudGVyOiB0aGlzLnN0YWxsZWRDb3VudGVyLFxuICAgICAgICAgICAgZmluaXNoZWRPbjogdGhpcy5maW5pc2hlZE9uLFxuICAgICAgICAgICAgcHJvY2Vzc2VkT246IHRoaXMucHJvY2Vzc2VkT24sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLFxuICAgICAgICAgICAgZmFpbGVkUmVhc29uOiBKU09OLnN0cmluZ2lmeSh0aGlzLmZhaWxlZFJlYXNvbiksXG4gICAgICAgICAgICBzdGFja3RyYWNlOiBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YWNrdHJhY2UpLFxuICAgICAgICAgICAgZGVib3VuY2VJZDogdGhpcy5kZWJvdW5jZUlkLFxuICAgICAgICAgICAgZGVkdXBsaWNhdGlvbklkOiB0aGlzLmRlZHVwbGljYXRpb25JZCxcbiAgICAgICAgICAgIHJlcGVhdEpvYktleTogdGhpcy5yZXBlYXRKb2JLZXksXG4gICAgICAgICAgICByZXR1cm52YWx1ZTogSlNPTi5zdHJpbmdpZnkodGhpcy5yZXR1cm52YWx1ZSksXG4gICAgICAgICAgICBucmppZDogdGhpcy5uZXh0UmVwZWF0YWJsZUpvYklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIG9wdHNBc0pTT04ob3B0cyA9IHt9LCBvcHRzRW5jb2RlID0gb3B0c0VuY29kZU1hcCkge1xuICAgICAgICBjb25zdCBvcHRpb25FbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob3B0cyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbYXR0cmlidXRlTmFtZSwgdmFsdWVdIG9mIG9wdGlvbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiBvcHRzRW5jb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NhYmxlQXR0cmlidXRlID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvcHRzRW5jb2RlW2NvbXByZXNzYWJsZUF0dHJpYnV0ZV07XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29tcGxleCBjb21wcmVzc2FibGUgZmllbGRzIHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3RlbGVtZXRyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG0gPSB2YWx1ZS5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUub21pdENvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbWMgPSB2YWx1ZS5vbWl0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1thdHRyaWJ1dGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSBqb2IgdG8gYmUgcGFzc2VkIHRvIFNhbmRib3guXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc0pTT05TYW5kYm94KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmFzSlNPTigpKSwgeyBxdWV1ZU5hbWU6IHRoaXMucXVldWVOYW1lLCBxdWV1ZVF1YWxpZmllZE5hbWU6IHRoaXMucXVldWVRdWFsaWZpZWROYW1lLCBwcmVmaXg6IHRoaXMucHJlZml4IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgam9iJ3MgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSB0aGUgZGF0YSB0aGF0IHdpbGwgcmVwbGFjZSB0aGUgY3VycmVudCBqb2JzIGRhdGEuXG4gICAgICovXG4gICAgdXBkYXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMudXBkYXRlRGF0YSh0aGlzLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIGpvYidzIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBudW1iZXIgb3Igb2JqZWN0IHRvIGJlIHNhdmVkIGFzIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLnVwZGF0ZVByb2dyZXNzKHRoaXMuaWQsIHByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5lbWl0KCdwcm9ncmVzcycsIHRoaXMsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBvbmUgcm93IG9mIGxvZyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvZ1JvdyAtIHN0cmluZyB3aXRoIGxvZyBkYXRhIHRvIGJlIGxvZ2dlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIGxvZyBlbnRyaWVzIGZvciB0aGlzIGpvYiBzbyBmYXIuXG4gICAgICovXG4gICAgYXN5bmMgbG9nKGxvZ1Jvdykge1xuICAgICAgICByZXR1cm4gSm9iLmFkZEpvYkxvZyh0aGlzLnF1ZXVlLCB0aGlzLmlkLCBsb2dSb3csIHRoaXMub3B0cy5rZWVwTG9ncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY2hpbGQgZGVwZW5kZW5jeSBmcm9tIHBhcmVudCB3aGVuIGNoaWxkIGlzIG5vdCB5ZXQgZmluaXNoZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlbGF0aW9uc2hpcCBleGlzdGVkIGFuZCBpZiBpdCB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDaGlsZERlcGVuZGVuY3koKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwZW5kZW5jeUlzUmVtb3ZlZCA9IGF3YWl0IHRoaXMuc2NyaXB0cy5yZW1vdmVDaGlsZERlcGVuZGVuY3kodGhpcy5pZCwgdGhpcy5wYXJlbnRLZXkpO1xuICAgICAgICBpZiAoY2hpbGREZXBlbmRlbmN5SXNSZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgam9iJ3MgbG9nc1xuICAgICAqXG4gICAgICogQHBhcmFtIGtlZXBMb2dzIC0gdGhlIGFtb3VudCBvZiBsb2cgZW50cmllcyB0byBwcmVzZXJ2ZVxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyTG9ncyhrZWVwTG9ncykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgbG9nc0tleSA9IHRoaXMudG9LZXkodGhpcy5pZCkgKyAnOmxvZ3MnO1xuICAgICAgICBpZiAoa2VlcExvZ3MpIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5sdHJpbShsb2dzS2V5LCAta2VlcExvZ3MsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5kZWwobG9nc0tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVseSByZW1vdmUgdGhlIGpvYiBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgKiBOb3RlLCB0aGlzIGNhbGwgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGpvYlxuICAgICAqIGlzIGJlaW5nIHByb2Nlc3NlZCB3aGVuIHRoZSBjYWxsIGlzIHBlcmZvcm1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyB0byByZW1vdmUgYSBqb2JcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmUoeyByZW1vdmVDaGlsZHJlbiA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucXVldWUud2FpdFVudGlsUmVhZHkoKTtcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICBjb25zdCBqb2IgPSB0aGlzO1xuICAgICAgICBjb25zdCByZW1vdmVkID0gYXdhaXQgdGhpcy5zY3JpcHRzLnJlbW92ZShqb2IuaWQsIHJlbW92ZUNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVtaXQoJ3JlbW92ZWQnLCBqb2IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBKb2IgJHt0aGlzLmlkfSBjb3VsZCBub3QgYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IGlzIGxvY2tlZCBieSBhbm90aGVyIHdvcmtlcmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGpvYiB0aGF0IGFyZSBub3QgeWV0IHByb2Nlc3NlZCxcbiAgICAgKiBpbiBvdGhlciB3b3JkcyB0aGF0IGFyZSBpbiBhbnkgb3RoZXIgc3RhdGUgdGhhbiBjb21wbGV0ZWQsIGZhaWxlZCBvciBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqICAtIEpvYnMgd2l0aCBsb2NrcyAobW9zdCBsaWtlbHkgYWN0aXZlKSBhcmUgaWdub3JlZC5cbiAgICAgKiAgLSBUaGlzIG1ldGhvZCBjYW4gYmUgc2xvdyBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGlzIGxhcmdlIChcXD4gMTAwMCkuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3Qgam9iSWQgPSB0aGlzLmlkO1xuICAgICAgICBhd2FpdCB0aGlzLnNjcmlwdHMucmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbihqb2JJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGUgbG9jayBmb3IgdGhpcyBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB1bmlxdWUgdG9rZW4gZm9yIHRoZSBsb2NrXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIC0gbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBleHRlbmRMb2NrKHRva2VuLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLmV4dGVuZExvY2sodGhpcy5pZCwgdG9rZW4sIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBqb2IgdG8gdGhlIGNvbXBsZXRlZCBxdWV1ZS5cbiAgICAgKiBSZXR1cm5lZCBqb2IgdG8gYmUgdXNlZCB3aXRoIFF1ZXVlLnByb3RvdHlwZS5uZXh0Sm9iRnJvbUpvYkRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0dXJuVmFsdWUgLSBUaGUgam9icyBzdWNjZXNzIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHRva2VuIC0gV29ya2VyIHRva2VuIHVzZWQgdG8gYWNxdWlyZSBjb21wbGV0ZWQgam9iLlxuICAgICAqIEBwYXJhbSBmZXRjaE5leHQgLSBUcnVlIHdoZW4gd2FudGluZyB0byBmZXRjaCB0aGUgbmV4dCBqb2IuXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgam9iRGF0YSBvZiB0aGUgbmV4dCBqb2IgaW4gdGhlIHdhaXRpbmcgcXVldWUgb3Igdm9pZC5cbiAgICAgKi9cbiAgICBhc3luYyBtb3ZlVG9Db21wbGV0ZWQocmV0dXJuVmFsdWUsIHRva2VuLCBmZXRjaE5leHQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAnY29tcGxldGUnLCB0aGlzLnF1ZXVlLm5hbWUsIGFzeW5jIChzcGFuLCBkc3RQcm9wYWdhdGlvbk1lZGF0YWRhdGEpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBsZXQgdG07XG4gICAgICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZWxlbWV0cnkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbWl0Q29udGV4dCkgJiYgZHN0UHJvcGFnYXRpb25NZWRhdGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdG0gPSBkc3RQcm9wYWdhdGlvbk1lZGF0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXVlLndhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgICAgICB0aGlzLnJldHVybnZhbHVlID0gcmV0dXJuVmFsdWUgfHwgdm9pZCAwO1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRSZXR1cm5WYWx1ZSA9IHRyeUNhdGNoKEpTT04uc3RyaW5naWZ5LCBKU09OLCBbXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZFJldHVyblZhbHVlID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yT2JqZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuc2NyaXB0cy5tb3ZlVG9Db21wbGV0ZWRBcmdzKHRoaXMsIHN0cmluZ2lmaWVkUmV0dXJuVmFsdWUsIHRoaXMub3B0cy5yZW1vdmVPbkNvbXBsZXRlLCB0b2tlbiwgZmV0Y2hOZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2NyaXB0cy5tb3ZlVG9GaW5pc2hlZCh0aGlzLmlkLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRPbiA9IGFyZ3NbdGhpcy5zY3JpcHRzLm1vdmVUb0ZpbmlzaGVkS2V5cy5sZW5ndGggKyAxXTtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHNNYWRlICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBqb2IgdG8gdGhlIHdhaXQgb3IgcHJpb3JpdGl6ZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBXb3JrZXIgdG9rZW4gdXNlZCB0byBhY3F1aXJlIGNvbXBsZXRlZCBqb2IuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBwdHRsLlxuICAgICAqL1xuICAgIG1vdmVUb1dhaXQodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5tb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdCh0aGlzLmlkLCB0b2tlbik7XG4gICAgfVxuICAgIGFzeW5jIHNob3VsZFJldHJ5Sm9iKGVycikge1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0c01hZGUgKyAxIDwgdGhpcy5vcHRzLmF0dGVtcHRzICYmXG4gICAgICAgICAgICAhdGhpcy5kaXNjYXJkZWQgJiZcbiAgICAgICAgICAgICEoZXJyIGluc3RhbmNlb2YgVW5yZWNvdmVyYWJsZUVycm9yIHx8IGVyci5uYW1lID09ICdVbnJlY292ZXJhYmxlRXJyb3InKSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMucXVldWUub3B0cztcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gYXdhaXQgQmFja29mZnMuY2FsY3VsYXRlKHRoaXMub3B0cy5iYWNrb2ZmLCB0aGlzLmF0dGVtcHRzTWFkZSArIDEsIGVyciwgdGhpcywgb3B0cy5zZXR0aW5ncyAmJiBvcHRzLnNldHRpbmdzLmJhY2tvZmZTdHJhdGVneSk7XG4gICAgICAgICAgICByZXR1cm4gW2RlbGF5ID09IC0xID8gZmFsc2UgOiB0cnVlLCBkZWxheSA9PSAtMSA/IDAgOiBkZWxheV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGpvYiB0byB0aGUgZmFpbGVkIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVyciAtIHRoZSBqb2JzIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHRva2VuIC0gdG9rZW4gdG8gY2hlY2sgam9iIGlzIGxvY2tlZCBieSBjdXJyZW50IHdvcmtlclxuICAgICAqIEBwYXJhbSBmZXRjaE5leHQgLSB0cnVlIHdoZW4gd2FudGluZyB0byBmZXRjaCB0aGUgbmV4dCBqb2JcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBqb2JEYXRhIG9mIHRoZSBuZXh0IGpvYiBpbiB0aGUgd2FpdGluZyBxdWV1ZSBvciB2b2lkLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb0ZhaWxlZChlcnIsIHRva2VuLCBmZXRjaE5leHQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZhaWxlZFJlYXNvbiA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbiBhdXRvbWF0aWMgcmV0cnkgc2hvdWxkIGJlIHBlcmZvcm1lZFxuICAgICAgICBjb25zdCBbc2hvdWxkUmV0cnksIHJldHJ5RGVsYXldID0gYXdhaXQgdGhpcy5zaG91bGRSZXRyeUpvYihlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgdGhpcy5nZXRTcGFuT3BlcmF0aW9uKHNob3VsZFJldHJ5LCByZXRyeURlbGF5KSwgdGhpcy5xdWV1ZS5uYW1lLCBhc3luYyAoc3BhbiwgZHN0UHJvcGFnYXRpb25NZWRhdGFkYXRhKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgbGV0IHRtO1xuICAgICAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub21pdENvbnRleHQpICYmIGRzdFByb3BhZ2F0aW9uTWVkYXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRtID0gZHN0UHJvcGFnYXRpb25NZWRhdGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhY2t0cmFjZShlcnIpO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzVG9VcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgZmFpbGVkUmVhc29uOiB0aGlzLmZhaWxlZFJlYXNvbixcbiAgICAgICAgICAgICAgICBzdGFja3RyYWNlOiBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YWNrdHJhY2UpLFxuICAgICAgICAgICAgICAgIHRtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZE9uO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5RGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgd2l0aCBkZWxheVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvRGVsYXllZCh0aGlzLmlkLCBEYXRlLm5vdygpLCByZXRyeURlbGF5LCB0b2tlbiwgeyBmaWVsZHNUb1VwZGF0ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2NyaXB0cy5yZXRyeUpvYih0aGlzLmlkLCB0aGlzLm9wdHMubGlmbywgdG9rZW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1RvVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5zY3JpcHRzLm1vdmVUb0ZhaWxlZEFyZ3ModGhpcywgdGhpcy5mYWlsZWRSZWFzb24sIHRoaXMub3B0cy5yZW1vdmVPbkZhaWwsIHRva2VuLCBmZXRjaE5leHQsIGZpZWxkc1RvVXBkYXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvRmluaXNoZWQodGhpcy5pZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgZmluaXNoZWRPbiA9IGFyZ3NbdGhpcy5zY3JpcHRzLm1vdmVUb0ZpbmlzaGVkS2V5cy5sZW5ndGggKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZE9uICYmIHR5cGVvZiBmaW5pc2hlZE9uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoZWRPbiA9IGZpbmlzaGVkT247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0cnlEZWxheSAmJiB0eXBlb2YgcmV0cnlEZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ID0gcmV0cnlEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHNNYWRlICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3Bhbk9wZXJhdGlvbihzaG91bGRSZXRyeSwgcmV0cnlEZWxheSkge1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgIGlmIChyZXRyeURlbGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZWxheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ3JldHJ5JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2ZhaWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBpc0NvbXBsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ2NvbXBsZXRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaGFzIGZhaWxlZC5cbiAgICAgKi9cbiAgICBpc0ZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ2ZhaWxlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbiAgICAgKi9cbiAgICBpc0RlbGF5ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5aU2V0KCdkZWxheWVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGpvYiBpcyB3YWl0aW5nIGZvciBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBpc1dhaXRpbmdDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblpTZXQoJ3dhaXRpbmctY2hpbGRyZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBvZiB0aGUgam9iIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbkxpc3QoJ2FjdGl2ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBqb2IgaXMgd2FpdGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBpc1dhaXRpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5pc0luTGlzdCgnd2FpdCcpKSB8fCAoYXdhaXQgdGhpcy5pc0luTGlzdCgncGF1c2VkJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgcXVldWUgbmFtZSB0aGlzIGpvYiBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIGdldCBxdWV1ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBwcmVmaXggdGhhdCBpcyB1c2VkLlxuICAgICAqL1xuICAgIGdldCBwcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLm9wdHMucHJlZml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgb25lIG9mIHRoZXNlIHZhbHVlczpcbiAgICAgKiAnY29tcGxldGVkJywgJ2ZhaWxlZCcsICdkZWxheWVkJywgJ2FjdGl2ZScsICd3YWl0aW5nJywgJ3dhaXRpbmctY2hpbGRyZW4nLCAndW5rbm93bicuXG4gICAgICovXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMuZ2V0U3RhdGUodGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBkZWxheSBvZiBhIGRlbGF5ZWQgam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlbGF5IC0gbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkIHRvIGN1cnJlbnQgdGltZS5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgYXN5bmMgY2hhbmdlRGVsYXkoZGVsYXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLmNoYW5nZURlbGF5KHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2Ugam9iIHByaW9yaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGNvbnRhaW5pbmcgcHJpb3JpdHkgYW5kIGxpZm8gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBhc3luYyBjaGFuZ2VQcmlvcml0eShvcHRzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2NyaXB0cy5jaGFuZ2VQcmlvcml0eSh0aGlzLmlkLCBvcHRzLnByaW9yaXR5LCBvcHRzLmxpZm8pO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhpcyBqb2JzIGNoaWxkcmVuIHJlc3VsdCB2YWx1ZXMgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgT2JqZWN0IG1hcHBpbmcgY2hpbGRyZW4gam9iIGtleXMgd2l0aCB0aGVpciB2YWx1ZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2hpbGRyZW5WYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgY2xpZW50LmhnZXRhbGwodGhpcy50b0tleShgJHt0aGlzLmlkfTpwcm9jZXNzZWRgKSkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3RWYWx1ZXMocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZhaWx1cmVzIG9mIGNoaWxkIGpvYnMgdGhhdCB3ZXJlIGV4cGxpY2l0bHkgaWdub3JlZCB3aGlsZSB1c2luZyBpZ25vcmVEZXBlbmRlbmN5T25GYWlsdXJlIG9wdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGluc3BlY3Rpbmcgd2hpY2ggY2hpbGQgam9icyB3ZXJlIGludGVudGlvbmFsbHkgaWdub3JlZCB3aGVuIGFuIGVycm9yIG9jY3VyZWQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmJ1bGxtcS5pby9ndWlkZS9mbG93cy9pZ25vcmUtZGVwZW5kZW5jeX1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE9iamVjdCBtYXBwaW5nIGNoaWxkcmVuIGpvYiBrZXlzIHdpdGggdGhlaXIgZmFpbHVyZSB2YWx1ZXMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXMoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmhnZXRhbGwodGhpcy50b0tleShgJHt0aGlzLmlkfTpmYWlsZWRgKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBqb2IncyBjaGlsZHJlbiBmYWlsdXJlIHZhbHVlcyB0aGF0IHdlcmUgaWdub3JlZCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjYuIFVzZSBnZXRJZ25vcmVkQ2hpbGRyZW5GYWlsdXJlcyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgT2JqZWN0IG1hcHBpbmcgY2hpbGRyZW4gam9iIGtleXMgd2l0aCB0aGVpciBmYWlsdXJlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYWlsZWRDaGlsZHJlblZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuaGdldGFsbCh0aGlzLnRvS2V5KGAke3RoaXMuaWR9OmZhaWxlZGApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNoaWxkcmVuIGpvYiBrZXlzIGlmIHRoaXMgam9iIGlzIGEgcGFyZW50IGFuZCBoYXMgY2hpbGRyZW4uXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb3VudCBvcHRpb25zIGJlZm9yZSBSZWRpcyB2Ny4yIHdvcmtzIGFzIGV4cGVjdGVkIHdpdGggYW55IHF1YW50aXR5IG9mIGVudHJpZXNcbiAgICAgKiBvbiBwcm9jZXNzZWQvdW5wcm9jZXNzZWQgZGVwZW5kZW5jaWVzLCBzaW5jZSB2Ny4yIHlvdSBtdXN0IGNvbnNpZGVyIHRoYXQgY291bnRcbiAgICAgKiB3b24ndCBoYXZlIGFueSBlZmZlY3QgdW50aWwgcHJvY2Vzc2VkL3VucHJvY2Vzc2VkIGRlcGVuZGVuY2llcyBoYXZlIGEgbGVuZ3RoXG4gICAgICogZ3JlYXRlciB0aGFuIDEyN1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVkaXMuaW8vZG9jcy9tYW5hZ2VtZW50L29wdGltaXphdGlvbi9tZW1vcnktb3B0aW1pemF0aW9uLyNyZWRpcy0tNzJ9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmJ1bGxtcS5pby9ndWlkZS9mbG93cyNnZXR0ZXJzfVxuICAgICAqIEByZXR1cm5zIGRlcGVuZGVuY2llcyBzZXBhcmF0ZWQgYnkgcHJvY2Vzc2VkLCB1bnByb2Nlc3NlZCwgaWdub3JlZCBhbmQgZmFpbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGVuZGVuY2llcyhvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IG11bHRpID0gY2xpZW50Lm11bHRpKCk7XG4gICAgICAgIGlmICghb3B0cy5wcm9jZXNzZWQgJiYgIW9wdHMudW5wcm9jZXNzZWQgJiYgIW9wdHMuaWdub3JlZCAmJiAhb3B0cy5mYWlsZWQpIHtcbiAgICAgICAgICAgIG11bHRpLmhnZXRhbGwodGhpcy50b0tleShgJHt0aGlzLmlkfTpwcm9jZXNzZWRgKSk7XG4gICAgICAgICAgICBtdWx0aS5zbWVtYmVycyh0aGlzLnRvS2V5KGAke3RoaXMuaWR9OmRlcGVuZGVuY2llc2ApKTtcbiAgICAgICAgICAgIG11bHRpLmhnZXRhbGwodGhpcy50b0tleShgJHt0aGlzLmlkfTpmYWlsZWRgKSk7XG4gICAgICAgICAgICBtdWx0aS56cmFuZ2UodGhpcy50b0tleShgJHt0aGlzLmlkfTp1bnN1Y2Nlc3NmdWxgKSwgMCwgLTEpO1xuICAgICAgICAgICAgY29uc3QgW1tlcnIxLCBwcm9jZXNzZWRdLCBbZXJyMiwgdW5wcm9jZXNzZWRdLCBbZXJyMywgaWdub3JlZF0sIFtlcnI0LCBmYWlsZWRdLF0gPSAoYXdhaXQgbXVsdGkuZXhlYygpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkOiBwYXJzZU9iamVjdFZhbHVlcyhwcm9jZXNzZWQpLFxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgIGZhaWxlZCxcbiAgICAgICAgICAgICAgICBpZ25vcmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRPcHRzID0ge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogMCxcbiAgICAgICAgICAgICAgICBjb3VudDogMjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5SZXN1bHRPcmRlciA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdHMucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5SZXN1bHRPcmRlci5wdXNoKCdwcm9jZXNzZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRPcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0cyksIG9wdHMucHJvY2Vzc2VkKTtcbiAgICAgICAgICAgICAgICBtdWx0aS5oc2Nhbih0aGlzLnRvS2V5KGAke3RoaXMuaWR9OnByb2Nlc3NlZGApLCBwcm9jZXNzZWRPcHRzLmN1cnNvciwgJ0NPVU5UJywgcHJvY2Vzc2VkT3B0cy5jb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy51bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuUmVzdWx0T3JkZXIucHVzaCgndW5wcm9jZXNzZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnByb2Nlc3NlZE9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRzKSwgb3B0cy51bnByb2Nlc3NlZCk7XG4gICAgICAgICAgICAgICAgbXVsdGkuc3NjYW4odGhpcy50b0tleShgJHt0aGlzLmlkfTpkZXBlbmRlbmNpZXNgKSwgdW5wcm9jZXNzZWRPcHRzLmN1cnNvciwgJ0NPVU5UJywgdW5wcm9jZXNzZWRPcHRzLmNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlblJlc3VsdE9yZGVyLnB1c2goJ2lnbm9yZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVkT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdHMpLCBvcHRzLmlnbm9yZWQpO1xuICAgICAgICAgICAgICAgIG11bHRpLmhzY2FuKHRoaXMudG9LZXkoYCR7dGhpcy5pZH06ZmFpbGVkYCksIGlnbm9yZWRPcHRzLmN1cnNvciwgJ0NPVU5UJywgaWdub3JlZE9wdHMuY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZhaWxlZEN1cnNvcjtcbiAgICAgICAgICAgIGlmIChvcHRzLmZhaWxlZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuUmVzdWx0T3JkZXIucHVzaCgnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbGVkT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdHMpLCBvcHRzLmZhaWxlZCk7XG4gICAgICAgICAgICAgICAgZmFpbGVkQ3Vyc29yID0gZmFpbGVkT3B0cy5jdXJzb3IgKyBmYWlsZWRPcHRzLmNvdW50O1xuICAgICAgICAgICAgICAgIG11bHRpLnpyYW5nZSh0aGlzLnRvS2V5KGAke3RoaXMuaWR9OnVuc3VjY2Vzc2Z1bGApLCBmYWlsZWRPcHRzLmN1cnNvciwgZmFpbGVkT3B0cy5jb3VudCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IChhd2FpdCBtdWx0aS5leGVjKCkpO1xuICAgICAgICAgICAgbGV0IHByb2Nlc3NlZEN1cnNvciwgcHJvY2Vzc2VkLCB1bnByb2Nlc3NlZEN1cnNvciwgdW5wcm9jZXNzZWQsIGZhaWxlZCwgaWdub3JlZEN1cnNvciwgaWdub3JlZDtcbiAgICAgICAgICAgIGNoaWxkcmVuUmVzdWx0T3JkZXIuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEN1cnNvciA9IHJlc3VsdHNbaW5kZXhdWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3UHJvY2Vzc2VkID0gcmVzdWx0c1tpbmRleF1bMV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFByb2Nlc3NlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kID0gMDsgaW5kIDwgcmF3UHJvY2Vzc2VkLmxlbmd0aDsgKytpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFByb2Nlc3NlZFtyYXdQcm9jZXNzZWRbaW5kIC0gMV1dID0gSlNPTi5wYXJzZShyYXdQcm9jZXNzZWRbaW5kXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gdHJhbnNmb3JtZWRQcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWQgPSByZXN1bHRzW2luZGV4XVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkQ3Vyc29yID0gcmVzdWx0c1tpbmRleF1bMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdJZ25vcmVkID0gcmVzdWx0c1tpbmRleF1bMV1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZElnbm9yZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZCA9IDA7IGluZCA8IHJhd0lnbm9yZWQubGVuZ3RoOyArK2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmQgJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkSWdub3JlZFtyYXdJZ25vcmVkW2luZCAtIDFdXSA9IHJhd0lnbm9yZWRbaW5kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkID0gdHJhbnNmb3JtZWRJZ25vcmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5wcm9jZXNzZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZEN1cnNvciA9IHJlc3VsdHNbaW5kZXhdWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQgPSByZXN1bHRzW2luZGV4XVsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHByb2Nlc3NlZEN1cnNvclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9jZXNzZWRDdXJzb3I6IE51bWJlcihwcm9jZXNzZWRDdXJzb3IpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSksIChpZ25vcmVkQ3Vyc29yXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZ25vcmVkQ3Vyc29yOiBOdW1iZXIoaWdub3JlZEN1cnNvciksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pKSwgKGZhaWxlZEN1cnNvclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRGYWlsZWRDdXJzb3I6IGZhaWxlZEN1cnNvcixcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCAodW5wcm9jZXNzZWRDdXJzb3JcbiAgICAgICAgICAgICAgICA/IHsgdW5wcm9jZXNzZWQsIG5leHRVbnByb2Nlc3NlZEN1cnNvcjogTnVtYmVyKHVucHJvY2Vzc2VkQ3Vyc29yKSB9XG4gICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjaGlsZHJlbiBqb2IgY291bnRzIGlmIHRoaXMgam9iIGlzIGEgcGFyZW50IGFuZCBoYXMgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBkZXBlbmRlbmNpZXMgY291bnQgc2VwYXJhdGVkIGJ5IHByb2Nlc3NlZCwgdW5wcm9jZXNzZWQsIGlnbm9yZWQgYW5kIGZhaWxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBlbmRlbmNpZXNDb3VudChvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbFR5cGVzID0gdHlwZXMubGVuZ3RoXG4gICAgICAgICAgICA/IHR5cGVzXG4gICAgICAgICAgICA6IFsncHJvY2Vzc2VkJywgJ3VucHJvY2Vzc2VkJywgJ2lnbm9yZWQnLCAnZmFpbGVkJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMuc2NyaXB0cy5nZXREZXBlbmRlbmN5Q291bnRzKHRoaXMuaWQsIGZpbmFsVHlwZXMpO1xuICAgICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgICAgcmVzcG9uc2VzLmZvckVhY2goKHJlcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvdW50c1tgJHtmaW5hbFR5cGVzW2luZGV4XX1gXSA9IHJlcyB8fCAwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhlIHJlc29sdmVzIHdoZW4gdGhlIGpvYiBoYXMgY29tcGxldGVkIChjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGpvYiksXG4gICAgICogb3IgcmVqZWN0cyB3aGVuIHRoZSBqb2IgaGFzIGZhaWxlZCAoY29udGFpbmluZyB0aGUgZmFpbGVkUmVhc29uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWV1ZUV2ZW50cyAtIEluc3RhbmNlIG9mIFF1ZXVlRXZlbnRzLlxuICAgICAqIEBwYXJhbSB0dGwgLSBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciBqb2IgdG8gZmluaXNoIGJlZm9yZSB0aW1pbmcgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRVbnRpbEZpbmlzaGVkKHF1ZXVlRXZlbnRzLCB0dGwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZS53YWl0VW50aWxSZWFkeSgpO1xuICAgICAgICBjb25zdCBqb2JJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgICAgIGlmICh0dGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBvbkZhaWxlZChcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICAgICAgYEpvYiB3YWl0ICR7dGhpcy5uYW1lfSB0aW1lZCBvdXQgYmVmb3JlIGZpbmlzaGluZywgbm8gZmluaXNoIG5vdGlmaWNhdGlvbiBhcnJpdmVkIGFmdGVyICR7dHRsfW1zIChpZD0ke2pvYklkfSlgKSwgdHRsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQ29tcGxldGVkKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFyZ3MucmV0dXJudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsZWQoYXJncykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYXJncy5mYWlsZWRSZWFzb24gfHwgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVkRXZlbnQgPSBgY29tcGxldGVkOiR7am9iSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZEV2ZW50ID0gYGZhaWxlZDoke2pvYklkfWA7XG4gICAgICAgICAgICBxdWV1ZUV2ZW50cy5vbihjb21wbGV0ZWRFdmVudCwgb25Db21wbGV0ZWQpO1xuICAgICAgICAgICAgcXVldWVFdmVudHMub24oZmFpbGVkRXZlbnQsIG9uRmFpbGVkKTtcbiAgICAgICAgICAgIHRoaXMucXVldWUub24oJ2Nsb3NpbmcnLCBvbkZhaWxlZCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50cy5yZW1vdmVMaXN0ZW5lcihjb21wbGV0ZWRFdmVudCwgb25Db21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzLnJlbW92ZUxpc3RlbmVyKGZhaWxlZEV2ZW50LCBvbkZhaWxlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmVMaXN0ZW5lcignY2xvc2luZycsIG9uRmFpbGVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBQb2xsIG9uY2UgcmlnaHQgbm93IHRvIHNlZSBpZiB0aGUgam9iIGhhcyBhbHJlYWR5IGZpbmlzaGVkLiBUaGUgam9iIG1heSBoYXZlIGJlZW4gY29tcGxldGVkIGJlZm9yZSB3ZSB3ZXJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIHJlZ2lzdGVyIHRoZSBldmVudCBoYW5kbGVycyBvbiB0aGUgUXVldWVFdmVudHMsIHNvIHdlIGNoZWNrIGhlcmUgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCB3YWl0aW5nIGZvciBhbiBldmVudFxuICAgICAgICAgICAgLy8gdGhhdCBoYXMgYWxyZWFkeSBoYXBwZW5lZC4gV2UgYmxvY2sgY2hlY2tpbmcgdGhlIGpvYiB1bnRpbCB0aGUgcXVldWUgZXZlbnRzIG9iamVjdCBpcyBhY3R1YWxseSBsaXN0ZW5pbmcgdG9cbiAgICAgICAgICAgIC8vIFJlZGlzIHNvIHRoZXJlJ3Mgbm8gY2hhbmNlIHRoYXQgaXQgd2lsbCBtaXNzIGV2ZW50cy5cbiAgICAgICAgICAgIGF3YWl0IHF1ZXVlRXZlbnRzLndhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgICAgICBjb25zdCBbc3RhdHVzLCByZXN1bHRdID0gKGF3YWl0IHRoaXMuc2NyaXB0cy5pc0ZpbmlzaGVkKGpvYklkLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25zdCBmaW5pc2hlZCA9IHN0YXR1cyAhPSAwO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAtMSB8fCBzdGF0dXMgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkZhaWxlZCh7IGZhaWxlZFJlYXNvbjogcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZWQoeyByZXR1cm52YWx1ZTogZ2V0UmV0dXJuVmFsdWUocmVzdWx0KSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgam9iIHRvIHRoZSBkZWxheSBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGltZXN0YW1wIHdoZW4gdGhlIGpvYiBzaG91bGQgYmUgbW92ZWQgYmFjayB0byBcIndhaXRcIlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIHRva2VuIHRvIGNoZWNrIGpvYiBpcyBsb2NrZWQgYnkgY3VycmVudCB3b3JrZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb0RlbGF5ZWQodGltZXN0YW1wLCB0b2tlbikge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBkZWxheSA9IHRpbWVzdGFtcCAtIG5vdztcbiAgICAgICAgY29uc3QgZmluYWxEZWxheSA9IGRlbGF5ID4gMCA/IGRlbGF5IDogMDtcbiAgICAgICAgY29uc3QgbW92ZWRUb0RlbGF5ZWQgPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvRGVsYXllZCh0aGlzLmlkLCBub3csIGZpbmFsRGVsYXksIHRva2VuLCB7IHNraXBBdHRlbXB0OiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZmluYWxEZWxheTtcbiAgICAgICAgcmV0dXJuIG1vdmVkVG9EZWxheWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgam9iIHRvIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRva2VuIHRvIGNoZWNrIGpvYiBpcyBsb2NrZWQgYnkgY3VycmVudCB3b3JrZXJcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zIGJhZyBmb3IgbW92aW5nIGEgam9iIHRvIHdhaXRpbmctY2hpbGRyZW4uXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgam9iIHdhcyBtb3ZlZFxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVUb1dhaXRpbmdDaGlsZHJlbih0b2tlbiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vdmVkVG9XYWl0aW5nQ2hpbGRyZW4gPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvV2FpdGluZ0NoaWxkcmVuKHRoaXMuaWQsIHRva2VuLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkVG9XYWl0aW5nQ2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb21vdGVzIGEgZGVsYXllZCBqb2Igc28gdGhhdCBpdCBzdGFydHMgdG8gYmUgcHJvY2Vzc2VkIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgICovXG4gICAgYXN5bmMgcHJvbW90ZSgpIHtcbiAgICAgICAgY29uc3Qgam9iSWQgPSB0aGlzLmlkO1xuICAgICAgICBhd2FpdCB0aGlzLnNjcmlwdHMucHJvbW90ZShqb2JJZCk7XG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byByZXRyeSB0aGUgam9iLiBPbmx5IGEgam9iIHRoYXQgaGFzIGZhaWxlZCBvciBjb21wbGV0ZWQgY2FuIGJlIHJldHJpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBjb21wbGV0ZWQgLyBmYWlsZWRcbiAgICAgKiBAcmV0dXJucyBJZiByZXNvbHZlZCBhbmQgcmV0dXJuIGNvZGUgaXMgMSwgdGhlbiB0aGUgcXVldWUgZW1pdHMgYSB3YWl0aW5nIGV2ZW50XG4gICAgICogb3RoZXJ3aXNlIHRoZSBvcGVyYXRpb24gd2FzIG5vdCBhIHN1Y2Nlc3MgYW5kIHRocm93IHRoZSBjb3JyZXNwb25kaW5nIGVycm9yLiBJZiB0aGUgcHJvbWlzZVxuICAgICAqIHJlamVjdHMsIGl0IGluZGljYXRlcyB0aGF0IHRoZSBzY3JpcHQgZmFpbGVkIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICByZXRyeShzdGF0ZSA9ICdmYWlsZWQnKSB7XG4gICAgICAgIHRoaXMuZmFpbGVkUmVhc29uID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5pc2hlZE9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRPbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0dXJudmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLnJlcHJvY2Vzc0pvYih0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgam9iIHRvIG5vdCBiZSByZXRyaWVkIGlmIGl0IGZhaWxzIChldmVuIGlmIGF0dGVtcHRzIGhhcyBiZWVuIGNvbmZpZ3VyZWQpXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIFVucmVjb3ZlcmFibGVFcnJvclxuICAgICAqL1xuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgaXNJblpTZXQoc2V0KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBzY29yZSA9IGF3YWl0IGNsaWVudC56c2NvcmUodGhpcy5xdWV1ZS50b0tleShzZXQpLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIHNjb3JlICE9PSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBpc0luTGlzdChsaXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdHMuaXNKb2JJbkxpc3QodGhpcy5xdWV1ZS50b0tleShsaXN0KSwgdGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGpvYiB0byBSZWRpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGllbnQgLVxuICAgICAqIEBwYXJhbSBwYXJlbnRPcHRzIC1cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFkZEpvYihjbGllbnQsIHBhcmVudE9wdHMpIHtcbiAgICAgICAgY29uc3Qgam9iRGF0YSA9IHRoaXMuYXNKU09OKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVPcHRpb25zKGpvYkRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLmFkZEpvYihjbGllbnQsIGpvYkRhdGEsIGpvYkRhdGEub3B0cywgdGhpcy5pZCwgcGFyZW50T3B0cyk7XG4gICAgfVxuICAgIHZhbGlkYXRlT3B0aW9ucyhqb2JEYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU9wdGlvbnMgPSBbXG4gICAgICAgICAgICAncmVtb3ZlRGVwZW5kZW5jeU9uRmFpbHVyZScsXG4gICAgICAgICAgICAnZmFpbFBhcmVudE9uRmFpbHVyZScsXG4gICAgICAgICAgICAnY29udGludWVQYXJlbnRPbkZhaWx1cmUnLFxuICAgICAgICAgICAgJ2lnbm9yZURlcGVuZGVuY3lPbkZhaWx1cmUnLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBleGNlZWRMaW1pdCA9IHRoaXMub3B0cy5zaXplTGltaXQgJiZcbiAgICAgICAgICAgIGxlbmd0aEluVXRmOEJ5dGVzKGpvYkRhdGEuZGF0YSkgPiB0aGlzLm9wdHMuc2l6ZUxpbWl0O1xuICAgICAgICBpZiAoZXhjZWVkTGltaXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNpemUgb2Ygam9iICR7dGhpcy5uYW1lfSBleGNlZWRzIHRoZSBsaW1pdCAke3RoaXMub3B0cy5zaXplTGltaXR9IGJ5dGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5kZWxheSAmJiB0aGlzLm9wdHMucmVwZWF0ICYmICEoKF9hID0gdGhpcy5vcHRzLnJlcGVhdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWxheSBhbmQgcmVwZWF0IG9wdGlvbnMgY291bGQgbm90IGJlIHVzZWQgdG9nZXRoZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmFibGVkRXhjbHVzaXZlT3B0aW9ucyA9IGV4Y2x1c2l2ZU9wdGlvbnMuZmlsdGVyKG9wdCA9PiB0aGlzLm9wdHNbb3B0XSk7XG4gICAgICAgIGlmIChlbmFibGVkRXhjbHVzaXZlT3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zTGlzdCA9IGVuYWJsZWRFeGNsdXNpdmVPcHRpb25zLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlcjogJHtvcHRpb25zTGlzdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuam9iSWQpIHtcbiAgICAgICAgICAgIGlmIChgJHtwYXJzZUludCh0aGlzLm9wdHMuam9iSWQsIDEwKX1gID09PSAoKF9jID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muam9iSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXN0b20gSWQgY2Fubm90IGJlIGludGVnZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoaXMgY2hlY2sgaW4gbmV4dCBicmVha2luZyBjaGVjayB3aXRoIGluY2x1ZGUoJzonKVxuICAgICAgICAgICAgLy8gQnkgdXNpbmcgc3BsaXQgd2UgYXJlIHN0aWxsIGtlZXBpbmcgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCByZXBlYXRhYmxlIGpvYnNcbiAgICAgICAgICAgIGlmICgoKF9kID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quam9iSWQuaW5jbHVkZXMoJzonKSkgJiZcbiAgICAgICAgICAgICAgICAoKF9mID0gKF9lID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuam9iSWQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zcGxpdCgnOicpLmxlbmd0aCkgIT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBJZCBjYW5ub3QgY29udGFpbiA6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmlvcml0eSkge1xuICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmModGhpcy5vcHRzLnByaW9yaXR5KSAhPT0gdGhpcy5vcHRzLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmlvcml0eSBzaG91bGQgbm90IGJlIGZsb2F0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnByaW9yaXR5ID4gUFJJT1JJVFlfTElNSVQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByaW9yaXR5IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7UFJJT1JJVFlfTElNSVR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5kZWR1cGxpY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAoISgoX2cgPSB0aGlzLm9wdHMuZGVkdXBsaWNhdGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVkdXBsaWNhdGlvbiBpZCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHY2XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGVib3VuY2UpIHtcbiAgICAgICAgICAgIGlmICghKChfaCA9IHRoaXMub3B0cy5kZWJvdW5jZSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVib3VuY2UgaWQgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmJhY2tvZmYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRzLmJhY2tvZmYuaml0dGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5iYWNrb2ZmLmppdHRlciA8IDAgfHwgdGhpcy5vcHRzLmJhY2tvZmYuaml0dGVyID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSml0dGVyIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGFja3RyYWNlKGVycikge1xuICAgICAgICB0aGlzLnN0YWNrdHJhY2UgPSB0aGlzLnN0YWNrdHJhY2UgfHwgW107XG4gICAgICAgIGlmIChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2t0cmFjZS5wdXNoKGVyci5zdGFjayk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnN0YWNrVHJhY2VMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRzLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IHRoaXMuc3RhY2t0cmFjZS5zbGljZSgtdGhpcy5vcHRzLnN0YWNrVHJhY2VMaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUcmFjZXMoc3RhY2t0cmFjZSkge1xuICAgIGlmICghc3RhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHRyYWNlcyA9IHRyeUNhdGNoKEpTT04ucGFyc2UsIEpTT04sIFtzdGFja3RyYWNlXSk7XG4gICAgaWYgKHRyYWNlcyA9PT0gZXJyb3JPYmplY3QgfHwgISh0cmFjZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlcztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZXR1cm5WYWx1ZShfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRyeUNhdGNoKEpTT04ucGFyc2UsIEpTT04sIFtfdmFsdWVdKTtcbiAgICBpZiAodmFsdWUgIT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlcignY29ycnVwdGVkIHJldHVybnZhbHVlOiAnICsgX3ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-base.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueBase: () => (/* binding */ QueueBase)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _utils_create_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/create-scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/create-scripts.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queue-keys */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\");\n\n\n\n\n\n\n/**\n * Base class for all classes that need to interact with queues.\n * This class is normally not used directly, but extended by the other classes.\n *\n */\nclass QueueBase extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    /**\n     *\n     * @param name - The name of the queue.\n     * @param opts - Options for the queue.\n     * @param Connection - An optional \"Connection\" class used to instantiate a Connection. This is useful for\n     * testing with mockups and/or extending the Connection class and passing an alternate implementation.\n     */\n    constructor(name, opts = { connection: {} }, Connection = _redis_connection__WEBPACK_IMPORTED_MODULE_3__.RedisConnection, hasBlockingConnection = false) {\n        super();\n        this.name = name;\n        this.opts = opts;\n        this.closed = false;\n        this.hasBlockingConnection = false;\n        this.hasBlockingConnection = hasBlockingConnection;\n        this.opts = Object.assign({ prefix: 'bull' }, opts);\n        if (!name) {\n            throw new Error('Queue name must be provided');\n        }\n        if (name.includes(':')) {\n            throw new Error('Queue name cannot contain :');\n        }\n        this.connection = new Connection(opts.connection, {\n            shared: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isRedisInstance)(opts.connection),\n            blocking: hasBlockingConnection,\n            skipVersionCheck: opts.skipVersionCheck,\n            skipWaitingForReady: opts.skipWaitingForReady,\n        });\n        this.connection.on('error', (error) => this.emit('error', error));\n        this.connection.on('close', () => {\n            if (!this.closing) {\n                this.emit('ioredis:close');\n            }\n        });\n        const queueKeys = new _queue_keys__WEBPACK_IMPORTED_MODULE_5__.QueueKeys(opts.prefix);\n        this.qualifiedName = queueKeys.getQueueQualifiedName(name);\n        this.keys = queueKeys.getKeys(name);\n        this.toKey = (type) => queueKeys.toKey(name, type);\n        this.createScripts();\n    }\n    /**\n     * Returns a promise that resolves to a redis client. Normally used only by subclasses.\n     */\n    get client() {\n        return this.connection.client;\n    }\n    createScripts() {\n        this.scripts = (0,_utils_create_scripts__WEBPACK_IMPORTED_MODULE_2__.createScripts)(this);\n    }\n    /**\n     * Returns the version of the Redis instance the client is connected to,\n     */\n    get redisVersion() {\n        return this.connection.redisVersion;\n    }\n    /**\n     * Helper to easily extend Job class calls.\n     */\n    get Job() {\n        return _job__WEBPACK_IMPORTED_MODULE_4__.Job;\n    }\n    /**\n     * Emits an event. Normally used by subclasses to emit events.\n     *\n     * @param event - The emitted event.\n     * @param args -\n     * @returns\n     */\n    emit(event, ...args) {\n        try {\n            return super.emit(event, ...args);\n        }\n        catch (err) {\n            try {\n                return super.emit('error', err);\n            }\n            catch (err) {\n                // We give up if the error event also throws an exception.\n                console.error(err);\n                return false;\n            }\n        }\n    }\n    waitUntilReady() {\n        return this.client;\n    }\n    base64Name() {\n        return Buffer.from(this.name).toString('base64');\n    }\n    clientName(suffix = '') {\n        const queueNameBase64 = this.base64Name();\n        return `${this.opts.prefix}:${queueNameBase64}${suffix}`;\n    }\n    /**\n     *\n     * Closes the connection and returns a promise that resolves when the connection is closed.\n     */\n    async close() {\n        if (!this.closing) {\n            this.closing = this.connection.close();\n        }\n        await this.closing;\n        this.closed = true;\n    }\n    /**\n     *\n     * Force disconnects a connection.\n     */\n    disconnect() {\n        return this.connection.disconnect();\n    }\n    async checkConnectionError(fn, delayInMs = _utils__WEBPACK_IMPORTED_MODULE_1__.DELAY_TIME_5) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.isNotConnectionError)(error)) {\n                this.emit('error', error);\n            }\n            if (!this.closing && delayInMs) {\n                await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.delay)(delayInMs);\n            }\n            else {\n                return;\n            }\n        }\n    }\n    /**\n     * Wraps the code with telemetry and provides a span for configuration.\n     *\n     * @param spanKind - kind of the span: Producer, Consumer, Internal\n     * @param operation - operation name (such as add, process, etc)\n     * @param destination - destination name (normally the queue name)\n     * @param callback - code to wrap with telemetry\n     * @param srcPropagationMedatada -\n     * @returns\n     */\n    trace(spanKind, operation, destination, callback, srcPropagationMetadata) {\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.trace)(this.opts.telemetry, spanKind, this.name, operation, destination, callback, srcPropagationMetadata);\n    }\n}\n//# sourceMappingURL=queue-base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUN3RDtBQUN0QztBQUNIO0FBQ3pCO0FBQ2E7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QixnREFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsZUFBZSw4REFBZTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixrREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCLEdBQUcsZ0JBQWdCLEVBQUUsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnREFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFLO0FBQ3BCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtYmFzZS5qcz8wNjc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBkZWxheSwgREVMQVlfVElNRV81LCBpc05vdENvbm5lY3Rpb25FcnJvciwgaXNSZWRpc0luc3RhbmNlLCB0cmFjZSwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVTY3JpcHRzIH0gZnJvbSAnLi4vdXRpbHMvY3JlYXRlLXNjcmlwdHMnO1xuaW1wb3J0IHsgUmVkaXNDb25uZWN0aW9uIH0gZnJvbSAnLi9yZWRpcy1jb25uZWN0aW9uJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IFF1ZXVlS2V5cyB9IGZyb20gJy4vcXVldWUta2V5cyc7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBjbGFzc2VzIHRoYXQgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHF1ZXVlcy5cbiAqIFRoaXMgY2xhc3MgaXMgbm9ybWFsbHkgbm90IHVzZWQgZGlyZWN0bHksIGJ1dCBleHRlbmRlZCBieSB0aGUgb3RoZXIgY2xhc3Nlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWV1ZUJhc2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGZvciB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIENvbm5lY3Rpb24gLSBBbiBvcHRpb25hbCBcIkNvbm5lY3Rpb25cIiBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGEgQ29ubmVjdGlvbi4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAgICogdGVzdGluZyB3aXRoIG1vY2t1cHMgYW5kL29yIGV4dGVuZGluZyB0aGUgQ29ubmVjdGlvbiBjbGFzcyBhbmQgcGFzc2luZyBhbiBhbHRlcm5hdGUgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0cyA9IHsgY29ubmVjdGlvbjoge30gfSwgQ29ubmVjdGlvbiA9IFJlZGlzQ29ubmVjdGlvbiwgaGFzQmxvY2tpbmdDb25uZWN0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNCbG9ja2luZ0Nvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNCbG9ja2luZ0Nvbm5lY3Rpb24gPSBoYXNCbG9ja2luZ0Nvbm5lY3Rpb247XG4gICAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oeyBwcmVmaXg6ICdidWxsJyB9LCBvcHRzKTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXVlIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVldWUgbmFtZSBjYW5ub3QgY29udGFpbiA6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24ob3B0cy5jb25uZWN0aW9uLCB7XG4gICAgICAgICAgICBzaGFyZWQ6IGlzUmVkaXNJbnN0YW5jZShvcHRzLmNvbm5lY3Rpb24pLFxuICAgICAgICAgICAgYmxvY2tpbmc6IGhhc0Jsb2NraW5nQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHNraXBWZXJzaW9uQ2hlY2s6IG9wdHMuc2tpcFZlcnNpb25DaGVjayxcbiAgICAgICAgICAgIHNraXBXYWl0aW5nRm9yUmVhZHk6IG9wdHMuc2tpcFdhaXRpbmdGb3JSZWFkeSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignZXJyb3InLCAoZXJyb3IpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcikpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2lvcmVkaXM6Y2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IG5ldyBRdWV1ZUtleXMob3B0cy5wcmVmaXgpO1xuICAgICAgICB0aGlzLnF1YWxpZmllZE5hbWUgPSBxdWV1ZUtleXMuZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLmtleXMgPSBxdWV1ZUtleXMuZ2V0S2V5cyhuYW1lKTtcbiAgICAgICAgdGhpcy50b0tleSA9ICh0eXBlKSA9PiBxdWV1ZUtleXMudG9LZXkobmFtZSwgdHlwZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlU2NyaXB0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgcmVkaXMgY2xpZW50LiBOb3JtYWxseSB1c2VkIG9ubHkgYnkgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmNsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlU2NyaXB0cygpIHtcbiAgICAgICAgdGhpcy5zY3JpcHRzID0gY3JlYXRlU2NyaXB0cyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgUmVkaXMgaW5zdGFuY2UgdGhlIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8sXG4gICAgICovXG4gICAgZ2V0IHJlZGlzVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5yZWRpc1ZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBlYXNpbHkgZXh0ZW5kIEpvYiBjbGFzcyBjYWxscy5cbiAgICAgKi9cbiAgICBnZXQgSm9iKCkge1xuICAgICAgICByZXR1cm4gSm9iO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC4gTm9ybWFsbHkgdXNlZCBieSBzdWJjbGFzc2VzIHRvIGVtaXQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGVtaXR0ZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIGFyZ3MgLVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnaXZlIHVwIGlmIHRoZSBlcnJvciBldmVudCBhbHNvIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3YWl0VW50aWxSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50O1xuICAgIH1cbiAgICBiYXNlNjROYW1lKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5uYW1lKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGNsaWVudE5hbWUoc3VmZml4ID0gJycpIHtcbiAgICAgICAgY29uc3QgcXVldWVOYW1lQmFzZTY0ID0gdGhpcy5iYXNlNjROYW1lKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdHMucHJlZml4fToke3F1ZXVlTmFtZUJhc2U2NH0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2luZztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvcmNlIGRpc2Nvbm5lY3RzIGEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tDb25uZWN0aW9uRXJyb3IoZm4sIGRlbGF5SW5NcyA9IERFTEFZX1RJTUVfNSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RDb25uZWN0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nICYmIGRlbGF5SW5Ncykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcHMgdGhlIGNvZGUgd2l0aCB0ZWxlbWV0cnkgYW5kIHByb3ZpZGVzIGEgc3BhbiBmb3IgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGFuS2luZCAtIGtpbmQgb2YgdGhlIHNwYW46IFByb2R1Y2VyLCBDb25zdW1lciwgSW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG5hbWUgKHN1Y2ggYXMgYWRkLCBwcm9jZXNzLCBldGMpXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIC0gZGVzdGluYXRpb24gbmFtZSAobm9ybWFsbHkgdGhlIHF1ZXVlIG5hbWUpXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gY29kZSB0byB3cmFwIHdpdGggdGVsZW1ldHJ5XG4gICAgICogQHBhcmFtIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEgLVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgdHJhY2Uoc3BhbktpbmQsIG9wZXJhdGlvbiwgZGVzdGluYXRpb24sIGNhbGxiYWNrLCBzcmNQcm9wYWdhdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiB0cmFjZSh0aGlzLm9wdHMudGVsZW1ldHJ5LCBzcGFuS2luZCwgdGhpcy5uYW1lLCBvcGVyYXRpb24sIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgc3JjUHJvcGFnYXRpb25NZXRhZGF0YSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUtYmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events-producer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-events-producer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueEventsProducer: () => (/* binding */ QueueEventsProducer)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n\n\n/**\n * The QueueEventsProducer class is used for publishing custom events.\n */\nclass QueueEventsProducer extends _queue_base__WEBPACK_IMPORTED_MODULE_0__.QueueBase {\n    constructor(name, opts = {\n        connection: {},\n    }, Connection) {\n        super(name, Object.assign({ blockingConnection: false }, opts), Connection);\n        this.opts = opts;\n    }\n    /**\n     * Publish custom event to be processed in QueueEvents.\n     * @param argsObj - Event payload\n     * @param maxEvents - Max quantity of events to be saved\n     */\n    async publishEvent(argsObj, maxEvents = 1000) {\n        const client = await this.client;\n        const key = this.keys.events;\n        const { eventName } = argsObj, restArgs = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(argsObj, [\"eventName\"]);\n        const args = ['MAXLEN', '~', maxEvents, '*', 'event', eventName];\n        for (const [key, value] of Object.entries(restArgs)) {\n            args.push(key, value);\n        }\n        await client.xadd(key, ...args);\n    }\n    /**\n     * Closes the connection and returns a promise that resolves when the connection is closed.\n     */\n    async close() {\n        if (!this.closing) {\n            this.closing = this.connection.close();\n        }\n        await this.closing;\n    }\n}\n//# sourceMappingURL=queue-events-producer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtZXZlbnRzLXByb2R1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxrREFBUztBQUNsRDtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0wsb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLHNCQUFzQiw2Q0FBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9xdWV1ZS1ldmVudHMtcHJvZHVjZXIuanM/OWZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFF1ZXVlQmFzZSB9IGZyb20gJy4vcXVldWUtYmFzZSc7XG4vKipcbiAqIFRoZSBRdWV1ZUV2ZW50c1Byb2R1Y2VyIGNsYXNzIGlzIHVzZWQgZm9yIHB1Ymxpc2hpbmcgY3VzdG9tIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFF1ZXVlRXZlbnRzUHJvZHVjZXIgZXh0ZW5kcyBRdWV1ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdHMgPSB7XG4gICAgICAgIGNvbm5lY3Rpb246IHt9LFxuICAgIH0sIENvbm5lY3Rpb24pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgT2JqZWN0LmFzc2lnbih7IGJsb2NraW5nQ29ubmVjdGlvbjogZmFsc2UgfSwgb3B0cyksIENvbm5lY3Rpb24pO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGN1c3RvbSBldmVudCB0byBiZSBwcm9jZXNzZWQgaW4gUXVldWVFdmVudHMuXG4gICAgICogQHBhcmFtIGFyZ3NPYmogLSBFdmVudCBwYXlsb2FkXG4gICAgICogQHBhcmFtIG1heEV2ZW50cyAtIE1heCBxdWFudGl0eSBvZiBldmVudHMgdG8gYmUgc2F2ZWRcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoRXZlbnQoYXJnc09iaiwgbWF4RXZlbnRzID0gMTAwMCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlzLmV2ZW50cztcbiAgICAgICAgY29uc3QgeyBldmVudE5hbWUgfSA9IGFyZ3NPYmosIHJlc3RBcmdzID0gX19yZXN0KGFyZ3NPYmosIFtcImV2ZW50TmFtZVwiXSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbJ01BWExFTicsICd+JywgbWF4RXZlbnRzLCAnKicsICdldmVudCcsIGV2ZW50TmFtZV07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3RBcmdzKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNsaWVudC54YWRkKGtleSwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2luZztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS1ldmVudHMtcHJvZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events-producer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-events.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueEvents: () => (/* binding */ QueueEvents)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n\n\n\n/**\n * The QueueEvents class is used for listening to the global events\n * emitted by a given queue.\n *\n * This class requires a dedicated redis connection.\n *\n */\nclass QueueEvents extends _queue_base__WEBPACK_IMPORTED_MODULE_1__.QueueBase {\n    constructor(name, _a = {\n        connection: {},\n    }, Connection) {\n        var { connection, autorun = true } = _a, opts = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(_a, [\"connection\", \"autorun\"]);\n        super(name, Object.assign(Object.assign({}, opts), { connection: (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isRedisInstance)(connection)\n                ? connection.duplicate()\n                : connection }), Connection, true);\n        this.running = false;\n        this.opts = Object.assign({\n            blockingTimeout: 10000,\n        }, this.opts);\n        if (autorun) {\n            this.run().catch(error => this.emit('error', error));\n        }\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Manually starts running the event consumming loop. This shall be used if you do not\n     * use the default \"autorun\" option on the constructor.\n     */\n    async run() {\n        if (!this.running) {\n            try {\n                this.running = true;\n                const client = await this.client;\n                // TODO: Planed for deprecation as it has no really a use case\n                try {\n                    await client.client('SETNAME', this.clientName(_utils__WEBPACK_IMPORTED_MODULE_0__.QUEUE_EVENT_SUFFIX));\n                }\n                catch (err) {\n                    if (!_utils__WEBPACK_IMPORTED_MODULE_0__.clientCommandMessageReg.test(err.message)) {\n                        throw err;\n                    }\n                }\n                await this.consumeEvents(client);\n            }\n            catch (error) {\n                this.running = false;\n                throw error;\n            }\n        }\n        else {\n            throw new Error('Queue Events is already running.');\n        }\n    }\n    async consumeEvents(client) {\n        const opts = this.opts;\n        const key = this.keys.events;\n        let id = opts.lastEventId || '$';\n        while (!this.closing) {\n            // Cast to actual return type, see: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44301\n            const data = await this.checkConnectionError(() => client.xread('BLOCK', opts.blockingTimeout, 'STREAMS', key, id));\n            if (data) {\n                const stream = data[0];\n                const events = stream[1];\n                for (let i = 0; i < events.length; i++) {\n                    id = events[i][0];\n                    const args = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.array2obj)(events[i][1]);\n                    //\n                    // TODO: we may need to have a separate xtream for progress data\n                    // to avoid this hack.\n                    switch (args.event) {\n                        case 'progress':\n                            args.data = JSON.parse(args.data);\n                            break;\n                        case 'completed':\n                            args.returnvalue = JSON.parse(args.returnvalue);\n                            break;\n                    }\n                    const { event } = args, restArgs = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__rest)(args, [\"event\"]);\n                    if (event === 'drained') {\n                        this.emit(event, id);\n                    }\n                    else {\n                        this.emit(event, restArgs, id);\n                        if (restArgs.jobId) {\n                            this.emit(`${event}:${restArgs.jobId}`, restArgs, id);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Stops consuming events and close the underlying Redis connection if necessary.\n     *\n     * @returns\n     */\n    close() {\n        if (!this.closing) {\n            this.closing = this.disconnect();\n        }\n        return this.closing;\n    }\n}\n//# sourceMappingURL=queue-events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDcUU7QUFDM0Q7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsa0RBQVM7QUFDMUM7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMLGNBQWMsNkJBQTZCLGFBQWEsNkNBQU07QUFDOUQsa0RBQWtELFdBQVcsWUFBWSx1REFBZTtBQUN4RjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNEQUFrQjtBQUNyRjtBQUNBO0FBQ0EseUJBQXlCLDJEQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0EsaUNBQWlDLGlEQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxtQkFBbUIsNkNBQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU0sR0FBRyxlQUFlO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy9xdWV1ZS1ldmVudHMuanM/Y2JkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGFycmF5Mm9iaiwgY2xpZW50Q29tbWFuZE1lc3NhZ2VSZWcsIGlzUmVkaXNJbnN0YW5jZSwgUVVFVUVfRVZFTlRfU1VGRklYLCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFF1ZXVlQmFzZSB9IGZyb20gJy4vcXVldWUtYmFzZSc7XG4vKipcbiAqIFRoZSBRdWV1ZUV2ZW50cyBjbGFzcyBpcyB1c2VkIGZvciBsaXN0ZW5pbmcgdG8gdGhlIGdsb2JhbCBldmVudHNcbiAqIGVtaXR0ZWQgYnkgYSBnaXZlbiBxdWV1ZS5cbiAqXG4gKiBUaGlzIGNsYXNzIHJlcXVpcmVzIGEgZGVkaWNhdGVkIHJlZGlzIGNvbm5lY3Rpb24uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUXVldWVFdmVudHMgZXh0ZW5kcyBRdWV1ZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIF9hID0ge1xuICAgICAgICBjb25uZWN0aW9uOiB7fSxcbiAgICB9LCBDb25uZWN0aW9uKSB7XG4gICAgICAgIHZhciB7IGNvbm5lY3Rpb24sIGF1dG9ydW4gPSB0cnVlIH0gPSBfYSwgb3B0cyA9IF9fcmVzdChfYSwgW1wiY29ubmVjdGlvblwiLCBcImF1dG9ydW5cIl0pO1xuICAgICAgICBzdXBlcihuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IGNvbm5lY3Rpb246IGlzUmVkaXNJbnN0YW5jZShjb25uZWN0aW9uKVxuICAgICAgICAgICAgICAgID8gY29ubmVjdGlvbi5kdXBsaWNhdGUoKVxuICAgICAgICAgICAgICAgIDogY29ubmVjdGlvbiB9KSwgQ29ubmVjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGJsb2NraW5nVGltZW91dDogMTAwMDAsXG4gICAgICAgIH0sIHRoaXMub3B0cyk7XG4gICAgICAgIGlmIChhdXRvcnVuKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigpLmNhdGNoKGVycm9yID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHN0YXJ0cyBydW5uaW5nIHRoZSBldmVudCBjb25zdW1taW5nIGxvb3AuIFRoaXMgc2hhbGwgYmUgdXNlZCBpZiB5b3UgZG8gbm90XG4gICAgICogdXNlIHRoZSBkZWZhdWx0IFwiYXV0b3J1blwiIG9wdGlvbiBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFBsYW5lZCBmb3IgZGVwcmVjYXRpb24gYXMgaXQgaGFzIG5vIHJlYWxseSBhIHVzZSBjYXNlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsaWVudCgnU0VUTkFNRScsIHRoaXMuY2xpZW50TmFtZShRVUVVRV9FVkVOVF9TVUZGSVgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaWVudENvbW1hbmRNZXNzYWdlUmVnLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25zdW1lRXZlbnRzKGNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVldWUgRXZlbnRzIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjb25zdW1lRXZlbnRzKGNsaWVudCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleXMuZXZlbnRzO1xuICAgICAgICBsZXQgaWQgPSBvcHRzLmxhc3RFdmVudElkIHx8ICckJztcbiAgICAgICAgd2hpbGUgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIC8vIENhc3QgdG8gYWN0dWFsIHJldHVybiB0eXBlLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2lzc3Vlcy80NDMwMVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2hlY2tDb25uZWN0aW9uRXJyb3IoKCkgPT4gY2xpZW50LnhyZWFkKCdCTE9DSycsIG9wdHMuYmxvY2tpbmdUaW1lb3V0LCAnU1RSRUFNUycsIGtleSwgaWQpKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBzdHJlYW1bMV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBldmVudHNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhcnJheTJvYmooZXZlbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2UgbWF5IG5lZWQgdG8gaGF2ZSBhIHNlcGFyYXRlIHh0cmVhbSBmb3IgcHJvZ3Jlc3MgZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0aGlzIGhhY2suXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJncy5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvZ3Jlc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuZGF0YSA9IEpTT04ucGFyc2UoYXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5yZXR1cm52YWx1ZSA9IEpTT04ucGFyc2UoYXJncy5yZXR1cm52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBldmVudCB9ID0gYXJncywgcmVzdEFyZ3MgPSBfX3Jlc3QoYXJncywgW1wiZXZlbnRcIl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdkcmFpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIHJlc3RBcmdzLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdEFyZ3Muam9iSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoYCR7ZXZlbnR9OiR7cmVzdEFyZ3Muam9iSWR9YCwgcmVzdEFyZ3MsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBjb25zdW1pbmcgZXZlbnRzIGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBSZWRpcyBjb25uZWN0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NpbmcgPSB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zaW5nO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-getters.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueGetters: () => (/* binding */ QueueGetters)\n/* harmony export */ });\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/*eslint-env node */\n\n\n\n/**\n * Provides different getters for different aspects of a queue.\n */\nclass QueueGetters extends _queue_base__WEBPACK_IMPORTED_MODULE_0__.QueueBase {\n    getJob(jobId) {\n        return this.Job.fromId(this, jobId);\n    }\n    commandByType(types, count, callback) {\n        return types.map((type) => {\n            type = type === 'waiting' ? 'wait' : type; // alias\n            const key = this.toKey(type);\n            switch (type) {\n                case 'completed':\n                case 'failed':\n                case 'delayed':\n                case 'prioritized':\n                case 'repeat':\n                case 'waiting-children':\n                    return callback(key, count ? 'zcard' : 'zrange');\n                case 'active':\n                case 'wait':\n                case 'paused':\n                    return callback(key, count ? 'llen' : 'lrange');\n            }\n        });\n    }\n    sanitizeJobTypes(types) {\n        const currentTypes = typeof types === 'string' ? [types] : types;\n        if (Array.isArray(currentTypes) && currentTypes.length > 0) {\n            const sanitizedTypes = [...currentTypes];\n            if (sanitizedTypes.indexOf('waiting') !== -1) {\n                sanitizedTypes.push('paused');\n            }\n            return [...new Set(sanitizedTypes)];\n        }\n        return [\n            'active',\n            'completed',\n            'delayed',\n            'failed',\n            'paused',\n            'prioritized',\n            'waiting',\n            'waiting-children',\n        ];\n    }\n    /**\n      Returns the number of jobs waiting to be processed. This includes jobs that are\n      \"waiting\" or \"delayed\" or \"prioritized\" or \"waiting-children\".\n    */\n    async count() {\n        const count = await this.getJobCountByTypes('waiting', 'paused', 'delayed', 'prioritized', 'waiting-children');\n        return count;\n    }\n    /**\n     * Returns the time to live for a rate limited key in milliseconds.\n     * @param maxJobs - max jobs to be considered in rate limit state. If not passed\n     * it will return the remaining ttl without considering if max jobs is excedeed.\n     * @returns -2 if the key does not exist.\n     * -1 if the key exists but has no associated expire.\n     * @see {@link https://redis.io/commands/pttl/}\n     */\n    async getRateLimitTtl(maxJobs) {\n        return this.scripts.getRateLimitTtl(maxJobs);\n    }\n    /**\n     * Get jobId that starts debounced state.\n     * @deprecated use getDeduplicationJobId method\n     *\n     * @param id - debounce identifier\n     */\n    async getDebounceJobId(id) {\n        const client = await this.client;\n        return client.get(`${this.keys.de}:${id}`);\n    }\n    /**\n     * Get jobId from deduplicated state.\n     *\n     * @param id - deduplication identifier\n     */\n    async getDeduplicationJobId(id) {\n        const client = await this.client;\n        return client.get(`${this.keys.de}:${id}`);\n    }\n    /**\n     * Job counts by type\n     *\n     * Queue#getJobCountByTypes('completed') =\\> completed count\n     * Queue#getJobCountByTypes('completed,failed') =\\> completed + failed count\n     * Queue#getJobCountByTypes('completed', 'failed') =\\> completed + failed count\n     * Queue#getJobCountByTypes('completed', 'waiting', 'failed') =\\> completed + waiting + failed count\n     */\n    async getJobCountByTypes(...types) {\n        const result = await this.getJobCounts(...types);\n        return Object.values(result).reduce((sum, count) => sum + count, 0);\n    }\n    /**\n     * Returns the job counts for each type specified or every list/set in the queue by default.\n     *\n     * @returns An object, key (type) and value (count)\n     */\n    async getJobCounts(...types) {\n        const currentTypes = this.sanitizeJobTypes(types);\n        const responses = await this.scripts.getCounts(currentTypes);\n        const counts = {};\n        responses.forEach((res, index) => {\n            counts[currentTypes[index]] = res || 0;\n        });\n        return counts;\n    }\n    /**\n     * Get current job state.\n     *\n     * @param jobId - job identifier.\n     * @returns Returns one of these values:\n     * 'completed', 'failed', 'delayed', 'active', 'waiting', 'waiting-children', 'unknown'.\n     */\n    getJobState(jobId) {\n        return this.scripts.getState(jobId);\n    }\n    /**\n     * Returns the number of jobs in completed status.\n     */\n    getCompletedCount() {\n        return this.getJobCountByTypes('completed');\n    }\n    /**\n     * Returns the number of jobs in failed status.\n     */\n    getFailedCount() {\n        return this.getJobCountByTypes('failed');\n    }\n    /**\n     * Returns the number of jobs in delayed status.\n     */\n    getDelayedCount() {\n        return this.getJobCountByTypes('delayed');\n    }\n    /**\n     * Returns the number of jobs in active status.\n     */\n    getActiveCount() {\n        return this.getJobCountByTypes('active');\n    }\n    /**\n     * Returns the number of jobs in prioritized status.\n     */\n    getPrioritizedCount() {\n        return this.getJobCountByTypes('prioritized');\n    }\n    /**\n     * Returns the number of jobs per priority.\n     */\n    async getCountsPerPriority(priorities) {\n        const uniquePriorities = [...new Set(priorities)];\n        const responses = await this.scripts.getCountsPerPriority(uniquePriorities);\n        const counts = {};\n        responses.forEach((res, index) => {\n            counts[`${uniquePriorities[index]}`] = res || 0;\n        });\n        return counts;\n    }\n    /**\n     * Returns the number of jobs in waiting or paused statuses.\n     */\n    getWaitingCount() {\n        return this.getJobCountByTypes('waiting');\n    }\n    /**\n     * Returns the number of jobs in waiting-children status.\n     */\n    getWaitingChildrenCount() {\n        return this.getJobCountByTypes('waiting-children');\n    }\n    /**\n     * Returns the jobs that are in the \"waiting\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getWaiting(start = 0, end = -1) {\n        return this.getJobs(['waiting'], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"waiting-children\" status.\n     * I.E. parent jobs that have at least one child that has not completed yet.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getWaitingChildren(start = 0, end = -1) {\n        return this.getJobs(['waiting-children'], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"active\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getActive(start = 0, end = -1) {\n        return this.getJobs(['active'], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"delayed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getDelayed(start = 0, end = -1) {\n        return this.getJobs(['delayed'], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"prioritized\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getPrioritized(start = 0, end = -1) {\n        return this.getJobs(['prioritized'], start, end, true);\n    }\n    /**\n     * Returns the jobs that are in the \"completed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getCompleted(start = 0, end = -1) {\n        return this.getJobs(['completed'], start, end, false);\n    }\n    /**\n     * Returns the jobs that are in the \"failed\" status.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     */\n    getFailed(start = 0, end = -1) {\n        return this.getJobs(['failed'], start, end, false);\n    }\n    /**\n     * Returns the qualified job ids and the raw job data (if available) of the\n     * children jobs of the given parent job.\n     * It is possible to get either the already processed children, in this case\n     * an array of qualified job ids and their result values will be returned,\n     * or the pending children, in this case an array of qualified job ids will\n     * be returned.\n     * A qualified job id is a string representing the job id in a given queue,\n     * for example: \"bull:myqueue:jobid\".\n     *\n     * @param parentId - The id of the parent job\n     * @param type - \"processed\" | \"pending\"\n     * @param opts - Options for the query.\n     *\n     * @returns an object with the following shape:\n     * `{ items: { id: string, v?: any, err?: string } [], jobs: JobJsonRaw[], total: number}`\n     */\n    async getDependencies(parentId, type, start, end) {\n        const key = this.toKey(type == 'processed'\n            ? `${parentId}:processed`\n            : `${parentId}:dependencies`);\n        const { items, total, jobs } = await this.scripts.paginate(key, {\n            start,\n            end,\n            fetchJobs: true,\n        });\n        return {\n            items,\n            jobs,\n            total,\n        };\n    }\n    async getRanges(types, start = 0, end = 1, asc = false) {\n        const multiCommands = [];\n        this.commandByType(types, false, (key, command) => {\n            switch (command) {\n                case 'lrange':\n                    multiCommands.push('lrange');\n                    break;\n                case 'zrange':\n                    multiCommands.push('zrange');\n                    break;\n            }\n        });\n        const responses = await this.scripts.getRanges(types, start, end, asc);\n        let results = [];\n        responses.forEach((response, index) => {\n            const result = response || [];\n            if (asc && multiCommands[index] === 'lrange') {\n                results = results.concat(result.reverse());\n            }\n            else {\n                results = results.concat(result);\n            }\n        });\n        return [...new Set(results)];\n    }\n    /**\n     * Returns the jobs that are on the given statuses (note that JobType is synonym for job status)\n     * @param types - the statuses of the jobs to return.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     * @param asc - if true, the jobs will be returned in ascending order.\n     */\n    async getJobs(types, start = 0, end = -1, asc = false) {\n        const currentTypes = this.sanitizeJobTypes(types);\n        const jobIds = await this.getRanges(currentTypes, start, end, asc);\n        return Promise.all(jobIds.map(jobId => this.Job.fromId(this, jobId)));\n    }\n    /**\n     * Returns the logs for a given Job.\n     * @param jobId - the id of the job to get the logs for.\n     * @param start - zero based index from where to start returning jobs.\n     * @param end - zero based index where to stop returning jobs.\n     * @param asc - if true, the jobs will be returned in ascending order.\n     */\n    async getJobLogs(jobId, start = 0, end = -1, asc = true) {\n        const client = await this.client;\n        const multi = client.multi();\n        const logsKey = this.toKey(jobId + ':logs');\n        if (asc) {\n            multi.lrange(logsKey, start, end);\n        }\n        else {\n            multi.lrange(logsKey, -(end + 1), -(start + 1));\n        }\n        multi.llen(logsKey);\n        const result = (await multi.exec());\n        if (!asc) {\n            result[0][1].reverse();\n        }\n        return {\n            logs: result[0][1],\n            count: result[1][1],\n        };\n    }\n    async baseGetClients(matcher) {\n        const client = await this.client;\n        try {\n            const clients = (await client.client('LIST'));\n            const list = this.parseClientList(clients, matcher);\n            return list;\n        }\n        catch (err) {\n            if (!_utils__WEBPACK_IMPORTED_MODULE_1__.clientCommandMessageReg.test(err.message)) {\n                throw err;\n            }\n            return [{ name: 'GCP does not support client list' }];\n        }\n    }\n    /**\n     * Get the worker list related to the queue. i.e. all the known\n     * workers that are available to process jobs for this queue.\n     * Note: GCP does not support SETNAME, so this call will not work\n     *\n     * @returns - Returns an array with workers info.\n     */\n    getWorkers() {\n        const unnamedWorkerClientName = `${this.clientName()}`;\n        const namedWorkerClientName = `${this.clientName()}:w:`;\n        const matcher = (name) => name &&\n            (name === unnamedWorkerClientName ||\n                name.startsWith(namedWorkerClientName));\n        return this.baseGetClients(matcher);\n    }\n    /**\n     * Returns the current count of workers for the queue.\n     *\n     * getWorkersCount(): Promise<number>\n     *\n     */\n    async getWorkersCount() {\n        const workers = await this.getWorkers();\n        return workers.length;\n    }\n    /**\n     * Get queue events list related to the queue.\n     * Note: GCP does not support SETNAME, so this call will not work\n     *\n     * @deprecated do not use this method, it will be removed in the future.\n     *\n     * @returns - Returns an array with queue events info.\n     */\n    async getQueueEvents() {\n        const clientName = `${this.clientName()}${_utils__WEBPACK_IMPORTED_MODULE_1__.QUEUE_EVENT_SUFFIX}`;\n        return this.baseGetClients((name) => name === clientName);\n    }\n    /**\n     * Get queue metrics related to the queue.\n     *\n     * This method returns the gathered metrics for the queue.\n     * The metrics are represented as an array of job counts\n     * per unit of time (1 minute).\n     *\n     * @param start - Start point of the metrics, where 0\n     * is the newest point to be returned.\n     * @param end - End point of the metrics, where -1 is the\n     * oldest point to be returned.\n     *\n     * @returns - Returns an object with queue metrics.\n     */\n    async getMetrics(type, start = 0, end = -1) {\n        const [meta, data, count] = await this.scripts.getMetrics(type, start, end);\n        return {\n            meta: {\n                count: parseInt(meta[0] || '0', 10),\n                prevTS: parseInt(meta[1] || '0', 10),\n                prevCount: parseInt(meta[2] || '0', 10),\n            },\n            data: data.map(point => +point || 0),\n            count,\n        };\n    }\n    parseClientList(list, matcher) {\n        const lines = list.split(/\\r?\\n/);\n        const clients = [];\n        lines.forEach((line) => {\n            const client = {};\n            const keyValues = line.split(' ');\n            keyValues.forEach(function (keyValue) {\n                const index = keyValue.indexOf('=');\n                const key = keyValue.substring(0, index);\n                const value = keyValue.substring(index + 1);\n                client[key] = value;\n            });\n            const name = client['name'];\n            if (matcher(name)) {\n                client['name'] = this.name;\n                client['rawname'] = name;\n                clients.push(client);\n            }\n        });\n        return clients;\n    }\n    /**\n     * Export the metrics for the queue in the Prometheus format.\n     * Automatically exports all the counts returned by getJobCounts().\n     *\n     * @returns - Returns a string with the metrics in the Prometheus format.\n     *\n     * @see {@link https://prometheus.io/docs/instrumenting/exposition_formats/}\n     *\n     **/\n    async exportPrometheusMetrics(globalVariables) {\n        const counts = await this.getJobCounts();\n        const metrics = [];\n        // Match the test's expected HELP text\n        metrics.push('# HELP bullmq_job_count Number of jobs in the queue by state');\n        metrics.push('# TYPE bullmq_job_count gauge');\n        const variables = !globalVariables\n            ? ''\n            : Object.keys(globalVariables).reduce((acc, curr) => `${acc}, ${curr}=\"${globalVariables[curr]}\"`, '');\n        for (const [state, count] of Object.entries(counts)) {\n            metrics.push(`bullmq_job_count{queue=\"${this.name}\", state=\"${state}\"${variables}} ${count}`);\n        }\n        return metrics.join('\\n');\n    }\n}\n//# sourceMappingURL=queue-getters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUtZ2V0dGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNhO0FBQzRCO0FBQzhCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQixrREFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxHQUFHLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhLEdBQUcsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsb0NBQW9DLHNDQUFzQztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUIsU0FBUztBQUMxQixnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUF1QjtBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0QseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLEVBQUUsc0RBQWtCLENBQUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSSxJQUFJLEtBQUssSUFBSSxzQkFBc0I7QUFDM0c7QUFDQSwyQ0FBMkMsU0FBUyxVQUFVLFlBQVksTUFBTSxHQUFHLFlBQVksRUFBRSxNQUFNO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLWdldHRlcnMuanM/YjZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgUXVldWVCYXNlIH0gZnJvbSAnLi9xdWV1ZS1iYXNlJztcbmltcG9ydCB7IGNsaWVudENvbW1hbmRNZXNzYWdlUmVnLCBRVUVVRV9FVkVOVF9TVUZGSVggfSBmcm9tICcuLi91dGlscyc7XG4vKipcbiAqIFByb3ZpZGVzIGRpZmZlcmVudCBnZXR0ZXJzIGZvciBkaWZmZXJlbnQgYXNwZWN0cyBvZiBhIHF1ZXVlLlxuICovXG5leHBvcnQgY2xhc3MgUXVldWVHZXR0ZXJzIGV4dGVuZHMgUXVldWVCYXNlIHtcbiAgICBnZXRKb2Ioam9iSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuSm9iLmZyb21JZCh0aGlzLCBqb2JJZCk7XG4gICAgfVxuICAgIGNvbW1hbmRCeVR5cGUodHlwZXMsIGNvdW50LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdHlwZXMubWFwKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSA9PT0gJ3dhaXRpbmcnID8gJ3dhaXQnIDogdHlwZTsgLy8gYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMudG9LZXkodHlwZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsYXllZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAncHJpb3JpdGl6ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGVhdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FpdGluZy1jaGlsZHJlbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhrZXksIGNvdW50ID8gJ3pjYXJkJyA6ICd6cmFuZ2UnKTtcbiAgICAgICAgICAgICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3dhaXQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdXNlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhrZXksIGNvdW50ID8gJ2xsZW4nIDogJ2xyYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FuaXRpemVKb2JUeXBlcyh0eXBlcykge1xuICAgICAgICBjb25zdCBjdXJyZW50VHlwZXMgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gW3R5cGVzXSA6IHR5cGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHlwZXMpICYmIGN1cnJlbnRUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRUeXBlcyA9IFsuLi5jdXJyZW50VHlwZXNdO1xuICAgICAgICAgICAgaWYgKHNhbml0aXplZFR5cGVzLmluZGV4T2YoJ3dhaXRpbmcnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZWRUeXBlcy5wdXNoKCdwYXVzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbLi4ubmV3IFNldChzYW5pdGl6ZWRUeXBlcyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYWN0aXZlJyxcbiAgICAgICAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgJ2RlbGF5ZWQnLFxuICAgICAgICAgICAgJ2ZhaWxlZCcsXG4gICAgICAgICAgICAncGF1c2VkJyxcbiAgICAgICAgICAgICdwcmlvcml0aXplZCcsXG4gICAgICAgICAgICAnd2FpdGluZycsXG4gICAgICAgICAgICAnd2FpdGluZy1jaGlsZHJlbicsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGpvYnMgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIFRoaXMgaW5jbHVkZXMgam9icyB0aGF0IGFyZVxuICAgICAgXCJ3YWl0aW5nXCIgb3IgXCJkZWxheWVkXCIgb3IgXCJwcmlvcml0aXplZFwiIG9yIFwid2FpdGluZy1jaGlsZHJlblwiLlxuICAgICovXG4gICAgYXN5bmMgY291bnQoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXdhaXQgdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3dhaXRpbmcnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAncHJpb3JpdGl6ZWQnLCAnd2FpdGluZy1jaGlsZHJlbicpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRpbWUgdG8gbGl2ZSBmb3IgYSByYXRlIGxpbWl0ZWQga2V5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gbWF4Sm9icyAtIG1heCBqb2JzIHRvIGJlIGNvbnNpZGVyZWQgaW4gcmF0ZSBsaW1pdCBzdGF0ZS4gSWYgbm90IHBhc3NlZFxuICAgICAqIGl0IHdpbGwgcmV0dXJuIHRoZSByZW1haW5pbmcgdHRsIHdpdGhvdXQgY29uc2lkZXJpbmcgaWYgbWF4IGpvYnMgaXMgZXhjZWRlZWQuXG4gICAgICogQHJldHVybnMgLTIgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiAtMSBpZiB0aGUga2V5IGV4aXN0cyBidXQgaGFzIG5vIGFzc29jaWF0ZWQgZXhwaXJlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVkaXMuaW8vY29tbWFuZHMvcHR0bC99XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmF0ZUxpbWl0VHRsKG1heEpvYnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5nZXRSYXRlTGltaXRUdGwobWF4Sm9icyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBqb2JJZCB0aGF0IHN0YXJ0cyBkZWJvdW5jZWQgc3RhdGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGdldERlZHVwbGljYXRpb25Kb2JJZCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIGRlYm91bmNlIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWJvdW5jZUpvYklkKGlkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmdldChgJHt0aGlzLmtleXMuZGV9OiR7aWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBqb2JJZCBmcm9tIGRlZHVwbGljYXRlZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIGRlZHVwbGljYXRpb24gaWRlbnRpZmllclxuICAgICAqL1xuICAgIGFzeW5jIGdldERlZHVwbGljYXRpb25Kb2JJZChpZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXQoYCR7dGhpcy5rZXlzLmRlfToke2lkfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2IgY291bnRzIGJ5IHR5cGVcbiAgICAgKlxuICAgICAqIFF1ZXVlI2dldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJykgPVxcPiBjb21wbGV0ZWQgY291bnRcbiAgICAgKiBRdWV1ZSNnZXRKb2JDb3VudEJ5VHlwZXMoJ2NvbXBsZXRlZCxmYWlsZWQnKSA9XFw+IGNvbXBsZXRlZCArIGZhaWxlZCBjb3VudFxuICAgICAqIFF1ZXVlI2dldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJywgJ2ZhaWxlZCcpID1cXD4gY29tcGxldGVkICsgZmFpbGVkIGNvdW50XG4gICAgICogUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnLCAnd2FpdGluZycsICdmYWlsZWQnKSA9XFw+IGNvbXBsZXRlZCArIHdhaXRpbmcgKyBmYWlsZWQgY291bnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRKb2JDb3VudEJ5VHlwZXMoLi4udHlwZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRKb2JDb3VudHMoLi4udHlwZXMpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQpLnJlZHVjZSgoc3VtLCBjb3VudCkgPT4gc3VtICsgY291bnQsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqb2IgY291bnRzIGZvciBlYWNoIHR5cGUgc3BlY2lmaWVkIG9yIGV2ZXJ5IGxpc3Qvc2V0IGluIHRoZSBxdWV1ZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0LCBrZXkgKHR5cGUpIGFuZCB2YWx1ZSAoY291bnQpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Sm9iQ291bnRzKC4uLnR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlcyA9IHRoaXMuc2FuaXRpemVKb2JUeXBlcyh0eXBlcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMuc2NyaXB0cy5nZXRDb3VudHMoY3VycmVudFR5cGVzKTtcbiAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb3VudHNbY3VycmVudFR5cGVzW2luZGV4XV0gPSByZXMgfHwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGpvYiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqb2JJZCAtIGpvYiBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgb25lIG9mIHRoZXNlIHZhbHVlczpcbiAgICAgKiAnY29tcGxldGVkJywgJ2ZhaWxlZCcsICdkZWxheWVkJywgJ2FjdGl2ZScsICd3YWl0aW5nJywgJ3dhaXRpbmctY2hpbGRyZW4nLCAndW5rbm93bicuXG4gICAgICovXG4gICAgZ2V0Sm9iU3RhdGUoam9iSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5nZXRTdGF0ZShqb2JJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIGNvbXBsZXRlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIGZhaWxlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0RmFpbGVkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnZmFpbGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIGRlbGF5ZWQgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldERlbGF5ZWRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdkZWxheWVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIGFjdGl2ZSBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0QWN0aXZlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnYWN0aXZlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIHByaW9yaXRpemVkIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXRQcmlvcml0aXplZENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3ByaW9yaXRpemVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIHBlciBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb3VudHNQZXJQcmlvcml0eShwcmlvcml0aWVzKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVByaW9yaXRpZXMgPSBbLi4ubmV3IFNldChwcmlvcml0aWVzKV07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMuc2NyaXB0cy5nZXRDb3VudHNQZXJQcmlvcml0eSh1bmlxdWVQcmlvcml0aWVzKTtcbiAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb3VudHNbYCR7dW5pcXVlUHJpb3JpdGllc1tpbmRleF19YF0gPSByZXMgfHwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3VudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIHdhaXRpbmcgb3IgcGF1c2VkIHN0YXR1c2VzLlxuICAgICAqL1xuICAgIGdldFdhaXRpbmdDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCd3YWl0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBqb2JzIGluIHdhaXRpbmctY2hpbGRyZW4gc3RhdHVzLlxuICAgICAqL1xuICAgIGdldFdhaXRpbmdDaGlsZHJlbkNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3dhaXRpbmctY2hpbGRyZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJ3YWl0aW5nXCIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqL1xuICAgIGdldFdhaXRpbmcoc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsnd2FpdGluZyddLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJ3YWl0aW5nLWNoaWxkcmVuXCIgc3RhdHVzLlxuICAgICAqIEkuRS4gcGFyZW50IGpvYnMgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZSBjaGlsZCB0aGF0IGhhcyBub3QgY29tcGxldGVkIHlldC5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKi9cbiAgICBnZXRXYWl0aW5nQ2hpbGRyZW4oc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsnd2FpdGluZy1jaGlsZHJlbiddLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJhY3RpdmVcIiBzdGF0dXMuXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gemVybyBiYXNlZCBpbmRleCBmcm9tIHdoZXJlIHRvIHN0YXJ0IHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBlbmQgLSB6ZXJvIGJhc2VkIGluZGV4IHdoZXJlIHRvIHN0b3AgcmV0dXJuaW5nIGpvYnMuXG4gICAgICovXG4gICAgZ2V0QWN0aXZlKHN0YXJ0ID0gMCwgZW5kID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ2FjdGl2ZSddLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJkZWxheWVkXCIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqL1xuICAgIGdldERlbGF5ZWQoc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsnZGVsYXllZCddLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJwcmlvcml0aXplZFwiIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKi9cbiAgICBnZXRQcmlvcml0aXplZChzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYnMoWydwcmlvcml0aXplZCddLCBzdGFydCwgZW5kLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgam9icyB0aGF0IGFyZSBpbiB0aGUgXCJjb21wbGV0ZWRcIiBzdGF0dXMuXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gemVybyBiYXNlZCBpbmRleCBmcm9tIHdoZXJlIHRvIHN0YXJ0IHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBlbmQgLSB6ZXJvIGJhc2VkIGluZGV4IHdoZXJlIHRvIHN0b3AgcmV0dXJuaW5nIGpvYnMuXG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVkKHN0YXJ0ID0gMCwgZW5kID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9icyhbJ2NvbXBsZXRlZCddLCBzdGFydCwgZW5kLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGpvYnMgdGhhdCBhcmUgaW4gdGhlIFwiZmFpbGVkXCIgc3RhdHVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqL1xuICAgIGdldEZhaWxlZChzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYnMoWydmYWlsZWQnXSwgc3RhcnQsIGVuZCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBxdWFsaWZpZWQgam9iIGlkcyBhbmQgdGhlIHJhdyBqb2IgZGF0YSAoaWYgYXZhaWxhYmxlKSBvZiB0aGVcbiAgICAgKiBjaGlsZHJlbiBqb2JzIG9mIHRoZSBnaXZlbiBwYXJlbnQgam9iLlxuICAgICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBlaXRoZXIgdGhlIGFscmVhZHkgcHJvY2Vzc2VkIGNoaWxkcmVuLCBpbiB0aGlzIGNhc2VcbiAgICAgKiBhbiBhcnJheSBvZiBxdWFsaWZpZWQgam9iIGlkcyBhbmQgdGhlaXIgcmVzdWx0IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkLFxuICAgICAqIG9yIHRoZSBwZW5kaW5nIGNoaWxkcmVuLCBpbiB0aGlzIGNhc2UgYW4gYXJyYXkgb2YgcXVhbGlmaWVkIGpvYiBpZHMgd2lsbFxuICAgICAqIGJlIHJldHVybmVkLlxuICAgICAqIEEgcXVhbGlmaWVkIGpvYiBpZCBpcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGpvYiBpZCBpbiBhIGdpdmVuIHF1ZXVlLFxuICAgICAqIGZvciBleGFtcGxlOiBcImJ1bGw6bXlxdWV1ZTpqb2JpZFwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudElkIC0gVGhlIGlkIG9mIHRoZSBwYXJlbnQgam9iXG4gICAgICogQHBhcmFtIHR5cGUgLSBcInByb2Nlc3NlZFwiIHwgXCJwZW5kaW5nXCJcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAgICogYHsgaXRlbXM6IHsgaWQ6IHN0cmluZywgdj86IGFueSwgZXJyPzogc3RyaW5nIH0gW10sIGpvYnM6IEpvYkpzb25SYXdbXSwgdG90YWw6IG51bWJlcn1gXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwZW5kZW5jaWVzKHBhcmVudElkLCB0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMudG9LZXkodHlwZSA9PSAncHJvY2Vzc2VkJ1xuICAgICAgICAgICAgPyBgJHtwYXJlbnRJZH06cHJvY2Vzc2VkYFxuICAgICAgICAgICAgOiBgJHtwYXJlbnRJZH06ZGVwZW5kZW5jaWVzYCk7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMsIHRvdGFsLCBqb2JzIH0gPSBhd2FpdCB0aGlzLnNjcmlwdHMucGFnaW5hdGUoa2V5LCB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGZldGNoSm9iczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgIGpvYnMsXG4gICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmFuZ2VzKHR5cGVzLCBzdGFydCA9IDAsIGVuZCA9IDEsIGFzYyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG11bHRpQ29tbWFuZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21tYW5kQnlUeXBlKHR5cGVzLCBmYWxzZSwgKGtleSwgY29tbWFuZCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbHJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlDb21tYW5kcy5wdXNoKCdscmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnenJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlDb21tYW5kcy5wdXNoKCd6cmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLnNjcmlwdHMuZ2V0UmFuZ2VzKHR5cGVzLCBzdGFydCwgZW5kLCBhc2MpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgICByZXNwb25zZXMuZm9yRWFjaCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChhc2MgJiYgbXVsdGlDb21tYW5kc1tpbmRleF0gPT09ICdscmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlc3VsdC5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQocmVzdWx0cyldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqb2JzIHRoYXQgYXJlIG9uIHRoZSBnaXZlbiBzdGF0dXNlcyAobm90ZSB0aGF0IEpvYlR5cGUgaXMgc3lub255bSBmb3Igam9iIHN0YXR1cylcbiAgICAgKiBAcGFyYW0gdHlwZXMgLSB0aGUgc3RhdHVzZXMgb2YgdGhlIGpvYnMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHplcm8gYmFzZWQgaW5kZXggZnJvbSB3aGVyZSB0byBzdGFydCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gZW5kIC0gemVybyBiYXNlZCBpbmRleCB3aGVyZSB0byBzdG9wIHJldHVybmluZyBqb2JzLlxuICAgICAqIEBwYXJhbSBhc2MgLSBpZiB0cnVlLCB0aGUgam9icyB3aWxsIGJlIHJldHVybmVkIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRKb2JzKHR5cGVzLCBzdGFydCA9IDAsIGVuZCA9IC0xLCBhc2MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VHlwZXMgPSB0aGlzLnNhbml0aXplSm9iVHlwZXModHlwZXMpO1xuICAgICAgICBjb25zdCBqb2JJZHMgPSBhd2FpdCB0aGlzLmdldFJhbmdlcyhjdXJyZW50VHlwZXMsIHN0YXJ0LCBlbmQsIGFzYyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JJZHMubWFwKGpvYklkID0+IHRoaXMuSm9iLmZyb21JZCh0aGlzLCBqb2JJZCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9ncyBmb3IgYSBnaXZlbiBKb2IuXG4gICAgICogQHBhcmFtIGpvYklkIC0gdGhlIGlkIG9mIHRoZSBqb2IgdG8gZ2V0IHRoZSBsb2dzIGZvci5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSB6ZXJvIGJhc2VkIGluZGV4IGZyb20gd2hlcmUgdG8gc3RhcnQgcmV0dXJuaW5nIGpvYnMuXG4gICAgICogQHBhcmFtIGVuZCAtIHplcm8gYmFzZWQgaW5kZXggd2hlcmUgdG8gc3RvcCByZXR1cm5pbmcgam9icy5cbiAgICAgKiBAcGFyYW0gYXNjIC0gaWYgdHJ1ZSwgdGhlIGpvYnMgd2lsbCBiZSByZXR1cm5lZCBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Sm9iTG9ncyhqb2JJZCwgc3RhcnQgPSAwLCBlbmQgPSAtMSwgYXNjID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgY29uc3QgbXVsdGkgPSBjbGllbnQubXVsdGkoKTtcbiAgICAgICAgY29uc3QgbG9nc0tleSA9IHRoaXMudG9LZXkoam9iSWQgKyAnOmxvZ3MnKTtcbiAgICAgICAgaWYgKGFzYykge1xuICAgICAgICAgICAgbXVsdGkubHJhbmdlKGxvZ3NLZXksIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXVsdGkubHJhbmdlKGxvZ3NLZXksIC0oZW5kICsgMSksIC0oc3RhcnQgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGkubGxlbihsb2dzS2V5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKGF3YWl0IG11bHRpLmV4ZWMoKSk7XG4gICAgICAgIGlmICghYXNjKSB7XG4gICAgICAgICAgICByZXN1bHRbMF1bMV0ucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2dzOiByZXN1bHRbMF1bMV0sXG4gICAgICAgICAgICBjb3VudDogcmVzdWx0WzFdWzFdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBiYXNlR2V0Q2xpZW50cyhtYXRjaGVyKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50cyA9IChhd2FpdCBjbGllbnQuY2xpZW50KCdMSVNUJykpO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMucGFyc2VDbGllbnRMaXN0KGNsaWVudHMsIG1hdGNoZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFjbGllbnRDb21tYW5kTWVzc2FnZVJlZy50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeyBuYW1lOiAnR0NQIGRvZXMgbm90IHN1cHBvcnQgY2xpZW50IGxpc3QnIH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd29ya2VyIGxpc3QgcmVsYXRlZCB0byB0aGUgcXVldWUuIGkuZS4gYWxsIHRoZSBrbm93blxuICAgICAqIHdvcmtlcnMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvIHByb2Nlc3Mgam9icyBmb3IgdGhpcyBxdWV1ZS5cbiAgICAgKiBOb3RlOiBHQ1AgZG9lcyBub3Qgc3VwcG9ydCBTRVROQU1FLCBzbyB0aGlzIGNhbGwgd2lsbCBub3Qgd29ya1xuICAgICAqXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIGFuIGFycmF5IHdpdGggd29ya2VycyBpbmZvLlxuICAgICAqL1xuICAgIGdldFdvcmtlcnMoKSB7XG4gICAgICAgIGNvbnN0IHVubmFtZWRXb3JrZXJDbGllbnROYW1lID0gYCR7dGhpcy5jbGllbnROYW1lKCl9YDtcbiAgICAgICAgY29uc3QgbmFtZWRXb3JrZXJDbGllbnROYW1lID0gYCR7dGhpcy5jbGllbnROYW1lKCl9Onc6YDtcbiAgICAgICAgY29uc3QgbWF0Y2hlciA9IChuYW1lKSA9PiBuYW1lICYmXG4gICAgICAgICAgICAobmFtZSA9PT0gdW5uYW1lZFdvcmtlckNsaWVudE5hbWUgfHxcbiAgICAgICAgICAgICAgICBuYW1lLnN0YXJ0c1dpdGgobmFtZWRXb3JrZXJDbGllbnROYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VHZXRDbGllbnRzKG1hdGNoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvdW50IG9mIHdvcmtlcnMgZm9yIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIGdldFdvcmtlcnNDb3VudCgpOiBQcm9taXNlPG51bWJlcj5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGdldFdvcmtlcnNDb3VudCgpIHtcbiAgICAgICAgY29uc3Qgd29ya2VycyA9IGF3YWl0IHRoaXMuZ2V0V29ya2VycygpO1xuICAgICAgICByZXR1cm4gd29ya2Vycy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBxdWV1ZSBldmVudHMgbGlzdCByZWxhdGVkIHRvIHRoZSBxdWV1ZS5cbiAgICAgKiBOb3RlOiBHQ1AgZG9lcyBub3Qgc3VwcG9ydCBTRVROQU1FLCBzbyB0aGlzIGNhbGwgd2lsbCBub3Qgd29ya1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgZG8gbm90IHVzZSB0aGlzIG1ldGhvZCwgaXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgYW4gYXJyYXkgd2l0aCBxdWV1ZSBldmVudHMgaW5mby5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRRdWV1ZUV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TmFtZSA9IGAke3RoaXMuY2xpZW50TmFtZSgpfSR7UVVFVUVfRVZFTlRfU1VGRklYfWA7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VHZXRDbGllbnRzKChuYW1lKSA9PiBuYW1lID09PSBjbGllbnROYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHF1ZXVlIG1ldHJpY3MgcmVsYXRlZCB0byB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBnYXRoZXJlZCBtZXRyaWNzIGZvciB0aGUgcXVldWUuXG4gICAgICogVGhlIG1ldHJpY3MgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGpvYiBjb3VudHNcbiAgICAgKiBwZXIgdW5pdCBvZiB0aW1lICgxIG1pbnV0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBwb2ludCBvZiB0aGUgbWV0cmljcywgd2hlcmUgMFxuICAgICAqIGlzIHRoZSBuZXdlc3QgcG9pbnQgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGVuZCAtIEVuZCBwb2ludCBvZiB0aGUgbWV0cmljcywgd2hlcmUgLTEgaXMgdGhlXG4gICAgICogb2xkZXN0IHBvaW50IHRvIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHF1ZXVlIG1ldHJpY3MuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TWV0cmljcyh0eXBlLCBzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgICAgIGNvbnN0IFttZXRhLCBkYXRhLCBjb3VudF0gPSBhd2FpdCB0aGlzLnNjcmlwdHMuZ2V0TWV0cmljcyh0eXBlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBjb3VudDogcGFyc2VJbnQobWV0YVswXSB8fCAnMCcsIDEwKSxcbiAgICAgICAgICAgICAgICBwcmV2VFM6IHBhcnNlSW50KG1ldGFbMV0gfHwgJzAnLCAxMCksXG4gICAgICAgICAgICAgICAgcHJldkNvdW50OiBwYXJzZUludChtZXRhWzJdIHx8ICcwJywgMTApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEubWFwKHBvaW50ID0+ICtwb2ludCB8fCAwKSxcbiAgICAgICAgICAgIGNvdW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUNsaWVudExpc3QobGlzdCwgbWF0Y2hlcikge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGxpc3Quc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlcyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGtleVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0ga2V5VmFsdWUuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleVZhbHVlLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBrZXlWYWx1ZS5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBjbGllbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY2xpZW50WyduYW1lJ107XG4gICAgICAgICAgICBpZiAobWF0Y2hlcihuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNsaWVudFsnbmFtZSddID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIGNsaWVudFsncmF3bmFtZSddID0gbmFtZTtcbiAgICAgICAgICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnQgdGhlIG1ldHJpY3MgZm9yIHRoZSBxdWV1ZSBpbiB0aGUgUHJvbWV0aGV1cyBmb3JtYXQuXG4gICAgICogQXV0b21hdGljYWxseSBleHBvcnRzIGFsbCB0aGUgY291bnRzIHJldHVybmVkIGJ5IGdldEpvYkNvdW50cygpLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIG1ldHJpY3MgaW4gdGhlIFByb21ldGhldXMgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9wcm9tZXRoZXVzLmlvL2RvY3MvaW5zdHJ1bWVudGluZy9leHBvc2l0aW9uX2Zvcm1hdHMvfVxuICAgICAqXG4gICAgICoqL1xuICAgIGFzeW5jIGV4cG9ydFByb21ldGhldXNNZXRyaWNzKGdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBjb3VudHMgPSBhd2FpdCB0aGlzLmdldEpvYkNvdW50cygpO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gW107XG4gICAgICAgIC8vIE1hdGNoIHRoZSB0ZXN0J3MgZXhwZWN0ZWQgSEVMUCB0ZXh0XG4gICAgICAgIG1ldHJpY3MucHVzaCgnIyBIRUxQIGJ1bGxtcV9qb2JfY291bnQgTnVtYmVyIG9mIGpvYnMgaW4gdGhlIHF1ZXVlIGJ5IHN0YXRlJyk7XG4gICAgICAgIG1ldHJpY3MucHVzaCgnIyBUWVBFIGJ1bGxtcV9qb2JfY291bnQgZ2F1Z2UnKTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gIWdsb2JhbFZhcmlhYmxlc1xuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBPYmplY3Qua2V5cyhnbG9iYWxWYXJpYWJsZXMpLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBgJHthY2N9LCAke2N1cnJ9PVwiJHtnbG9iYWxWYXJpYWJsZXNbY3Vycl19XCJgLCAnJyk7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXRlLCBjb3VudF0gb2YgT2JqZWN0LmVudHJpZXMoY291bnRzKSkge1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKGBidWxsbXFfam9iX2NvdW50e3F1ZXVlPVwiJHt0aGlzLm5hbWV9XCIsIHN0YXRlPVwiJHtzdGF0ZX1cIiR7dmFyaWFibGVzfX0gJHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0cmljcy5qb2luKCdcXG4nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS1nZXR0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue-keys.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueueKeys: () => (/* binding */ QueueKeys)\n/* harmony export */ });\nclass QueueKeys {\n    constructor(prefix = 'bull') {\n        this.prefix = prefix;\n    }\n    getKeys(name) {\n        const keys = {};\n        [\n            '',\n            'active',\n            'wait',\n            'waiting-children',\n            'paused',\n            'id',\n            'delayed',\n            'prioritized',\n            'stalled-check',\n            'completed',\n            'failed',\n            'stalled',\n            'repeat',\n            'limiter',\n            'meta',\n            'events',\n            'pc', // priority counter key\n            'marker', // marker key\n            'de', // deduplication key\n        ].forEach(key => {\n            keys[key] = this.toKey(name, key);\n        });\n        return keys;\n    }\n    toKey(name, type) {\n        return `${this.getQueueQualifiedName(name)}:${type}`;\n    }\n    getQueueQualifiedName(name) {\n        return `${this.prefix}:${name}`;\n    }\n}\n//# sourceMappingURL=queue-keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUta2V5cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQyxHQUFHLEtBQUs7QUFDM0Q7QUFDQTtBQUNBLGtCQUFrQixZQUFZLEdBQUcsS0FBSztBQUN0QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLWtleXMuanM/MTIwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgUXVldWVLZXlzIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXggPSAnYnVsbCcpIHtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIGdldEtleXMobmFtZSkge1xuICAgICAgICBjb25zdCBrZXlzID0ge307XG4gICAgICAgIFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ2FjdGl2ZScsXG4gICAgICAgICAgICAnd2FpdCcsXG4gICAgICAgICAgICAnd2FpdGluZy1jaGlsZHJlbicsXG4gICAgICAgICAgICAncGF1c2VkJyxcbiAgICAgICAgICAgICdpZCcsXG4gICAgICAgICAgICAnZGVsYXllZCcsXG4gICAgICAgICAgICAncHJpb3JpdGl6ZWQnLFxuICAgICAgICAgICAgJ3N0YWxsZWQtY2hlY2snLFxuICAgICAgICAgICAgJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAnZmFpbGVkJyxcbiAgICAgICAgICAgICdzdGFsbGVkJyxcbiAgICAgICAgICAgICdyZXBlYXQnLFxuICAgICAgICAgICAgJ2xpbWl0ZXInLFxuICAgICAgICAgICAgJ21ldGEnLFxuICAgICAgICAgICAgJ2V2ZW50cycsXG4gICAgICAgICAgICAncGMnLCAvLyBwcmlvcml0eSBjb3VudGVyIGtleVxuICAgICAgICAgICAgJ21hcmtlcicsIC8vIG1hcmtlciBrZXlcbiAgICAgICAgICAgICdkZScsIC8vIGRlZHVwbGljYXRpb24ga2V5XG4gICAgICAgIF0uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5c1trZXldID0gdGhpcy50b0tleShuYW1lLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHRvS2V5KG5hbWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5hbWUpfToke3R5cGV9YDtcbiAgICB9XG4gICAgZ2V0UXVldWVRdWFsaWZpZWROYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJlZml4fToke25hbWV9YDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue-keys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/queue.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm/v4.js\");\n/* harmony import */ var _job__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job.js\");\n/* harmony import */ var _queue_getters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./queue-getters */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-getters.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _job_scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./job-scheduler */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job-scheduler.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../version */ \"(rsc)/./node_modules/bullmq/dist/esm/version.js\");\n\n\n\n\n\n\n\n/**\n * Queue\n *\n * This class provides methods to add jobs to a queue and some other high-level\n * administration such as pausing or deleting queues.\n *\n * @typeParam DataType - The type of the data that the job will process.\n * @typeParam ResultType - The type of the result of the job.\n * @typeParam NameType - The type of the name of the job.\n *\n * @example\n *\n * ```typescript\n * import { Queue } from 'bullmq';\n *\n * interface MyDataType {\n *  foo: string;\n * }\n *\n * interface MyResultType {\n *   bar: string;\n * }\n *\n * const queue = new Queue<MyDataType, MyResultType, \"blue\" | \"brown\">('myQueue');\n * ```\n */\nclass Queue extends _queue_getters__WEBPACK_IMPORTED_MODULE_1__.QueueGetters {\n    constructor(name, opts, Connection) {\n        var _a;\n        super(name, Object.assign({}, opts), Connection);\n        this.token = (0,uuid__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n        this.libName = 'bullmq';\n        this.jobsOpts = (_a = opts === null || opts === void 0 ? void 0 : opts.defaultJobOptions) !== null && _a !== void 0 ? _a : {};\n        this.waitUntilReady()\n            .then(client => {\n            if (!this.closing && !(opts === null || opts === void 0 ? void 0 : opts.skipMetasUpdate)) {\n                return client.hmset(this.keys.meta, this.metaValues);\n            }\n        })\n            .catch(err => {\n            // We ignore this error to avoid warnings. The error can still\n            // be received by listening to event 'error'\n        });\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    /**\n     * Returns this instance current default job options.\n     */\n    get defaultJobOptions() {\n        return Object.assign({}, this.jobsOpts);\n    }\n    get metaValues() {\n        var _a, _b, _c, _d;\n        return {\n            'opts.maxLenEvents': (_d = (_c = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.streams) === null || _b === void 0 ? void 0 : _b.events) === null || _c === void 0 ? void 0 : _c.maxLen) !== null && _d !== void 0 ? _d : 10000,\n            version: `${this.libName}:${_version__WEBPACK_IMPORTED_MODULE_5__.version}`,\n        };\n    }\n    /**\n     * Get library version.\n     *\n     * @returns the content of the meta.library field.\n     */\n    async getVersion() {\n        const client = await this.client;\n        return await client.hget(this.keys.meta, 'version');\n    }\n    get repeat() {\n        return new Promise(async (resolve) => {\n            if (!this._repeat) {\n                this._repeat = new _repeat__WEBPACK_IMPORTED_MODULE_2__.Repeat(this.name, Object.assign(Object.assign({}, this.opts), { connection: await this.client }));\n                this._repeat.on('error', e => this.emit.bind(this, e));\n            }\n            resolve(this._repeat);\n        });\n    }\n    get jobScheduler() {\n        return new Promise(async (resolve) => {\n            if (!this._jobScheduler) {\n                this._jobScheduler = new _job_scheduler__WEBPACK_IMPORTED_MODULE_4__.JobScheduler(this.name, Object.assign(Object.assign({}, this.opts), { connection: await this.client }));\n                this._jobScheduler.on('error', e => this.emit.bind(this, e));\n            }\n            resolve(this._jobScheduler);\n        });\n    }\n    /**\n     * Get global concurrency value.\n     * Returns null in case no value is set.\n     */\n    async getGlobalConcurrency() {\n        const client = await this.client;\n        const concurrency = await client.hget(this.keys.meta, 'concurrency');\n        if (concurrency) {\n            return Number(concurrency);\n        }\n        return null;\n    }\n    /**\n     * Enable and set global concurrency value.\n     * @param concurrency - Maximum number of simultaneous jobs that the workers can handle.\n     * For instance, setting this value to 1 ensures that no more than one job\n     * is processed at any given time. If this limit is not defined, there will be no\n     * restriction on the number of concurrent jobs.\n     */\n    async setGlobalConcurrency(concurrency) {\n        const client = await this.client;\n        return client.hset(this.keys.meta, 'concurrency', concurrency);\n    }\n    /**\n     * Enable and set rate limit.\n     * @param max - Max number of jobs to process in the time period specified in `duration`\n     * @param duration - Time in milliseconds. During this time, a maximum of `max` jobs will be processed.\n     */\n    async setGlobalRateLimit(max, duration) {\n        const client = await this.client;\n        return client.hset(this.keys.meta, 'max', max, 'duration', duration);\n    }\n    /**\n     * Remove global concurrency value.\n     */\n    async removeGlobalConcurrency() {\n        const client = await this.client;\n        return client.hdel(this.keys.meta, 'concurrency');\n    }\n    /**\n     * Adds a new job to the queue.\n     *\n     * @param name - Name of the job to be added to the queue.\n     * @param data - Arbitrary data to append to the job.\n     * @param opts - Job options that affects how the job is going to be processed.\n     */\n    async add(name, data, opts) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.PRODUCER, 'add', `${this.name}.${name}`, async (span, srcPropagationMedatada) => {\n            var _a;\n            if (srcPropagationMedatada && !((_a = opts === null || opts === void 0 ? void 0 : opts.telemetry) === null || _a === void 0 ? void 0 : _a.omitContext)) {\n                const telemetry = {\n                    metadata: srcPropagationMedatada,\n                };\n                opts = Object.assign(Object.assign({}, opts), { telemetry });\n            }\n            const job = await this.addJob(name, data, opts);\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobName]: name,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: job.id,\n            });\n            return job;\n        });\n    }\n    /**\n     * addJob is a telemetry free version of the add method, useful in order to wrap it\n     * with custom telemetry on subclasses.\n     *\n     * @param name - Name of the job to be added to the queue.\n     * @param data - Arbitrary data to append to the job.\n     * @param opts - Job options that affects how the job is going to be processed.\n     *\n     * @returns Job\n     */\n    async addJob(name, data, opts) {\n        if (opts && opts.repeat) {\n            if (opts.repeat.endDate) {\n                if (+new Date(opts.repeat.endDate) < Date.now()) {\n                    throw new Error('End date must be greater than current timestamp');\n                }\n            }\n            return (await this.repeat).updateRepeatableJob(name, data, Object.assign(Object.assign({}, this.jobsOpts), opts), { override: true });\n        }\n        else {\n            const jobId = opts === null || opts === void 0 ? void 0 : opts.jobId;\n            if (jobId == '0' || (jobId === null || jobId === void 0 ? void 0 : jobId.startsWith('0:'))) {\n                throw new Error(\"JobId cannot be '0' or start with 0:\");\n            }\n            const job = await this.Job.create(this, name, data, Object.assign(Object.assign(Object.assign({}, this.jobsOpts), opts), { jobId }));\n            this.emit('waiting', job);\n            return job;\n        }\n    }\n    /**\n     * Adds an array of jobs to the queue. This method may be faster than adding\n     * one job at a time in a sequence.\n     *\n     * @param jobs - The array of jobs to add to the queue. Each job is defined by 3\n     * properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.\n     */\n    async addBulk(jobs) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.PRODUCER, 'addBulk', this.name, async (span, srcPropagationMedatada) => {\n            if (span) {\n                span.setAttributes({\n                    [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.BulkNames]: jobs.map(job => job.name),\n                    [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.BulkCount]: jobs.length,\n                });\n            }\n            return await this.Job.createBulk(this, jobs.map(job => {\n                var _a, _b, _c, _d, _e, _f;\n                let telemetry = (_a = job.opts) === null || _a === void 0 ? void 0 : _a.telemetry;\n                if (srcPropagationMedatada) {\n                    const omitContext = (_c = (_b = job.opts) === null || _b === void 0 ? void 0 : _b.telemetry) === null || _c === void 0 ? void 0 : _c.omitContext;\n                    const telemetryMetadata = ((_e = (_d = job.opts) === null || _d === void 0 ? void 0 : _d.telemetry) === null || _e === void 0 ? void 0 : _e.metadata) ||\n                        (!omitContext && srcPropagationMedatada);\n                    if (telemetryMetadata || omitContext) {\n                        telemetry = {\n                            metadata: telemetryMetadata,\n                            omitContext,\n                        };\n                    }\n                }\n                return {\n                    name: job.name,\n                    data: job.data,\n                    opts: Object.assign(Object.assign(Object.assign({}, this.jobsOpts), job.opts), { jobId: (_f = job.opts) === null || _f === void 0 ? void 0 : _f.jobId, telemetry }),\n                };\n            }));\n        });\n    }\n    /**\n     * Upserts a scheduler.\n     *\n     * A scheduler is a job factory that creates jobs at a given interval.\n     * Upserting a scheduler will create a new job scheduler or update an existing one.\n     * It will also create the first job based on the repeat options and delayed accordingly.\n     *\n     * @param key - Unique key for the repeatable job meta.\n     * @param repeatOpts - Repeat options\n     * @param jobTemplate - Job template. If provided it will be used for all the jobs\n     * created by the scheduler.\n     *\n     * @returns The next job to be scheduled (would normally be in delayed state).\n     */\n    async upsertJobScheduler(jobSchedulerId, repeatOpts, jobTemplate) {\n        var _a, _b;\n        if (repeatOpts.endDate) {\n            if (+new Date(repeatOpts.endDate) < Date.now()) {\n                throw new Error('End date must be greater than current timestamp');\n            }\n        }\n        return (await this.jobScheduler).upsertJobScheduler(jobSchedulerId, repeatOpts, (_a = jobTemplate === null || jobTemplate === void 0 ? void 0 : jobTemplate.name) !== null && _a !== void 0 ? _a : jobSchedulerId, (_b = jobTemplate === null || jobTemplate === void 0 ? void 0 : jobTemplate.data) !== null && _b !== void 0 ? _b : {}, Object.assign(Object.assign({}, this.jobsOpts), jobTemplate === null || jobTemplate === void 0 ? void 0 : jobTemplate.opts), { override: true });\n    }\n    /**\n     * Pauses the processing of this queue globally.\n     *\n     * We use an atomic RENAME operation on the wait queue. Since\n     * we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue\n     * is renamed to 'paused', no new jobs will be processed (the current ones\n     * will run until finalized).\n     *\n     * Adding jobs requires a LUA script to check first if the paused list exist\n     * and in that case it will add it there instead of the wait list.\n     */\n    async pause() {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'pause', this.name, async () => {\n            await this.scripts.pause(true);\n            this.emit('paused');\n        });\n    }\n    /**\n     * Close the queue instance.\n     *\n     */\n    async close() {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'close', this.name, async () => {\n            if (!this.closing) {\n                if (this._repeat) {\n                    await this._repeat.close();\n                }\n            }\n            await super.close();\n        });\n    }\n    /**\n     * Overrides the rate limit to be active for the next jobs.\n     *\n     * @param expireTimeMs - expire time in ms of this rate limit.\n     */\n    async rateLimit(expireTimeMs) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'rateLimit', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueRateLimit]: expireTimeMs,\n            });\n            await this.client.then(client => client.set(this.keys.limiter, Number.MAX_SAFE_INTEGER, 'PX', expireTimeMs));\n        });\n    }\n    /**\n     * Resumes the processing of this queue globally.\n     *\n     * The method reverses the pause operation by resuming the processing of the\n     * queue.\n     */\n    async resume() {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'resume', this.name, async () => {\n            await this.scripts.pause(false);\n            this.emit('resumed');\n        });\n    }\n    /**\n     * Returns true if the queue is currently paused.\n     */\n    async isPaused() {\n        const client = await this.client;\n        const pausedKeyExists = await client.hexists(this.keys.meta, 'paused');\n        return pausedKeyExists === 1;\n    }\n    /**\n     * Returns true if the queue is currently maxed.\n     */\n    isMaxed() {\n        return this.scripts.isMaxed();\n    }\n    /**\n     * Get all repeatable meta jobs.\n     *\n     * @deprecated This method is deprecated and will be removed in v6. Use getJobSchedulers instead.\n     *\n     * @param start - Offset of first job to return.\n     * @param end - Offset of last job to return.\n     * @param asc - Determine the order in which jobs are returned based on their\n     * next execution time.\n     */\n    async getRepeatableJobs(start, end, asc) {\n        return (await this.repeat).getRepeatableJobs(start, end, asc);\n    }\n    /**\n     * Get Job Scheduler by id\n     *\n     * @param id - identifier of scheduler.\n     */\n    async getJobScheduler(id) {\n        return (await this.jobScheduler).getScheduler(id);\n    }\n    /**\n     * Get all Job Schedulers\n     *\n     * @param start - Offset of first scheduler to return.\n     * @param end - Offset of last scheduler to return.\n     * @param asc - Determine the order in which schedulers are returned based on their\n     * next execution time.\n     */\n    async getJobSchedulers(start, end, asc) {\n        return (await this.jobScheduler).getJobSchedulers(start, end, asc);\n    }\n    /**\n     *\n     * Get the number of job schedulers.\n     *\n     * @returns The number of job schedulers.\n     */\n    async getJobSchedulersCount() {\n        return (await this.jobScheduler).getSchedulersCount();\n    }\n    /**\n     * Removes a repeatable job.\n     *\n     * Note: you need to use the exact same repeatOpts when deleting a repeatable job\n     * than when adding it.\n     *\n     * @deprecated This method is deprecated and will be removed in v6. Use removeJobScheduler instead.\n     *\n     * @see removeRepeatableByKey\n     *\n     * @param name - Job name\n     * @param repeatOpts - Repeat options\n     * @param jobId - Job id to remove. If not provided, all jobs with the same repeatOpts\n     * @returns\n     */\n    async removeRepeatable(name, repeatOpts, jobId) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'removeRepeatable', `${this.name}.${name}`, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobName]: name,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: jobId,\n            });\n            const repeat = await this.repeat;\n            const removed = await repeat.removeRepeatable(name, repeatOpts, jobId);\n            return !removed;\n        });\n    }\n    /**\n     *\n     * Removes a job scheduler.\n     *\n     * @param jobSchedulerId - identifier of the job scheduler.\n     *\n     * @returns\n     */\n    async removeJobScheduler(jobSchedulerId) {\n        const jobScheduler = await this.jobScheduler;\n        const removed = await jobScheduler.removeJobScheduler(jobSchedulerId);\n        return !removed;\n    }\n    /**\n     * Removes a debounce key.\n     * @deprecated use removeDeduplicationKey\n     *\n     * @param id - debounce identifier\n     */\n    async removeDebounceKey(id) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'removeDebounceKey', `${this.name}`, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobKey]: id,\n            });\n            const client = await this.client;\n            return await client.del(`${this.keys.de}:${id}`);\n        });\n    }\n    /**\n     * Removes a deduplication key.\n     *\n     * @param id - identifier\n     */\n    async removeDeduplicationKey(id) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'removeDeduplicationKey', `${this.name}`, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.DeduplicationKey]: id,\n            });\n            const client = await this.client;\n            return client.del(`${this.keys.de}:${id}`);\n        });\n    }\n    /**\n     * Removes rate limit key.\n     */\n    async removeRateLimitKey() {\n        const client = await this.client;\n        return client.del(this.keys.limiter);\n    }\n    /**\n     * Removes a repeatable job by its key. Note that the key is the one used\n     * to store the repeatable job metadata and not one of the job iterations\n     * themselves. You can use \"getRepeatableJobs\" in order to get the keys.\n     *\n     * @see getRepeatableJobs\n     *\n     * @deprecated This method is deprecated and will be removed in v6. Use removeJobScheduler instead.\n     *\n     * @param repeatJobKey - To the repeatable job.\n     * @returns\n     */\n    async removeRepeatableByKey(key) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'removeRepeatableByKey', `${this.name}`, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobKey]: key,\n            });\n            const repeat = await this.repeat;\n            const removed = await repeat.removeRepeatableByKey(key);\n            return !removed;\n        });\n    }\n    /**\n     * Removes the given job from the queue as well as all its\n     * dependencies.\n     *\n     * @param jobId - The id of the job to remove\n     * @param opts - Options to remove a job\n     * @returns 1 if it managed to remove the job or 0 if the job or\n     * any of its dependencies were locked.\n     */\n    async remove(jobId, { removeChildren = true } = {}) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'remove', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: jobId,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobOptions]: JSON.stringify({\n                    removeChildren,\n                }),\n            });\n            return await this.scripts.remove(jobId, removeChildren);\n        });\n    }\n    /**\n     * Updates the given job's progress.\n     *\n     * @param jobId - The id of the job to update\n     * @param progress - Number or object to be saved as progress.\n     */\n    async updateJobProgress(jobId, progress) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'updateJobProgress', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobId]: jobId,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobProgress]: JSON.stringify(progress),\n            });\n            await this.scripts.updateProgress(jobId, progress);\n        });\n    }\n    /**\n     * Logs one row of job's log data.\n     *\n     * @param jobId - The job id to log against.\n     * @param logRow - String with log data to be logged.\n     * @param keepLogs - Max number of log entries to keep (0 for unlimited).\n     *\n     * @returns The total number of log entries for this job so far.\n     */\n    async addJobLog(jobId, logRow, keepLogs) {\n        return _job__WEBPACK_IMPORTED_MODULE_0__.Job.addJobLog(this, jobId, logRow, keepLogs);\n    }\n    /**\n     * Drains the queue, i.e., removes all jobs that are waiting\n     * or delayed, but not active, completed or failed.\n     *\n     * @param delayed - Pass true if it should also clean the\n     * delayed jobs.\n     */\n    async drain(delayed = false) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'drain', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueDrainDelay]: delayed,\n            });\n            await this.scripts.drain(delayed);\n        });\n    }\n    /**\n     * Cleans jobs from a queue. Similar to drain but keeps jobs within a certain\n     * grace period.\n     *\n     * @param grace - The grace period in milliseconds\n     * @param limit - Max number of jobs to clean\n     * @param type - The type of job to clean\n     * Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.\n     * @returns Id jobs from the deleted records\n     */\n    async clean(grace, limit, type = 'completed') {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'clean', this.name, async (span) => {\n            const maxCount = limit || Infinity;\n            const maxCountPerCall = Math.min(10000, maxCount);\n            const timestamp = Date.now() - grace;\n            let deletedCount = 0;\n            const deletedJobsIds = [];\n            // Normalize 'waiting' to 'wait' for consistency with internal Redis keys\n            const normalizedType = type === 'waiting' ? 'wait' : type;\n            while (deletedCount < maxCount) {\n                const jobsIds = await this.scripts.cleanJobsInSet(normalizedType, timestamp, maxCountPerCall);\n                this.emit('cleaned', jobsIds, normalizedType);\n                deletedCount += jobsIds.length;\n                deletedJobsIds.push(...jobsIds);\n                if (jobsIds.length < maxCountPerCall) {\n                    break;\n                }\n            }\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueGrace]: grace,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobType]: type,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueCleanLimit]: maxCount,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.JobIds]: deletedJobsIds,\n            });\n            return deletedJobsIds;\n        });\n    }\n    /**\n     * Completely destroys the queue and all of its contents irreversibly.\n     * This method will *pause* the queue and requires that there are no\n     * active jobs. It is possible to bypass this requirement, i.e. not\n     * having active jobs using the \"force\" option.\n     *\n     * Note: This operation requires to iterate on all the jobs stored in the queue\n     * and can be slow for very large queues.\n     *\n     * @param opts - Obliterate options.\n     */\n    async obliterate(opts) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'obliterate', this.name, async () => {\n            await this.pause();\n            let cursor = 0;\n            do {\n                cursor = await this.scripts.obliterate(Object.assign({ force: false, count: 1000 }, opts));\n            } while (cursor);\n        });\n    }\n    /**\n     * Retry all the failed or completed jobs.\n     *\n     * @param opts - An object with the following properties:\n     *   - count  number to limit how many jobs will be moved to wait status per iteration,\n     *   - state  failed by default or completed.\n     *   - timestamp from which timestamp to start moving jobs to wait status, default Date.now().\n     *\n     * @returns\n     */\n    async retryJobs(opts = {}) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.PRODUCER, 'retryJobs', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueOptions]: JSON.stringify(opts),\n            });\n            let cursor = 0;\n            do {\n                cursor = await this.scripts.retryJobs(opts.state, opts.count, opts.timestamp);\n            } while (cursor);\n        });\n    }\n    /**\n     * Promote all the delayed jobs.\n     *\n     * @param opts - An object with the following properties:\n     *   - count  number to limit how many jobs will be moved to wait status per iteration\n     *\n     * @returns\n     */\n    async promoteJobs(opts = {}) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'promoteJobs', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueOptions]: JSON.stringify(opts),\n            });\n            let cursor = 0;\n            do {\n                cursor = await this.scripts.promoteJobs(opts.count);\n            } while (cursor);\n        });\n    }\n    /**\n     * Trim the event stream to an approximately maxLength.\n     *\n     * @param maxLength -\n     */\n    async trimEvents(maxLength) {\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.INTERNAL, 'trimEvents', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueEventMaxLength]: maxLength,\n            });\n            const client = await this.client;\n            return await client.xtrim(this.keys.events, 'MAXLEN', '~', maxLength);\n        });\n    }\n    /**\n     * Delete old priority helper key.\n     */\n    async removeDeprecatedPriorityKey() {\n        const client = await this.client;\n        return client.del(this.toKey('priority'));\n    }\n}\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEI7QUFDRTtBQUNtQjtBQUNiO0FBQ3VCO0FBQ1Y7QUFDVjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvQkFBb0Isd0RBQVk7QUFDdkM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxxQkFBcUIsZ0RBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhLEdBQUcsNkNBQU8sQ0FBQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJDQUFNLDBDQUEwQyxnQkFBZ0IsK0JBQStCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3REFBWSwwQ0FBMEMsZ0JBQWdCLCtCQUErQjtBQUM5STtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFRLHFCQUFxQixVQUFVLEdBQUcsS0FBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVcsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQW1CO0FBQ3BDLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRywyQkFBMkIsZ0JBQWdCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RywyQkFBMkIsT0FBTztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQVE7QUFDbEM7QUFDQTtBQUNBLHFCQUFxQix1REFBbUI7QUFDeEMscUJBQXFCLHVEQUFtQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLCtCQUErQixpRkFBaUY7QUFDdEw7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ1ZBQWdWLGdDQUFnQyxpR0FBaUcsZ0JBQWdCO0FBQ2plO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFRO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUTtBQUNqQztBQUNBLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVE7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQVEsa0NBQWtDLFVBQVUsR0FBRyxLQUFLO0FBQ3RGO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxpQkFBaUIsdURBQW1CO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFRLG1DQUFtQyxVQUFVO0FBQy9FO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUMsYUFBYSxHQUFHLEdBQUc7QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFRLHdDQUF3QyxVQUFVO0FBQ3BGO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsYUFBYSxHQUFHLEdBQUc7QUFDcEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUSx1Q0FBdUMsVUFBVTtBQUNuRjtBQUNBLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0IsSUFBSTtBQUN0RCwwQkFBMEIsNENBQVE7QUFDbEM7QUFDQSxpQkFBaUIsdURBQW1CO0FBQ3BDLGlCQUFpQix1REFBbUI7QUFDcEM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVE7QUFDakM7QUFDQSxpQkFBaUIsdURBQW1CO0FBQ3BDLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBUTtBQUNqQztBQUNBLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxpQkFBaUIsdURBQW1CO0FBQ3BDLGlCQUFpQix1REFBbUI7QUFDcEMsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDJCQUEyQjtBQUNsRyxjQUFjO0FBQ2QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCLDRDQUFRO0FBQ2pDO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IseUJBQXlCLDRDQUFRO0FBQ2pDO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUTtBQUNsQztBQUNBLGlCQUFpQix1REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3F1ZXVlLmpzPzFkMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IEpvYiB9IGZyb20gJy4vam9iJztcbmltcG9ydCB7IFF1ZXVlR2V0dGVycyB9IGZyb20gJy4vcXVldWUtZ2V0dGVycyc7XG5pbXBvcnQgeyBSZXBlYXQgfSBmcm9tICcuL3JlcGVhdCc7XG5pbXBvcnQgeyBTcGFuS2luZCwgVGVsZW1ldHJ5QXR0cmlidXRlcyB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IEpvYlNjaGVkdWxlciB9IGZyb20gJy4vam9iLXNjaGVkdWxlcic7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbic7XG4vKipcbiAqIFF1ZXVlXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtZXRob2RzIHRvIGFkZCBqb2JzIHRvIGEgcXVldWUgYW5kIHNvbWUgb3RoZXIgaGlnaC1sZXZlbFxuICogYWRtaW5pc3RyYXRpb24gc3VjaCBhcyBwYXVzaW5nIG9yIGRlbGV0aW5nIHF1ZXVlcy5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGRhdGEgdGhhdCB0aGUgam9iIHdpbGwgcHJvY2Vzcy5cbiAqIEB0eXBlUGFyYW0gUmVzdWx0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSByZXN1bHQgb2YgdGhlIGpvYi5cbiAqIEB0eXBlUGFyYW0gTmFtZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbmFtZSBvZiB0aGUgam9iLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUXVldWUgfSBmcm9tICdidWxsbXEnO1xuICpcbiAqIGludGVyZmFjZSBNeURhdGFUeXBlIHtcbiAqICBmb286IHN0cmluZztcbiAqIH1cbiAqXG4gKiBpbnRlcmZhY2UgTXlSZXN1bHRUeXBlIHtcbiAqICAgYmFyOiBzdHJpbmc7XG4gKiB9XG4gKlxuICogY29uc3QgcXVldWUgPSBuZXcgUXVldWU8TXlEYXRhVHlwZSwgTXlSZXN1bHRUeXBlLCBcImJsdWVcIiB8IFwiYnJvd25cIj4oJ215UXVldWUnKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUXVldWUgZXh0ZW5kcyBRdWV1ZUdldHRlcnMge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdHMsIENvbm5lY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihuYW1lLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgQ29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMudG9rZW4gPSB2NCgpO1xuICAgICAgICB0aGlzLmxpYk5hbWUgPSAnYnVsbG1xJztcbiAgICAgICAgdGhpcy5qb2JzT3B0cyA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5kZWZhdWx0Sm9iT3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgIHRoaXMud2FpdFVudGlsUmVhZHkoKVxuICAgICAgICAgICAgLnRoZW4oY2xpZW50ID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nICYmICEob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNraXBNZXRhc1VwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Lmhtc2V0KHRoaXMua2V5cy5tZXRhLCB0aGlzLm1ldGFWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgdGhpcyBlcnJvciB0byBhdm9pZCB3YXJuaW5ncy4gVGhlIGVycm9yIGNhbiBzdGlsbFxuICAgICAgICAgICAgLy8gYmUgcmVjZWl2ZWQgYnkgbGlzdGVuaW5nIHRvIGV2ZW50ICdlcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBpbnN0YW5jZSBjdXJyZW50IGRlZmF1bHQgam9iIG9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRKb2JPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5qb2JzT3B0cyk7XG4gICAgfVxuICAgIGdldCBtZXRhVmFsdWVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnb3B0cy5tYXhMZW5FdmVudHMnOiAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHJlYW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4TGVuKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxMDAwMCxcbiAgICAgICAgICAgIHZlcnNpb246IGAke3RoaXMubGliTmFtZX06JHt2ZXJzaW9ufWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsaWJyYXJ5IHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgbWV0YS5saWJyYXJ5IGZpZWxkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gYXdhaXQgY2xpZW50LmhnZXQodGhpcy5rZXlzLm1ldGEsICd2ZXJzaW9uJyk7XG4gICAgfVxuICAgIGdldCByZXBlYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQgPSBuZXcgUmVwZWF0KHRoaXMubmFtZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpLCB7IGNvbm5lY3Rpb246IGF3YWl0IHRoaXMuY2xpZW50IH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQub24oJ2Vycm9yJywgZSA9PiB0aGlzLmVtaXQuYmluZCh0aGlzLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgam9iU2NoZWR1bGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fam9iU2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fam9iU2NoZWR1bGVyID0gbmV3IEpvYlNjaGVkdWxlcih0aGlzLm5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKSwgeyBjb25uZWN0aW9uOiBhd2FpdCB0aGlzLmNsaWVudCB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fam9iU2NoZWR1bGVyLm9uKCdlcnJvcicsIGUgPT4gdGhpcy5lbWl0LmJpbmQodGhpcywgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9qb2JTY2hlZHVsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGdsb2JhbCBjb25jdXJyZW5jeSB2YWx1ZS5cbiAgICAgKiBSZXR1cm5zIG51bGwgaW4gY2FzZSBubyB2YWx1ZSBpcyBzZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R2xvYmFsQ29uY3VycmVuY3koKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICBjb25zdCBjb25jdXJyZW5jeSA9IGF3YWl0IGNsaWVudC5oZ2V0KHRoaXMua2V5cy5tZXRhLCAnY29uY3VycmVuY3knKTtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGNvbmN1cnJlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGFuZCBzZXQgZ2xvYmFsIGNvbmN1cnJlbmN5IHZhbHVlLlxuICAgICAqIEBwYXJhbSBjb25jdXJyZW5jeSAtIE1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBqb2JzIHRoYXQgdGhlIHdvcmtlcnMgY2FuIGhhbmRsZS5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIHNldHRpbmcgdGhpcyB2YWx1ZSB0byAxIGVuc3VyZXMgdGhhdCBubyBtb3JlIHRoYW4gb25lIGpvYlxuICAgICAqIGlzIHByb2Nlc3NlZCBhdCBhbnkgZ2l2ZW4gdGltZS4gSWYgdGhpcyBsaW1pdCBpcyBub3QgZGVmaW5lZCwgdGhlcmUgd2lsbCBiZSBub1xuICAgICAqIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBqb2JzLlxuICAgICAqL1xuICAgIGFzeW5jIHNldEdsb2JhbENvbmN1cnJlbmN5KGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmhzZXQodGhpcy5rZXlzLm1ldGEsICdjb25jdXJyZW5jeScsIGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGFuZCBzZXQgcmF0ZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0gbWF4IC0gTWF4IG51bWJlciBvZiBqb2JzIHRvIHByb2Nlc3MgaW4gdGhlIHRpbWUgcGVyaW9kIHNwZWNpZmllZCBpbiBgZHVyYXRpb25gXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIC0gVGltZSBpbiBtaWxsaXNlY29uZHMuIER1cmluZyB0aGlzIHRpbWUsIGEgbWF4aW11bSBvZiBgbWF4YCBqb2JzIHdpbGwgYmUgcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHNldEdsb2JhbFJhdGVMaW1pdChtYXgsIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmhzZXQodGhpcy5rZXlzLm1ldGEsICdtYXgnLCBtYXgsICdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGdsb2JhbCBjb25jdXJyZW5jeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVHbG9iYWxDb25jdXJyZW5jeSgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuaGRlbCh0aGlzLmtleXMubWV0YSwgJ2NvbmN1cnJlbmN5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgam9iIHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIEFyYml0cmFyeSBkYXRhIHRvIGFwcGVuZCB0byB0aGUgam9iLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gSm9iIG9wdGlvbnMgdGhhdCBhZmZlY3RzIGhvdyB0aGUgam9iIGlzIGdvaW5nIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBhZGQobmFtZSwgZGF0YSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjZShTcGFuS2luZC5QUk9EVUNFUiwgJ2FkZCcsIGAke3RoaXMubmFtZX0uJHtuYW1lfWAsIGFzeW5jIChzcGFuLCBzcmNQcm9wYWdhdGlvbk1lZGF0YWRhKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoc3JjUHJvcGFnYXRpb25NZWRhdGFkYSAmJiAhKChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy50ZWxlbWV0cnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbWl0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZWxlbWV0cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzcmNQcm9wYWdhdGlvbk1lZGF0YWRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgdGVsZW1ldHJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgdGhpcy5hZGRKb2IobmFtZSwgZGF0YSwgb3B0cyk7XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iTmFtZV06IG5hbWUsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iSWRdOiBqb2IuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBqb2I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRKb2IgaXMgYSB0ZWxlbWV0cnkgZnJlZSB2ZXJzaW9uIG9mIHRoZSBhZGQgbWV0aG9kLCB1c2VmdWwgaW4gb3JkZXIgdG8gd3JhcCBpdFxuICAgICAqIHdpdGggY3VzdG9tIHRlbGVtZXRyeSBvbiBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBqb2IgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBkYXRhIC0gQXJiaXRyYXJ5IGRhdGEgdG8gYXBwZW5kIHRvIHRoZSBqb2IuXG4gICAgICogQHBhcmFtIG9wdHMgLSBKb2Igb3B0aW9ucyB0aGF0IGFmZmVjdHMgaG93IHRoZSBqb2IgaXMgZ29pbmcgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgSm9iXG4gICAgICovXG4gICAgYXN5bmMgYWRkSm9iKG5hbWUsIGRhdGEsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBlYXQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlcGVhdC5lbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCtuZXcgRGF0ZShvcHRzLnJlcGVhdC5lbmREYXRlKSA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmQgZGF0ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHRpbWVzdGFtcCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5yZXBlYXQpLnVwZGF0ZVJlcGVhdGFibGVKb2IobmFtZSwgZGF0YSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmpvYnNPcHRzKSwgb3B0cyksIHsgb3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBqb2JJZCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5qb2JJZDtcbiAgICAgICAgICAgIGlmIChqb2JJZCA9PSAnMCcgfHwgKGpvYklkID09PSBudWxsIHx8IGpvYklkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBqb2JJZC5zdGFydHNXaXRoKCcwOicpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpvYklkIGNhbm5vdCBiZSAnMCcgb3Igc3RhcnQgd2l0aCAwOlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IGF3YWl0IHRoaXMuSm9iLmNyZWF0ZSh0aGlzLCBuYW1lLCBkYXRhLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5qb2JzT3B0cyksIG9wdHMpLCB7IGpvYklkIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnd2FpdGluZycsIGpvYik7XG4gICAgICAgICAgICByZXR1cm4gam9iO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXJyYXkgb2Ygam9icyB0byB0aGUgcXVldWUuIFRoaXMgbWV0aG9kIG1heSBiZSBmYXN0ZXIgdGhhbiBhZGRpbmdcbiAgICAgKiBvbmUgam9iIGF0IGEgdGltZSBpbiBhIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYnMgLSBUaGUgYXJyYXkgb2Ygam9icyB0byBhZGQgdG8gdGhlIHF1ZXVlLiBFYWNoIGpvYiBpcyBkZWZpbmVkIGJ5IDNcbiAgICAgKiBwcm9wZXJ0aWVzLCAnbmFtZScsICdkYXRhJyBhbmQgJ29wdHMnLiBUaGV5IGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmUgYXMgJ1F1ZXVlLmFkZCcuXG4gICAgICovXG4gICAgYXN5bmMgYWRkQnVsayhqb2JzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNlKFNwYW5LaW5kLlBST0RVQ0VSLCAnYWRkQnVsaycsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4sIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpID0+IHtcbiAgICAgICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuQnVsa05hbWVzXTogam9icy5tYXAoam9iID0+IGpvYi5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuQnVsa0NvdW50XTogam9icy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5Kb2IuY3JlYXRlQnVsayh0aGlzLCBqb2JzLm1hcChqb2IgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGxldCB0ZWxlbWV0cnkgPSAoX2EgPSBqb2Iub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRlbGVtZXRyeTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjUHJvcGFnYXRpb25NZWRhdGFkYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbWl0Q29udGV4dCA9IChfYyA9IChfYiA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub21pdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbGVtZXRyeU1ldGFkYXRhID0gKChfZSA9IChfZCA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWV0YWRhdGEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIW9taXRDb250ZXh0ICYmIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVsZW1ldHJ5TWV0YWRhdGEgfHwgb21pdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogdGVsZW1ldHJ5TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb21pdENvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGpvYi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBqb2IuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuam9ic09wdHMpLCBqb2Iub3B0cyksIHsgam9iSWQ6IChfZiA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuam9iSWQsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBzZXJ0cyBhIHNjaGVkdWxlci5cbiAgICAgKlxuICAgICAqIEEgc2NoZWR1bGVyIGlzIGEgam9iIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGpvYnMgYXQgYSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBVcHNlcnRpbmcgYSBzY2hlZHVsZXIgd2lsbCBjcmVhdGUgYSBuZXcgam9iIHNjaGVkdWxlciBvciB1cGRhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICAgICAqIEl0IHdpbGwgYWxzbyBjcmVhdGUgdGhlIGZpcnN0IGpvYiBiYXNlZCBvbiB0aGUgcmVwZWF0IG9wdGlvbnMgYW5kIGRlbGF5ZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVW5pcXVlIGtleSBmb3IgdGhlIHJlcGVhdGFibGUgam9iIG1ldGEuXG4gICAgICogQHBhcmFtIHJlcGVhdE9wdHMgLSBSZXBlYXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBqb2JUZW1wbGF0ZSAtIEpvYiB0ZW1wbGF0ZS4gSWYgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIGZvciBhbGwgdGhlIGpvYnNcbiAgICAgKiBjcmVhdGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCBqb2IgdG8gYmUgc2NoZWR1bGVkICh3b3VsZCBub3JtYWxseSBiZSBpbiBkZWxheWVkIHN0YXRlKS5cbiAgICAgKi9cbiAgICBhc3luYyB1cHNlcnRKb2JTY2hlZHVsZXIoam9iU2NoZWR1bGVySWQsIHJlcGVhdE9wdHMsIGpvYlRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChyZXBlYXRPcHRzLmVuZERhdGUpIHtcbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUocmVwZWF0T3B0cy5lbmREYXRlKSA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZCBkYXRlIG11c3QgYmUgZ3JlYXRlciB0aGFuIGN1cnJlbnQgdGltZXN0YW1wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmpvYlNjaGVkdWxlcikudXBzZXJ0Sm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkLCByZXBlYXRPcHRzLCAoX2EgPSBqb2JUZW1wbGF0ZSA9PT0gbnVsbCB8fCBqb2JUZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogam9iVGVtcGxhdGUubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogam9iU2NoZWR1bGVySWQsIChfYiA9IGpvYlRlbXBsYXRlID09PSBudWxsIHx8IGpvYlRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBqb2JUZW1wbGF0ZS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmpvYnNPcHRzKSwgam9iVGVtcGxhdGUgPT09IG51bGwgfHwgam9iVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGpvYlRlbXBsYXRlLm9wdHMpLCB7IG92ZXJyaWRlOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGhpcyBxdWV1ZSBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqIFdlIHVzZSBhbiBhdG9taWMgUkVOQU1FIG9wZXJhdGlvbiBvbiB0aGUgd2FpdCBxdWV1ZS4gU2luY2VcbiAgICAgKiB3ZSBoYXZlIGJsb2NraW5nIGNhbGxzIHdpdGggQlJQT1BMUFVTSCBvbiB0aGUgd2FpdCBxdWV1ZSwgYXMgbG9uZyBhcyB0aGUgcXVldWVcbiAgICAgKiBpcyByZW5hbWVkIHRvICdwYXVzZWQnLCBubyBuZXcgam9icyB3aWxsIGJlIHByb2Nlc3NlZCAodGhlIGN1cnJlbnQgb25lc1xuICAgICAqIHdpbGwgcnVuIHVudGlsIGZpbmFsaXplZCkuXG4gICAgICpcbiAgICAgKiBBZGRpbmcgam9icyByZXF1aXJlcyBhIExVQSBzY3JpcHQgdG8gY2hlY2sgZmlyc3QgaWYgdGhlIHBhdXNlZCBsaXN0IGV4aXN0XG4gICAgICogYW5kIGluIHRoYXQgY2FzZSBpdCB3aWxsIGFkZCBpdCB0aGVyZSBpbnN0ZWFkIG9mIHRoZSB3YWl0IGxpc3QuXG4gICAgICovXG4gICAgYXN5bmMgcGF1c2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhY2UoU3BhbktpbmQuSU5URVJOQUwsICdwYXVzZScsIHRoaXMubmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRzLnBhdXNlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBxdWV1ZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAnY2xvc2UnLCB0aGlzLm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZXBlYXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzdXBlci5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSByYXRlIGxpbWl0IHRvIGJlIGFjdGl2ZSBmb3IgdGhlIG5leHQgam9icy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBpcmVUaW1lTXMgLSBleHBpcmUgdGltZSBpbiBtcyBvZiB0aGlzIHJhdGUgbGltaXQuXG4gICAgICovXG4gICAgYXN5bmMgcmF0ZUxpbWl0KGV4cGlyZVRpbWVNcykge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAncmF0ZUxpbWl0JywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlUmF0ZUxpbWl0XTogZXhwaXJlVGltZU1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50aGVuKGNsaWVudCA9PiBjbGllbnQuc2V0KHRoaXMua2V5cy5saW1pdGVyLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgJ1BYJywgZXhwaXJlVGltZU1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mIHRoaXMgcXVldWUgZ2xvYmFsbHkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIHJldmVyc2VzIHRoZSBwYXVzZSBvcGVyYXRpb24gYnkgcmVzdW1pbmcgdGhlIHByb2Nlc3Npbmcgb2YgdGhlXG4gICAgICogcXVldWUuXG4gICAgICovXG4gICAgYXN5bmMgcmVzdW1lKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAncmVzdW1lJywgdGhpcy5uYW1lLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjcmlwdHMucGF1c2UoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgaXNQYXVzZWQoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICBjb25zdCBwYXVzZWRLZXlFeGlzdHMgPSBhd2FpdCBjbGllbnQuaGV4aXN0cyh0aGlzLmtleXMubWV0YSwgJ3BhdXNlZCcpO1xuICAgICAgICByZXR1cm4gcGF1c2VkS2V5RXhpc3RzID09PSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBtYXhlZC5cbiAgICAgKi9cbiAgICBpc01heGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLmlzTWF4ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZXBlYXRhYmxlIG1ldGEgam9icy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ni4gVXNlIGdldEpvYlNjaGVkdWxlcnMgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCAtIE9mZnNldCBvZiBmaXJzdCBqb2IgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBlbmQgLSBPZmZzZXQgb2YgbGFzdCBqb2IgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBhc2MgLSBEZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIGpvYnMgYXJlIHJldHVybmVkIGJhc2VkIG9uIHRoZWlyXG4gICAgICogbmV4dCBleGVjdXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXBlYXRhYmxlSm9icyhzdGFydCwgZW5kLCBhc2MpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlcGVhdCkuZ2V0UmVwZWF0YWJsZUpvYnMoc3RhcnQsIGVuZCwgYXNjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEpvYiBTY2hlZHVsZXIgYnkgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIGlkZW50aWZpZXIgb2Ygc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEpvYlNjaGVkdWxlcihpZCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuam9iU2NoZWR1bGVyKS5nZXRTY2hlZHVsZXIoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIEpvYiBTY2hlZHVsZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBPZmZzZXQgb2YgZmlyc3Qgc2NoZWR1bGVyIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gZW5kIC0gT2Zmc2V0IG9mIGxhc3Qgc2NoZWR1bGVyIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gYXNjIC0gRGV0ZXJtaW5lIHRoZSBvcmRlciBpbiB3aGljaCBzY2hlZHVsZXJzIGFyZSByZXR1cm5lZCBiYXNlZCBvbiB0aGVpclxuICAgICAqIG5leHQgZXhlY3V0aW9uIHRpbWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Sm9iU2NoZWR1bGVycyhzdGFydCwgZW5kLCBhc2MpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmpvYlNjaGVkdWxlcikuZ2V0Sm9iU2NoZWR1bGVycyhzdGFydCwgZW5kLCBhc2MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGpvYiBzY2hlZHVsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBqb2Igc2NoZWR1bGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRKb2JTY2hlZHVsZXJzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5qb2JTY2hlZHVsZXIpLmdldFNjaGVkdWxlcnNDb3VudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcmVwZWF0YWJsZSBqb2IuXG4gICAgICpcbiAgICAgKiBOb3RlOiB5b3UgbmVlZCB0byB1c2UgdGhlIGV4YWN0IHNhbWUgcmVwZWF0T3B0cyB3aGVuIGRlbGV0aW5nIGEgcmVwZWF0YWJsZSBqb2JcbiAgICAgKiB0aGFuIHdoZW4gYWRkaW5nIGl0LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY2LiBVc2UgcmVtb3ZlSm9iU2NoZWR1bGVyIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAc2VlIHJlbW92ZVJlcGVhdGFibGVCeUtleVxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBKb2IgbmFtZVxuICAgICAqIEBwYXJhbSByZXBlYXRPcHRzIC0gUmVwZWF0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gam9iSWQgLSBKb2IgaWQgdG8gcmVtb3ZlLiBJZiBub3QgcHJvdmlkZWQsIGFsbCBqb2JzIHdpdGggdGhlIHNhbWUgcmVwZWF0T3B0c1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZShuYW1lLCByZXBlYXRPcHRzLCBqb2JJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3JlbW92ZVJlcGVhdGFibGUnLCBgJHt0aGlzLm5hbWV9LiR7bmFtZX1gLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYk5hbWVdOiBuYW1lLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkXTogam9iSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcGVhdCA9IGF3YWl0IHRoaXMucmVwZWF0O1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGF3YWl0IHJlcGVhdC5yZW1vdmVSZXBlYXRhYmxlKG5hbWUsIHJlcGVhdE9wdHMsIGpvYklkKTtcbiAgICAgICAgICAgIHJldHVybiAhcmVtb3ZlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVtb3ZlcyBhIGpvYiBzY2hlZHVsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gam9iU2NoZWR1bGVySWQgLSBpZGVudGlmaWVyIG9mIHRoZSBqb2Igc2NoZWR1bGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVKb2JTY2hlZHVsZXIoam9iU2NoZWR1bGVySWQpIHtcbiAgICAgICAgY29uc3Qgam9iU2NoZWR1bGVyID0gYXdhaXQgdGhpcy5qb2JTY2hlZHVsZXI7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBhd2FpdCBqb2JTY2hlZHVsZXIucmVtb3ZlSm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkKTtcbiAgICAgICAgcmV0dXJuICFyZW1vdmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZGVib3VuY2Uga2V5LlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSByZW1vdmVEZWR1cGxpY2F0aW9uS2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBkZWJvdW5jZSBpZGVudGlmaWVyXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlRGVib3VuY2VLZXkoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2UoU3BhbktpbmQuSU5URVJOQUwsICdyZW1vdmVEZWJvdW5jZUtleScsIGAke3RoaXMubmFtZX1gLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYktleV06IGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGVsKGAke3RoaXMua2V5cy5kZX06JHtpZH1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkZWR1cGxpY2F0aW9uIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVEZWR1cGxpY2F0aW9uS2V5KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAncmVtb3ZlRGVkdXBsaWNhdGlvbktleScsIGAke3RoaXMubmFtZX1gLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkRlZHVwbGljYXRpb25LZXldOiBpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LmRlbChgJHt0aGlzLmtleXMuZGV9OiR7aWR9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHJhdGUgbGltaXQga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZVJhdGVMaW1pdEtleSgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGVsKHRoaXMua2V5cy5saW1pdGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJlcGVhdGFibGUgam9iIGJ5IGl0cyBrZXkuIE5vdGUgdGhhdCB0aGUga2V5IGlzIHRoZSBvbmUgdXNlZFxuICAgICAqIHRvIHN0b3JlIHRoZSByZXBlYXRhYmxlIGpvYiBtZXRhZGF0YSBhbmQgbm90IG9uZSBvZiB0aGUgam9iIGl0ZXJhdGlvbnNcbiAgICAgKiB0aGVtc2VsdmVzLiBZb3UgY2FuIHVzZSBcImdldFJlcGVhdGFibGVKb2JzXCIgaW4gb3JkZXIgdG8gZ2V0IHRoZSBrZXlzLlxuICAgICAqXG4gICAgICogQHNlZSBnZXRSZXBlYXRhYmxlSm9ic1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY2LiBVc2UgcmVtb3ZlSm9iU2NoZWR1bGVyIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVwZWF0Sm9iS2V5IC0gVG8gdGhlIHJlcGVhdGFibGUgam9iLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZUJ5S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3JlbW92ZVJlcGVhdGFibGVCeUtleScsIGAke3RoaXMubmFtZX1gLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYktleV06IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVwZWF0ID0gYXdhaXQgdGhpcy5yZXBlYXQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkID0gYXdhaXQgcmVwZWF0LnJlbW92ZVJlcGVhdGFibGVCeUtleShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuICFyZW1vdmVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gam9iIGZyb20gdGhlIHF1ZXVlIGFzIHdlbGwgYXMgYWxsIGl0c1xuICAgICAqIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqb2JJZCAtIFRoZSBpZCBvZiB0aGUgam9iIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyB0byByZW1vdmUgYSBqb2JcbiAgICAgKiBAcmV0dXJucyAxIGlmIGl0IG1hbmFnZWQgdG8gcmVtb3ZlIHRoZSBqb2Igb3IgMCBpZiB0aGUgam9iIG9yXG4gICAgICogYW55IG9mIGl0cyBkZXBlbmRlbmNpZXMgd2VyZSBsb2NrZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlKGpvYklkLCB7IHJlbW92ZUNoaWxkcmVuID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2UoU3BhbktpbmQuSU5URVJOQUwsICdyZW1vdmUnLCB0aGlzLm5hbWUsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iSWRdOiBqb2JJZCxcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Kb2JPcHRpb25zXTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2NyaXB0cy5yZW1vdmUoam9iSWQsIHJlbW92ZUNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGpvYidzIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYklkIC0gVGhlIGlkIG9mIHRoZSBqb2IgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHByb2dyZXNzIC0gTnVtYmVyIG9yIG9iamVjdCB0byBiZSBzYXZlZCBhcyBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVKb2JQcm9ncmVzcyhqb2JJZCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3VwZGF0ZUpvYlByb2dyZXNzJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkXTogam9iSWQsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iUHJvZ3Jlc3NdOiBKU09OLnN0cmluZ2lmeShwcm9ncmVzcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NyaXB0cy51cGRhdGVQcm9ncmVzcyhqb2JJZCwgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyBvbmUgcm93IG9mIGpvYidzIGxvZyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvYklkIC0gVGhlIGpvYiBpZCB0byBsb2cgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gbG9nUm93IC0gU3RyaW5nIHdpdGggbG9nIGRhdGEgdG8gYmUgbG9nZ2VkLlxuICAgICAqIEBwYXJhbSBrZWVwTG9ncyAtIE1heCBudW1iZXIgb2YgbG9nIGVudHJpZXMgdG8ga2VlcCAoMCBmb3IgdW5saW1pdGVkKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2YgbG9nIGVudHJpZXMgZm9yIHRoaXMgam9iIHNvIGZhci5cbiAgICAgKi9cbiAgICBhc3luYyBhZGRKb2JMb2coam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpIHtcbiAgICAgICAgcmV0dXJuIEpvYi5hZGRKb2JMb2codGhpcywgam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmFpbnMgdGhlIHF1ZXVlLCBpLmUuLCByZW1vdmVzIGFsbCBqb2JzIHRoYXQgYXJlIHdhaXRpbmdcbiAgICAgKiBvciBkZWxheWVkLCBidXQgbm90IGFjdGl2ZSwgY29tcGxldGVkIG9yIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWxheWVkIC0gUGFzcyB0cnVlIGlmIGl0IHNob3VsZCBhbHNvIGNsZWFuIHRoZVxuICAgICAqIGRlbGF5ZWQgam9icy5cbiAgICAgKi9cbiAgICBhc3luYyBkcmFpbihkZWxheWVkID0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ2RyYWluJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlRHJhaW5EZWxheV06IGRlbGF5ZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NyaXB0cy5kcmFpbihkZWxheWVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyBqb2JzIGZyb20gYSBxdWV1ZS4gU2ltaWxhciB0byBkcmFpbiBidXQga2VlcHMgam9icyB3aXRoaW4gYSBjZXJ0YWluXG4gICAgICogZ3JhY2UgcGVyaW9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyYWNlIC0gVGhlIGdyYWNlIHBlcmlvZCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0gbGltaXQgLSBNYXggbnVtYmVyIG9mIGpvYnMgdG8gY2xlYW5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGpvYiB0byBjbGVhblxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgY29tcGxldGVkLCB3YWl0LCBhY3RpdmUsIHBhdXNlZCwgZGVsYXllZCwgZmFpbGVkLiBEZWZhdWx0cyB0byBjb21wbGV0ZWQuXG4gICAgICogQHJldHVybnMgSWQgam9icyBmcm9tIHRoZSBkZWxldGVkIHJlY29yZHNcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhbihncmFjZSwgbGltaXQsIHR5cGUgPSAnY29tcGxldGVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ2NsZWFuJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF4Q291bnQgPSBsaW1pdCB8fCBJbmZpbml0eTtcbiAgICAgICAgICAgIGNvbnN0IG1heENvdW50UGVyQ2FsbCA9IE1hdGgubWluKDEwMDAwLCBtYXhDb3VudCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpIC0gZ3JhY2U7XG4gICAgICAgICAgICBsZXQgZGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWRKb2JzSWRzID0gW107XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgJ3dhaXRpbmcnIHRvICd3YWl0JyBmb3IgY29uc2lzdGVuY3kgd2l0aCBpbnRlcm5hbCBSZWRpcyBrZXlzXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVHlwZSA9IHR5cGUgPT09ICd3YWl0aW5nJyA/ICd3YWl0JyA6IHR5cGU7XG4gICAgICAgICAgICB3aGlsZSAoZGVsZXRlZENvdW50IDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2JzSWRzID0gYXdhaXQgdGhpcy5zY3JpcHRzLmNsZWFuSm9ic0luU2V0KG5vcm1hbGl6ZWRUeXBlLCB0aW1lc3RhbXAsIG1heENvdW50UGVyQ2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbGVhbmVkJywgam9ic0lkcywgbm9ybWFsaXplZFR5cGUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCArPSBqb2JzSWRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBkZWxldGVkSm9ic0lkcy5wdXNoKC4uLmpvYnNJZHMpO1xuICAgICAgICAgICAgICAgIGlmIChqb2JzSWRzLmxlbmd0aCA8IG1heENvdW50UGVyQ2FsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuUXVldWVHcmFjZV06IGdyYWNlLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYlR5cGVdOiB0eXBlLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlQ2xlYW5MaW1pdF06IG1heENvdW50LFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkc106IGRlbGV0ZWRKb2JzSWRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlZEpvYnNJZHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZWx5IGRlc3Ryb3lzIHRoZSBxdWV1ZSBhbmQgYWxsIG9mIGl0cyBjb250ZW50cyBpcnJldmVyc2libHkuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCAqcGF1c2UqIHRoZSBxdWV1ZSBhbmQgcmVxdWlyZXMgdGhhdCB0aGVyZSBhcmUgbm9cbiAgICAgKiBhY3RpdmUgam9icy4gSXQgaXMgcG9zc2libGUgdG8gYnlwYXNzIHRoaXMgcmVxdWlyZW1lbnQsIGkuZS4gbm90XG4gICAgICogaGF2aW5nIGFjdGl2ZSBqb2JzIHVzaW5nIHRoZSBcImZvcmNlXCIgb3B0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRpb24gcmVxdWlyZXMgdG8gaXRlcmF0ZSBvbiBhbGwgdGhlIGpvYnMgc3RvcmVkIGluIHRoZSBxdWV1ZVxuICAgICAqIGFuZCBjYW4gYmUgc2xvdyBmb3IgdmVyeSBsYXJnZSBxdWV1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9ibGl0ZXJhdGUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBvYmxpdGVyYXRlKG9wdHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ29ibGl0ZXJhdGUnLCB0aGlzLm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IGF3YWl0IHRoaXMuc2NyaXB0cy5vYmxpdGVyYXRlKE9iamVjdC5hc3NpZ24oeyBmb3JjZTogZmFsc2UsIGNvdW50OiAxMDAwIH0sIG9wdHMpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyeSBhbGwgdGhlIGZhaWxlZCBvciBjb21wbGV0ZWQgam9icy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqICAgLSBjb3VudCAgbnVtYmVyIHRvIGxpbWl0IGhvdyBtYW55IGpvYnMgd2lsbCBiZSBtb3ZlZCB0byB3YWl0IHN0YXR1cyBwZXIgaXRlcmF0aW9uLFxuICAgICAqICAgLSBzdGF0ZSAgZmFpbGVkIGJ5IGRlZmF1bHQgb3IgY29tcGxldGVkLlxuICAgICAqICAgLSB0aW1lc3RhbXAgZnJvbSB3aGljaCB0aW1lc3RhbXAgdG8gc3RhcnQgbW92aW5nIGpvYnMgdG8gd2FpdCBzdGF0dXMsIGRlZmF1bHQgRGF0ZS5ub3coKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcmV0cnlKb2JzKG9wdHMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLlBST0RVQ0VSLCAncmV0cnlKb2JzJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlT3B0aW9uc106IEpTT04uc3RyaW5naWZ5KG9wdHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBhd2FpdCB0aGlzLnNjcmlwdHMucmV0cnlKb2JzKG9wdHMuc3RhdGUsIG9wdHMuY291bnQsIG9wdHMudGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9tb3RlIGFsbCB0aGUgZGVsYXllZCBqb2JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogICAtIGNvdW50ICBudW1iZXIgdG8gbGltaXQgaG93IG1hbnkgam9icyB3aWxsIGJlIG1vdmVkIHRvIHdhaXQgc3RhdHVzIHBlciBpdGVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcHJvbW90ZUpvYnMob3B0cyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudHJhY2UoU3BhbktpbmQuSU5URVJOQUwsICdwcm9tb3RlSm9icycsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5RdWV1ZU9wdGlvbnNdOiBKU09OLnN0cmluZ2lmeShvcHRzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gYXdhaXQgdGhpcy5zY3JpcHRzLnByb21vdGVKb2JzKG9wdHMuY291bnQpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW0gdGhlIGV2ZW50IHN0cmVhbSB0byBhbiBhcHByb3hpbWF0ZWx5IG1heExlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXhMZW5ndGggLVxuICAgICAqL1xuICAgIGFzeW5jIHRyaW1FdmVudHMobWF4TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAndHJpbUV2ZW50cycsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5RdWV1ZUV2ZW50TWF4TGVuZ3RoXTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjbGllbnQueHRyaW0odGhpcy5rZXlzLmV2ZW50cywgJ01BWExFTicsICd+JywgbWF4TGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBvbGQgcHJpb3JpdHkgaGVscGVyIGtleS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVEZXByZWNhdGVkUHJpb3JpdHlLZXkoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50LmRlbCh0aGlzLnRvS2V5KCdwcmlvcml0eScpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/redis-connection.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RedisConnection: () => (/* binding */ RedisConnection)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ioredis */ \"(rsc)/./node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ioredis/built/utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../version */ \"(rsc)/./node_modules/bullmq/dist/esm/version.js\");\n/* harmony import */ var _scripts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js\");\n\n\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\n\n\nconst overrideMessage = [\n    'BullMQ: WARNING! Your redis options maxRetriesPerRequest must be null',\n    'and will be overridden by BullMQ.',\n].join(' ');\nconst deprecationMessage = 'BullMQ: Your redis options maxRetriesPerRequest must be null.';\nclass RedisConnection extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(opts, extraOptions) {\n        super();\n        this.extraOptions = extraOptions;\n        this.capabilities = {\n            canDoubleTimeout: false,\n            canBlockFor1Ms: true,\n        };\n        this.status = 'initializing';\n        this.packageVersion = _version__WEBPACK_IMPORTED_MODULE_4__.version;\n        // Set extra options defaults\n        this.extraOptions = Object.assign({ shared: false, blocking: true, skipVersionCheck: false, skipWaitingForReady: false }, extraOptions);\n        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisInstance)(opts)) {\n            this.checkBlockingOptions(overrideMessage, opts);\n            this.opts = Object.assign({ port: 6379, host: '127.0.0.1', retryStrategy: function (times) {\n                    return Math.max(Math.min(Math.exp(times), 20000), 1000);\n                } }, opts);\n            if (this.extraOptions.blocking) {\n                this.opts.maxRetriesPerRequest = null;\n            }\n        }\n        else {\n            this._client = opts;\n            // Test if the redis instance is using keyPrefix\n            // and if so, throw an error.\n            if (this._client.options.keyPrefix) {\n                throw new Error('BullMQ: ioredis does not support ioredis prefixes, use the prefix option instead.');\n            }\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisCluster)(this._client)) {\n                this.opts = this._client.options.redisOptions;\n            }\n            else {\n                this.opts = this._client.options;\n            }\n            this.checkBlockingOptions(deprecationMessage, this.opts, true);\n        }\n        this.skipVersionCheck =\n            (extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.skipVersionCheck) ||\n                !!(this.opts && this.opts.skipVersionCheck);\n        this.handleClientError = (err) => {\n            this.emit('error', err);\n        };\n        this.handleClientClose = () => {\n            this.emit('close');\n        };\n        this.handleClientReady = () => {\n            this.emit('ready');\n        };\n        this.initializing = this.init();\n        this.initializing.catch(err => this.emit('error', err));\n    }\n    checkBlockingOptions(msg, options, throwError = false) {\n        if (this.extraOptions.blocking && options && options.maxRetriesPerRequest) {\n            if (throwError) {\n                throw new Error(msg);\n            }\n            else {\n                console.error(msg);\n            }\n        }\n    }\n    /**\n     * Waits for a redis client to be ready.\n     * @param redis - client\n     */\n    static async waitUntilReady(client) {\n        if (client.status === 'ready') {\n            return;\n        }\n        if (client.status === 'wait') {\n            return client.connect();\n        }\n        if (client.status === 'end') {\n            throw new Error(ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_CLOSED_ERROR_MSG);\n        }\n        let handleReady;\n        let handleEnd;\n        let handleError;\n        try {\n            await new Promise((resolve, reject) => {\n                let lastError;\n                handleError = (err) => {\n                    lastError = err;\n                };\n                handleReady = () => {\n                    resolve();\n                };\n                handleEnd = () => {\n                    if (client.status !== 'end') {\n                        reject(lastError || new Error(ioredis_built_utils__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_CLOSED_ERROR_MSG));\n                    }\n                    else {\n                        if (lastError) {\n                            reject(lastError);\n                        }\n                        else {\n                            // when custon 'end' status is set we already closed\n                            resolve();\n                        }\n                    }\n                };\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(client, 3);\n                client.once('ready', handleReady);\n                client.on('end', handleEnd);\n                client.once('error', handleError);\n            });\n        }\n        finally {\n            client.removeListener('end', handleEnd);\n            client.removeListener('error', handleError);\n            client.removeListener('ready', handleReady);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(client, 3);\n        }\n    }\n    get client() {\n        return this.initializing;\n    }\n    loadCommands(packageVersion, providedScripts) {\n        const finalScripts = providedScripts || _scripts__WEBPACK_IMPORTED_MODULE_5__;\n        for (const property in finalScripts) {\n            // Only define the command if not already defined\n            const commandName = `${finalScripts[property].name}:${packageVersion}`;\n            if (!this._client[commandName]) {\n                this._client.defineCommand(commandName, {\n                    numberOfKeys: finalScripts[property].keys,\n                    lua: finalScripts[property].content,\n                });\n            }\n        }\n    }\n    async init() {\n        if (!this._client) {\n            const _a = this.opts, { url } = _a, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__rest)(_a, [\"url\"]);\n            this._client = url ? new (ioredis__WEBPACK_IMPORTED_MODULE_1___default())(url, rest) : new (ioredis__WEBPACK_IMPORTED_MODULE_1___default())(rest);\n        }\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(this._client, 3);\n        this._client.on('error', this.handleClientError);\n        // ioredis treats connection errors as a different event ('close')\n        this._client.on('close', this.handleClientClose);\n        this._client.on('ready', this.handleClientReady);\n        if (!this.extraOptions.skipWaitingForReady) {\n            await RedisConnection.waitUntilReady(this._client);\n        }\n        this.loadCommands(this.packageVersion);\n        if (this._client['status'] !== 'end') {\n            this.version = await this.getRedisVersion();\n            if (this.skipVersionCheck !== true && !this.closing) {\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, RedisConnection.minimumVersion)) {\n                    throw new Error(`Redis version needs to be greater or equal than ${RedisConnection.minimumVersion} ` +\n                        `Current: ${this.version}`);\n                }\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, RedisConnection.recommendedMinimumVersion)) {\n                    console.warn(`It is highly recommended to use a minimum Redis version of ${RedisConnection.recommendedMinimumVersion}\n             Current: ${this.version}`);\n                }\n            }\n            this.capabilities = {\n                canDoubleTimeout: !(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, '6.0.0'),\n                canBlockFor1Ms: !(0,_utils__WEBPACK_IMPORTED_MODULE_3__.isRedisVersionLowerThan)(this.version, '7.0.8'),\n            };\n            this.status = 'ready';\n        }\n        return this._client;\n    }\n    async disconnect(wait = true) {\n        const client = await this.client;\n        if (client.status !== 'end') {\n            let _resolve, _reject;\n            if (!wait) {\n                return client.disconnect();\n            }\n            const disconnecting = new Promise((resolve, reject) => {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.increaseMaxListeners)(client, 2);\n                client.once('end', resolve);\n                client.once('error', reject);\n                _resolve = resolve;\n                _reject = reject;\n            });\n            client.disconnect();\n            try {\n                await disconnecting;\n            }\n            finally {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(client, 2);\n                client.removeListener('end', _resolve);\n                client.removeListener('error', _reject);\n            }\n        }\n    }\n    async reconnect() {\n        const client = await this.client;\n        return client.connect();\n    }\n    async close(force = false) {\n        if (!this.closing) {\n            const status = this.status;\n            this.status = 'closing';\n            this.closing = true;\n            try {\n                if (status === 'ready') {\n                    // Not sure if we need to wait for this\n                    await this.initializing;\n                }\n                if (!this.extraOptions.shared) {\n                    if (status == 'initializing' || force) {\n                        // If we have not still connected to Redis, we need to disconnect.\n                        this._client.disconnect();\n                    }\n                    else {\n                        await this._client.quit();\n                    }\n                    // As IORedis does not update this status properly, we do it ourselves.\n                    this._client['status'] = 'end';\n                }\n            }\n            catch (error) {\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.isNotConnectionError)(error)) {\n                    throw error;\n                }\n            }\n            finally {\n                this._client.off('error', this.handleClientError);\n                this._client.off('close', this.handleClientClose);\n                this._client.off('ready', this.handleClientReady);\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__.decreaseMaxListeners)(this._client, 3);\n                this.removeAllListeners();\n                this.status = 'closed';\n            }\n        }\n    }\n    async getRedisVersion() {\n        if (this.skipVersionCheck) {\n            return RedisConnection.minimumVersion;\n        }\n        const doc = await this._client.info();\n        const redisPrefix = 'redis_version:';\n        const maxMemoryPolicyPrefix = 'maxmemory_policy:';\n        const lines = doc.split(/\\r?\\n/);\n        let redisVersion;\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].indexOf(maxMemoryPolicyPrefix) === 0) {\n                const maxMemoryPolicy = lines[i].substr(maxMemoryPolicyPrefix.length);\n                if (maxMemoryPolicy !== 'noeviction') {\n                    console.warn(`IMPORTANT! Eviction policy is ${maxMemoryPolicy}. It should be \"noeviction\"`);\n                }\n            }\n            if (lines[i].indexOf(redisPrefix) === 0) {\n                redisVersion = lines[i].substr(redisPrefix.length);\n            }\n        }\n        return redisVersion;\n    }\n    get redisVersion() {\n        return this.version;\n    }\n}\nRedisConnection.minimumVersion = '5.0.0';\nRedisConnection.recommendedMinimumVersion = '6.2.0';\n//# sourceMappingURL=redis-connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcmVkaXMtY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ087QUFDTztBQUM3QztBQUNBO0FBQ2tFO0FBQ3FGO0FBQ2hHO0FBQ2pCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsZ0RBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBYztBQUM1QztBQUNBLDRDQUE0QyxvRkFBb0Y7QUFDaEksYUFBYSx1REFBZTtBQUM1QjtBQUNBLHdDQUF3QztBQUN4QztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEVBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0RUFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUNBQU87QUFDdkQ7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEIsR0FBRyxlQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxhQUFhLDZDQUFNO0FBQzdELHFDQUFxQyxnREFBTyxrQkFBa0IsZ0RBQU87QUFDckU7QUFDQSxRQUFRLDREQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUF1QjtBQUMzQyx1RkFBdUYsZ0NBQWdDO0FBQ3ZILG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0Esb0JBQW9CLCtEQUF1QjtBQUMzQywrRkFBK0Y7QUFDL0Ysd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtEQUF1QjtBQUMxRCxpQ0FBaUMsK0RBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3JlZGlzLWNvbm5lY3Rpb24uanM/MGFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIElPUmVkaXMgfSBmcm9tICdpb3JlZGlzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyB9IGZyb20gJ2lvcmVkaXMvYnVpbHQvdXRpbHMnO1xuaW1wb3J0IHsgZGVjcmVhc2VNYXhMaXN0ZW5lcnMsIGluY3JlYXNlTWF4TGlzdGVuZXJzLCBpc05vdENvbm5lY3Rpb25FcnJvciwgaXNSZWRpc0NsdXN0ZXIsIGlzUmVkaXNJbnN0YW5jZSwgaXNSZWRpc1ZlcnNpb25Mb3dlclRoYW4sIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgdmVyc2lvbiBhcyBwYWNrYWdlVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0ICogYXMgc2NyaXB0cyBmcm9tICcuLi9zY3JpcHRzJztcbmNvbnN0IG92ZXJyaWRlTWVzc2FnZSA9IFtcbiAgICAnQnVsbE1ROiBXQVJOSU5HISBZb3VyIHJlZGlzIG9wdGlvbnMgbWF4UmV0cmllc1BlclJlcXVlc3QgbXVzdCBiZSBudWxsJyxcbiAgICAnYW5kIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSBCdWxsTVEuJyxcbl0uam9pbignICcpO1xuY29uc3QgZGVwcmVjYXRpb25NZXNzYWdlID0gJ0J1bGxNUTogWW91ciByZWRpcyBvcHRpb25zIG1heFJldHJpZXNQZXJSZXF1ZXN0IG11c3QgYmUgbnVsbC4nO1xuZXhwb3J0IGNsYXNzIFJlZGlzQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0cywgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXh0cmFPcHRpb25zID0gZXh0cmFPcHRpb25zO1xuICAgICAgICB0aGlzLmNhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgIGNhbkRvdWJsZVRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FuQmxvY2tGb3IxTXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2luaXRpYWxpemluZyc7XG4gICAgICAgIHRoaXMucGFja2FnZVZlcnNpb24gPSBwYWNrYWdlVmVyc2lvbjtcbiAgICAgICAgLy8gU2V0IGV4dHJhIG9wdGlvbnMgZGVmYXVsdHNcbiAgICAgICAgdGhpcy5leHRyYU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc2hhcmVkOiBmYWxzZSwgYmxvY2tpbmc6IHRydWUsIHNraXBWZXJzaW9uQ2hlY2s6IGZhbHNlLCBza2lwV2FpdGluZ0ZvclJlYWR5OiBmYWxzZSB9LCBleHRyYU9wdGlvbnMpO1xuICAgICAgICBpZiAoIWlzUmVkaXNJbnN0YW5jZShvcHRzKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Jsb2NraW5nT3B0aW9ucyhvdmVycmlkZU1lc3NhZ2UsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7IHBvcnQ6IDYzNzksIGhvc3Q6ICcxMjcuMC4wLjEnLCByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKE1hdGguZXhwKHRpbWVzKSwgMjAwMDApLCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9IH0sIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXh0cmFPcHRpb25zLmJsb2NraW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzLm1heFJldHJpZXNQZXJSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudCA9IG9wdHM7XG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSByZWRpcyBpbnN0YW5jZSBpcyB1c2luZyBrZXlQcmVmaXhcbiAgICAgICAgICAgIC8vIGFuZCBpZiBzbywgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2xpZW50Lm9wdGlvbnMua2V5UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWxsTVE6IGlvcmVkaXMgZG9lcyBub3Qgc3VwcG9ydCBpb3JlZGlzIHByZWZpeGVzLCB1c2UgdGhlIHByZWZpeCBvcHRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1JlZGlzQ2x1c3Rlcih0aGlzLl9jbGllbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fY2xpZW50Lm9wdGlvbnMucmVkaXNPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5fY2xpZW50Lm9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQmxvY2tpbmdPcHRpb25zKGRlcHJlY2F0aW9uTWVzc2FnZSwgdGhpcy5vcHRzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBWZXJzaW9uQ2hlY2sgPVxuICAgICAgICAgICAgKGV4dHJhT3B0aW9ucyA9PT0gbnVsbCB8fCBleHRyYU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5za2lwVmVyc2lvbkNoZWNrKSB8fFxuICAgICAgICAgICAgICAgICEhKHRoaXMub3B0cyAmJiB0aGlzLm9wdHMuc2tpcFZlcnNpb25DaGVjayk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpZW50RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRSZWFkeSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICB9XG4gICAgY2hlY2tCbG9ja2luZ09wdGlvbnMobXNnLCBvcHRpb25zLCB0aHJvd0Vycm9yID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFPcHRpb25zLmJsb2NraW5nICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzUGVyUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRocm93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgYSByZWRpcyBjbGllbnQgdG8gYmUgcmVhZHkuXG4gICAgICogQHBhcmFtIHJlZGlzIC0gY2xpZW50XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHdhaXRVbnRpbFJlYWR5KGNsaWVudCkge1xuICAgICAgICBpZiAoY2xpZW50LnN0YXR1cyA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAnd2FpdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAnZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZVJlYWR5O1xuICAgICAgICBsZXQgaGFuZGxlRW5kO1xuICAgICAgICBsZXQgaGFuZGxlRXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGhhbmRsZUVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgIT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobGFzdEVycm9yIHx8IG5ldyBFcnJvcihDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobGFzdEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY3VzdG9uICdlbmQnIHN0YXR1cyBpcyBzZXQgd2UgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluY3JlYXNlTWF4TGlzdGVuZXJzKGNsaWVudCwgMyk7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ3JlYWR5JywgaGFuZGxlUmVhZHkpO1xuICAgICAgICAgICAgICAgIGNsaWVudC5vbignZW5kJywgaGFuZGxlRW5kKTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25jZSgnZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZW5kJywgaGFuZGxlRW5kKTtcbiAgICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ3JlYWR5JywgaGFuZGxlUmVhZHkpO1xuICAgICAgICAgICAgZGVjcmVhc2VNYXhMaXN0ZW5lcnMoY2xpZW50LCAzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXppbmc7XG4gICAgfVxuICAgIGxvYWRDb21tYW5kcyhwYWNrYWdlVmVyc2lvbiwgcHJvdmlkZWRTY3JpcHRzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsU2NyaXB0cyA9IHByb3ZpZGVkU2NyaXB0cyB8fCBzY3JpcHRzO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGZpbmFsU2NyaXB0cykge1xuICAgICAgICAgICAgLy8gT25seSBkZWZpbmUgdGhlIGNvbW1hbmQgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgICAgICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSBgJHtmaW5hbFNjcmlwdHNbcHJvcGVydHldLm5hbWV9OiR7cGFja2FnZVZlcnNpb259YDtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2xpZW50W2NvbW1hbmROYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudC5kZWZpbmVDb21tYW5kKGNvbW1hbmROYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mS2V5czogZmluYWxTY3JpcHRzW3Byb3BlcnR5XS5rZXlzLFxuICAgICAgICAgICAgICAgICAgICBsdWE6IGZpbmFsU2NyaXB0c1twcm9wZXJ0eV0uY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgICAgICAgY29uc3QgX2EgPSB0aGlzLm9wdHMsIHsgdXJsIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widXJsXCJdKTtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudCA9IHVybCA/IG5ldyBJT1JlZGlzKHVybCwgcmVzdCkgOiBuZXcgSU9SZWRpcyhyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpbmNyZWFzZU1heExpc3RlbmVycyh0aGlzLl9jbGllbnQsIDMpO1xuICAgICAgICB0aGlzLl9jbGllbnQub24oJ2Vycm9yJywgdGhpcy5oYW5kbGVDbGllbnRFcnJvcik7XG4gICAgICAgIC8vIGlvcmVkaXMgdHJlYXRzIGNvbm5lY3Rpb24gZXJyb3JzIGFzIGEgZGlmZmVyZW50IGV2ZW50ICgnY2xvc2UnKVxuICAgICAgICB0aGlzLl9jbGllbnQub24oJ2Nsb3NlJywgdGhpcy5oYW5kbGVDbGllbnRDbG9zZSk7XG4gICAgICAgIHRoaXMuX2NsaWVudC5vbigncmVhZHknLCB0aGlzLmhhbmRsZUNsaWVudFJlYWR5KTtcbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhT3B0aW9ucy5za2lwV2FpdGluZ0ZvclJlYWR5KSB7XG4gICAgICAgICAgICBhd2FpdCBSZWRpc0Nvbm5lY3Rpb24ud2FpdFVudGlsUmVhZHkodGhpcy5fY2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDb21tYW5kcyh0aGlzLnBhY2thZ2VWZXJzaW9uKTtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWVudFsnc3RhdHVzJ10gIT09ICdlbmQnKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBhd2FpdCB0aGlzLmdldFJlZGlzVmVyc2lvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcFZlcnNpb25DaGVjayAhPT0gdHJ1ZSAmJiAhdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMudmVyc2lvbiwgUmVkaXNDb25uZWN0aW9uLm1pbmltdW1WZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZGlzIHZlcnNpb24gbmVlZHMgdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuICR7UmVkaXNDb25uZWN0aW9uLm1pbmltdW1WZXJzaW9ufSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBDdXJyZW50OiAke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVkaXNWZXJzaW9uTG93ZXJUaGFuKHRoaXMudmVyc2lvbiwgUmVkaXNDb25uZWN0aW9uLnJlY29tbWVuZGVkTWluaW11bVZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSBhIG1pbmltdW0gUmVkaXMgdmVyc2lvbiBvZiAke1JlZGlzQ29ubmVjdGlvbi5yZWNvbW1lbmRlZE1pbmltdW1WZXJzaW9ufVxuICAgICAgICAgICAgIEN1cnJlbnQ6ICR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgICAgIGNhbkRvdWJsZVRpbWVvdXQ6ICFpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbih0aGlzLnZlcnNpb24sICc2LjAuMCcpLFxuICAgICAgICAgICAgICAgIGNhbkJsb2NrRm9yMU1zOiAhaXNSZWRpc1ZlcnNpb25Mb3dlclRoYW4odGhpcy52ZXJzaW9uLCAnNy4wLjgnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICdyZWFkeSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCh3YWl0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgIT09ICdlbmQnKSB7XG4gICAgICAgICAgICBsZXQgX3Jlc29sdmUsIF9yZWplY3Q7XG4gICAgICAgICAgICBpZiAoIXdhaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaW5jcmVhc2VNYXhMaXN0ZW5lcnMoY2xpZW50LCAyKTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGlzY29ubmVjdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlY3JlYXNlTWF4TGlzdGVuZXJzKGNsaWVudCwgMik7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBfcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgIHJldHVybiBjbGllbnQuY29ubmVjdCgpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ2Nsb3NpbmcnO1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHRyYU9wdGlvbnMuc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gJ2luaXRpYWxpemluZycgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm90IHN0aWxsIGNvbm5lY3RlZCB0byBSZWRpcywgd2UgbmVlZCB0byBkaXNjb25uZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudC5xdWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgSU9SZWRpcyBkb2VzIG5vdCB1cGRhdGUgdGhpcyBzdGF0dXMgcHJvcGVybHksIHdlIGRvIGl0IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50WydzdGF0dXMnXSA9ICdlbmQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc05vdENvbm5lY3Rpb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpZW50Lm9mZignZXJyb3InLCB0aGlzLmhhbmRsZUNsaWVudEVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGllbnQub2ZmKCdjbG9zZScsIHRoaXMuaGFuZGxlQ2xpZW50Q2xvc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaWVudC5vZmYoJ3JlYWR5JywgdGhpcy5oYW5kbGVDbGllbnRSZWFkeSk7XG4gICAgICAgICAgICAgICAgZGVjcmVhc2VNYXhMaXN0ZW5lcnModGhpcy5fY2xpZW50LCAzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVkaXNWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5za2lwVmVyc2lvbkNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVkaXNDb25uZWN0aW9uLm1pbmltdW1WZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGF3YWl0IHRoaXMuX2NsaWVudC5pbmZvKCk7XG4gICAgICAgIGNvbnN0IHJlZGlzUHJlZml4ID0gJ3JlZGlzX3ZlcnNpb246JztcbiAgICAgICAgY29uc3QgbWF4TWVtb3J5UG9saWN5UHJlZml4ID0gJ21heG1lbW9yeV9wb2xpY3k6JztcbiAgICAgICAgY29uc3QgbGluZXMgPSBkb2Muc3BsaXQoL1xccj9cXG4vKTtcbiAgICAgICAgbGV0IHJlZGlzVmVyc2lvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmluZGV4T2YobWF4TWVtb3J5UG9saWN5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heE1lbW9yeVBvbGljeSA9IGxpbmVzW2ldLnN1YnN0cihtYXhNZW1vcnlQb2xpY3lQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4TWVtb3J5UG9saWN5ICE9PSAnbm9ldmljdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJTVBPUlRBTlQhIEV2aWN0aW9uIHBvbGljeSBpcyAke21heE1lbW9yeVBvbGljeX0uIEl0IHNob3VsZCBiZSBcIm5vZXZpY3Rpb25cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRleE9mKHJlZGlzUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlZGlzVmVyc2lvbiA9IGxpbmVzW2ldLnN1YnN0cihyZWRpc1ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWRpc1ZlcnNpb247XG4gICAgfVxuICAgIGdldCByZWRpc1ZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgfVxufVxuUmVkaXNDb25uZWN0aW9uLm1pbmltdW1WZXJzaW9uID0gJzUuMC4wJztcblJlZGlzQ29ubmVjdGlvbi5yZWNvbW1lbmRlZE1pbmltdW1WZXJzaW9uID0gJzYuMi4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlzLWNvbm5lY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/repeat.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Repeat: () => (/* binding */ Repeat),\n/* harmony export */   getNextMillis: () => (/* binding */ getNextMillis)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cron-parser */ \"(rsc)/./node_modules/cron-parser/lib/parser.js\");\n/* harmony import */ var cron_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cron_parser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n\n\n\n\nclass Repeat extends _queue_base__WEBPACK_IMPORTED_MODULE_2__.QueueBase {\n    constructor(name, opts, Connection) {\n        super(name, opts, Connection);\n        this.repeatStrategy =\n            (opts.settings && opts.settings.repeatStrategy) || getNextMillis;\n        this.repeatKeyHashAlgorithm =\n            (opts.settings && opts.settings.repeatKeyHashAlgorithm) || 'md5';\n    }\n    async updateRepeatableJob(name, data, opts, { override }) {\n        var _a, _b;\n        // Backwards compatibility for repeatable jobs for versions <= 3.0.0\n        const repeatOpts = Object.assign({}, opts.repeat);\n        (_a = repeatOpts.pattern) !== null && _a !== void 0 ? _a : (repeatOpts.pattern = repeatOpts.cron);\n        delete repeatOpts.cron;\n        // Check if we reached the limit of the repeatable job's iterations\n        const iterationCount = repeatOpts.count ? repeatOpts.count + 1 : 1;\n        if (typeof repeatOpts.limit !== 'undefined' &&\n            iterationCount > repeatOpts.limit) {\n            return;\n        }\n        // Check if we reached the end date of the repeatable job\n        let now = Date.now();\n        const { endDate } = repeatOpts;\n        if (endDate && now > new Date(endDate).getTime()) {\n            return;\n        }\n        const prevMillis = opts.prevMillis || 0;\n        now = prevMillis < now ? now : prevMillis;\n        const nextMillis = await this.repeatStrategy(now, repeatOpts, name);\n        const { every, pattern } = repeatOpts;\n        const hasImmediately = Boolean((every || pattern) && repeatOpts.immediately);\n        const offset = hasImmediately && every ? now - nextMillis : undefined;\n        if (nextMillis) {\n            // We store the undecorated opts.jobId into the repeat options\n            if (!prevMillis && opts.jobId) {\n                repeatOpts.jobId = opts.jobId;\n            }\n            const legacyRepeatKey = getRepeatConcatOptions(name, repeatOpts);\n            const newRepeatKey = (_b = opts.repeat.key) !== null && _b !== void 0 ? _b : this.hash(legacyRepeatKey);\n            let repeatJobKey;\n            if (override) {\n                repeatJobKey = await this.scripts.addRepeatableJob(newRepeatKey, nextMillis, {\n                    name,\n                    endDate: endDate ? new Date(endDate).getTime() : undefined,\n                    tz: repeatOpts.tz,\n                    pattern,\n                    every,\n                }, legacyRepeatKey);\n            }\n            else {\n                const client = await this.client;\n                repeatJobKey = await this.scripts.updateRepeatableJobMillis(client, newRepeatKey, nextMillis, legacyRepeatKey);\n            }\n            const { immediately } = repeatOpts, filteredRepeatOpts = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(repeatOpts, [\"immediately\"]);\n            return this.createNextJob(name, nextMillis, repeatJobKey, Object.assign(Object.assign({}, opts), { repeat: Object.assign({ offset }, filteredRepeatOpts) }), data, iterationCount, hasImmediately);\n        }\n    }\n    async createNextJob(name, nextMillis, repeatJobKey, opts, data, currentCount, hasImmediately) {\n        //\n        // Generate unique job id for this iteration.\n        //\n        const jobId = this.getRepeatJobKey(name, nextMillis, repeatJobKey, data);\n        const now = Date.now();\n        const delay = nextMillis + (opts.repeat.offset ? opts.repeat.offset : 0) - now;\n        const mergedOpts = Object.assign(Object.assign({}, opts), { jobId, delay: delay < 0 || hasImmediately ? 0 : delay, timestamp: now, prevMillis: nextMillis, repeatJobKey });\n        mergedOpts.repeat = Object.assign(Object.assign({}, opts.repeat), { count: currentCount });\n        return this.Job.create(this, name, data, mergedOpts);\n    }\n    // TODO: remove legacy code in next breaking change\n    getRepeatJobKey(name, nextMillis, repeatJobKey, data) {\n        if (repeatJobKey.split(':').length > 2) {\n            return this.getRepeatJobId({\n                name: name,\n                nextMillis: nextMillis,\n                namespace: this.hash(repeatJobKey),\n                jobId: data === null || data === void 0 ? void 0 : data.id,\n            });\n        }\n        return this.getRepeatDelayedJobId({\n            customKey: repeatJobKey,\n            nextMillis,\n        });\n    }\n    async removeRepeatable(name, repeat, jobId) {\n        var _a;\n        const repeatConcatOptions = getRepeatConcatOptions(name, Object.assign(Object.assign({}, repeat), { jobId }));\n        const repeatJobKey = (_a = repeat.key) !== null && _a !== void 0 ? _a : this.hash(repeatConcatOptions);\n        const legacyRepeatJobId = this.getRepeatJobId({\n            name,\n            nextMillis: '',\n            namespace: this.hash(repeatConcatOptions),\n            jobId: jobId !== null && jobId !== void 0 ? jobId : repeat.jobId,\n            key: repeat.key,\n        });\n        return this.scripts.removeRepeatable(legacyRepeatJobId, repeatConcatOptions, repeatJobKey);\n    }\n    async removeRepeatableByKey(repeatJobKey) {\n        const data = this.keyToData(repeatJobKey);\n        const legacyRepeatJobId = this.getRepeatJobId({\n            name: data.name,\n            nextMillis: '',\n            namespace: this.hash(repeatJobKey),\n            jobId: data.id,\n        });\n        return this.scripts.removeRepeatable(legacyRepeatJobId, '', repeatJobKey);\n    }\n    async getRepeatableData(client, key, next) {\n        const jobData = await client.hgetall(this.toKey('repeat:' + key));\n        if (jobData) {\n            return {\n                key,\n                name: jobData.name,\n                endDate: parseInt(jobData.endDate) || null,\n                tz: jobData.tz || null,\n                pattern: jobData.pattern || null,\n                every: jobData.every || null,\n                next,\n            };\n        }\n        return this.keyToData(key, next);\n    }\n    keyToData(key, next) {\n        const data = key.split(':');\n        const pattern = data.slice(4).join(':') || null;\n        return {\n            key,\n            name: data[0],\n            id: data[1] || null,\n            endDate: parseInt(data[2]) || null,\n            tz: data[3] || null,\n            pattern,\n            next,\n        };\n    }\n    async getRepeatableJobs(start = 0, end = -1, asc = false) {\n        const client = await this.client;\n        const key = this.keys.repeat;\n        const result = asc\n            ? await client.zrange(key, start, end, 'WITHSCORES')\n            : await client.zrevrange(key, start, end, 'WITHSCORES');\n        const jobs = [];\n        for (let i = 0; i < result.length; i += 2) {\n            jobs.push(this.getRepeatableData(client, result[i], parseInt(result[i + 1])));\n        }\n        return Promise.all(jobs);\n    }\n    async getRepeatableCount() {\n        const client = await this.client;\n        return client.zcard(this.toKey('repeat'));\n    }\n    hash(str) {\n        return (0,crypto__WEBPACK_IMPORTED_MODULE_1__.createHash)(this.repeatKeyHashAlgorithm).update(str).digest('hex');\n    }\n    getRepeatDelayedJobId({ nextMillis, customKey, }) {\n        return `repeat:${customKey}:${nextMillis}`;\n    }\n    getRepeatJobId({ name, nextMillis, namespace, jobId, key, }) {\n        const checksum = key !== null && key !== void 0 ? key : this.hash(`${name}${jobId || ''}${namespace}`);\n        return `repeat:${checksum}:${nextMillis}`;\n    }\n}\nfunction getRepeatConcatOptions(name, repeat) {\n    const endDate = repeat.endDate ? new Date(repeat.endDate).getTime() : '';\n    const tz = repeat.tz || '';\n    const pattern = repeat.pattern;\n    const suffix = (pattern ? pattern : String(repeat.every)) || '';\n    const jobId = repeat.jobId ? repeat.jobId : '';\n    return `${name}:${jobId}:${endDate}:${tz}:${suffix}`;\n}\nconst getNextMillis = (millis, opts) => {\n    const pattern = opts.pattern;\n    if (pattern && opts.every) {\n        throw new Error('Both .pattern and .every options are defined for this repeatable job');\n    }\n    if (opts.every) {\n        return (Math.floor(millis / opts.every) * opts.every +\n            (opts.immediately ? 0 : opts.every));\n    }\n    const currentDate = opts.startDate && new Date(opts.startDate) > new Date(millis)\n        ? new Date(opts.startDate)\n        : new Date(millis);\n    const interval = (0,cron_parser__WEBPACK_IMPORTED_MODULE_0__.parseExpression)(pattern, Object.assign(Object.assign({}, opts), { currentDate }));\n    try {\n        if (opts.immediately) {\n            return new Date().getTime();\n        }\n        else {\n            return interval.next().getTime();\n        }\n    }\n    catch (e) {\n        // Ignore error\n    }\n};\n//# sourceMappingURL=repeat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvcmVwZWF0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2U7QUFDVjtBQUNLO0FBQ2xDLHFCQUFxQixrREFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLG1DQUFtQyw2Q0FBTTtBQUMzRSxvR0FBb0csV0FBVyx3QkFBd0IsUUFBUSx1QkFBdUI7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsNkdBQTZHO0FBQ2pMLDBEQUEwRCxrQkFBa0IscUJBQXFCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixhQUFhLE9BQU87QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRCx5QkFBeUIsVUFBVSxHQUFHLFdBQVc7QUFDakQ7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9ELDZFQUE2RSxLQUFLLEVBQUUsWUFBWSxFQUFFLFVBQVU7QUFDNUcseUJBQXlCLFNBQVMsR0FBRyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssR0FBRyxNQUFNLEdBQUcsUUFBUSxHQUFHLEdBQUcsR0FBRyxPQUFPO0FBQ3ZEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFlLHdDQUF3QyxXQUFXLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3JlcGVhdC5qcz84YjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAnY3Jvbi1wYXJzZXInO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBRdWV1ZUJhc2UgfSBmcm9tICcuL3F1ZXVlLWJhc2UnO1xuZXhwb3J0IGNsYXNzIFJlcGVhdCBleHRlbmRzIFF1ZXVlQmFzZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0cywgQ29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcihuYW1lLCBvcHRzLCBDb25uZWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZXBlYXRTdHJhdGVneSA9XG4gICAgICAgICAgICAob3B0cy5zZXR0aW5ncyAmJiBvcHRzLnNldHRpbmdzLnJlcGVhdFN0cmF0ZWd5KSB8fCBnZXROZXh0TWlsbGlzO1xuICAgICAgICB0aGlzLnJlcGVhdEtleUhhc2hBbGdvcml0aG0gPVxuICAgICAgICAgICAgKG9wdHMuc2V0dGluZ3MgJiYgb3B0cy5zZXR0aW5ncy5yZXBlYXRLZXlIYXNoQWxnb3JpdGhtKSB8fCAnbWQ1JztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUmVwZWF0YWJsZUpvYihuYW1lLCBkYXRhLCBvcHRzLCB7IG92ZXJyaWRlIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHJlcGVhdGFibGUgam9icyBmb3IgdmVyc2lvbnMgPD0gMy4wLjBcbiAgICAgICAgY29uc3QgcmVwZWF0T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMucmVwZWF0KTtcbiAgICAgICAgKF9hID0gcmVwZWF0T3B0cy5wYXR0ZXJuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocmVwZWF0T3B0cy5wYXR0ZXJuID0gcmVwZWF0T3B0cy5jcm9uKTtcbiAgICAgICAgZGVsZXRlIHJlcGVhdE9wdHMuY3JvbjtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgcmVhY2hlZCB0aGUgbGltaXQgb2YgdGhlIHJlcGVhdGFibGUgam9iJ3MgaXRlcmF0aW9uc1xuICAgICAgICBjb25zdCBpdGVyYXRpb25Db3VudCA9IHJlcGVhdE9wdHMuY291bnQgPyByZXBlYXRPcHRzLmNvdW50ICsgMSA6IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwZWF0T3B0cy5saW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGl0ZXJhdGlvbkNvdW50ID4gcmVwZWF0T3B0cy5saW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBkYXRlIG9mIHRoZSByZXBlYXRhYmxlIGpvYlxuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgeyBlbmREYXRlIH0gPSByZXBlYXRPcHRzO1xuICAgICAgICBpZiAoZW5kRGF0ZSAmJiBub3cgPiBuZXcgRGF0ZShlbmREYXRlKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TWlsbGlzID0gb3B0cy5wcmV2TWlsbGlzIHx8IDA7XG4gICAgICAgIG5vdyA9IHByZXZNaWxsaXMgPCBub3cgPyBub3cgOiBwcmV2TWlsbGlzO1xuICAgICAgICBjb25zdCBuZXh0TWlsbGlzID0gYXdhaXQgdGhpcy5yZXBlYXRTdHJhdGVneShub3csIHJlcGVhdE9wdHMsIG5hbWUpO1xuICAgICAgICBjb25zdCB7IGV2ZXJ5LCBwYXR0ZXJuIH0gPSByZXBlYXRPcHRzO1xuICAgICAgICBjb25zdCBoYXNJbW1lZGlhdGVseSA9IEJvb2xlYW4oKGV2ZXJ5IHx8IHBhdHRlcm4pICYmIHJlcGVhdE9wdHMuaW1tZWRpYXRlbHkpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBoYXNJbW1lZGlhdGVseSAmJiBldmVyeSA/IG5vdyAtIG5leHRNaWxsaXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChuZXh0TWlsbGlzKSB7XG4gICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgdW5kZWNvcmF0ZWQgb3B0cy5qb2JJZCBpbnRvIHRoZSByZXBlYXQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCFwcmV2TWlsbGlzICYmIG9wdHMuam9iSWQpIHtcbiAgICAgICAgICAgICAgICByZXBlYXRPcHRzLmpvYklkID0gb3B0cy5qb2JJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVJlcGVhdEtleSA9IGdldFJlcGVhdENvbmNhdE9wdGlvbnMobmFtZSwgcmVwZWF0T3B0cyk7XG4gICAgICAgICAgICBjb25zdCBuZXdSZXBlYXRLZXkgPSAoX2IgPSBvcHRzLnJlcGVhdC5rZXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuaGFzaChsZWdhY3lSZXBlYXRLZXkpO1xuICAgICAgICAgICAgbGV0IHJlcGVhdEpvYktleTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJlcGVhdEpvYktleSA9IGF3YWl0IHRoaXMuc2NyaXB0cy5hZGRSZXBlYXRhYmxlSm9iKG5ld1JlcGVhdEtleSwgbmV4dE1pbGxpcywge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiBlbmREYXRlID8gbmV3IERhdGUoZW5kRGF0ZSkuZ2V0VGltZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB0ejogcmVwZWF0T3B0cy50eixcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZXZlcnksXG4gICAgICAgICAgICAgICAgfSwgbGVnYWN5UmVwZWF0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICAgICAgICAgIHJlcGVhdEpvYktleSA9IGF3YWl0IHRoaXMuc2NyaXB0cy51cGRhdGVSZXBlYXRhYmxlSm9iTWlsbGlzKGNsaWVudCwgbmV3UmVwZWF0S2V5LCBuZXh0TWlsbGlzLCBsZWdhY3lSZXBlYXRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBpbW1lZGlhdGVseSB9ID0gcmVwZWF0T3B0cywgZmlsdGVyZWRSZXBlYXRPcHRzID0gX19yZXN0KHJlcGVhdE9wdHMsIFtcImltbWVkaWF0ZWx5XCJdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5leHRKb2IobmFtZSwgbmV4dE1pbGxpcywgcmVwZWF0Sm9iS2V5LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IHJlcGVhdDogT2JqZWN0LmFzc2lnbih7IG9mZnNldCB9LCBmaWx0ZXJlZFJlcGVhdE9wdHMpIH0pLCBkYXRhLCBpdGVyYXRpb25Db3VudCwgaGFzSW1tZWRpYXRlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZU5leHRKb2IobmFtZSwgbmV4dE1pbGxpcywgcmVwZWF0Sm9iS2V5LCBvcHRzLCBkYXRhLCBjdXJyZW50Q291bnQsIGhhc0ltbWVkaWF0ZWx5KSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBqb2IgaWQgZm9yIHRoaXMgaXRlcmF0aW9uLlxuICAgICAgICAvL1xuICAgICAgICBjb25zdCBqb2JJZCA9IHRoaXMuZ2V0UmVwZWF0Sm9iS2V5KG5hbWUsIG5leHRNaWxsaXMsIHJlcGVhdEpvYktleSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gbmV4dE1pbGxpcyArIChvcHRzLnJlcGVhdC5vZmZzZXQgPyBvcHRzLnJlcGVhdC5vZmZzZXQgOiAwKSAtIG5vdztcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgam9iSWQsIGRlbGF5OiBkZWxheSA8IDAgfHwgaGFzSW1tZWRpYXRlbHkgPyAwIDogZGVsYXksIHRpbWVzdGFtcDogbm93LCBwcmV2TWlsbGlzOiBuZXh0TWlsbGlzLCByZXBlYXRKb2JLZXkgfSk7XG4gICAgICAgIG1lcmdlZE9wdHMucmVwZWF0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzLnJlcGVhdCksIHsgY291bnQ6IGN1cnJlbnRDb3VudCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuSm9iLmNyZWF0ZSh0aGlzLCBuYW1lLCBkYXRhLCBtZXJnZWRPcHRzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlIGxlZ2FjeSBjb2RlIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG4gICAgZ2V0UmVwZWF0Sm9iS2V5KG5hbWUsIG5leHRNaWxsaXMsIHJlcGVhdEpvYktleSwgZGF0YSkge1xuICAgICAgICBpZiAocmVwZWF0Sm9iS2V5LnNwbGl0KCc6JykubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVwZWF0Sm9iSWQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbmV4dE1pbGxpczogbmV4dE1pbGxpcyxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMuaGFzaChyZXBlYXRKb2JLZXkpLFxuICAgICAgICAgICAgICAgIGpvYklkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXBlYXREZWxheWVkSm9iSWQoe1xuICAgICAgICAgICAgY3VzdG9tS2V5OiByZXBlYXRKb2JLZXksXG4gICAgICAgICAgICBuZXh0TWlsbGlzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlUmVwZWF0YWJsZShuYW1lLCByZXBlYXQsIGpvYklkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVwZWF0Q29uY2F0T3B0aW9ucyA9IGdldFJlcGVhdENvbmNhdE9wdGlvbnMobmFtZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXBlYXQpLCB7IGpvYklkIH0pKTtcbiAgICAgICAgY29uc3QgcmVwZWF0Sm9iS2V5ID0gKF9hID0gcmVwZWF0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5oYXNoKHJlcGVhdENvbmNhdE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsZWdhY3lSZXBlYXRKb2JJZCA9IHRoaXMuZ2V0UmVwZWF0Sm9iSWQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5leHRNaWxsaXM6ICcnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiB0aGlzLmhhc2gocmVwZWF0Q29uY2F0T3B0aW9ucyksXG4gICAgICAgICAgICBqb2JJZDogam9iSWQgIT09IG51bGwgJiYgam9iSWQgIT09IHZvaWQgMCA/IGpvYklkIDogcmVwZWF0LmpvYklkLFxuICAgICAgICAgICAga2V5OiByZXBlYXQua2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0cy5yZW1vdmVSZXBlYXRhYmxlKGxlZ2FjeVJlcGVhdEpvYklkLCByZXBlYXRDb25jYXRPcHRpb25zLCByZXBlYXRKb2JLZXkpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVSZXBlYXRhYmxlQnlLZXkocmVwZWF0Sm9iS2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmtleVRvRGF0YShyZXBlYXRKb2JLZXkpO1xuICAgICAgICBjb25zdCBsZWdhY3lSZXBlYXRKb2JJZCA9IHRoaXMuZ2V0UmVwZWF0Sm9iSWQoe1xuICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgICAgbmV4dE1pbGxpczogJycsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMuaGFzaChyZXBlYXRKb2JLZXkpLFxuICAgICAgICAgICAgam9iSWQ6IGRhdGEuaWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRzLnJlbW92ZVJlcGVhdGFibGUobGVnYWN5UmVwZWF0Sm9iSWQsICcnLCByZXBlYXRKb2JLZXkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXBlYXRhYmxlRGF0YShjbGllbnQsIGtleSwgbmV4dCkge1xuICAgICAgICBjb25zdCBqb2JEYXRhID0gYXdhaXQgY2xpZW50LmhnZXRhbGwodGhpcy50b0tleSgncmVwZWF0OicgKyBrZXkpKTtcbiAgICAgICAgaWYgKGpvYkRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG5hbWU6IGpvYkRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICBlbmREYXRlOiBwYXJzZUludChqb2JEYXRhLmVuZERhdGUpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgdHo6IGpvYkRhdGEudHogfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBqb2JEYXRhLnBhdHRlcm4gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBldmVyeTogam9iRGF0YS5ldmVyeSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleVRvRGF0YShrZXksIG5leHQpO1xuICAgIH1cbiAgICBrZXlUb0RhdGEoa2V5LCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBrZXkuc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRhdGEuc2xpY2UoNCkuam9pbignOicpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBuYW1lOiBkYXRhWzBdLFxuICAgICAgICAgICAgaWQ6IGRhdGFbMV0gfHwgbnVsbCxcbiAgICAgICAgICAgIGVuZERhdGU6IHBhcnNlSW50KGRhdGFbMl0pIHx8IG51bGwsXG4gICAgICAgICAgICB0ejogZGF0YVszXSB8fCBudWxsLFxuICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcGVhdGFibGVKb2JzKHN0YXJ0ID0gMCwgZW5kID0gLTEsIGFzYyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleXMucmVwZWF0O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhc2NcbiAgICAgICAgICAgID8gYXdhaXQgY2xpZW50LnpyYW5nZShrZXksIHN0YXJ0LCBlbmQsICdXSVRIU0NPUkVTJylcbiAgICAgICAgICAgIDogYXdhaXQgY2xpZW50LnpyZXZyYW5nZShrZXksIHN0YXJ0LCBlbmQsICdXSVRIU0NPUkVTJyk7XG4gICAgICAgIGNvbnN0IGpvYnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGpvYnMucHVzaCh0aGlzLmdldFJlcGVhdGFibGVEYXRhKGNsaWVudCwgcmVzdWx0W2ldLCBwYXJzZUludChyZXN1bHRbaSArIDFdKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVwZWF0YWJsZUNvdW50KCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgcmV0dXJuIGNsaWVudC56Y2FyZCh0aGlzLnRvS2V5KCdyZXBlYXQnKSk7XG4gICAgfVxuICAgIGhhc2goc3RyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKHRoaXMucmVwZWF0S2V5SGFzaEFsZ29yaXRobSkudXBkYXRlKHN0cikuZGlnZXN0KCdoZXgnKTtcbiAgICB9XG4gICAgZ2V0UmVwZWF0RGVsYXllZEpvYklkKHsgbmV4dE1pbGxpcywgY3VzdG9tS2V5LCB9KSB7XG4gICAgICAgIHJldHVybiBgcmVwZWF0OiR7Y3VzdG9tS2V5fToke25leHRNaWxsaXN9YDtcbiAgICB9XG4gICAgZ2V0UmVwZWF0Sm9iSWQoeyBuYW1lLCBuZXh0TWlsbGlzLCBuYW1lc3BhY2UsIGpvYklkLCBrZXksIH0pIHtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBrZXkgIT09IG51bGwgJiYga2V5ICE9PSB2b2lkIDAgPyBrZXkgOiB0aGlzLmhhc2goYCR7bmFtZX0ke2pvYklkIHx8ICcnfSR7bmFtZXNwYWNlfWApO1xuICAgICAgICByZXR1cm4gYHJlcGVhdDoke2NoZWNrc3VtfToke25leHRNaWxsaXN9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZXBlYXRDb25jYXRPcHRpb25zKG5hbWUsIHJlcGVhdCkge1xuICAgIGNvbnN0IGVuZERhdGUgPSByZXBlYXQuZW5kRGF0ZSA/IG5ldyBEYXRlKHJlcGVhdC5lbmREYXRlKS5nZXRUaW1lKCkgOiAnJztcbiAgICBjb25zdCB0eiA9IHJlcGVhdC50eiB8fCAnJztcbiAgICBjb25zdCBwYXR0ZXJuID0gcmVwZWF0LnBhdHRlcm47XG4gICAgY29uc3Qgc3VmZml4ID0gKHBhdHRlcm4gPyBwYXR0ZXJuIDogU3RyaW5nKHJlcGVhdC5ldmVyeSkpIHx8ICcnO1xuICAgIGNvbnN0IGpvYklkID0gcmVwZWF0LmpvYklkID8gcmVwZWF0LmpvYklkIDogJyc7XG4gICAgcmV0dXJuIGAke25hbWV9OiR7am9iSWR9OiR7ZW5kRGF0ZX06JHt0en06JHtzdWZmaXh9YDtcbn1cbmV4cG9ydCBjb25zdCBnZXROZXh0TWlsbGlzID0gKG1pbGxpcywgb3B0cykgPT4ge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBvcHRzLnBhdHRlcm47XG4gICAgaWYgKHBhdHRlcm4gJiYgb3B0cy5ldmVyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggLnBhdHRlcm4gYW5kIC5ldmVyeSBvcHRpb25zIGFyZSBkZWZpbmVkIGZvciB0aGlzIHJlcGVhdGFibGUgam9iJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLmV2ZXJ5KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5mbG9vcihtaWxsaXMgLyBvcHRzLmV2ZXJ5KSAqIG9wdHMuZXZlcnkgK1xuICAgICAgICAgICAgKG9wdHMuaW1tZWRpYXRlbHkgPyAwIDogb3B0cy5ldmVyeSkpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG9wdHMuc3RhcnREYXRlICYmIG5ldyBEYXRlKG9wdHMuc3RhcnREYXRlKSA+IG5ldyBEYXRlKG1pbGxpcylcbiAgICAgICAgPyBuZXcgRGF0ZShvcHRzLnN0YXJ0RGF0ZSlcbiAgICAgICAgOiBuZXcgRGF0ZShtaWxsaXMpO1xuICAgIGNvbnN0IGludGVydmFsID0gcGFyc2VFeHByZXNzaW9uKHBhdHRlcm4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgY3VycmVudERhdGUgfSkpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRzLmltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWwubmV4dCgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/sandbox.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n\nconst sandbox = (processFile, childPool) => {\n    return async function process(job, token) {\n        let child;\n        let msgHandler;\n        let exitHandler;\n        try {\n            const done = new Promise((resolve, reject) => {\n                const initChild = async () => {\n                    try {\n                        exitHandler = (exitCode, signal) => {\n                            reject(new Error('Unexpected exit code: ' + exitCode + ' signal: ' + signal));\n                        };\n                        child = await childPool.retain(processFile);\n                        child.on('exit', exitHandler);\n                        msgHandler = async (msg) => {\n                            var _a, _b, _c, _d, _e;\n                            try {\n                                switch (msg.cmd) {\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Completed:\n                                        resolve(msg.value);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Failed:\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Error: {\n                                        const err = new Error();\n                                        Object.assign(err, msg.value);\n                                        reject(err);\n                                        break;\n                                    }\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Progress:\n                                        await job.updateProgress(msg.value);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Log:\n                                        await job.log(msg.value);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToDelayed:\n                                        await job.moveToDelayed((_a = msg.value) === null || _a === void 0 ? void 0 : _a.timestamp, (_b = msg.value) === null || _b === void 0 ? void 0 : _b.token);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToWait:\n                                        await job.moveToWait((_c = msg.value) === null || _c === void 0 ? void 0 : _c.token);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.MoveToWaitingChildren:\n                                        {\n                                            const value = await job.moveToWaitingChildren((_d = msg.value) === null || _d === void 0 ? void 0 : _d.token, (_e = msg.value) === null || _e === void 0 ? void 0 : _e.opts);\n                                            child.send({\n                                                requestId: msg.requestId,\n                                                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ChildCommand.MoveToWaitingChildrenResponse,\n                                                value,\n                                            });\n                                        }\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.Update:\n                                        await job.updateData(msg.value);\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.GetChildrenValues:\n                                        {\n                                            const value = await job.getChildrenValues();\n                                            child.send({\n                                                requestId: msg.requestId,\n                                                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ChildCommand.GetChildrenValuesResponse,\n                                                value,\n                                            });\n                                        }\n                                        break;\n                                    case _enums__WEBPACK_IMPORTED_MODULE_0__.ParentCommand.GetIgnoredChildrenFailures:\n                                        {\n                                            const value = await job.getIgnoredChildrenFailures();\n                                            child.send({\n                                                requestId: msg.requestId,\n                                                cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ChildCommand.GetIgnoredChildrenFailuresResponse,\n                                                value,\n                                            });\n                                        }\n                                        break;\n                                }\n                            }\n                            catch (err) {\n                                reject(err);\n                            }\n                        };\n                        child.on('message', msgHandler);\n                        child.send({\n                            cmd: _enums__WEBPACK_IMPORTED_MODULE_0__.ChildCommand.Start,\n                            job: job.asJSONSandbox(),\n                            token,\n                        });\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                };\n                initChild();\n            });\n            await done;\n            return done;\n        }\n        finally {\n            if (child) {\n                child.off('message', msgHandler);\n                child.off('exit', exitHandler);\n                if (child.exitCode === null && child.signalCode === null) {\n                    childPool.release(child);\n                }\n            }\n        }\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sandbox);\n//# sourceMappingURL=sandbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2FuZGJveC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQWE7QUFDdEQ7QUFDQTtBQUNBLHlDQUF5QyxpREFBYTtBQUN0RCx5Q0FBeUMsaURBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpREFBYTtBQUN0RDtBQUNBO0FBQ0EseUNBQXlDLGlEQUFhO0FBQ3REO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQWE7QUFDdEQ7QUFDQTtBQUNBLHlDQUF5QyxpREFBYTtBQUN0RDtBQUNBO0FBQ0EseUNBQXlDLGlEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdEQUFZO0FBQ2pFO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQWE7QUFDdEQ7QUFDQTtBQUNBLHlDQUF5QyxpREFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnREFBWTtBQUNqRTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EseUNBQXlDLGlEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdEQUFZO0FBQ2pFO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFZO0FBQzdDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxPQUFPLEVBQUM7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9jbGFzc2VzL3NhbmRib3guanM/Y2EzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGlsZENvbW1hbmQsIFBhcmVudENvbW1hbmQgfSBmcm9tICcuLi9lbnVtcyc7XG5jb25zdCBzYW5kYm94ID0gKHByb2Nlc3NGaWxlLCBjaGlsZFBvb2wpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcHJvY2Vzcyhqb2IsIHRva2VuKSB7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgbGV0IG1zZ0hhbmRsZXI7XG4gICAgICAgIGxldCBleGl0SGFuZGxlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdENoaWxkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEhhbmRsZXIgPSAoZXhpdENvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXhpdCBjb2RlOiAnICsgZXhpdENvZGUgKyAnIHNpZ25hbDogJyArIHNpZ25hbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gYXdhaXQgY2hpbGRQb29sLnJldGFpbihwcm9jZXNzRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5vbignZXhpdCcsIGV4aXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ0hhbmRsZXIgPSBhc3luYyAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1zZy5jbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtc2cudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQYXJlbnRDb21tYW5kLkZhaWxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5FcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCBtc2cudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQYXJlbnRDb21tYW5kLlByb2dyZXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGpvYi51cGRhdGVQcm9ncmVzcyhtc2cudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQYXJlbnRDb21tYW5kLkxvZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBqb2IubG9nKG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFBhcmVudENvbW1hbmQuTW92ZVRvRGVsYXllZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBqb2IubW92ZVRvRGVsYXllZCgoX2EgPSBtc2cudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aW1lc3RhbXAsIChfYiA9IG1zZy52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5Nb3ZlVG9XYWl0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGpvYi5tb3ZlVG9XYWl0KChfYyA9IG1zZy52YWx1ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5Nb3ZlVG9XYWl0aW5nQ2hpbGRyZW46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGpvYi5tb3ZlVG9XYWl0aW5nQ2hpbGRyZW4oKF9kID0gbXNnLnZhbHVlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9rZW4sIChfZSA9IG1zZy52YWx1ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZDogQ2hpbGRDb21tYW5kLk1vdmVUb1dhaXRpbmdDaGlsZHJlblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5VcGRhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgam9iLnVwZGF0ZURhdGEobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGFyZW50Q29tbWFuZC5HZXRDaGlsZHJlblZhbHVlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgam9iLmdldENoaWxkcmVuVmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtc2cucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kOiBDaGlsZENvbW1hbmQuR2V0Q2hpbGRyZW5WYWx1ZXNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFBhcmVudENvbW1hbmQuR2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGpvYi5nZXRJZ25vcmVkQ2hpbGRyZW5GYWlsdXJlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbXNnLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZDogQ2hpbGRDb21tYW5kLkdldElnbm9yZWRDaGlsZHJlbkZhaWx1cmVzUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgbXNnSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQ6IENoaWxkQ29tbWFuZC5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2I6IGpvYi5hc0pTT05TYW5kYm94KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluaXRDaGlsZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBkb25lO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5vZmYoJ21lc3NhZ2UnLCBtc2dIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5vZmYoJ2V4aXQnLCBleGl0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4aXRDb2RlID09PSBudWxsICYmIGNoaWxkLnNpZ25hbENvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQb29sLnJlbGVhc2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgc2FuZGJveDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbmRib3guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/scripts.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scripts: () => (/* binding */ Scripts),\n/* harmony export */   raw2NextJobData: () => (/* binding */ raw2NextJobData)\n/* harmony export */ });\n/* harmony import */ var msgpackr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! msgpackr */ \"(rsc)/./node_modules/msgpackr/node-index.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../version */ \"(rsc)/./node_modules/bullmq/dist/esm/version.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\");\n/**\n * Includes all the scripts needed by the queue and jobs.\n */\n/*eslint-env node */\n\n\nconst packer = new msgpackr__WEBPACK_IMPORTED_MODULE_0__.Packr({\n    useRecords: false,\n    encodeUndefinedAsNil: true,\n});\nconst pack = packer.pack;\n\n\n\n\nclass Scripts {\n    constructor(queue) {\n        this.queue = queue;\n        this.version = _version__WEBPACK_IMPORTED_MODULE_3__.version;\n        const queueKeys = this.queue.keys;\n        this.moveToFinishedKeys = [\n            queueKeys.wait,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.events,\n            queueKeys.stalled,\n            queueKeys.limiter,\n            queueKeys.delayed,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.pc,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n        ];\n    }\n    execCommand(client, commandName, args) {\n        const commandNameWithVersion = `${commandName}:${this.version}`;\n        return client[commandNameWithVersion](args);\n    }\n    async isJobInList(listKey, jobId) {\n        const client = await this.queue.client;\n        let result;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.isRedisVersionLowerThan)(this.queue.redisVersion, '6.0.6')) {\n            result = await this.execCommand(client, 'isJobInList', [listKey, jobId]);\n        }\n        else {\n            result = await client.lpos(listKey, jobId);\n        }\n        return Number.isInteger(result);\n    }\n    addDelayedJobArgs(job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.delayed,\n            queueKeys.completed,\n            queueKeys.events,\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return keys;\n    }\n    addDelayedJob(client, job, encodedOpts, args) {\n        const argsList = this.addDelayedJobArgs(job, encodedOpts, args);\n        return this.execCommand(client, 'addDelayedJob', argsList);\n    }\n    addPrioritizedJobArgs(job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.prioritized,\n            queueKeys.delayed,\n            queueKeys.completed,\n            queueKeys.active,\n            queueKeys.events,\n            queueKeys.pc,\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return keys;\n    }\n    addPrioritizedJob(client, job, encodedOpts, args) {\n        const argsList = this.addPrioritizedJobArgs(job, encodedOpts, args);\n        return this.execCommand(client, 'addPrioritizedJob', argsList);\n    }\n    addParentJobArgs(job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.delayed,\n            queueKeys.completed,\n            queueKeys.events,\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return keys;\n    }\n    addParentJob(client, job, encodedOpts, args) {\n        const argsList = this.addParentJobArgs(job, encodedOpts, args);\n        return this.execCommand(client, 'addParentJob', argsList);\n    }\n    addStandardJobArgs(job, encodedOpts, args) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.id,\n            queueKeys.completed,\n            queueKeys.delayed,\n            queueKeys.active,\n            queueKeys.events,\n            queueKeys.marker,\n        ];\n        keys.push(pack(args), job.data, encodedOpts);\n        return keys;\n    }\n    addStandardJob(client, job, encodedOpts, args) {\n        const argsList = this.addStandardJobArgs(job, encodedOpts, args);\n        return this.execCommand(client, 'addStandardJob', argsList);\n    }\n    async addJob(client, job, opts, jobId, parentKeyOpts = {}) {\n        const queueKeys = this.queue.keys;\n        const parent = job.parent;\n        const args = [\n            queueKeys[''],\n            typeof jobId !== 'undefined' ? jobId : '',\n            job.name,\n            job.timestamp,\n            job.parentKey || null,\n            parentKeyOpts.waitChildrenKey || null,\n            parentKeyOpts.parentDependenciesKey || null,\n            parent,\n            job.repeatJobKey,\n            job.deduplicationId ? `${queueKeys.de}:${job.deduplicationId}` : null,\n        ];\n        let encodedOpts;\n        if (opts.repeat) {\n            const repeat = Object.assign({}, opts.repeat);\n            if (repeat.startDate) {\n                repeat.startDate = +new Date(repeat.startDate);\n            }\n            if (repeat.endDate) {\n                repeat.endDate = +new Date(repeat.endDate);\n            }\n            encodedOpts = pack(Object.assign(Object.assign({}, opts), { repeat }));\n        }\n        else {\n            encodedOpts = pack(opts);\n        }\n        let result;\n        if (parentKeyOpts.waitChildrenKey) {\n            result = await this.addParentJob(client, job, encodedOpts, args);\n        }\n        else if (typeof opts.delay == 'number' && opts.delay > 0) {\n            result = await this.addDelayedJob(client, job, encodedOpts, args);\n        }\n        else if (opts.priority) {\n            result = await this.addPrioritizedJob(client, job, encodedOpts, args);\n        }\n        else {\n            result = await this.addStandardJob(client, job, encodedOpts, args);\n        }\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                parentKey: parentKeyOpts.parentKey,\n                command: 'addJob',\n            });\n        }\n        return result;\n    }\n    pauseArgs(pause) {\n        let src = 'wait', dst = 'paused';\n        if (!pause) {\n            src = 'paused';\n            dst = 'wait';\n        }\n        const keys = [src, dst, 'meta', 'prioritized'].map((name) => this.queue.toKey(name));\n        keys.push(this.queue.keys.events, this.queue.keys.delayed, this.queue.keys.marker);\n        const args = [pause ? 'paused' : 'resumed'];\n        return keys.concat(args);\n    }\n    async pause(pause) {\n        const client = await this.queue.client;\n        const args = this.pauseArgs(pause);\n        return this.execCommand(client, 'pause', args);\n    }\n    addRepeatableJobArgs(customKey, nextMillis, opts, legacyCustomKey) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.repeat,\n            queueKeys.delayed,\n        ];\n        const args = [\n            nextMillis,\n            pack(opts),\n            legacyCustomKey,\n            customKey,\n            queueKeys[''],\n        ];\n        return keys.concat(args);\n    }\n    async addRepeatableJob(customKey, nextMillis, opts, legacyCustomKey) {\n        const client = await this.queue.client;\n        const args = this.addRepeatableJobArgs(customKey, nextMillis, opts, legacyCustomKey);\n        return this.execCommand(client, 'addRepeatableJob', args);\n    }\n    async addJobScheduler(jobSchedulerId, nextMillis, templateData, templateOpts, opts, delayedJobOpts, \n    // The job id of the job that produced this next iteration\n    producerId) {\n        const client = await this.queue.client;\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.repeat,\n            queueKeys.delayed,\n            queueKeys.wait,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.prioritized,\n            queueKeys.marker,\n            queueKeys.id,\n            queueKeys.events,\n            queueKeys.pc,\n            queueKeys.active,\n        ];\n        const args = [\n            nextMillis,\n            pack(opts),\n            jobSchedulerId,\n            templateData,\n            pack(templateOpts),\n            pack(delayedJobOpts),\n            Date.now(),\n            queueKeys[''],\n            producerId ? this.queue.toKey(producerId) : '',\n        ];\n        const result = await this.execCommand(client, 'addJobScheduler', keys.concat(args));\n        if (typeof result === 'number' && result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                command: 'addJobScheduler',\n            });\n        }\n        return result;\n    }\n    async updateRepeatableJobMillis(client, customKey, nextMillis, legacyCustomKey) {\n        const args = [\n            this.queue.keys.repeat,\n            nextMillis,\n            customKey,\n            legacyCustomKey,\n        ];\n        return this.execCommand(client, 'updateRepeatableJobMillis', args);\n    }\n    async updateJobSchedulerNextMillis(jobSchedulerId, nextMillis, templateData, delayedJobOpts, \n    // The job id of the job that produced this next iteration - TODO: remove in next breaking change\n    producerId) {\n        const client = await this.queue.client;\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.repeat,\n            queueKeys.delayed,\n            queueKeys.wait,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.prioritized,\n            queueKeys.marker,\n            queueKeys.id,\n            queueKeys.events,\n            queueKeys.pc,\n            producerId ? this.queue.toKey(producerId) : '',\n            queueKeys.active,\n        ];\n        const args = [\n            nextMillis,\n            jobSchedulerId,\n            templateData,\n            pack(delayedJobOpts),\n            Date.now(),\n            queueKeys[''],\n            producerId,\n        ];\n        return this.execCommand(client, 'updateJobScheduler', keys.concat(args));\n    }\n    removeRepeatableArgs(legacyRepeatJobId, repeatConcatOptions, repeatJobKey) {\n        const queueKeys = this.queue.keys;\n        const keys = [queueKeys.repeat, queueKeys.delayed, queueKeys.events];\n        const args = [\n            legacyRepeatJobId,\n            this.getRepeatConcatOptions(repeatConcatOptions, repeatJobKey),\n            repeatJobKey,\n            queueKeys[''],\n        ];\n        return keys.concat(args);\n    }\n    // TODO: remove this check in next breaking change\n    getRepeatConcatOptions(repeatConcatOptions, repeatJobKey) {\n        if (repeatJobKey && repeatJobKey.split(':').length > 2) {\n            return repeatJobKey;\n        }\n        return repeatConcatOptions;\n    }\n    async removeRepeatable(legacyRepeatJobId, repeatConcatOptions, repeatJobKey) {\n        const client = await this.queue.client;\n        const args = this.removeRepeatableArgs(legacyRepeatJobId, repeatConcatOptions, repeatJobKey);\n        return this.execCommand(client, 'removeRepeatable', args);\n    }\n    async removeJobScheduler(jobSchedulerId) {\n        const client = await this.queue.client;\n        const queueKeys = this.queue.keys;\n        const keys = [queueKeys.repeat, queueKeys.delayed, queueKeys.events];\n        const args = [jobSchedulerId, queueKeys['']];\n        return this.execCommand(client, 'removeJobScheduler', keys.concat(args));\n    }\n    removeArgs(jobId, removeChildren) {\n        const keys = [jobId, 'repeat'].map(name => this.queue.toKey(name));\n        const args = [jobId, removeChildren ? 1 : 0, this.queue.toKey('')];\n        return keys.concat(args);\n    }\n    async remove(jobId, removeChildren) {\n        const client = await this.queue.client;\n        const args = this.removeArgs(jobId, removeChildren);\n        const result = await this.execCommand(client, 'removeJob', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'removeJob',\n            });\n        }\n        return result;\n    }\n    async removeUnprocessedChildren(jobId) {\n        const client = await this.queue.client;\n        const args = [\n            this.queue.toKey(jobId),\n            this.queue.keys.meta,\n            this.queue.toKey(''),\n            jobId,\n        ];\n        await this.execCommand(client, 'removeUnprocessedChildren', args);\n    }\n    async extendLock(jobId, token, duration, client) {\n        client = client || (await this.queue.client);\n        const args = [\n            this.queue.toKey(jobId) + ':lock',\n            this.queue.keys.stalled,\n            token,\n            duration,\n            jobId,\n        ];\n        return this.execCommand(client, 'extendLock', args);\n    }\n    async extendLocks(jobIds, tokens, duration) {\n        const client = await this.queue.client;\n        const args = [\n            this.queue.keys.stalled,\n            this.queue.toKey(''),\n            pack(tokens),\n            pack(jobIds),\n            duration,\n        ];\n        return this.execCommand(client, 'extendLocks', args);\n    }\n    async updateData(job, data) {\n        const client = await this.queue.client;\n        const keys = [this.queue.toKey(job.id)];\n        const dataJson = JSON.stringify(data);\n        const result = await this.execCommand(client, 'updateData', keys.concat([dataJson]));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId: job.id,\n                command: 'updateData',\n            });\n        }\n    }\n    async updateProgress(jobId, progress) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(jobId),\n            this.queue.keys.events,\n            this.queue.keys.meta,\n        ];\n        const progressJson = JSON.stringify(progress);\n        const result = await this.execCommand(client, 'updateProgress', keys.concat([jobId, progressJson]));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'updateProgress',\n            });\n        }\n    }\n    async addLog(jobId, logRow, keepLogs) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(jobId),\n            this.queue.toKey(jobId) + ':logs',\n        ];\n        const result = await this.execCommand(client, 'addLog', keys.concat([jobId, logRow, keepLogs ? keepLogs : '']));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'addLog',\n            });\n        }\n        return result;\n    }\n    moveToFinishedArgs(job, val, propVal, shouldRemove, target, token, timestamp, fetchNext = true, fieldsToUpdate) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const queueKeys = this.queue.keys;\n        const opts = this.queue.opts;\n        const workerKeepJobs = target === 'completed' ? opts.removeOnComplete : opts.removeOnFail;\n        const metricsKey = this.queue.toKey(`metrics:${target}`);\n        const keys = this.moveToFinishedKeys;\n        keys[10] = queueKeys[target];\n        keys[11] = this.queue.toKey((_a = job.id) !== null && _a !== void 0 ? _a : '');\n        keys[12] = metricsKey;\n        keys[13] = this.queue.keys.marker;\n        const keepJobs = this.getKeepJobs(shouldRemove, workerKeepJobs);\n        const args = [\n            job.id,\n            timestamp,\n            propVal,\n            typeof val === 'undefined' ? 'null' : val,\n            target,\n            !fetchNext || this.queue.closing ? 0 : 1,\n            queueKeys[''],\n            pack({\n                token,\n                name: opts.name,\n                keepJobs,\n                limiter: opts.limiter,\n                lockDuration: opts.lockDuration,\n                attempts: job.opts.attempts,\n                maxMetricsSize: ((_b = opts.metrics) === null || _b === void 0 ? void 0 : _b.maxDataPoints)\n                    ? (_c = opts.metrics) === null || _c === void 0 ? void 0 : _c.maxDataPoints\n                    : '',\n                fpof: !!((_d = job.opts) === null || _d === void 0 ? void 0 : _d.failParentOnFailure),\n                cpof: !!((_e = job.opts) === null || _e === void 0 ? void 0 : _e.continueParentOnFailure),\n                idof: !!((_f = job.opts) === null || _f === void 0 ? void 0 : _f.ignoreDependencyOnFailure),\n                rdof: !!((_g = job.opts) === null || _g === void 0 ? void 0 : _g.removeDependencyOnFailure),\n            }),\n            fieldsToUpdate ? pack((0,_utils__WEBPACK_IMPORTED_MODULE_2__.objectToFlatArray)(fieldsToUpdate)) : void 0,\n        ];\n        return keys.concat(args);\n    }\n    getKeepJobs(shouldRemove, workerKeepJobs) {\n        if (typeof shouldRemove === 'undefined') {\n            return workerKeepJobs || { count: shouldRemove ? 0 : -1 };\n        }\n        return typeof shouldRemove === 'object'\n            ? shouldRemove\n            : typeof shouldRemove === 'number'\n                ? { count: shouldRemove }\n                : { count: shouldRemove ? 0 : -1 };\n    }\n    async moveToFinished(jobId, args) {\n        const client = await this.queue.client;\n        const result = await this.execCommand(client, 'moveToFinished', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'moveToFinished',\n                state: 'active',\n            });\n        }\n        else {\n            if (typeof result !== 'undefined') {\n                return raw2NextJobData(result);\n            }\n        }\n    }\n    drainArgs(delayed) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.paused,\n            queueKeys.delayed,\n            queueKeys.prioritized,\n            queueKeys.repeat,\n        ];\n        const args = [queueKeys[''], delayed ? '1' : '0'];\n        return keys.concat(args);\n    }\n    async drain(delayed) {\n        const client = await this.queue.client;\n        const args = this.drainArgs(delayed);\n        return this.execCommand(client, 'drain', args);\n    }\n    removeChildDependencyArgs(jobId, parentKey) {\n        const queueKeys = this.queue.keys;\n        const keys = [queueKeys['']];\n        const args = [this.queue.toKey(jobId), parentKey];\n        return keys.concat(args);\n    }\n    async removeChildDependency(jobId, parentKey) {\n        const client = await this.queue.client;\n        const args = this.removeChildDependencyArgs(jobId, parentKey);\n        const result = await this.execCommand(client, 'removeChildDependency', args);\n        switch (result) {\n            case 0:\n                return true;\n            case 1:\n                return false;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId,\n                    parentKey,\n                    command: 'removeChildDependency',\n                });\n        }\n    }\n    getRangesArgs(types, start, end, asc) {\n        const queueKeys = this.queue.keys;\n        const transformedTypes = types.map(type => {\n            return type === 'waiting' ? 'wait' : type;\n        });\n        const keys = [queueKeys['']];\n        const args = [start, end, asc ? '1' : '0', ...transformedTypes];\n        return keys.concat(args);\n    }\n    async getRanges(types, start = 0, end = 1, asc = false) {\n        const client = await this.queue.client;\n        const args = this.getRangesArgs(types, start, end, asc);\n        return await this.execCommand(client, 'getRanges', args);\n    }\n    getCountsArgs(types) {\n        const queueKeys = this.queue.keys;\n        const transformedTypes = types.map(type => {\n            return type === 'waiting' ? 'wait' : type;\n        });\n        const keys = [queueKeys['']];\n        const args = [...transformedTypes];\n        return keys.concat(args);\n    }\n    async getCounts(types) {\n        const client = await this.queue.client;\n        const args = this.getCountsArgs(types);\n        return await this.execCommand(client, 'getCounts', args);\n    }\n    getCountsPerPriorityArgs(priorities) {\n        const keys = [\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.prioritized,\n        ];\n        const args = priorities;\n        return keys.concat(args);\n    }\n    async getCountsPerPriority(priorities) {\n        const client = await this.queue.client;\n        const args = this.getCountsPerPriorityArgs(priorities);\n        return await this.execCommand(client, 'getCountsPerPriority', args);\n    }\n    getDependencyCountsArgs(jobId, types) {\n        const keys = [\n            `${jobId}:processed`,\n            `${jobId}:dependencies`,\n            `${jobId}:failed`,\n            `${jobId}:unsuccessful`,\n        ].map(name => {\n            return this.queue.toKey(name);\n        });\n        const args = types;\n        return keys.concat(args);\n    }\n    async getDependencyCounts(jobId, types) {\n        const client = await this.queue.client;\n        const args = this.getDependencyCountsArgs(jobId, types);\n        return await this.execCommand(client, 'getDependencyCounts', args);\n    }\n    moveToCompletedArgs(job, returnvalue, removeOnComplete, token, fetchNext = false) {\n        const timestamp = Date.now();\n        return this.moveToFinishedArgs(job, returnvalue, 'returnvalue', removeOnComplete, 'completed', token, timestamp, fetchNext);\n    }\n    moveToFailedArgs(job, failedReason, removeOnFailed, token, fetchNext = false, fieldsToUpdate) {\n        const timestamp = Date.now();\n        return this.moveToFinishedArgs(job, failedReason, 'failedReason', removeOnFailed, 'failed', token, timestamp, fetchNext, fieldsToUpdate);\n    }\n    async isFinished(jobId, returnValue = false) {\n        const client = await this.queue.client;\n        const keys = ['completed', 'failed', jobId].map((key) => {\n            return this.queue.toKey(key);\n        });\n        return this.execCommand(client, 'isFinished', keys.concat([jobId, returnValue ? '1' : '']));\n    }\n    async getState(jobId) {\n        const client = await this.queue.client;\n        const keys = [\n            'completed',\n            'failed',\n            'delayed',\n            'active',\n            'wait',\n            'paused',\n            'waiting-children',\n            'prioritized',\n        ].map((key) => {\n            return this.queue.toKey(key);\n        });\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_2__.isRedisVersionLowerThan)(this.queue.redisVersion, '6.0.6')) {\n            return this.execCommand(client, 'getState', keys.concat([jobId]));\n        }\n        return this.execCommand(client, 'getStateV2', keys.concat([jobId]));\n    }\n    async changeDelay(jobId, delay) {\n        const client = await this.queue.client;\n        const args = this.changeDelayArgs(jobId, delay);\n        const result = await this.execCommand(client, 'changeDelay', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'changeDelay',\n                state: 'delayed',\n            });\n        }\n    }\n    changeDelayArgs(jobId, delay) {\n        const timestamp = Date.now();\n        const keys = [\n            this.queue.keys.delayed,\n            this.queue.keys.meta,\n            this.queue.keys.marker,\n            this.queue.keys.events,\n        ];\n        return keys.concat([\n            delay,\n            JSON.stringify(timestamp),\n            jobId,\n            this.queue.toKey(jobId),\n        ]);\n    }\n    async changePriority(jobId, priority = 0, lifo = false) {\n        const client = await this.queue.client;\n        const args = this.changePriorityArgs(jobId, priority, lifo);\n        const result = await this.execCommand(client, 'changePriority', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'changePriority',\n            });\n        }\n    }\n    changePriorityArgs(jobId, priority = 0, lifo = false) {\n        const keys = [\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.prioritized,\n            this.queue.keys.active,\n            this.queue.keys.pc,\n            this.queue.keys.marker,\n        ];\n        return keys.concat([priority, this.queue.toKey(''), jobId, lifo ? 1 : 0]);\n    }\n    moveToDelayedArgs(jobId, timestamp, token, delay, opts = {}) {\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.marker,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.delayed,\n            this.queue.toKey(jobId),\n            queueKeys.events,\n            queueKeys.meta,\n            queueKeys.stalled,\n        ];\n        return keys.concat([\n            this.queue.keys[''],\n            timestamp,\n            jobId,\n            token,\n            delay,\n            opts.skipAttempt ? '1' : '0',\n            opts.fieldsToUpdate\n                ? pack((0,_utils__WEBPACK_IMPORTED_MODULE_2__.objectToFlatArray)(opts.fieldsToUpdate))\n                : void 0,\n        ]);\n    }\n    moveToWaitingChildrenArgs(jobId, token, opts) {\n        const timestamp = Date.now();\n        const childKey = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.getParentKey)(opts.child);\n        const keys = [\n            'active',\n            'waiting-children',\n            jobId,\n            `${jobId}:dependencies`,\n            `${jobId}:unsuccessful`,\n            'stalled',\n            'events',\n        ].map(name => {\n            return this.queue.toKey(name);\n        });\n        return keys.concat([\n            token,\n            childKey !== null && childKey !== void 0 ? childKey : '',\n            JSON.stringify(timestamp),\n            jobId,\n            this.queue.toKey(''),\n        ]);\n    }\n    isMaxedArgs() {\n        const queueKeys = this.queue.keys;\n        const keys = [queueKeys.meta, queueKeys.active];\n        return keys;\n    }\n    async isMaxed() {\n        const client = await this.queue.client;\n        const args = this.isMaxedArgs();\n        return !!(await this.execCommand(client, 'isMaxed', args));\n    }\n    async moveToDelayed(jobId, timestamp, delay, token = '0', opts = {}) {\n        const client = await this.queue.client;\n        const args = this.moveToDelayedArgs(jobId, timestamp, token, delay, opts);\n        const result = await this.execCommand(client, 'moveToDelayed', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'moveToDelayed',\n                state: 'active',\n            });\n        }\n    }\n    /**\n     * Move parent job to waiting-children state.\n     *\n     * @returns true if job is successfully moved, false if there are pending dependencies.\n     * @throws JobNotExist\n     * This exception is thrown if jobId is missing.\n     * @throws JobLockNotExist\n     * This exception is thrown if job lock is missing.\n     * @throws JobNotInState\n     * This exception is thrown if job is not in active state.\n     */\n    async moveToWaitingChildren(jobId, token, opts = {}) {\n        const client = await this.queue.client;\n        const args = this.moveToWaitingChildrenArgs(jobId, token, opts);\n        const result = await this.execCommand(client, 'moveToWaitingChildren', args);\n        switch (result) {\n            case 0:\n                return true;\n            case 1:\n                return false;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId,\n                    command: 'moveToWaitingChildren',\n                    state: 'active',\n                });\n        }\n    }\n    getRateLimitTtlArgs(maxJobs) {\n        const keys = [\n            this.queue.keys.limiter,\n            this.queue.keys.meta,\n        ];\n        return keys.concat([maxJobs !== null && maxJobs !== void 0 ? maxJobs : '0']);\n    }\n    async getRateLimitTtl(maxJobs) {\n        const client = await this.queue.client;\n        const args = this.getRateLimitTtlArgs(maxJobs);\n        return this.execCommand(client, 'getRateLimitTtl', args);\n    }\n    /**\n     * Remove jobs in a specific state.\n     *\n     * @returns Id jobs from the deleted records.\n     */\n    async cleanJobsInSet(set, timestamp, limit = 0) {\n        const client = await this.queue.client;\n        return this.execCommand(client, 'cleanJobsInSet', [\n            this.queue.toKey(set),\n            this.queue.toKey('events'),\n            this.queue.toKey('repeat'),\n            this.queue.toKey(''),\n            timestamp,\n            limit,\n            set,\n        ]);\n    }\n    getJobSchedulerArgs(id) {\n        const keys = [this.queue.keys.repeat];\n        return keys.concat([id]);\n    }\n    async getJobScheduler(id) {\n        const client = await this.queue.client;\n        const args = this.getJobSchedulerArgs(id);\n        return this.execCommand(client, 'getJobScheduler', args);\n    }\n    retryJobArgs(jobId, lifo, token, opts = {}) {\n        const keys = [\n            this.queue.keys.active,\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.toKey(jobId),\n            this.queue.keys.meta,\n            this.queue.keys.events,\n            this.queue.keys.delayed,\n            this.queue.keys.prioritized,\n            this.queue.keys.pc,\n            this.queue.keys.marker,\n            this.queue.keys.stalled,\n        ];\n        const pushCmd = (lifo ? 'R' : 'L') + 'PUSH';\n        return keys.concat([\n            this.queue.toKey(''),\n            Date.now(),\n            pushCmd,\n            jobId,\n            token,\n            opts.fieldsToUpdate\n                ? pack((0,_utils__WEBPACK_IMPORTED_MODULE_2__.objectToFlatArray)(opts.fieldsToUpdate))\n                : void 0,\n        ]);\n    }\n    async retryJob(jobId, lifo, token = '0', opts = {}) {\n        const client = await this.queue.client;\n        const args = this.retryJobArgs(jobId, lifo, token, opts);\n        const result = await this.execCommand(client, 'retryJob', args);\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'retryJob',\n                state: 'active',\n            });\n        }\n    }\n    moveJobsToWaitArgs(state, count, timestamp) {\n        const keys = [\n            this.queue.toKey(''),\n            this.queue.keys.events,\n            this.queue.toKey(state),\n            this.queue.toKey('wait'),\n            this.queue.toKey('paused'),\n            this.queue.keys.meta,\n            this.queue.keys.active,\n            this.queue.keys.marker,\n        ];\n        const args = [count, timestamp, state];\n        return keys.concat(args);\n    }\n    async retryJobs(state = 'failed', count = 1000, timestamp = new Date().getTime()) {\n        const client = await this.queue.client;\n        const args = this.moveJobsToWaitArgs(state, count, timestamp);\n        return this.execCommand(client, 'moveJobsToWait', args);\n    }\n    async promoteJobs(count = 1000) {\n        const client = await this.queue.client;\n        const args = this.moveJobsToWaitArgs('delayed', count, Number.MAX_VALUE);\n        return this.execCommand(client, 'moveJobsToWait', args);\n    }\n    /**\n     * Attempts to reprocess a job\n     *\n     * @param job -\n     * @param state - The expected job state. If the job is not found\n     * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'\n     *\n     * @returns Returns a promise that evaluates to a return code:\n     * 1 means the operation was a success\n     * 0 means the job does not exist\n     * -1 means the job is currently locked and can't be retried.\n     * -2 means the job was not found in the expected set\n     */\n    async reprocessJob(job, state) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(job.id),\n            this.queue.keys.events,\n            this.queue.toKey(state),\n            this.queue.keys.wait,\n            this.queue.keys.meta,\n            this.queue.keys.paused,\n            this.queue.keys.active,\n            this.queue.keys.marker,\n        ];\n        const args = [\n            job.id,\n            (job.opts.lifo ? 'R' : 'L') + 'PUSH',\n            state === 'failed' ? 'failedReason' : 'returnvalue',\n            state,\n        ];\n        const result = await this.execCommand(client, 'reprocessJob', keys.concat(args));\n        switch (result) {\n            case 1:\n                return;\n            default:\n                throw this.finishedErrors({\n                    code: result,\n                    jobId: job.id,\n                    command: 'reprocessJob',\n                    state,\n                });\n        }\n    }\n    async getMetrics(type, start = 0, end = -1) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.toKey(`metrics:${type}`),\n            this.queue.toKey(`metrics:${type}:data`),\n        ];\n        const args = [start, end];\n        const result = await this.execCommand(client, 'getMetrics', keys.concat(args));\n        return result;\n    }\n    async moveToActive(client, token, name) {\n        const opts = this.queue.opts;\n        const queueKeys = this.queue.keys;\n        const keys = [\n            queueKeys.wait,\n            queueKeys.active,\n            queueKeys.prioritized,\n            queueKeys.events,\n            queueKeys.stalled,\n            queueKeys.limiter,\n            queueKeys.delayed,\n            queueKeys.paused,\n            queueKeys.meta,\n            queueKeys.pc,\n            queueKeys.marker,\n        ];\n        const args = [\n            queueKeys[''],\n            Date.now(),\n            pack({\n                token,\n                lockDuration: opts.lockDuration,\n                limiter: opts.limiter,\n                name,\n            }),\n        ];\n        const result = await this.execCommand(client, 'moveToActive', keys.concat(args));\n        return raw2NextJobData(result);\n    }\n    async promote(jobId) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.keys.delayed,\n            this.queue.keys.wait,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.prioritized,\n            this.queue.keys.active,\n            this.queue.keys.pc,\n            this.queue.keys.events,\n            this.queue.keys.marker,\n        ];\n        const args = [this.queue.toKey(''), jobId];\n        const code = await this.execCommand(client, 'promote', keys.concat(args));\n        if (code < 0) {\n            throw this.finishedErrors({\n                code,\n                jobId,\n                command: 'promote',\n                state: 'delayed',\n            });\n        }\n    }\n    moveStalledJobsToWaitArgs() {\n        const opts = this.queue.opts;\n        const keys = [\n            this.queue.keys.stalled,\n            this.queue.keys.wait,\n            this.queue.keys.active,\n            this.queue.keys['stalled-check'],\n            this.queue.keys.meta,\n            this.queue.keys.paused,\n            this.queue.keys.marker,\n            this.queue.keys.events,\n        ];\n        const args = [\n            opts.maxStalledCount,\n            this.queue.toKey(''),\n            Date.now(),\n            opts.stalledInterval,\n        ];\n        return keys.concat(args);\n    }\n    /**\n     * Looks for unlocked jobs in the active queue.\n     *\n     * The job was being worked on, but the worker process died and it failed to renew the lock.\n     * We call these jobs 'stalled'. This is the most common case. We resolve these by moving them\n     * back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,\n     * (e.g. if the job handler keeps crashing),\n     * we limit the number stalled job recoveries to settings.maxStalledCount.\n     */\n    async moveStalledJobsToWait() {\n        const client = await this.queue.client;\n        const args = this.moveStalledJobsToWaitArgs();\n        return this.execCommand(client, 'moveStalledJobsToWait', args);\n    }\n    /**\n     * Moves a job back from Active to Wait.\n     * This script is used when a job has been manually rate limited and needs\n     * to be moved back to wait from active status.\n     *\n     * @param client - Redis client\n     * @param jobId - Job id\n     * @returns\n     */\n    async moveJobFromActiveToWait(jobId, token = '0') {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.keys.active,\n            this.queue.keys.wait,\n            this.queue.keys.stalled,\n            this.queue.keys.paused,\n            this.queue.keys.meta,\n            this.queue.keys.limiter,\n            this.queue.keys.prioritized,\n            this.queue.keys.marker,\n            this.queue.keys.events,\n        ];\n        const args = [jobId, token, this.queue.toKey(jobId)];\n        const result = await this.execCommand(client, 'moveJobFromActiveToWait', keys.concat(args));\n        if (result < 0) {\n            throw this.finishedErrors({\n                code: result,\n                jobId,\n                command: 'moveJobFromActiveToWait',\n                state: 'active',\n            });\n        }\n        return result;\n    }\n    async obliterate(opts) {\n        const client = await this.queue.client;\n        const keys = [\n            this.queue.keys.meta,\n            this.queue.toKey(''),\n        ];\n        const args = [opts.count, opts.force ? 'force' : null];\n        const result = await this.execCommand(client, 'obliterate', keys.concat(args));\n        if (result < 0) {\n            switch (result) {\n                case -1:\n                    throw new Error('Cannot obliterate non-paused queue');\n                case -2:\n                    throw new Error('Cannot obliterate queue with active jobs');\n            }\n        }\n        return result;\n    }\n    /**\n     * Paginate a set or hash keys.\n     * @param opts - options to define the pagination behaviour\n     *\n     */\n    async paginate(key, opts) {\n        const client = await this.queue.client;\n        const keys = [key];\n        const maxIterations = 5;\n        const pageSize = opts.end >= 0 ? opts.end - opts.start + 1 : Infinity;\n        let cursor = '0', offset = 0, items, total, rawJobs, page = [], jobs = [];\n        do {\n            const args = [\n                opts.start + page.length,\n                opts.end,\n                cursor,\n                offset,\n                maxIterations,\n            ];\n            if (opts.fetchJobs) {\n                args.push(1);\n            }\n            [cursor, offset, items, total, rawJobs] = await this.execCommand(client, 'paginate', keys.concat(args));\n            page = page.concat(items);\n            if (rawJobs && rawJobs.length) {\n                jobs = jobs.concat(rawJobs.map(_utils__WEBPACK_IMPORTED_MODULE_2__.array2obj));\n            }\n            // Important to keep this coercive inequality (!=) instead of strict inequality (!==)\n        } while (cursor != '0' && page.length < pageSize);\n        // If we get an array of arrays, it means we are paginating a hash\n        if (page.length && Array.isArray(page[0])) {\n            const result = [];\n            for (let index = 0; index < page.length; index++) {\n                const [id, value] = page[index];\n                try {\n                    result.push({ id, v: JSON.parse(value) });\n                }\n                catch (err) {\n                    result.push({ id, err: err.message });\n                }\n            }\n            return {\n                cursor,\n                items: result,\n                total,\n                jobs,\n            };\n        }\n        else {\n            return {\n                cursor,\n                items: page.map(item => ({ id: item })),\n                total,\n                jobs,\n            };\n        }\n    }\n    finishedErrors({ code, jobId, parentKey, command, state, }) {\n        let error;\n        switch (code) {\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobNotExist:\n                error = new Error(`Missing key for job ${jobId}. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobLockNotExist:\n                error = new Error(`Missing lock for job ${jobId}. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobNotInState:\n                error = new Error(`Job ${jobId} is not in the ${state} state. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobPendingChildren:\n                error = new Error(`Job ${jobId} has pending dependencies. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.ParentJobNotExist:\n                error = new Error(`Missing key for parent job ${parentKey}. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobLockMismatch:\n                error = new Error(`Lock mismatch for job ${jobId}. Cmd ${command} from ${state}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.ParentJobCannotBeReplaced:\n                error = new Error(`The parent job ${parentKey} cannot be replaced. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobBelongsToJobScheduler:\n                error = new Error(`Job ${jobId} belongs to a job scheduler and cannot be removed directly. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.JobHasFailedChildren:\n                error = new _errors__WEBPACK_IMPORTED_MODULE_4__.UnrecoverableError(`Cannot complete job ${jobId} because it has at least one failed child. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.SchedulerJobIdCollision:\n                error = new Error(`Cannot create job scheduler iteration - job ID already exists. ${command}`);\n                break;\n            case _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.SchedulerJobSlotsBusy:\n                error = new Error(`Cannot create job scheduler iteration - current and next time slots already have jobs. ${command}`);\n                break;\n            default:\n                error = new Error(`Unknown code ${code} error for ${jobId}. ${command}`);\n        }\n        // Add the code property to the error object\n        error.code = code;\n        return error;\n    }\n}\nfunction raw2NextJobData(raw) {\n    if (raw) {\n        const result = [null, raw[1], raw[2], raw[3]];\n        if (raw[0]) {\n            result[0] = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.array2obj)(raw[0]);\n        }\n        return result;\n    }\n    return [];\n}\n//# sourceMappingURL=scripts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2NyaXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNvQjtBQUNqQyxtQkFBbUIsMkNBQUs7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNxQztBQUMyRDtBQUN6QztBQUNUO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZLEdBQUcsYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYSxHQUFHLG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVcsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQ0FBa0MseURBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVksK0RBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3Qyx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBUztBQUN4RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQix5REFBeUQsTUFBTSxJQUFJLFFBQVE7QUFDM0U7QUFDQSxpQkFBaUIsNkNBQVM7QUFDMUIsMERBQTBELE1BQU0sSUFBSSxRQUFRO0FBQzVFO0FBQ0EsaUJBQWlCLDZDQUFTO0FBQzFCLHlDQUF5QyxPQUFPLGdCQUFnQixPQUFPLFNBQVMsUUFBUTtBQUN4RjtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQix5Q0FBeUMsT0FBTyw0QkFBNEIsUUFBUTtBQUNwRjtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQixnRUFBZ0UsVUFBVSxJQUFJLFFBQVE7QUFDdEY7QUFDQSxpQkFBaUIsNkNBQVM7QUFDMUIsMkRBQTJELE1BQU0sUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUMvRjtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQixvREFBb0QsV0FBVyxzQkFBc0IsUUFBUTtBQUM3RjtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQix5Q0FBeUMsT0FBTyw2REFBNkQsUUFBUTtBQUNySDtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQiw0QkFBNEIsdURBQWtCLHdCQUF3QixPQUFPLDRDQUE0QyxRQUFRO0FBQ2pJO0FBQ0EsaUJBQWlCLDZDQUFTO0FBQzFCLG9HQUFvRyxRQUFRO0FBQzVHO0FBQ0EsaUJBQWlCLDZDQUFTO0FBQzFCLDRIQUE0SCxRQUFRO0FBQ3BJO0FBQ0E7QUFDQSxrREFBa0QsTUFBTSxZQUFZLE1BQU0sSUFBSSxRQUFRO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvc2NyaXB0cy5qcz85YzU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5jbHVkZXMgYWxsIHRoZSBzY3JpcHRzIG5lZWRlZCBieSB0aGUgcXVldWUgYW5kIGpvYnMuXG4gKi9cbi8qZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBQYWNrciB9IGZyb20gJ21zZ3BhY2tyJztcbmNvbnN0IHBhY2tlciA9IG5ldyBQYWNrcih7XG4gICAgdXNlUmVjb3JkczogZmFsc2UsXG4gICAgZW5jb2RlVW5kZWZpbmVkQXNOaWw6IHRydWUsXG59KTtcbmNvbnN0IHBhY2sgPSBwYWNrZXIucGFjaztcbmltcG9ydCB7IEVycm9yQ29kZSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IGFycmF5Mm9iaiwgZ2V0UGFyZW50S2V5LCBpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbiwgb2JqZWN0VG9GbGF0QXJyYXksIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgdmVyc2lvbiBhcyBwYWNrYWdlVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0IHsgVW5yZWNvdmVyYWJsZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0IGNsYXNzIFNjcmlwdHMge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcGFja2FnZVZlcnNpb247XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgdGhpcy5tb3ZlVG9GaW5pc2hlZEtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLnN0YWxsZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubGltaXRlcixcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tZXRhLFxuICAgICAgICAgICAgcXVldWVLZXlzLnBjLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBleGVjQ29tbWFuZChjbGllbnQsIGNvbW1hbmROYW1lLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmROYW1lV2l0aFZlcnNpb24gPSBgJHtjb21tYW5kTmFtZX06JHt0aGlzLnZlcnNpb259YDtcbiAgICAgICAgcmV0dXJuIGNsaWVudFtjb21tYW5kTmFtZVdpdGhWZXJzaW9uXShhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgaXNKb2JJbkxpc3QobGlzdEtleSwgam9iSWQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbih0aGlzLnF1ZXVlLnJlZGlzVmVyc2lvbiwgJzYuMC42JykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnaXNKb2JJbkxpc3QnLCBbbGlzdEtleSwgam9iSWRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNsaWVudC5scG9zKGxpc3RLZXksIGpvYklkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihyZXN1bHQpO1xuICAgIH1cbiAgICBhZGREZWxheWVkSm9iQXJncyhqb2IsIGVuY29kZWRPcHRzLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tYXJrZXIsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmNvbXBsZXRlZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5ldmVudHMsXG4gICAgICAgIF07XG4gICAgICAgIGtleXMucHVzaChwYWNrKGFyZ3MpLCBqb2IuZGF0YSwgZW5jb2RlZE9wdHMpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgYWRkRGVsYXllZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnc0xpc3QgPSB0aGlzLmFkZERlbGF5ZWRKb2JBcmdzKGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdhZGREZWxheWVkSm9iJywgYXJnc0xpc3QpO1xuICAgIH1cbiAgICBhZGRQcmlvcml0aXplZEpvYkFyZ3Moam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMubWFya2VyLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1ldGEsXG4gICAgICAgICAgICBxdWV1ZUtleXMuaWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5jb21wbGV0ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuYWN0aXZlLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYyxcbiAgICAgICAgXTtcbiAgICAgICAga2V5cy5wdXNoKHBhY2soYXJncyksIGpvYi5kYXRhLCBlbmNvZGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBhZGRQcmlvcml0aXplZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnc0xpc3QgPSB0aGlzLmFkZFByaW9yaXRpemVkSm9iQXJncyhqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnYWRkUHJpb3JpdGl6ZWRKb2InLCBhcmdzTGlzdCk7XG4gICAgfVxuICAgIGFkZFBhcmVudEpvYkFyZ3Moam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmNvbXBsZXRlZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5ldmVudHMsXG4gICAgICAgIF07XG4gICAgICAgIGtleXMucHVzaChwYWNrKGFyZ3MpLCBqb2IuZGF0YSwgZW5jb2RlZE9wdHMpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgYWRkUGFyZW50Sm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBhcmdzTGlzdCA9IHRoaXMuYWRkUGFyZW50Sm9iQXJncyhqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnYWRkUGFyZW50Sm9iJywgYXJnc0xpc3QpO1xuICAgIH1cbiAgICBhZGRTdGFuZGFyZEpvYkFyZ3Moam9iLCBlbmNvZGVkT3B0cywgYXJncykge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWV0YSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5jb21wbGV0ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAga2V5cy5wdXNoKHBhY2soYXJncyksIGpvYi5kYXRhLCBlbmNvZGVkT3B0cyk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBhZGRTdGFuZGFyZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnc0xpc3QgPSB0aGlzLmFkZFN0YW5kYXJkSm9iQXJncyhqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnYWRkU3RhbmRhcmRKb2InLCBhcmdzTGlzdCk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEpvYihjbGllbnQsIGpvYiwgb3B0cywgam9iSWQsIHBhcmVudEtleU9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGpvYi5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgICAgICAgdHlwZW9mIGpvYklkICE9PSAndW5kZWZpbmVkJyA/IGpvYklkIDogJycsXG4gICAgICAgICAgICBqb2IubmFtZSxcbiAgICAgICAgICAgIGpvYi50aW1lc3RhbXAsXG4gICAgICAgICAgICBqb2IucGFyZW50S2V5IHx8IG51bGwsXG4gICAgICAgICAgICBwYXJlbnRLZXlPcHRzLndhaXRDaGlsZHJlbktleSB8fCBudWxsLFxuICAgICAgICAgICAgcGFyZW50S2V5T3B0cy5wYXJlbnREZXBlbmRlbmNpZXNLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGpvYi5yZXBlYXRKb2JLZXksXG4gICAgICAgICAgICBqb2IuZGVkdXBsaWNhdGlvbklkID8gYCR7cXVldWVLZXlzLmRlfToke2pvYi5kZWR1cGxpY2F0aW9uSWR9YCA6IG51bGwsXG4gICAgICAgIF07XG4gICAgICAgIGxldCBlbmNvZGVkT3B0cztcbiAgICAgICAgaWYgKG9wdHMucmVwZWF0KSB7XG4gICAgICAgICAgICBjb25zdCByZXBlYXQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLnJlcGVhdCk7XG4gICAgICAgICAgICBpZiAocmVwZWF0LnN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlcGVhdC5zdGFydERhdGUgPSArbmV3IERhdGUocmVwZWF0LnN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwZWF0LmVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXBlYXQuZW5kRGF0ZSA9ICtuZXcgRGF0ZShyZXBlYXQuZW5kRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGVkT3B0cyA9IHBhY2soT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyByZXBlYXQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlZE9wdHMgPSBwYWNrKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChwYXJlbnRLZXlPcHRzLndhaXRDaGlsZHJlbktleSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGRQYXJlbnRKb2IoY2xpZW50LCBqb2IsIGVuY29kZWRPcHRzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy5kZWxheSA9PSAnbnVtYmVyJyAmJiBvcHRzLmRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGREZWxheWVkSm9iKGNsaWVudCwgam9iLCBlbmNvZGVkT3B0cywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGRQcmlvcml0aXplZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGRTdGFuZGFyZEpvYihjbGllbnQsIGpvYiwgZW5jb2RlZE9wdHMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnRLZXlPcHRzLnBhcmVudEtleSxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnYWRkSm9iJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhdXNlQXJncyhwYXVzZSkge1xuICAgICAgICBsZXQgc3JjID0gJ3dhaXQnLCBkc3QgPSAncGF1c2VkJztcbiAgICAgICAgaWYgKCFwYXVzZSkge1xuICAgICAgICAgICAgc3JjID0gJ3BhdXNlZCc7XG4gICAgICAgICAgICBkc3QgPSAnd2FpdCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IFtzcmMsIGRzdCwgJ21ldGEnLCAncHJpb3JpdGl6ZWQnXS5tYXAoKG5hbWUpID0+IHRoaXMucXVldWUudG9LZXkobmFtZSkpO1xuICAgICAgICBrZXlzLnB1c2godGhpcy5xdWV1ZS5rZXlzLmV2ZW50cywgdGhpcy5xdWV1ZS5rZXlzLmRlbGF5ZWQsIHRoaXMucXVldWUua2V5cy5tYXJrZXIpO1xuICAgICAgICBjb25zdCBhcmdzID0gW3BhdXNlID8gJ3BhdXNlZCcgOiAncmVzdW1lZCddO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlKHBhdXNlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXVzZUFyZ3MocGF1c2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdwYXVzZScsIGFyZ3MpO1xuICAgIH1cbiAgICBhZGRSZXBlYXRhYmxlSm9iQXJncyhjdXN0b21LZXksIG5leHRNaWxsaXMsIG9wdHMsIGxlZ2FjeUN1c3RvbUtleSkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMucmVwZWF0LFxuICAgICAgICAgICAgcXVldWVLZXlzLmRlbGF5ZWQsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXh0TWlsbGlzLFxuICAgICAgICAgICAgcGFjayhvcHRzKSxcbiAgICAgICAgICAgIGxlZ2FjeUN1c3RvbUtleSxcbiAgICAgICAgICAgIGN1c3RvbUtleSxcbiAgICAgICAgICAgIHF1ZXVlS2V5c1snJ10sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkUmVwZWF0YWJsZUpvYihjdXN0b21LZXksIG5leHRNaWxsaXMsIG9wdHMsIGxlZ2FjeUN1c3RvbUtleSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYWRkUmVwZWF0YWJsZUpvYkFyZ3MoY3VzdG9tS2V5LCBuZXh0TWlsbGlzLCBvcHRzLCBsZWdhY3lDdXN0b21LZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdhZGRSZXBlYXRhYmxlSm9iJywgYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEpvYlNjaGVkdWxlcihqb2JTY2hlZHVsZXJJZCwgbmV4dE1pbGxpcywgdGVtcGxhdGVEYXRhLCB0ZW1wbGF0ZU9wdHMsIG9wdHMsIGRlbGF5ZWRKb2JPcHRzLCBcbiAgICAvLyBUaGUgam9iIGlkIG9mIHRoZSBqb2IgdGhhdCBwcm9kdWNlZCB0aGlzIG5leHQgaXRlcmF0aW9uXG4gICAgcHJvZHVjZXJJZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgcXVldWVLZXlzLnJlcGVhdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLndhaXQsXG4gICAgICAgICAgICBxdWV1ZUtleXMucGF1c2VkLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1ldGEsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWFya2VyLFxuICAgICAgICAgICAgcXVldWVLZXlzLmlkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXh0TWlsbGlzLFxuICAgICAgICAgICAgcGFjayhvcHRzKSxcbiAgICAgICAgICAgIGpvYlNjaGVkdWxlcklkLFxuICAgICAgICAgICAgdGVtcGxhdGVEYXRhLFxuICAgICAgICAgICAgcGFjayh0ZW1wbGF0ZU9wdHMpLFxuICAgICAgICAgICAgcGFjayhkZWxheWVkSm9iT3B0cyksXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcXVldWVLZXlzWycnXSxcbiAgICAgICAgICAgIHByb2R1Y2VySWQgPyB0aGlzLnF1ZXVlLnRvS2V5KHByb2R1Y2VySWQpIDogJycsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnYWRkSm9iU2NoZWR1bGVyJywga2V5cy5jb25jYXQoYXJncykpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgJiYgcmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRKb2JTY2hlZHVsZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUmVwZWF0YWJsZUpvYk1pbGxpcyhjbGllbnQsIGN1c3RvbUtleSwgbmV4dE1pbGxpcywgbGVnYWN5Q3VzdG9tS2V5KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucmVwZWF0LFxuICAgICAgICAgICAgbmV4dE1pbGxpcyxcbiAgICAgICAgICAgIGN1c3RvbUtleSxcbiAgICAgICAgICAgIGxlZ2FjeUN1c3RvbUtleSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAndXBkYXRlUmVwZWF0YWJsZUpvYk1pbGxpcycsIGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVKb2JTY2hlZHVsZXJOZXh0TWlsbGlzKGpvYlNjaGVkdWxlcklkLCBuZXh0TWlsbGlzLCB0ZW1wbGF0ZURhdGEsIGRlbGF5ZWRKb2JPcHRzLCBcbiAgICAvLyBUaGUgam9iIGlkIG9mIHRoZSBqb2IgdGhhdCBwcm9kdWNlZCB0aGlzIG5leHQgaXRlcmF0aW9uIC0gVE9ETzogcmVtb3ZlIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG4gICAgcHJvZHVjZXJJZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgcXVldWVLZXlzLnJlcGVhdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLndhaXQsXG4gICAgICAgICAgICBxdWV1ZUtleXMucGF1c2VkLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1ldGEsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubWFya2VyLFxuICAgICAgICAgICAgcXVldWVLZXlzLmlkLFxuICAgICAgICAgICAgcXVldWVLZXlzLmV2ZW50cyxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYyxcbiAgICAgICAgICAgIHByb2R1Y2VySWQgPyB0aGlzLnF1ZXVlLnRvS2V5KHByb2R1Y2VySWQpIDogJycsXG4gICAgICAgICAgICBxdWV1ZUtleXMuYWN0aXZlLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgbmV4dE1pbGxpcyxcbiAgICAgICAgICAgIGpvYlNjaGVkdWxlcklkLFxuICAgICAgICAgICAgdGVtcGxhdGVEYXRhLFxuICAgICAgICAgICAgcGFjayhkZWxheWVkSm9iT3B0cyksXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcXVldWVLZXlzWycnXSxcbiAgICAgICAgICAgIHByb2R1Y2VySWQsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ3VwZGF0ZUpvYlNjaGVkdWxlcicsIGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgcmVtb3ZlUmVwZWF0YWJsZUFyZ3MobGVnYWN5UmVwZWF0Sm9iSWQsIHJlcGVhdENvbmNhdE9wdGlvbnMsIHJlcGVhdEpvYktleSkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbcXVldWVLZXlzLnJlcGVhdCwgcXVldWVLZXlzLmRlbGF5ZWQsIHF1ZXVlS2V5cy5ldmVudHNdO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgbGVnYWN5UmVwZWF0Sm9iSWQsXG4gICAgICAgICAgICB0aGlzLmdldFJlcGVhdENvbmNhdE9wdGlvbnMocmVwZWF0Q29uY2F0T3B0aW9ucywgcmVwZWF0Sm9iS2V5KSxcbiAgICAgICAgICAgIHJlcGVhdEpvYktleSxcbiAgICAgICAgICAgIHF1ZXVlS2V5c1snJ10sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gbmV4dCBicmVha2luZyBjaGFuZ2VcbiAgICBnZXRSZXBlYXRDb25jYXRPcHRpb25zKHJlcGVhdENvbmNhdE9wdGlvbnMsIHJlcGVhdEpvYktleSkge1xuICAgICAgICBpZiAocmVwZWF0Sm9iS2V5ICYmIHJlcGVhdEpvYktleS5zcGxpdCgnOicpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBlYXRKb2JLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdENvbmNhdE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVJlcGVhdGFibGUobGVnYWN5UmVwZWF0Sm9iSWQsIHJlcGVhdENvbmNhdE9wdGlvbnMsIHJlcGVhdEpvYktleSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucmVtb3ZlUmVwZWF0YWJsZUFyZ3MobGVnYWN5UmVwZWF0Sm9iSWQsIHJlcGVhdENvbmNhdE9wdGlvbnMsIHJlcGVhdEpvYktleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ3JlbW92ZVJlcGVhdGFibGUnLCBhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlSm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbcXVldWVLZXlzLnJlcGVhdCwgcXVldWVLZXlzLmRlbGF5ZWQsIHF1ZXVlS2V5cy5ldmVudHNdO1xuICAgICAgICBjb25zdCBhcmdzID0gW2pvYlNjaGVkdWxlcklkLCBxdWV1ZUtleXNbJyddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncmVtb3ZlSm9iU2NoZWR1bGVyJywga2V5cy5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICByZW1vdmVBcmdzKGpvYklkLCByZW1vdmVDaGlsZHJlbikge1xuICAgICAgICBjb25zdCBrZXlzID0gW2pvYklkLCAncmVwZWF0J10ubWFwKG5hbWUgPT4gdGhpcy5xdWV1ZS50b0tleShuYW1lKSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbam9iSWQsIHJlbW92ZUNoaWxkcmVuID8gMSA6IDAsIHRoaXMucXVldWUudG9LZXkoJycpXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmUoam9iSWQsIHJlbW92ZUNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5yZW1vdmVBcmdzKGpvYklkLCByZW1vdmVDaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncmVtb3ZlSm9iJywgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3JlbW92ZUpvYicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVVbnByb2Nlc3NlZENoaWxkcmVuKGpvYklkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoJycpLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgIF07XG4gICAgICAgIGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbicsIGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBleHRlbmRMb2NrKGpvYklkLCB0b2tlbiwgZHVyYXRpb24sIGNsaWVudCkge1xuICAgICAgICBjbGllbnQgPSBjbGllbnQgfHwgKGF3YWl0IHRoaXMucXVldWUuY2xpZW50KTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpICsgJzpsb2NrJyxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5zdGFsbGVkLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdleHRlbmRMb2NrJywgYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGV4dGVuZExvY2tzKGpvYklkcywgdG9rZW5zLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5zdGFsbGVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnJyksXG4gICAgICAgICAgICBwYWNrKHRva2VucyksXG4gICAgICAgICAgICBwYWNrKGpvYklkcyksXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnZXh0ZW5kTG9ja3MnLCBhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YShqb2IsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbdGhpcy5xdWV1ZS50b0tleShqb2IuaWQpXTtcbiAgICAgICAgY29uc3QgZGF0YUpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICd1cGRhdGVEYXRhJywga2V5cy5jb25jYXQoW2RhdGFKc29uXSkpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkOiBqb2IuaWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3VwZGF0ZURhdGEnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvZ3Jlc3Moam9iSWQsIHByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHByb2dyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICd1cGRhdGVQcm9ncmVzcycsIGtleXMuY29uY2F0KFtqb2JJZCwgcHJvZ3Jlc3NKc29uXSkpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd1cGRhdGVQcm9ncmVzcycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhZGRMb2coam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KGpvYklkKSxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpICsgJzpsb2dzJyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdhZGRMb2cnLCBrZXlzLmNvbmNhdChbam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MgPyBrZWVwTG9ncyA6ICcnXSkpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRMb2cnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbW92ZVRvRmluaXNoZWRBcmdzKGpvYiwgdmFsLCBwcm9wVmFsLCBzaG91bGRSZW1vdmUsIHRhcmdldCwgdG9rZW4sIHRpbWVzdGFtcCwgZmV0Y2hOZXh0ID0gdHJ1ZSwgZmllbGRzVG9VcGRhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLnF1ZXVlLm9wdHM7XG4gICAgICAgIGNvbnN0IHdvcmtlcktlZXBKb2JzID0gdGFyZ2V0ID09PSAnY29tcGxldGVkJyA/IG9wdHMucmVtb3ZlT25Db21wbGV0ZSA6IG9wdHMucmVtb3ZlT25GYWlsO1xuICAgICAgICBjb25zdCBtZXRyaWNzS2V5ID0gdGhpcy5xdWV1ZS50b0tleShgbWV0cmljczoke3RhcmdldH1gKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMubW92ZVRvRmluaXNoZWRLZXlzO1xuICAgICAgICBrZXlzWzEwXSA9IHF1ZXVlS2V5c1t0YXJnZXRdO1xuICAgICAgICBrZXlzWzExXSA9IHRoaXMucXVldWUudG9LZXkoKF9hID0gam9iLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIGtleXNbMTJdID0gbWV0cmljc0tleTtcbiAgICAgICAga2V5c1sxM10gPSB0aGlzLnF1ZXVlLmtleXMubWFya2VyO1xuICAgICAgICBjb25zdCBrZWVwSm9icyA9IHRoaXMuZ2V0S2VlcEpvYnMoc2hvdWxkUmVtb3ZlLCB3b3JrZXJLZWVwSm9icyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBqb2IuaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBwcm9wVmFsLFxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAnbnVsbCcgOiB2YWwsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAhZmV0Y2hOZXh0IHx8IHRoaXMucXVldWUuY2xvc2luZyA/IDAgOiAxLFxuICAgICAgICAgICAgcXVldWVLZXlzWycnXSxcbiAgICAgICAgICAgIHBhY2soe1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgICAgICAgICBrZWVwSm9icyxcbiAgICAgICAgICAgICAgICBsaW1pdGVyOiBvcHRzLmxpbWl0ZXIsXG4gICAgICAgICAgICAgICAgbG9ja0R1cmF0aW9uOiBvcHRzLmxvY2tEdXJhdGlvbixcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogam9iLm9wdHMuYXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgbWF4TWV0cmljc1NpemU6ICgoX2IgPSBvcHRzLm1ldHJpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhEYXRhUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICA/IChfYyA9IG9wdHMubWV0cmljcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heERhdGFQb2ludHNcbiAgICAgICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICBmcG9mOiAhISgoX2QgPSBqb2Iub3B0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZhaWxQYXJlbnRPbkZhaWx1cmUpLFxuICAgICAgICAgICAgICAgIGNwb2Y6ICEhKChfZSA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY29udGludWVQYXJlbnRPbkZhaWx1cmUpLFxuICAgICAgICAgICAgICAgIGlkb2Y6ICEhKChfZiA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaWdub3JlRGVwZW5kZW5jeU9uRmFpbHVyZSksXG4gICAgICAgICAgICAgICAgcmRvZjogISEoKF9nID0gam9iLm9wdHMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5yZW1vdmVEZXBlbmRlbmN5T25GYWlsdXJlKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmllbGRzVG9VcGRhdGUgPyBwYWNrKG9iamVjdFRvRmxhdEFycmF5KGZpZWxkc1RvVXBkYXRlKSkgOiB2b2lkIDAsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgZ2V0S2VlcEpvYnMoc2hvdWxkUmVtb3ZlLCB3b3JrZXJLZWVwSm9icykge1xuICAgICAgICBpZiAodHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJLZWVwSm9icyB8fCB7IGNvdW50OiBzaG91bGRSZW1vdmUgPyAwIDogLTEgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gc2hvdWxkUmVtb3ZlXG4gICAgICAgICAgICA6IHR5cGVvZiBzaG91bGRSZW1vdmUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyB7IGNvdW50OiBzaG91bGRSZW1vdmUgfVxuICAgICAgICAgICAgICAgIDogeyBjb3VudDogc2hvdWxkUmVtb3ZlID8gMCA6IC0xIH07XG4gICAgfVxuICAgIGFzeW5jIG1vdmVUb0ZpbmlzaGVkKGpvYklkLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ21vdmVUb0ZpbmlzaGVkJywgYXJncyk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ21vdmVUb0ZpbmlzaGVkJyxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2FjdGl2ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXcyTmV4dEpvYkRhdGEocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbkFyZ3MoZGVsYXllZCkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5yZXBlYXQsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbcXVldWVLZXlzWycnXSwgZGVsYXllZCA/ICcxJyA6ICcwJ107XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgZHJhaW4oZGVsYXllZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuZHJhaW5BcmdzKGRlbGF5ZWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdkcmFpbicsIGFyZ3MpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZERlcGVuZGVuY3lBcmdzKGpvYklkLCBwYXJlbnRLZXkpIHtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW3F1ZXVlS2V5c1snJ11dO1xuICAgICAgICBjb25zdCBhcmdzID0gW3RoaXMucXVldWUudG9LZXkoam9iSWQpLCBwYXJlbnRLZXldO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUNoaWxkRGVwZW5kZW5jeShqb2JJZCwgcGFyZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5yZW1vdmVDaGlsZERlcGVuZGVuY3lBcmdzKGpvYklkLCBwYXJlbnRLZXkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ3JlbW92ZUNoaWxkRGVwZW5kZW5jeScsIGFyZ3MpO1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3JlbW92ZUNoaWxkRGVwZW5kZW5jeScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmFuZ2VzQXJncyh0eXBlcywgc3RhcnQsIGVuZCwgYXNjKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHRoaXMucXVldWUua2V5cztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRUeXBlcyA9IHR5cGVzLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnd2FpdGluZycgPyAnd2FpdCcgOiB0eXBlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtxdWV1ZUtleXNbJyddXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdGFydCwgZW5kLCBhc2MgPyAnMScgOiAnMCcsIC4uLnRyYW5zZm9ybWVkVHlwZXNdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJhbmdlcyh0eXBlcywgc3RhcnQgPSAwLCBlbmQgPSAxLCBhc2MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuZ2V0UmFuZ2VzQXJncyh0eXBlcywgc3RhcnQsIGVuZCwgYXNjKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnZ2V0UmFuZ2VzJywgYXJncyk7XG4gICAgfVxuICAgIGdldENvdW50c0FyZ3ModHlwZXMpIHtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFR5cGVzID0gdHlwZXMubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICd3YWl0aW5nJyA/ICd3YWl0JyA6IHR5cGU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBrZXlzID0gW3F1ZXVlS2V5c1snJ11dO1xuICAgICAgICBjb25zdCBhcmdzID0gWy4uLnRyYW5zZm9ybWVkVHlwZXNdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGdldENvdW50cyh0eXBlcykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuZ2V0Q291bnRzQXJncyh0eXBlcyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ2dldENvdW50cycsIGFyZ3MpO1xuICAgIH1cbiAgICBnZXRDb3VudHNQZXJQcmlvcml0eUFyZ3MocHJpb3JpdGllcykge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLndhaXQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwcmlvcml0aWVzO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIGdldENvdW50c1BlclByaW9yaXR5KHByaW9yaXRpZXMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmdldENvdW50c1BlclByaW9yaXR5QXJncyhwcmlvcml0aWVzKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnZ2V0Q291bnRzUGVyUHJpb3JpdHknLCBhcmdzKTtcbiAgICB9XG4gICAgZ2V0RGVwZW5kZW5jeUNvdW50c0FyZ3Moam9iSWQsIHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBgJHtqb2JJZH06cHJvY2Vzc2VkYCxcbiAgICAgICAgICAgIGAke2pvYklkfTpkZXBlbmRlbmNpZXNgLFxuICAgICAgICAgICAgYCR7am9iSWR9OmZhaWxlZGAsXG4gICAgICAgICAgICBgJHtqb2JJZH06dW5zdWNjZXNzZnVsYCxcbiAgICAgICAgXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS50b0tleShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBnZXREZXBlbmRlbmN5Q291bnRzKGpvYklkLCB0eXBlcykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuZ2V0RGVwZW5kZW5jeUNvdW50c0FyZ3Moam9iSWQsIHR5cGVzKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnZ2V0RGVwZW5kZW5jeUNvdW50cycsIGFyZ3MpO1xuICAgIH1cbiAgICBtb3ZlVG9Db21wbGV0ZWRBcmdzKGpvYiwgcmV0dXJudmFsdWUsIHJlbW92ZU9uQ29tcGxldGUsIHRva2VuLCBmZXRjaE5leHQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlVG9GaW5pc2hlZEFyZ3Moam9iLCByZXR1cm52YWx1ZSwgJ3JldHVybnZhbHVlJywgcmVtb3ZlT25Db21wbGV0ZSwgJ2NvbXBsZXRlZCcsIHRva2VuLCB0aW1lc3RhbXAsIGZldGNoTmV4dCk7XG4gICAgfVxuICAgIG1vdmVUb0ZhaWxlZEFyZ3Moam9iLCBmYWlsZWRSZWFzb24sIHJlbW92ZU9uRmFpbGVkLCB0b2tlbiwgZmV0Y2hOZXh0ID0gZmFsc2UsIGZpZWxkc1RvVXBkYXRlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVUb0ZpbmlzaGVkQXJncyhqb2IsIGZhaWxlZFJlYXNvbiwgJ2ZhaWxlZFJlYXNvbicsIHJlbW92ZU9uRmFpbGVkLCAnZmFpbGVkJywgdG9rZW4sIHRpbWVzdGFtcCwgZmV0Y2hOZXh0LCBmaWVsZHNUb1VwZGF0ZSk7XG4gICAgfVxuICAgIGFzeW5jIGlzRmluaXNoZWQoam9iSWQsIHJldHVyblZhbHVlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbJ2NvbXBsZXRlZCcsICdmYWlsZWQnLCBqb2JJZF0ubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnRvS2V5KGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdpc0ZpbmlzaGVkJywga2V5cy5jb25jYXQoW2pvYklkLCByZXR1cm5WYWx1ZSA/ICcxJyA6ICcnXSkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdGF0ZShqb2JJZCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgICAgICAgJ2ZhaWxlZCcsXG4gICAgICAgICAgICAnZGVsYXllZCcsXG4gICAgICAgICAgICAnYWN0aXZlJyxcbiAgICAgICAgICAgICd3YWl0JyxcbiAgICAgICAgICAgICdwYXVzZWQnLFxuICAgICAgICAgICAgJ3dhaXRpbmctY2hpbGRyZW4nLFxuICAgICAgICAgICAgJ3ByaW9yaXRpemVkJyxcbiAgICAgICAgXS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUudG9LZXkoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbih0aGlzLnF1ZXVlLnJlZGlzVmVyc2lvbiwgJzYuMC42JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ2dldFN0YXRlJywga2V5cy5jb25jYXQoW2pvYklkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ2dldFN0YXRlVjInLCBrZXlzLmNvbmNhdChbam9iSWRdKSk7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZURlbGF5KGpvYklkLCBkZWxheSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuY2hhbmdlRGVsYXlBcmdzKGpvYklkLCBkZWxheSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnY2hhbmdlRGVsYXknLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2hhbmdlRGVsYXknLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnZGVsYXllZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VEZWxheUFyZ3Moam9iSWQsIGRlbGF5KSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZGVsYXllZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcixcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5ldmVudHMsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRpbWVzdGFtcCksXG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlUHJpb3JpdHkoam9iSWQsIHByaW9yaXR5ID0gMCwgbGlmbyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5jaGFuZ2VQcmlvcml0eUFyZ3Moam9iSWQsIHByaW9yaXR5LCBsaWZvKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdjaGFuZ2VQcmlvcml0eScsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjaGFuZ2VQcmlvcml0eScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VQcmlvcml0eUFyZ3Moam9iSWQsIHByaW9yaXR5ID0gMCwgbGlmbyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMud2FpdCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5wYXVzZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5hY3RpdmUsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGMsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoW3ByaW9yaXR5LCB0aGlzLnF1ZXVlLnRvS2V5KCcnKSwgam9iSWQsIGxpZm8gPyAxIDogMF0pO1xuICAgIH1cbiAgICBtb3ZlVG9EZWxheWVkQXJncyhqb2JJZCwgdGltZXN0YW1wLCB0b2tlbiwgZGVsYXksIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMubWFya2VyLFxuICAgICAgICAgICAgcXVldWVLZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShqb2JJZCksXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1ldGEsXG4gICAgICAgICAgICBxdWV1ZUtleXMuc3RhbGxlZCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5c1snJ10sXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBvcHRzLnNraXBBdHRlbXB0ID8gJzEnIDogJzAnLFxuICAgICAgICAgICAgb3B0cy5maWVsZHNUb1VwZGF0ZVxuICAgICAgICAgICAgICAgID8gcGFjayhvYmplY3RUb0ZsYXRBcnJheShvcHRzLmZpZWxkc1RvVXBkYXRlKSlcbiAgICAgICAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIG1vdmVUb1dhaXRpbmdDaGlsZHJlbkFyZ3Moam9iSWQsIHRva2VuLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gZ2V0UGFyZW50S2V5KG9wdHMuY2hpbGQpO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgJ2FjdGl2ZScsXG4gICAgICAgICAgICAnd2FpdGluZy1jaGlsZHJlbicsXG4gICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgIGAke2pvYklkfTpkZXBlbmRlbmNpZXNgLFxuICAgICAgICAgICAgYCR7am9iSWR9OnVuc3VjY2Vzc2Z1bGAsXG4gICAgICAgICAgICAnc3RhbGxlZCcsXG4gICAgICAgICAgICAnZXZlbnRzJyxcbiAgICAgICAgXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS50b0tleShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGNoaWxkS2V5ICE9PSBudWxsICYmIGNoaWxkS2V5ICE9PSB2b2lkIDAgPyBjaGlsZEtleSA6ICcnLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGltZXN0YW1wKSxcbiAgICAgICAgICAgIGpvYklkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnJyksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpc01heGVkQXJncygpIHtcbiAgICAgICAgY29uc3QgcXVldWVLZXlzID0gdGhpcy5xdWV1ZS5rZXlzO1xuICAgICAgICBjb25zdCBrZXlzID0gW3F1ZXVlS2V5cy5tZXRhLCBxdWV1ZUtleXMuYWN0aXZlXTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGFzeW5jIGlzTWF4ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5pc01heGVkQXJncygpO1xuICAgICAgICByZXR1cm4gISEoYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdpc01heGVkJywgYXJncykpO1xuICAgIH1cbiAgICBhc3luYyBtb3ZlVG9EZWxheWVkKGpvYklkLCB0aW1lc3RhbXAsIGRlbGF5LCB0b2tlbiA9ICcwJywgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5tb3ZlVG9EZWxheWVkQXJncyhqb2JJZCwgdGltZXN0YW1wLCB0b2tlbiwgZGVsYXksIG9wdHMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ21vdmVUb0RlbGF5ZWQnLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnbW92ZVRvRGVsYXllZCcsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdhY3RpdmUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZSBwYXJlbnQgam9iIHRvIHdhaXRpbmctY2hpbGRyZW4gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGpvYiBpcyBzdWNjZXNzZnVsbHkgbW92ZWQsIGZhbHNlIGlmIHRoZXJlIGFyZSBwZW5kaW5nIGRlcGVuZGVuY2llcy5cbiAgICAgKiBAdGhyb3dzIEpvYk5vdEV4aXN0XG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGlmIGpvYklkIGlzIG1pc3NpbmcuXG4gICAgICogQHRocm93cyBKb2JMb2NrTm90RXhpc3RcbiAgICAgKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgam9iIGxvY2sgaXMgbWlzc2luZy5cbiAgICAgKiBAdGhyb3dzIEpvYk5vdEluU3RhdGVcbiAgICAgKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgam9iIGlzIG5vdCBpbiBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYXN5bmMgbW92ZVRvV2FpdGluZ0NoaWxkcmVuKGpvYklkLCB0b2tlbiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5tb3ZlVG9XYWl0aW5nQ2hpbGRyZW5BcmdzKGpvYklkLCB0b2tlbiwgb3B0cyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnbW92ZVRvV2FpdGluZ0NoaWxkcmVuJywgYXJncyk7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ21vdmVUb1dhaXRpbmdDaGlsZHJlbicsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSYXRlTGltaXRUdGxBcmdzKG1heEpvYnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5saW1pdGVyLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbbWF4Sm9icyAhPT0gbnVsbCAmJiBtYXhKb2JzICE9PSB2b2lkIDAgPyBtYXhKb2JzIDogJzAnXSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJhdGVMaW1pdFR0bChtYXhKb2JzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5nZXRSYXRlTGltaXRUdGxBcmdzKG1heEpvYnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdnZXRSYXRlTGltaXRUdGwnLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGpvYnMgaW4gYSBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElkIGpvYnMgZnJvbSB0aGUgZGVsZXRlZCByZWNvcmRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFuSm9ic0luU2V0KHNldCwgdGltZXN0YW1wLCBsaW1pdCA9IDApIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ2NsZWFuSm9ic0luU2V0JywgW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShzZXQpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnZXZlbnRzJyksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCdyZXBlYXQnKSxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoJycpLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBzZXQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBnZXRKb2JTY2hlZHVsZXJBcmdzKGlkKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbdGhpcy5xdWV1ZS5rZXlzLnJlcGVhdF07XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbaWRdKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Sm9iU2NoZWR1bGVyKGlkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5nZXRKb2JTY2hlZHVsZXJBcmdzKGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnZ2V0Sm9iU2NoZWR1bGVyJywgYXJncyk7XG4gICAgfVxuICAgIHJldHJ5Sm9iQXJncyhqb2JJZCwgbGlmbywgdG9rZW4sIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy53YWl0LFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoam9iSWQpLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1ldGEsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmRlbGF5ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGMsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHB1c2hDbWQgPSAobGlmbyA/ICdSJyA6ICdMJykgKyAnUFVTSCc7XG4gICAgICAgIHJldHVybiBrZXlzLmNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBwdXNoQ21kLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIG9wdHMuZmllbGRzVG9VcGRhdGVcbiAgICAgICAgICAgICAgICA/IHBhY2sob2JqZWN0VG9GbGF0QXJyYXkob3B0cy5maWVsZHNUb1VwZGF0ZSkpXG4gICAgICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyByZXRyeUpvYihqb2JJZCwgbGlmbywgdG9rZW4gPSAnMCcsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucmV0cnlKb2JBcmdzKGpvYklkLCBsaWZvLCB0b2tlbiwgb3B0cyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncmV0cnlKb2InLCBhcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBqb2JJZCxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAncmV0cnlKb2InLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnYWN0aXZlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVKb2JzVG9XYWl0QXJncyhzdGF0ZSwgY291bnQsIHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleSgnJyksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShzdGF0ZSksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCd3YWl0JyksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCdwYXVzZWQnKSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tYXJrZXIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbY291bnQsIHRpbWVzdGFtcCwgc3RhdGVdO1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5Sm9icyhzdGF0ZSA9ICdmYWlsZWQnLCBjb3VudCA9IDEwMDAsIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5tb3ZlSm9ic1RvV2FpdEFyZ3Moc3RhdGUsIGNvdW50LCB0aW1lc3RhbXApO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdtb3ZlSm9ic1RvV2FpdCcsIGFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBwcm9tb3RlSm9icyhjb3VudCA9IDEwMDApIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLm1vdmVKb2JzVG9XYWl0QXJncygnZGVsYXllZCcsIGNvdW50LCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnbW92ZUpvYnNUb1dhaXQnLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcmVwcm9jZXNzIGEgam9iXG4gICAgICpcbiAgICAgKiBAcGFyYW0gam9iIC1cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBUaGUgZXhwZWN0ZWQgam9iIHN0YXRlLiBJZiB0aGUgam9iIGlzIG5vdCBmb3VuZFxuICAgICAqIG9uIHRoZSBwcm92aWRlZCBzdGF0ZSwgdGhlbiBpdCdzIG5vdCByZXByb2Nlc3NlZC4gU3VwcG9ydGVkIHN0YXRlczogJ2ZhaWxlZCcsICdjb21wbGV0ZWQnXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGV2YWx1YXRlcyB0byBhIHJldHVybiBjb2RlOlxuICAgICAqIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAgICogMCBtZWFucyB0aGUgam9iIGRvZXMgbm90IGV4aXN0XG4gICAgICogLTEgbWVhbnMgdGhlIGpvYiBpcyBjdXJyZW50bHkgbG9ja2VkIGFuZCBjYW4ndCBiZSByZXRyaWVkLlxuICAgICAqIC0yIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0XG4gICAgICovXG4gICAgYXN5bmMgcmVwcm9jZXNzSm9iKGpvYiwgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KGpvYi5pZCksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShzdGF0ZSksXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMud2FpdCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5hY3RpdmUsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWFya2VyLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgam9iLmlkLFxuICAgICAgICAgICAgKGpvYi5vcHRzLmxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnLFxuICAgICAgICAgICAgc3RhdGUgPT09ICdmYWlsZWQnID8gJ2ZhaWxlZFJlYXNvbicgOiAncmV0dXJudmFsdWUnLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncmVwcm9jZXNzSm9iJywga2V5cy5jb25jYXQoYXJncykpO1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5maW5pc2hlZEVycm9ycyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgam9iSWQ6IGpvYi5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3JlcHJvY2Vzc0pvYicsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE1ldHJpY3ModHlwZSwgc3RhcnQgPSAwLCBlbmQgPSAtMSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnF1ZXVlLmNsaWVudDtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoYG1ldHJpY3M6JHt0eXBlfWApLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS50b0tleShgbWV0cmljczoke3R5cGV9OmRhdGFgKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdnZXRNZXRyaWNzJywga2V5cy5jb25jYXQoYXJncykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBtb3ZlVG9BY3RpdmUoY2xpZW50LCB0b2tlbiwgbmFtZSkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5xdWV1ZS5vcHRzO1xuICAgICAgICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLnF1ZXVlLmtleXM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICBxdWV1ZUtleXMud2FpdCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5hY3RpdmUsXG4gICAgICAgICAgICBxdWV1ZUtleXMucHJpb3JpdGl6ZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMuZXZlbnRzLFxuICAgICAgICAgICAgcXVldWVLZXlzLnN0YWxsZWQsXG4gICAgICAgICAgICBxdWV1ZUtleXMubGltaXRlcixcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgICAgICAgcXVldWVLZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHF1ZXVlS2V5cy5tZXRhLFxuICAgICAgICAgICAgcXVldWVLZXlzLnBjLFxuICAgICAgICAgICAgcXVldWVLZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIHF1ZXVlS2V5c1snJ10sXG4gICAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcGFjayh7XG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgbG9ja0R1cmF0aW9uOiBvcHRzLmxvY2tEdXJhdGlvbixcbiAgICAgICAgICAgICAgICBsaW1pdGVyOiBvcHRzLmxpbWl0ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWNDb21tYW5kKGNsaWVudCwgJ21vdmVUb0FjdGl2ZScsIGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHJhdzJOZXh0Sm9iRGF0YShyZXN1bHQpO1xuICAgIH1cbiAgICBhc3luYyBwcm9tb3RlKGpvYklkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucXVldWUuY2xpZW50O1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLmRlbGF5ZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMud2FpdCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5wYXVzZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5wcmlvcml0aXplZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5hY3RpdmUsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMucGMsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYXJncyA9IFt0aGlzLnF1ZXVlLnRvS2V5KCcnKSwgam9iSWRdO1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5leGVjQ29tbWFuZChjbGllbnQsICdwcm9tb3RlJywga2V5cy5jb25jYXQoYXJncykpO1xuICAgICAgICBpZiAoY29kZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmluaXNoZWRFcnJvcnMoe1xuICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Byb21vdGUnLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnZGVsYXllZCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlU3RhbGxlZEpvYnNUb1dhaXRBcmdzKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5xdWV1ZS5vcHRzO1xuICAgICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMud2FpdCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5hY3RpdmUsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXNbJ3N0YWxsZWQtY2hlY2snXSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tZXRhLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnBhdXNlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5tYXJrZXIsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuZXZlbnRzLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgb3B0cy5tYXhTdGFsbGVkQ291bnQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgICAgICAgIERhdGUubm93KCksXG4gICAgICAgICAgICBvcHRzLnN0YWxsZWRJbnRlcnZhbCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGtleXMuY29uY2F0KGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyBmb3IgdW5sb2NrZWQgam9icyBpbiB0aGUgYWN0aXZlIHF1ZXVlLlxuICAgICAqXG4gICAgICogVGhlIGpvYiB3YXMgYmVpbmcgd29ya2VkIG9uLCBidXQgdGhlIHdvcmtlciBwcm9jZXNzIGRpZWQgYW5kIGl0IGZhaWxlZCB0byByZW5ldyB0aGUgbG9jay5cbiAgICAgKiBXZSBjYWxsIHRoZXNlIGpvYnMgJ3N0YWxsZWQnLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLiBXZSByZXNvbHZlIHRoZXNlIGJ5IG1vdmluZyB0aGVtXG4gICAgICogYmFjayB0byB3YWl0IHRvIGJlIHJlLXByb2Nlc3NlZC4gVG8gcHJldmVudCBqb2JzIGZyb20gY3ljbGluZyBlbmRsZXNzbHkgYmV0d2VlbiBhY3RpdmUgYW5kIHdhaXQsXG4gICAgICogKGUuZy4gaWYgdGhlIGpvYiBoYW5kbGVyIGtlZXBzIGNyYXNoaW5nKSxcbiAgICAgKiB3ZSBsaW1pdCB0aGUgbnVtYmVyIHN0YWxsZWQgam9iIHJlY292ZXJpZXMgdG8gc2V0dGluZ3MubWF4U3RhbGxlZENvdW50LlxuICAgICAqL1xuICAgIGFzeW5jIG1vdmVTdGFsbGVkSm9ic1RvV2FpdCgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLm1vdmVTdGFsbGVkSm9ic1RvV2FpdEFyZ3MoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnbW92ZVN0YWxsZWRKb2JzVG9XYWl0JywgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgam9iIGJhY2sgZnJvbSBBY3RpdmUgdG8gV2FpdC5cbiAgICAgKiBUaGlzIHNjcmlwdCBpcyB1c2VkIHdoZW4gYSBqb2IgaGFzIGJlZW4gbWFudWFsbHkgcmF0ZSBsaW1pdGVkIGFuZCBuZWVkc1xuICAgICAqIHRvIGJlIG1vdmVkIGJhY2sgdG8gd2FpdCBmcm9tIGFjdGl2ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50IC0gUmVkaXMgY2xpZW50XG4gICAgICogQHBhcmFtIGpvYklkIC0gSm9iIGlkXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBtb3ZlSm9iRnJvbUFjdGl2ZVRvV2FpdChqb2JJZCwgdG9rZW4gPSAnMCcpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuYWN0aXZlLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLndhaXQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMuc3RhbGxlZCxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5wYXVzZWQsXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5saW1pdGVyLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLnByaW9yaXRpemVkLFxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5rZXlzLm1hcmtlcixcbiAgICAgICAgICAgIHRoaXMucXVldWUua2V5cy5ldmVudHMsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbam9iSWQsIHRva2VuLCB0aGlzLnF1ZXVlLnRvS2V5KGpvYklkKV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQnLCBrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZpbmlzaGVkRXJyb3JzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ21vdmVKb2JGcm9tQWN0aXZlVG9XYWl0JyxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2FjdGl2ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBvYmxpdGVyYXRlKG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmtleXMubWV0YSxcbiAgICAgICAgICAgIHRoaXMucXVldWUudG9LZXkoJycpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBhcmdzID0gW29wdHMuY291bnQsIG9wdHMuZm9yY2UgPyAnZm9yY2UnIDogbnVsbF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAnb2JsaXRlcmF0ZScsIGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2JsaXRlcmF0ZSBub24tcGF1c2VkIHF1ZXVlJyk7XG4gICAgICAgICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2JsaXRlcmF0ZSBxdWV1ZSB3aXRoIGFjdGl2ZSBqb2JzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFnaW5hdGUgYSBzZXQgb3IgaGFzaCBrZXlzLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyB0byBkZWZpbmUgdGhlIHBhZ2luYXRpb24gYmVoYXZpb3VyXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwYWdpbmF0ZShrZXksIG9wdHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5xdWV1ZS5jbGllbnQ7XG4gICAgICAgIGNvbnN0IGtleXMgPSBba2V5XTtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDU7XG4gICAgICAgIGNvbnN0IHBhZ2VTaXplID0gb3B0cy5lbmQgPj0gMCA/IG9wdHMuZW5kIC0gb3B0cy5zdGFydCArIDEgOiBJbmZpbml0eTtcbiAgICAgICAgbGV0IGN1cnNvciA9ICcwJywgb2Zmc2V0ID0gMCwgaXRlbXMsIHRvdGFsLCByYXdKb2JzLCBwYWdlID0gW10sIGpvYnMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgICAgICBvcHRzLnN0YXJ0ICsgcGFnZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0cy5lbmQsXG4gICAgICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZldGNoSm9icykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtjdXJzb3IsIG9mZnNldCwgaXRlbXMsIHRvdGFsLCByYXdKb2JzXSA9IGF3YWl0IHRoaXMuZXhlY0NvbW1hbmQoY2xpZW50LCAncGFnaW5hdGUnLCBrZXlzLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBwYWdlID0gcGFnZS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgaWYgKHJhd0pvYnMgJiYgcmF3Sm9icy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBqb2JzID0gam9icy5jb25jYXQocmF3Sm9icy5tYXAoYXJyYXkyb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbXBvcnRhbnQgdG8ga2VlcCB0aGlzIGNvZXJjaXZlIGluZXF1YWxpdHkgKCE9KSBpbnN0ZWFkIG9mIHN0cmljdCBpbmVxdWFsaXR5ICghPT0pXG4gICAgICAgIH0gd2hpbGUgKGN1cnNvciAhPSAnMCcgJiYgcGFnZS5sZW5ndGggPCBwYWdlU2l6ZSk7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBhcnJheSBvZiBhcnJheXMsIGl0IG1lYW5zIHdlIGFyZSBwYWdpbmF0aW5nIGEgaGFzaFxuICAgICAgICBpZiAocGFnZS5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShwYWdlWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFnZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaWQsIHZhbHVlXSA9IHBhZ2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaWQsIHY6IEpTT04ucGFyc2UodmFsdWUpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgaWQsIGVycjogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBqb2JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBwYWdlLm1hcChpdGVtID0+ICh7IGlkOiBpdGVtIH0pKSxcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBqb2JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2hlZEVycm9ycyh7IGNvZGUsIGpvYklkLCBwYXJlbnRLZXksIGNvbW1hbmQsIHN0YXRlLCB9KSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5Kb2JOb3RFeGlzdDpcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyBrZXkgZm9yIGpvYiAke2pvYklkfS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTG9ja05vdEV4aXN0OlxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIGxvY2sgZm9yIGpvYiAke2pvYklkfS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTm90SW5TdGF0ZTpcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihgSm9iICR7am9iSWR9IGlzIG5vdCBpbiB0aGUgJHtzdGF0ZX0gc3RhdGUuICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkpvYlBlbmRpbmdDaGlsZHJlbjpcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihgSm9iICR7am9iSWR9IGhhcyBwZW5kaW5nIGRlcGVuZGVuY2llcy4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuUGFyZW50Sm9iTm90RXhpc3Q6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoYE1pc3Npbmcga2V5IGZvciBwYXJlbnQgam9iICR7cGFyZW50S2V5fS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iTG9ja01pc21hdGNoOlxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGBMb2NrIG1pc21hdGNoIGZvciBqb2IgJHtqb2JJZH0uIENtZCAke2NvbW1hbmR9IGZyb20gJHtzdGF0ZX1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlBhcmVudEpvYkNhbm5vdEJlUmVwbGFjZWQ6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoYFRoZSBwYXJlbnQgam9iICR7cGFyZW50S2V5fSBjYW5ub3QgYmUgcmVwbGFjZWQuICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkpvYkJlbG9uZ3NUb0pvYlNjaGVkdWxlcjpcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihgSm9iICR7am9iSWR9IGJlbG9uZ3MgdG8gYSBqb2Igc2NoZWR1bGVyIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZCBkaXJlY3RseS4gJHtjb21tYW5kfWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSm9iSGFzRmFpbGVkQ2hpbGRyZW46XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgVW5yZWNvdmVyYWJsZUVycm9yKGBDYW5ub3QgY29tcGxldGUgam9iICR7am9iSWR9IGJlY2F1c2UgaXQgaGFzIGF0IGxlYXN0IG9uZSBmYWlsZWQgY2hpbGQuICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlNjaGVkdWxlckpvYklkQ29sbGlzaW9uOlxuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGpvYiBzY2hlZHVsZXIgaXRlcmF0aW9uIC0gam9iIElEIGFscmVhZHkgZXhpc3RzLiAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5TY2hlZHVsZXJKb2JTbG90c0J1c3k6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgam9iIHNjaGVkdWxlciBpdGVyYXRpb24gLSBjdXJyZW50IGFuZCBuZXh0IHRpbWUgc2xvdHMgYWxyZWFkeSBoYXZlIGpvYnMuICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoYFVua25vd24gY29kZSAke2NvZGV9IGVycm9yIGZvciAke2pvYklkfS4gJHtjb21tYW5kfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29kZSBwcm9wZXJ0eSB0byB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJhdzJOZXh0Sm9iRGF0YShyYXcpIHtcbiAgICBpZiAocmF3KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtudWxsLCByYXdbMV0sIHJhd1syXSwgcmF3WzNdXTtcbiAgICAgICAgaWYgKHJhd1swXSkge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gYXJyYXkyb2JqKHJhd1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/classes/worker.js ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Worker: () => (/* binding */ Worker)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm/v4.js\");\n/* harmony import */ var node_abort_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node-abort-controller */ \"(rsc)/./node_modules/node-abort-controller/index.js\");\n/* harmony import */ var node_abort_controller__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(node_abort_controller__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _queue_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queue-base */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/queue-base.js\");\n/* harmony import */ var _repeat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./repeat */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/repeat.js\");\n/* harmony import */ var _child_pool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./child-pool */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/child-pool.js\");\n/* harmony import */ var _redis_connection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./redis-connection */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/redis-connection.js\");\n/* harmony import */ var _sandbox__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/sandbox.js\");\n/* harmony import */ var _async_fifo_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./async-fifo-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/async-fifo-queue.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/errors/index.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _job_scheduler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./job-scheduler */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/job-scheduler.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n// Note: this Polyfill is only needed for Node versions < 15.4.0\n\n\n\n\n\n\n\n\n\n\n\nconst ONE_SECOND = 1000;\n// 10 seconds is the maximum time a BZPOPMIN can block.\nconst maximumBlockTimeout = 10;\n// 30 seconds is the maximum limit until.\nconst maximumRateLimitDelay = 30000;\n/**\n *\n * This class represents a worker that is able to process jobs from the queue.\n * As soon as the class is instantiated and a connection to Redis is established\n * it will start processing jobs.\n *\n */\nclass Worker extends _queue_base__WEBPACK_IMPORTED_MODULE_5__.QueueBase {\n    static RateLimitError() {\n        return new _errors__WEBPACK_IMPORTED_MODULE_11__.RateLimitError();\n    }\n    constructor(name, processor, opts, Connection) {\n        super(name, Object.assign(Object.assign({ drainDelay: 5, concurrency: 1, lockDuration: 30000, maxStalledCount: 1, stalledInterval: 30000, autorun: true, runRetryDelay: 15000 }, opts), { blockingConnection: true }), Connection);\n        this.abortDelayController = null;\n        this.blockUntil = 0;\n        this.drained = false;\n        this.extendLocksTimer = null;\n        this.limitUntil = 0;\n        this.waiting = null;\n        this.running = false;\n        this.mainLoopRunning = null;\n        if (!opts || !opts.connection) {\n            throw new Error('Worker requires a connection');\n        }\n        if (typeof this.opts.maxStalledCount !== 'number' ||\n            this.opts.maxStalledCount < 0) {\n            throw new Error('maxStalledCount must be greater or equal than 0');\n        }\n        if (typeof this.opts.maxStartedAttempts === 'number' &&\n            this.opts.maxStartedAttempts < 0) {\n            throw new Error('maxStartedAttempts must be greater or equal than 0');\n        }\n        if (typeof this.opts.stalledInterval !== 'number' ||\n            this.opts.stalledInterval <= 0) {\n            throw new Error('stalledInterval must be greater than 0');\n        }\n        if (typeof this.opts.drainDelay !== 'number' || this.opts.drainDelay <= 0) {\n            throw new Error('drainDelay must be greater than 0');\n        }\n        this.concurrency = this.opts.concurrency;\n        this.opts.lockRenewTime =\n            this.opts.lockRenewTime || this.opts.lockDuration / 2;\n        this.id = (0,uuid__WEBPACK_IMPORTED_MODULE_14__[\"default\"])();\n        if (processor) {\n            if (typeof processor === 'function') {\n                this.processFn = processor;\n            }\n            else {\n                // SANDBOXED\n                if (processor instanceof url__WEBPACK_IMPORTED_MODULE_1__.URL) {\n                    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(processor)) {\n                        throw new Error(`URL ${processor} does not exist in the local file system`);\n                    }\n                    processor = processor.href;\n                }\n                else {\n                    const supportedFileTypes = ['.js', '.ts', '.flow', '.cjs', '.mjs'];\n                    const processorFile = processor +\n                        (supportedFileTypes.includes(path__WEBPACK_IMPORTED_MODULE_2__.extname(processor)) ? '' : '.js');\n                    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(processorFile)) {\n                        throw new Error(`File ${processorFile} does not exist`);\n                    }\n                }\n                // Separate paths so that bundling tools can resolve dependencies easier\n                const dirname = path__WEBPACK_IMPORTED_MODULE_2__.dirname(module.filename || __filename);\n                const workerThreadsMainFile = path__WEBPACK_IMPORTED_MODULE_2__.join(dirname, 'main-worker.js');\n                const spawnProcessMainFile = path__WEBPACK_IMPORTED_MODULE_2__.join(dirname, 'main.js');\n                let mainFilePath = this.opts.useWorkerThreads\n                    ? workerThreadsMainFile\n                    : spawnProcessMainFile;\n                try {\n                    fs__WEBPACK_IMPORTED_MODULE_0__.statSync(mainFilePath); // would throw if file not exists\n                }\n                catch (_) {\n                    const mainFile = this.opts.useWorkerThreads\n                        ? 'main-worker.js'\n                        : 'main.js';\n                    mainFilePath = path__WEBPACK_IMPORTED_MODULE_2__.join(process.cwd(), `dist/cjs/classes/${mainFile}`);\n                    fs__WEBPACK_IMPORTED_MODULE_0__.statSync(mainFilePath);\n                }\n                this.childPool = new _child_pool__WEBPACK_IMPORTED_MODULE_7__.ChildPool({\n                    mainFile: mainFilePath,\n                    useWorkerThreads: this.opts.useWorkerThreads,\n                    workerForkOptions: this.opts.workerForkOptions,\n                    workerThreadsOptions: this.opts.workerThreadsOptions,\n                });\n                this.processFn = (0,_sandbox__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(processor, this.childPool).bind(this);\n            }\n            if (this.opts.autorun) {\n                this.run().catch(error => this.emit('error', error));\n            }\n        }\n        const connectionName = this.clientName() + (this.opts.name ? `:w:${this.opts.name}` : '');\n        this.blockingConnection = new _redis_connection__WEBPACK_IMPORTED_MODULE_8__.RedisConnection((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isRedisInstance)(opts.connection)\n            ? opts.connection.duplicate({ connectionName })\n            : Object.assign(Object.assign({}, opts.connection), { connectionName }), {\n            shared: false,\n            blocking: true,\n            skipVersionCheck: opts.skipVersionCheck,\n        });\n        this.blockingConnection.on('error', error => this.emit('error', error));\n        this.blockingConnection.on('ready', () => setTimeout(() => this.emit('ready'), 0));\n    }\n    emit(event, ...args) {\n        return super.emit(event, ...args);\n    }\n    off(eventName, listener) {\n        super.off(eventName, listener);\n        return this;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        super.once(event, listener);\n        return this;\n    }\n    callProcessJob(job, token) {\n        return this.processFn(job, token);\n    }\n    createJob(data, jobId) {\n        return this.Job.fromJSON(this, data, jobId);\n    }\n    /**\n     *\n     * Waits until the worker is ready to start processing jobs.\n     * In general only useful when writing tests.\n     *\n     */\n    async waitUntilReady() {\n        await super.waitUntilReady();\n        return this.blockingConnection.client;\n    }\n    set concurrency(concurrency) {\n        if (typeof concurrency !== 'number' ||\n            concurrency < 1 ||\n            !isFinite(concurrency)) {\n            throw new Error('concurrency must be a finite number greater than 0');\n        }\n        this._concurrency = concurrency;\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    get repeat() {\n        return new Promise(async (resolve) => {\n            if (!this._repeat) {\n                const connection = await this.client;\n                this._repeat = new _repeat__WEBPACK_IMPORTED_MODULE_6__.Repeat(this.name, Object.assign(Object.assign({}, this.opts), { connection }));\n                this._repeat.on('error', e => this.emit.bind(this, e));\n            }\n            resolve(this._repeat);\n        });\n    }\n    get jobScheduler() {\n        return new Promise(async (resolve) => {\n            if (!this._jobScheduler) {\n                const connection = await this.client;\n                this._jobScheduler = new _job_scheduler__WEBPACK_IMPORTED_MODULE_13__.JobScheduler(this.name, Object.assign(Object.assign({}, this.opts), { connection }));\n                this._jobScheduler.on('error', e => this.emit.bind(this, e));\n            }\n            resolve(this._jobScheduler);\n        });\n    }\n    async run() {\n        if (!this.processFn) {\n            throw new Error('No process function is defined.');\n        }\n        if (this.running) {\n            throw new Error('Worker is already running.');\n        }\n        try {\n            this.running = true;\n            if (this.closing || this.paused) {\n                return;\n            }\n            await this.startStalledCheckTimer();\n            const client = await this.client;\n            const bclient = await this.blockingConnection.client;\n            this.mainLoopRunning = this.mainLoop(client, bclient);\n            // We must await here or finally will be called too early.\n            await this.mainLoopRunning;\n        }\n        finally {\n            this.running = false;\n        }\n    }\n    async waitForRateLimit() {\n        var _a;\n        const limitUntil = this.limitUntil;\n        if (limitUntil > Date.now()) {\n            (_a = this.abortDelayController) === null || _a === void 0 ? void 0 : _a.abort();\n            this.abortDelayController = new node_abort_controller__WEBPACK_IMPORTED_MODULE_3__.AbortController();\n            const delay = this.getRateLimitDelay(limitUntil - Date.now());\n            await this.delay(delay, this.abortDelayController);\n        }\n    }\n    /**\n     * This is the main loop in BullMQ. Its goals are to fetch jobs from the queue\n     * as efficiently as possible, providing concurrency and minimal unnecessary calls\n     * to Redis.\n     */\n    async mainLoop(client, bclient) {\n        const asyncFifoQueue = new _async_fifo_queue__WEBPACK_IMPORTED_MODULE_10__.AsyncFifoQueue();\n        const jobsInProgress = new Set();\n        this.startLockExtenderTimer(jobsInProgress);\n        let tokenPostfix = 0;\n        while ((!this.closing && !this.paused) || asyncFifoQueue.numTotal() > 0) {\n            /**\n             * This inner loop tries to fetch jobs concurrently, but if we are waiting for a job\n             * to arrive at the queue we should not try to fetch more jobs (as it would be pointless)\n             */\n            while (!this.closing &&\n                !this.paused &&\n                !this.waiting &&\n                asyncFifoQueue.numTotal() < this._concurrency &&\n                !this.isRateLimited()) {\n                const token = `${this.id}:${tokenPostfix++}`;\n                const fetchedJob = this.retryIfFailed(() => this._getNextJob(client, bclient, token, { block: true }), this.opts.runRetryDelay);\n                asyncFifoQueue.add(fetchedJob);\n                if (this.waiting && asyncFifoQueue.numTotal() > 1) {\n                    // We are waiting for jobs but we have others that we could start processing already\n                    break;\n                }\n                // We await here so that we fetch jobs in sequence, this is important to avoid unnecessary calls\n                // to Redis in high concurrency scenarios.\n                const job = await fetchedJob;\n                // No more jobs waiting but we have others that could start processing already\n                if (!job && asyncFifoQueue.numTotal() > 1) {\n                    break;\n                }\n                // If there are potential jobs to be processed and blockUntil is set, we should exit to avoid waiting\n                // for processing this job.\n                if (this.blockUntil) {\n                    break;\n                }\n            }\n            // Since there can be undefined jobs in the queue (when a job fails or queue is empty)\n            // we iterate until we find a job.\n            let job;\n            do {\n                job = await asyncFifoQueue.fetch();\n            } while (!job && asyncFifoQueue.numQueued() > 0);\n            if (job) {\n                const token = job.token;\n                asyncFifoQueue.add(this.retryIfFailed(() => this.processJob(job, token, () => asyncFifoQueue.numTotal() <= this._concurrency, jobsInProgress), this.opts.runRetryDelay));\n            }\n            else if (asyncFifoQueue.numQueued() === 0) {\n                await this.waitForRateLimit();\n            }\n        }\n    }\n    /**\n     * Returns a promise that resolves to the next job in queue.\n     * @param token - worker token to be assigned to retrieved job\n     * @returns a Job or undefined if no job was available in the queue.\n     */\n    async getNextJob(token, { block = true } = {}) {\n        var _a, _b;\n        const nextJob = await this._getNextJob(await this.client, await this.blockingConnection.client, token, { block });\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'getNextJob', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.QueueName]: this.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerOptions]: JSON.stringify({ block }),\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobId]: nextJob === null || nextJob === void 0 ? void 0 : nextJob.id,\n            });\n            return nextJob;\n        }, (_b = (_a = nextJob === null || nextJob === void 0 ? void 0 : nextJob.opts) === null || _a === void 0 ? void 0 : _a.telemetry) === null || _b === void 0 ? void 0 : _b.metadata);\n    }\n    async _getNextJob(client, bclient, token, { block = true } = {}) {\n        if (this.paused) {\n            return;\n        }\n        if (this.closing) {\n            return;\n        }\n        if (this.drained && block && !this.limitUntil && !this.waiting) {\n            this.waiting = this.waitForJob(bclient, this.blockUntil);\n            try {\n                this.blockUntil = await this.waiting;\n                if (this.blockUntil <= 0 || this.blockUntil - Date.now() < 1) {\n                    return await this.moveToActive(client, token, this.opts.name);\n                }\n            }\n            catch (err) {\n                // Swallow error if locally not paused or not closing since we did not force a disconnection\n                if (!(this.paused || this.closing) &&\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(err)) {\n                    throw err;\n                }\n            }\n            finally {\n                this.waiting = null;\n            }\n        }\n        else {\n            if (!this.isRateLimited()) {\n                return this.moveToActive(client, token, this.opts.name);\n            }\n        }\n    }\n    /**\n     * Overrides the rate limit to be active for the next jobs.\n     * @deprecated This method is deprecated and will be removed in v6. Use queue.rateLimit method instead.\n     * @param expireTimeMs - expire time in ms of this rate limit.\n     */\n    async rateLimit(expireTimeMs) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'rateLimit', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerRateLimit]: expireTimeMs,\n            });\n            await this.client.then(client => client.set(this.keys.limiter, Number.MAX_SAFE_INTEGER, 'PX', expireTimeMs));\n        });\n    }\n    get minimumBlockTimeout() {\n        return this.blockingConnection.capabilities.canBlockFor1Ms\n            ? /* 1 millisecond is chosen because the granularity of our timestamps are milliseconds.\n      Obviously we can still process much faster than 1 job per millisecond but delays and rate limits\n      will never work with more accuracy than 1ms. */\n                0.001\n            : 0.002;\n    }\n    isRateLimited() {\n        return this.limitUntil > Date.now();\n    }\n    async moveToActive(client, token, name) {\n        const [jobData, id, rateLimitDelay, delayUntil] = await this.scripts.moveToActive(client, token, name);\n        this.updateDelays(rateLimitDelay, delayUntil);\n        return this.nextJobFromJobData(jobData, id, token);\n    }\n    async waitForJob(bclient, blockUntil) {\n        if (this.paused) {\n            return Infinity;\n        }\n        let timeout;\n        try {\n            if (!this.closing && !this.isRateLimited()) {\n                let blockTimeout = this.getBlockTimeout(blockUntil);\n                if (blockTimeout > 0) {\n                    blockTimeout = this.blockingConnection.capabilities.canDoubleTimeout\n                        ? blockTimeout\n                        : Math.ceil(blockTimeout);\n                    // We cannot trust that the blocking connection stays blocking forever\n                    // due to issues in Redis and IORedis, so we will reconnect if we\n                    // don't get a response in the expected time.\n                    timeout = setTimeout(async () => {\n                        bclient.disconnect(!this.closing);\n                    }, blockTimeout * 1000 + 1000);\n                    this.updateDelays(); // reset delays to avoid reusing same values in next iteration\n                    // Markers should only be used for un-blocking, so we will handle them in this\n                    // function only.\n                    const result = await bclient.bzpopmin(this.keys.marker, blockTimeout);\n                    if (result) {\n                        const [_key, member, score] = result;\n                        if (member) {\n                            const newBlockUntil = parseInt(score);\n                            // Use by pro version as rate limited groups could generate lower blockUntil values\n                            // markers only return delays for delayed jobs\n                            if (blockUntil && newBlockUntil > blockUntil) {\n                                return blockUntil;\n                            }\n                            return newBlockUntil;\n                        }\n                    }\n                }\n                return 0;\n            }\n        }\n        catch (error) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(error)) {\n                this.emit('error', error);\n            }\n            if (!this.closing) {\n                await this.delay();\n            }\n        }\n        finally {\n            clearTimeout(timeout);\n        }\n        return Infinity;\n    }\n    getBlockTimeout(blockUntil) {\n        const opts = this.opts;\n        // when there are delayed jobs\n        if (blockUntil) {\n            const blockDelay = blockUntil - Date.now();\n            // when we reach the time to get new jobs\n            if (blockDelay <= 0) {\n                return blockDelay;\n            }\n            else if (blockDelay < this.minimumBlockTimeout * 1000) {\n                return this.minimumBlockTimeout;\n            }\n            else {\n                // We restrict the maximum block timeout to 10 second to avoid\n                // blocking the connection for too long in the case of reconnections\n                // reference: https://github.com/taskforcesh/bullmq/issues/1658\n                return Math.min(blockDelay / 1000, maximumBlockTimeout);\n            }\n        }\n        else {\n            return Math.max(opts.drainDelay, this.minimumBlockTimeout);\n        }\n    }\n    getRateLimitDelay(delay) {\n        // We restrict the maximum limit until to 30 second to\n        // be able to promote delayed jobs while queue is rate limited\n        return Math.min(delay, maximumRateLimitDelay);\n    }\n    /**\n     *\n     * This function is exposed only for testing purposes.\n     */\n    async delay(milliseconds, abortController) {\n        await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.delay)(milliseconds || _utils__WEBPACK_IMPORTED_MODULE_4__.DELAY_TIME_1, abortController);\n    }\n    updateDelays(limitDelay = 0, delayUntil = 0) {\n        const clampedLimit = Math.max(limitDelay, 0);\n        if (clampedLimit > 0) {\n            this.limitUntil = Date.now() + clampedLimit;\n        }\n        else {\n            this.limitUntil = 0;\n        }\n        this.blockUntil = Math.max(delayUntil, 0) || 0;\n    }\n    async nextJobFromJobData(jobData, jobId, token) {\n        if (!jobData) {\n            if (!this.drained) {\n                this.emit('drained');\n                this.drained = true;\n            }\n        }\n        else {\n            this.drained = false;\n            const job = this.createJob(jobData, jobId);\n            job.token = token;\n            try {\n                await this.retryIfFailed(async () => {\n                    if (job.repeatJobKey && job.repeatJobKey.split(':').length < 5) {\n                        const jobScheduler = await this.jobScheduler;\n                        await jobScheduler.upsertJobScheduler(\n                        // Most of these arguments are not really needed\n                        // anymore as we read them from the job scheduler itself\n                        job.repeatJobKey, job.opts.repeat, job.name, job.data, job.opts, { override: false, producerId: job.id });\n                    }\n                    else if (job.opts.repeat) {\n                        const repeat = await this.repeat;\n                        await repeat.updateRepeatableJob(job.name, job.data, job.opts, {\n                            override: false,\n                        });\n                    }\n                }, 2.5 * ONE_SECOND, // Wait 2.5 seconds between attempts\n                3);\n            }\n            catch (err) {\n                // Emit error but don't throw to avoid breaking current job completion\n                // and leaving the new job in stalled state\n                const errorMessage = err instanceof Error ? err.message : String(err);\n                const schedulingError = new Error(`Failed to add repeatable job for next iteration: ${errorMessage}`);\n                this.emit('error', schedulingError);\n                // Try to move the job to delayed with backoff to prevent infinite retry loops\n                try {\n                    // Calculate backoff delay: base delay of 5 seconds, exponentially increasing with attempts\n                    const baseDelay = ONE_SECOND; // 1 second\n                    const maxDelay = 300 * ONE_SECOND; // 5 minutes max\n                    const attempt = job.attemptsStarted;\n                    const exponentialDelay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n                    await job.moveToDelayed(Date.now() + exponentialDelay, job.token);\n                }\n                catch (moveErr) {\n                    // If we can't move it to delayed, emit error and let it become stalled\n                    // Stalled jobs will be automatically retried by the stalled checker\n                    const moveErrorMessage = moveErr instanceof Error ? moveErr.message : String(moveErr);\n                    this.emit('error', new Error(`Failed to move job ${job.id} to delayed after scheduling error: ${moveErrorMessage}. \n              Job will become stalled and be retried automatically.`));\n                }\n                // Return undefined to indicate no next job is available\n                return undefined;\n            }\n            return job;\n        }\n    }\n    async processJob(job, token, fetchNextCallback = () => true, jobsInProgress) {\n        var _a, _b;\n        const srcPropagationMedatada = (_b = (_a = job.opts) === null || _a === void 0 ? void 0 : _a.telemetry) === null || _b === void 0 ? void 0 : _b.metadata;\n        return this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.CONSUMER, 'process', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobId]: job.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobName]: job.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobAttemptsMade]: job.attemptsMade,\n            });\n            this.emit('active', job, 'waiting');\n            const processedOn = Date.now();\n            const inProgressItem = { job, ts: processedOn };\n            try {\n                const unrecoverableErrorMessage = this.getUnrecoverableErrorMessage(job);\n                if (unrecoverableErrorMessage) {\n                    const failed = await this.handleFailed(new _errors__WEBPACK_IMPORTED_MODULE_11__.UnrecoverableError(unrecoverableErrorMessage), job, token, fetchNextCallback, jobsInProgress, inProgressItem, span);\n                    return failed;\n                }\n                jobsInProgress.add(inProgressItem);\n                const result = await this.callProcessJob(job, token);\n                return await this.handleCompleted(result, job, token, fetchNextCallback, jobsInProgress, inProgressItem, span);\n            }\n            catch (err) {\n                const failed = await this.handleFailed(err, job, token, fetchNextCallback, jobsInProgress, inProgressItem, span);\n                return failed;\n            }\n            finally {\n                span === null || span === void 0 ? void 0 : span.setAttributes({\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobFinishedTimestamp]: Date.now(),\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobProcessedTimestamp]: processedOn,\n                });\n            }\n        }, srcPropagationMedatada);\n    }\n    getUnrecoverableErrorMessage(job) {\n        if (job.deferredFailure) {\n            return job.deferredFailure;\n        }\n        if (this.opts.maxStartedAttempts &&\n            this.opts.maxStartedAttempts < job.attemptsStarted) {\n            return 'job started more than allowable limit';\n        }\n    }\n    async handleCompleted(result, job, token, fetchNextCallback = () => true, jobsInProgress, inProgressItem, span) {\n        jobsInProgress.delete(inProgressItem);\n        if (!this.connection.closing) {\n            const completed = await job.moveToCompleted(result, token, fetchNextCallback() && !(this.closing || this.paused));\n            this.emit('completed', job, result, 'active');\n            span === null || span === void 0 ? void 0 : span.addEvent('job completed', {\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobResult]: JSON.stringify(result),\n            });\n            const [jobData, jobId, rateLimitDelay, delayUntil] = completed || [];\n            this.updateDelays(rateLimitDelay, delayUntil);\n            return this.nextJobFromJobData(jobData, jobId, token);\n        }\n    }\n    async handleFailed(err, job, token, fetchNextCallback = () => true, jobsInProgress, inProgressItem, span) {\n        jobsInProgress.delete(inProgressItem);\n        if (!this.connection.closing) {\n            try {\n                // Check if the job was manually rate-limited\n                if (err.message == _errors__WEBPACK_IMPORTED_MODULE_11__.RATE_LIMIT_ERROR) {\n                    const rateLimitTtl = await this.moveLimitedBackToWait(job, token);\n                    this.limitUntil = rateLimitTtl > 0 ? Date.now() + rateLimitTtl : 0;\n                    return;\n                }\n                if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_11__.DelayedError ||\n                    err.name == 'DelayedError' ||\n                    err instanceof _errors__WEBPACK_IMPORTED_MODULE_11__.WaitingError ||\n                    err.name == 'WaitingError' ||\n                    err instanceof _errors__WEBPACK_IMPORTED_MODULE_11__.WaitingChildrenError ||\n                    err.name == 'WaitingChildrenError') {\n                    return;\n                }\n                const result = await job.moveToFailed(err, token, fetchNextCallback() && !(this.closing || this.paused));\n                this.emit('failed', job, err, 'active');\n                span === null || span === void 0 ? void 0 : span.addEvent('job failed', {\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobFailedReason]: err.message,\n                });\n                if (result) {\n                    const [jobData, jobId, rateLimitDelay, delayUntil] = result;\n                    this.updateDelays(rateLimitDelay, delayUntil);\n                    return this.nextJobFromJobData(jobData, jobId, token);\n                }\n            }\n            catch (err) {\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(err)) {\n                    this.emit('error', err);\n                }\n                // It probably means that the job has lost the lock before completion\n                // A worker will (or already has) moved the job back\n                // to the waiting list (as stalled)\n                span === null || span === void 0 ? void 0 : span.recordException(err.message);\n            }\n        }\n    }\n    /**\n     *\n     * Pauses the processing of this queue only for this worker.\n     */\n    async pause(doNotWaitActive) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'pause', this.name, async (span) => {\n            var _a;\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerDoNotWaitActive]: doNotWaitActive,\n            });\n            if (!this.paused) {\n                this.paused = true;\n                if (!doNotWaitActive) {\n                    await this.whenCurrentJobsFinished();\n                }\n                (_a = this.stalledCheckStopper) === null || _a === void 0 ? void 0 : _a.call(this);\n                this.emit('paused');\n            }\n        });\n    }\n    /**\n     *\n     * Resumes processing of this worker (if paused).\n     */\n    resume() {\n        if (!this.running) {\n            this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'resume', this.name, span => {\n                span === null || span === void 0 ? void 0 : span.setAttributes({\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                });\n                this.paused = false;\n                if (this.processFn) {\n                    this.run();\n                }\n                this.emit('resumed');\n            });\n        }\n    }\n    /**\n     *\n     * Checks if worker is paused.\n     *\n     * @returns true if worker is paused, false otherwise.\n     */\n    isPaused() {\n        return !!this.paused;\n    }\n    /**\n     *\n     * Checks if worker is currently running.\n     *\n     * @returns true if worker is running, false otherwise.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     *\n     * Closes the worker and related redis connections.\n     *\n     * This method waits for current jobs to finalize before returning.\n     *\n     * @param force - Use force boolean parameter if you do not want to wait for\n     * current jobs to be processed. When using telemetry, be mindful that it can\n     * interfere with the proper closure of spans, potentially preventing them from being exported.\n     *\n     * @returns Promise that resolves when the worker has been closed.\n     */\n    async close(force = false) {\n        if (this.closing) {\n            return this.closing;\n        }\n        this.closing = (async () => {\n            await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'close', this.name, async (span) => {\n                var _a, _b;\n                span === null || span === void 0 ? void 0 : span.setAttributes({\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerForceClose]: force,\n                });\n                this.emit('closing', 'closing queue');\n                (_a = this.abortDelayController) === null || _a === void 0 ? void 0 : _a.abort();\n                // Define the async cleanup functions\n                const asyncCleanups = [\n                    () => {\n                        return force || this.whenCurrentJobsFinished(false);\n                    },\n                    () => { var _a; return (_a = this.childPool) === null || _a === void 0 ? void 0 : _a.clean(); },\n                    () => this.blockingConnection.close(force),\n                    () => this.connection.close(force),\n                ];\n                // Run cleanup functions sequentially and make sure all are run despite any errors\n                for (const cleanup of asyncCleanups) {\n                    try {\n                        await cleanup();\n                    }\n                    catch (err) {\n                        this.emit('error', err);\n                    }\n                }\n                clearTimeout(this.extendLocksTimer);\n                (_b = this.stalledCheckStopper) === null || _b === void 0 ? void 0 : _b.call(this);\n                this.closed = true;\n                this.emit('closed');\n            });\n        })();\n        return await this.closing;\n    }\n    /**\n     *\n     * Manually starts the stalled checker.\n     * The check will run once as soon as this method is called, and\n     * then every opts.stalledInterval milliseconds until the worker is closed.\n     * Note: Normally you do not need to call this method, since the stalled checker\n     * is automatically started when the worker starts processing jobs after\n     * calling run. However if you want to process the jobs manually you need\n     * to call this method to start the stalled checker.\n     *\n     * @see {@link https://docs.bullmq.io/patterns/manually-fetching-jobs}\n     */\n    async startStalledCheckTimer() {\n        if (!this.opts.skipStalledCheck) {\n            if (!this.closing) {\n                await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'startStalledCheckTimer', this.name, async (span) => {\n                    span === null || span === void 0 ? void 0 : span.setAttributes({\n                        [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                        [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                    });\n                    this.stalledChecker().catch(err => {\n                        this.emit('error', err);\n                    });\n                });\n            }\n        }\n    }\n    async stalledChecker() {\n        while (!(this.closing || this.paused)) {\n            await this.checkConnectionError(() => this.moveStalledJobsToWait());\n            await new Promise(resolve => {\n                const timeout = setTimeout(resolve, this.opts.stalledInterval);\n                this.stalledCheckStopper = () => {\n                    clearTimeout(timeout);\n                    resolve();\n                };\n            });\n        }\n    }\n    startLockExtenderTimer(jobsInProgress) {\n        if (!this.opts.skipLockRenewal) {\n            clearTimeout(this.extendLocksTimer);\n            if (!this.closed) {\n                this.extendLocksTimer = setTimeout(async () => {\n                    // Get all the jobs whose locks expire in less than 1/2 of the lockRenewTime\n                    const now = Date.now();\n                    const jobsToExtend = [];\n                    for (const item of jobsInProgress) {\n                        const { job, ts } = item;\n                        if (!ts) {\n                            item.ts = now;\n                            continue;\n                        }\n                        if (ts + this.opts.lockRenewTime / 2 < now) {\n                            item.ts = now;\n                            jobsToExtend.push(job);\n                        }\n                    }\n                    try {\n                        if (jobsToExtend.length) {\n                            await this.extendLocks(jobsToExtend);\n                        }\n                    }\n                    catch (err) {\n                        if ((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(err)) {\n                            this.emit('error', err);\n                        }\n                    }\n                    this.startLockExtenderTimer(jobsInProgress);\n                }, this.opts.lockRenewTime / 2);\n            }\n        }\n    }\n    /**\n     * Returns a promise that resolves when active jobs are cleared\n     *\n     * @returns\n     */\n    async whenCurrentJobsFinished(reconnect = true) {\n        //\n        // Force reconnection of blocking connection to abort blocking redis call immediately.\n        //\n        if (this.waiting) {\n            // If we are not going to reconnect, we will not wait for the disconnection.\n            await this.blockingConnection.disconnect(reconnect);\n        }\n        else {\n            reconnect = false;\n        }\n        if (this.mainLoopRunning) {\n            await this.mainLoopRunning;\n        }\n        reconnect && (await this.blockingConnection.reconnect());\n    }\n    async retryIfFailed(fn, delayInMs, maxRetries = Infinity) {\n        let retry = 0;\n        do {\n            try {\n                return await fn();\n            }\n            catch (err) {\n                if ((0,_utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError)(err)) {\n                    this.emit('error', err);\n                    if (delayInMs) {\n                        await this.delay(delayInMs);\n                    }\n                    throw err;\n                }\n                else {\n                    if (delayInMs) {\n                        await this.delay(delayInMs);\n                    }\n                    if (retry + 1 >= maxRetries) {\n                        // If we've reached max retries, throw the last error\n                        throw err;\n                    }\n                }\n            }\n        } while (++retry < maxRetries);\n    }\n    async extendLocks(jobs) {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'extendLocks', this.name, async (span) => {\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerJobsToExtendLocks]: jobs.map(job => job.id),\n            });\n            const erroredJobIds = await this.scripts.extendLocks(jobs.map(job => job.id), jobs.map(job => job.token), this.opts.lockDuration);\n            for (const jobId of erroredJobIds) {\n                // TODO: Send signal to process function that the job has been lost.\n                this.emit('error', new Error(`could not renew lock for job ${jobId}`));\n            }\n        });\n    }\n    async moveStalledJobsToWait() {\n        await this.trace(_enums__WEBPACK_IMPORTED_MODULE_12__.SpanKind.INTERNAL, 'moveStalledJobsToWait', this.name, async (span) => {\n            const stalled = await this.scripts.moveStalledJobsToWait();\n            span === null || span === void 0 ? void 0 : span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerId]: this.id,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerName]: this.opts.name,\n                [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.WorkerStalledJobs]: stalled,\n            });\n            stalled.forEach((jobId) => {\n                span === null || span === void 0 ? void 0 : span.addEvent('job stalled', {\n                    [_enums__WEBPACK_IMPORTED_MODULE_12__.TelemetryAttributes.JobId]: jobId,\n                });\n                this.emit('stalled', jobId, 'active');\n            });\n        });\n    }\n    moveLimitedBackToWait(job, token) {\n        return job.moveToWait(token);\n    }\n}\n//# sourceMappingURL=worker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2NsYXNzZXMvd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QjtBQUNDO0FBQ0c7QUFDSDtBQUMxQjtBQUN3RDtBQUMrQjtBQUM5QztBQUNQO0FBQ087QUFDWTtBQUNyQjtBQUNvQjtBQUMrRTtBQUMxRTtBQUNWO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQixrREFBUztBQUNyQztBQUNBLG1CQUFtQixvREFBYztBQUNqQztBQUNBO0FBQ0Esa0RBQWtELHFJQUFxSSxXQUFXLDBCQUEwQjtBQUM1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBRztBQUM1Qyx5QkFBeUIsMENBQWE7QUFDdEMsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlDQUFZO0FBQ2pFLHlCQUF5QiwwQ0FBYTtBQUN0QyxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUNBQVk7QUFDNUMsOENBQThDLHNDQUFTO0FBQ3ZELDZDQUE2QyxzQ0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBVyxnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBUyxvQ0FBb0MsU0FBUztBQUN6RixvQkFBb0Isd0NBQVc7QUFDL0I7QUFDQSxxQ0FBcUMsa0RBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUNBQWlDLG9EQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRixzQ0FBc0MsOERBQWUsQ0FBQyx1REFBZTtBQUNyRSwwQ0FBMEMsZ0JBQWdCO0FBQzFELDRDQUE0QyxzQkFBc0IsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBTSwwQ0FBMEMsZ0JBQWdCLFlBQVk7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQVksMENBQTBDLGdCQUFnQixZQUFZO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtFQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsR0FBRyxlQUFlO0FBQzNELHVHQUF1RyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlLElBQUk7QUFDakQ7QUFDQSxpSEFBaUgsT0FBTztBQUN4SCwwQkFBMEIsNkNBQVE7QUFDbEM7QUFDQSxpQkFBaUIsd0RBQW1CO0FBQ3BDLGlCQUFpQix3REFBbUI7QUFDcEMsaUJBQWlCLHdEQUFtQjtBQUNwQyxpQkFBaUIsd0RBQW1CLGtDQUFrQyxPQUFPO0FBQzdFLGlCQUFpQix3REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0RBQWdELGVBQWUsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBUTtBQUNqQztBQUNBLGlCQUFpQix3REFBbUI7QUFDcEMsaUJBQWlCLHdEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFLLGlCQUFpQixnREFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHFDQUFxQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxhQUFhO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVEscUNBQXFDLGlCQUFpQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFRO0FBQ2xDO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQyxpQkFBaUIsd0RBQW1CO0FBQ3BDLGlCQUFpQix3REFBbUI7QUFDcEMsaUJBQWlCLHdEQUFtQjtBQUNwQyxpQkFBaUIsd0RBQW1CO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx3REFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFtQjtBQUN4QyxxQkFBcUIsd0RBQW1CO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBWTtBQUMvQztBQUNBLG1DQUFtQyxrREFBWTtBQUMvQztBQUNBLG1DQUFtQywwREFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFtQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVE7QUFDakM7QUFDQTtBQUNBLGlCQUFpQix3REFBbUI7QUFDcEMsaUJBQWlCLHdEQUFtQjtBQUNwQyxpQkFBaUIsd0RBQW1CO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFRO0FBQy9CO0FBQ0EscUJBQXFCLHdEQUFtQjtBQUN4QyxxQkFBcUIsd0RBQW1CO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUFRO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQW1CO0FBQ3hDLHFCQUFxQix3REFBbUI7QUFDeEMscUJBQXFCLHdEQUFtQjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDRCQUE0QixRQUFRLCtFQUErRTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZDQUFRO0FBQ3pDO0FBQ0EseUJBQXlCLHdEQUFtQjtBQUM1Qyx5QkFBeUIsd0RBQW1CO0FBQzVDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVE7QUFDakM7QUFDQSxpQkFBaUIsd0RBQW1CO0FBQ3BDLGlCQUFpQix3REFBbUI7QUFDcEMsaUJBQWlCLHdEQUFtQjtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBUTtBQUNqQztBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQyxpQkFBaUIsd0RBQW1CO0FBQ3BDLGlCQUFpQix3REFBbUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQW1CO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vY2xhc3Nlcy93b3JrZXIuanM/MWYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG4vLyBOb3RlOiB0aGlzIFBvbHlmaWxsIGlzIG9ubHkgbmVlZGVkIGZvciBOb2RlIHZlcnNpb25zIDwgMTUuNC4wXG5pbXBvcnQgeyBBYm9ydENvbnRyb2xsZXIgfSBmcm9tICdub2RlLWFib3J0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgZGVsYXksIERFTEFZX1RJTUVfMSwgaXNOb3RDb25uZWN0aW9uRXJyb3IsIGlzUmVkaXNJbnN0YW5jZSwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBRdWV1ZUJhc2UgfSBmcm9tICcuL3F1ZXVlLWJhc2UnO1xuaW1wb3J0IHsgUmVwZWF0IH0gZnJvbSAnLi9yZXBlYXQnO1xuaW1wb3J0IHsgQ2hpbGRQb29sIH0gZnJvbSAnLi9jaGlsZC1wb29sJztcbmltcG9ydCB7IFJlZGlzQ29ubmVjdGlvbiB9IGZyb20gJy4vcmVkaXMtY29ubmVjdGlvbic7XG5pbXBvcnQgc2FuZGJveCBmcm9tICcuL3NhbmRib3gnO1xuaW1wb3J0IHsgQXN5bmNGaWZvUXVldWUgfSBmcm9tICcuL2FzeW5jLWZpZm8tcXVldWUnO1xuaW1wb3J0IHsgRGVsYXllZEVycm9yLCBSYXRlTGltaXRFcnJvciwgUkFURV9MSU1JVF9FUlJPUiwgV2FpdGluZ0NoaWxkcmVuRXJyb3IsIFdhaXRpbmdFcnJvciwgVW5yZWNvdmVyYWJsZUVycm9yLCB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IFNwYW5LaW5kLCBUZWxlbWV0cnlBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgSm9iU2NoZWR1bGVyIH0gZnJvbSAnLi9qb2Itc2NoZWR1bGVyJztcbmNvbnN0IE9ORV9TRUNPTkQgPSAxMDAwO1xuLy8gMTAgc2Vjb25kcyBpcyB0aGUgbWF4aW11bSB0aW1lIGEgQlpQT1BNSU4gY2FuIGJsb2NrLlxuY29uc3QgbWF4aW11bUJsb2NrVGltZW91dCA9IDEwO1xuLy8gMzAgc2Vjb25kcyBpcyB0aGUgbWF4aW11bSBsaW1pdCB1bnRpbC5cbmNvbnN0IG1heGltdW1SYXRlTGltaXREZWxheSA9IDMwMDAwO1xuLyoqXG4gKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgd29ya2VyIHRoYXQgaXMgYWJsZSB0byBwcm9jZXNzIGpvYnMgZnJvbSB0aGUgcXVldWUuXG4gKiBBcyBzb29uIGFzIHRoZSBjbGFzcyBpcyBpbnN0YW50aWF0ZWQgYW5kIGEgY29ubmVjdGlvbiB0byBSZWRpcyBpcyBlc3RhYmxpc2hlZFxuICogaXQgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGpvYnMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgV29ya2VyIGV4dGVuZHMgUXVldWVCYXNlIHtcbiAgICBzdGF0aWMgUmF0ZUxpbWl0RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0RXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJvY2Vzc29yLCBvcHRzLCBDb25uZWN0aW9uKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRyYWluRGVsYXk6IDUsIGNvbmN1cnJlbmN5OiAxLCBsb2NrRHVyYXRpb246IDMwMDAwLCBtYXhTdGFsbGVkQ291bnQ6IDEsIHN0YWxsZWRJbnRlcnZhbDogMzAwMDAsIGF1dG9ydW46IHRydWUsIHJ1blJldHJ5RGVsYXk6IDE1MDAwIH0sIG9wdHMpLCB7IGJsb2NraW5nQ29ubmVjdGlvbjogdHJ1ZSB9KSwgQ29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrVW50aWwgPSAwO1xuICAgICAgICB0aGlzLmRyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlbmRMb2Nrc1RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW1pdFVudGlsID0gMDtcbiAgICAgICAgdGhpcy53YWl0aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFpbkxvb3BSdW5uaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIHJlcXVpcmVzIGEgY29ubmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1heFN0YWxsZWRDb3VudCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXhTdGFsbGVkQ291bnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFN0YWxsZWRDb3VudCBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWF4U3RhcnRlZEF0dGVtcHRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdGhpcy5vcHRzLm1heFN0YXJ0ZWRBdHRlbXB0cyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4U3RhcnRlZEF0dGVtcHRzIG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5zdGFsbGVkSW50ZXJ2YWwgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0aGlzLm9wdHMuc3RhbGxlZEludGVydmFsIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhbGxlZEludGVydmFsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5kcmFpbkRlbGF5ICE9PSAnbnVtYmVyJyB8fCB0aGlzLm9wdHMuZHJhaW5EZWxheSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYWluRGVsYXkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uY3VycmVuY3kgPSB0aGlzLm9wdHMuY29uY3VycmVuY3k7XG4gICAgICAgIHRoaXMub3B0cy5sb2NrUmVuZXdUaW1lID1cbiAgICAgICAgICAgIHRoaXMub3B0cy5sb2NrUmVuZXdUaW1lIHx8IHRoaXMub3B0cy5sb2NrRHVyYXRpb24gLyAyO1xuICAgICAgICB0aGlzLmlkID0gdjQoKTtcbiAgICAgICAgaWYgKHByb2Nlc3Nvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NGbiA9IHByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNBTkRCT1hFRFxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3IgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHByb2Nlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVVJMICR7cHJvY2Vzc29yfSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRlZEZpbGVUeXBlcyA9IFsnLmpzJywgJy50cycsICcuZmxvdycsICcuY2pzJywgJy5tanMnXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yRmlsZSA9IHByb2Nlc3NvciArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3VwcG9ydGVkRmlsZVR5cGVzLmluY2x1ZGVzKHBhdGguZXh0bmFtZShwcm9jZXNzb3IpKSA/ICcnIDogJy5qcycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocHJvY2Vzc29yRmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSAke3Byb2Nlc3NvckZpbGV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdGUgcGF0aHMgc28gdGhhdCBidW5kbGluZyB0b29scyBjYW4gcmVzb2x2ZSBkZXBlbmRlbmNpZXMgZWFzaWVyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlybmFtZSA9IHBhdGguZGlybmFtZShtb2R1bGUuZmlsZW5hbWUgfHwgX19maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2VyVGhyZWFkc01haW5GaWxlID0gcGF0aC5qb2luKGRpcm5hbWUsICdtYWluLXdvcmtlci5qcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYXduUHJvY2Vzc01haW5GaWxlID0gcGF0aC5qb2luKGRpcm5hbWUsICdtYWluLmpzJyk7XG4gICAgICAgICAgICAgICAgbGV0IG1haW5GaWxlUGF0aCA9IHRoaXMub3B0cy51c2VXb3JrZXJUaHJlYWRzXG4gICAgICAgICAgICAgICAgICAgID8gd29ya2VyVGhyZWFkc01haW5GaWxlXG4gICAgICAgICAgICAgICAgICAgIDogc3Bhd25Qcm9jZXNzTWFpbkZpbGU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnMuc3RhdFN5bmMobWFpbkZpbGVQYXRoKTsgLy8gd291bGQgdGhyb3cgaWYgZmlsZSBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1haW5GaWxlID0gdGhpcy5vcHRzLnVzZVdvcmtlclRocmVhZHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ21haW4td29ya2VyLmpzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWFpbi5qcyc7XG4gICAgICAgICAgICAgICAgICAgIG1haW5GaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBgZGlzdC9janMvY2xhc3Nlcy8ke21haW5GaWxlfWApO1xuICAgICAgICAgICAgICAgICAgICBmcy5zdGF0U3luYyhtYWluRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkUG9vbCA9IG5ldyBDaGlsZFBvb2woe1xuICAgICAgICAgICAgICAgICAgICBtYWluRmlsZTogbWFpbkZpbGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICB1c2VXb3JrZXJUaHJlYWRzOiB0aGlzLm9wdHMudXNlV29ya2VyVGhyZWFkcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyRm9ya09wdGlvbnM6IHRoaXMub3B0cy53b3JrZXJGb3JrT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyVGhyZWFkc09wdGlvbnM6IHRoaXMub3B0cy53b3JrZXJUaHJlYWRzT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NGbiA9IHNhbmRib3gocHJvY2Vzc29yLCB0aGlzLmNoaWxkUG9vbCkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuKCkuY2F0Y2goZXJyb3IgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbk5hbWUgPSB0aGlzLmNsaWVudE5hbWUoKSArICh0aGlzLm9wdHMubmFtZSA/IGA6dzoke3RoaXMub3B0cy5uYW1lfWAgOiAnJyk7XG4gICAgICAgIHRoaXMuYmxvY2tpbmdDb25uZWN0aW9uID0gbmV3IFJlZGlzQ29ubmVjdGlvbihpc1JlZGlzSW5zdGFuY2Uob3B0cy5jb25uZWN0aW9uKVxuICAgICAgICAgICAgPyBvcHRzLmNvbm5lY3Rpb24uZHVwbGljYXRlKHsgY29ubmVjdGlvbk5hbWUgfSlcbiAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzLmNvbm5lY3Rpb24pLCB7IGNvbm5lY3Rpb25OYW1lIH0pLCB7XG4gICAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tpbmc6IHRydWUsXG4gICAgICAgICAgICBza2lwVmVyc2lvbkNoZWNrOiBvcHRzLnNraXBWZXJzaW9uQ2hlY2ssXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5vbignZXJyb3InLCBlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICAgICAgdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24ub24oJ3JlYWR5JywgKCkgPT4gc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoJ3JlYWR5JyksIDApKTtcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub25jZShldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FsbFByb2Nlc3NKb2Ioam9iLCB0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRm4oam9iLCB0b2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZUpvYihkYXRhLCBqb2JJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Kb2IuZnJvbUpTT04odGhpcywgZGF0YSwgam9iSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSB3b3JrZXIgaXMgcmVhZHkgdG8gc3RhcnQgcHJvY2Vzc2luZyBqb2JzLlxuICAgICAqIEluIGdlbmVyYWwgb25seSB1c2VmdWwgd2hlbiB3cml0aW5nIHRlc3RzLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFVudGlsUmVhZHkoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLndhaXRVbnRpbFJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jbGllbnQ7XG4gICAgfVxuICAgIHNldCBjb25jdXJyZW5jeShjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgY29uY3VycmVuY3kgPCAxIHx8XG4gICAgICAgICAgICAhaXNGaW5pdGUoY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbmN1cnJlbmN5IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeTtcbiAgICB9XG4gICAgZ2V0IGNvbmN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIGdldCByZXBlYXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5jbGllbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0ID0gbmV3IFJlcGVhdCh0aGlzLm5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKSwgeyBjb25uZWN0aW9uIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXQub24oJ2Vycm9yJywgZSA9PiB0aGlzLmVtaXQuYmluZCh0aGlzLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgam9iU2NoZWR1bGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fam9iU2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuY2xpZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2pvYlNjaGVkdWxlciA9IG5ldyBKb2JTY2hlZHVsZXIodGhpcy5uYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cyksIHsgY29ubmVjdGlvbiB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fam9iU2NoZWR1bGVyLm9uKCdlcnJvcicsIGUgPT4gdGhpcy5lbWl0LmJpbmQodGhpcywgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9qb2JTY2hlZHVsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc0ZuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByb2Nlc3MgZnVuY3Rpb24gaXMgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zaW5nIHx8IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFN0YWxsZWRDaGVja1RpbWVyKCk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudDtcbiAgICAgICAgICAgIGNvbnN0IGJjbGllbnQgPSBhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jbGllbnQ7XG4gICAgICAgICAgICB0aGlzLm1haW5Mb29wUnVubmluZyA9IHRoaXMubWFpbkxvb3AoY2xpZW50LCBiY2xpZW50KTtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgYXdhaXQgaGVyZSBvciBmaW5hbGx5IHdpbGwgYmUgY2FsbGVkIHRvbyBlYXJseS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWFpbkxvb3BSdW5uaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgd2FpdEZvclJhdGVMaW1pdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBsaW1pdFVudGlsID0gdGhpcy5saW1pdFVudGlsO1xuICAgICAgICBpZiAobGltaXRVbnRpbCA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYWJvcnREZWxheUNvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5hYm9ydERlbGF5Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5nZXRSYXRlTGltaXREZWxheShsaW1pdFVudGlsIC0gRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KGRlbGF5LCB0aGlzLmFib3J0RGVsYXlDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGxvb3AgaW4gQnVsbE1RLiBJdHMgZ29hbHMgYXJlIHRvIGZldGNoIGpvYnMgZnJvbSB0aGUgcXVldWVcbiAgICAgKiBhcyBlZmZpY2llbnRseSBhcyBwb3NzaWJsZSwgcHJvdmlkaW5nIGNvbmN1cnJlbmN5IGFuZCBtaW5pbWFsIHVubmVjZXNzYXJ5IGNhbGxzXG4gICAgICogdG8gUmVkaXMuXG4gICAgICovXG4gICAgYXN5bmMgbWFpbkxvb3AoY2xpZW50LCBiY2xpZW50KSB7XG4gICAgICAgIGNvbnN0IGFzeW5jRmlmb1F1ZXVlID0gbmV3IEFzeW5jRmlmb1F1ZXVlKCk7XG4gICAgICAgIGNvbnN0IGpvYnNJblByb2dyZXNzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN0YXJ0TG9ja0V4dGVuZGVyVGltZXIoam9ic0luUHJvZ3Jlc3MpO1xuICAgICAgICBsZXQgdG9rZW5Qb3N0Zml4ID0gMDtcbiAgICAgICAgd2hpbGUgKCghdGhpcy5jbG9zaW5nICYmICF0aGlzLnBhdXNlZCkgfHwgYXN5bmNGaWZvUXVldWUubnVtVG90YWwoKSA+IDApIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBpbm5lciBsb29wIHRyaWVzIHRvIGZldGNoIGpvYnMgY29uY3VycmVudGx5LCBidXQgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGEgam9iXG4gICAgICAgICAgICAgKiB0byBhcnJpdmUgYXQgdGhlIHF1ZXVlIHdlIHNob3VsZCBub3QgdHJ5IHRvIGZldGNoIG1vcmUgam9icyAoYXMgaXQgd291bGQgYmUgcG9pbnRsZXNzKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuY2xvc2luZyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnBhdXNlZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLndhaXRpbmcgJiZcbiAgICAgICAgICAgICAgICBhc3luY0ZpZm9RdWV1ZS5udW1Ub3RhbCgpIDwgdGhpcy5fY29uY3VycmVuY3kgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pc1JhdGVMaW1pdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IGAke3RoaXMuaWR9OiR7dG9rZW5Qb3N0Zml4Kyt9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkSm9iID0gdGhpcy5yZXRyeUlmRmFpbGVkKCgpID0+IHRoaXMuX2dldE5leHRKb2IoY2xpZW50LCBiY2xpZW50LCB0b2tlbiwgeyBibG9jazogdHJ1ZSB9KSwgdGhpcy5vcHRzLnJ1blJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgIGFzeW5jRmlmb1F1ZXVlLmFkZChmZXRjaGVkSm9iKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53YWl0aW5nICYmIGFzeW5jRmlmb1F1ZXVlLm51bVRvdGFsKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSB3YWl0aW5nIGZvciBqb2JzIGJ1dCB3ZSBoYXZlIG90aGVycyB0aGF0IHdlIGNvdWxkIHN0YXJ0IHByb2Nlc3NpbmcgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgYXdhaXQgaGVyZSBzbyB0aGF0IHdlIGZldGNoIGpvYnMgaW4gc2VxdWVuY2UsIHRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNhbGxzXG4gICAgICAgICAgICAgICAgLy8gdG8gUmVkaXMgaW4gaGlnaCBjb25jdXJyZW5jeSBzY2VuYXJpb3MuXG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gYXdhaXQgZmV0Y2hlZEpvYjtcbiAgICAgICAgICAgICAgICAvLyBObyBtb3JlIGpvYnMgd2FpdGluZyBidXQgd2UgaGF2ZSBvdGhlcnMgdGhhdCBjb3VsZCBzdGFydCBwcm9jZXNzaW5nIGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoIWpvYiAmJiBhc3luY0ZpZm9RdWV1ZS5udW1Ub3RhbCgpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHBvdGVudGlhbCBqb2JzIHRvIGJlIHByb2Nlc3NlZCBhbmQgYmxvY2tVbnRpbCBpcyBzZXQsIHdlIHNob3VsZCBleGl0IHRvIGF2b2lkIHdhaXRpbmdcbiAgICAgICAgICAgICAgICAvLyBmb3IgcHJvY2Vzc2luZyB0aGlzIGpvYi5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja1VudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGNhbiBiZSB1bmRlZmluZWQgam9icyBpbiB0aGUgcXVldWUgKHdoZW4gYSBqb2IgZmFpbHMgb3IgcXVldWUgaXMgZW1wdHkpXG4gICAgICAgICAgICAvLyB3ZSBpdGVyYXRlIHVudGlsIHdlIGZpbmQgYSBqb2IuXG4gICAgICAgICAgICBsZXQgam9iO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGpvYiA9IGF3YWl0IGFzeW5jRmlmb1F1ZXVlLmZldGNoKCk7XG4gICAgICAgICAgICB9IHdoaWxlICgham9iICYmIGFzeW5jRmlmb1F1ZXVlLm51bVF1ZXVlZCgpID4gMCk7XG4gICAgICAgICAgICBpZiAoam9iKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBqb2IudG9rZW47XG4gICAgICAgICAgICAgICAgYXN5bmNGaWZvUXVldWUuYWRkKHRoaXMucmV0cnlJZkZhaWxlZCgoKSA9PiB0aGlzLnByb2Nlc3NKb2Ioam9iLCB0b2tlbiwgKCkgPT4gYXN5bmNGaWZvUXVldWUubnVtVG90YWwoKSA8PSB0aGlzLl9jb25jdXJyZW5jeSwgam9ic0luUHJvZ3Jlc3MpLCB0aGlzLm9wdHMucnVuUmV0cnlEZWxheSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXN5bmNGaWZvUXVldWUubnVtUXVldWVkKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JSYXRlTGltaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXh0IGpvYiBpbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB3b3JrZXIgdG9rZW4gdG8gYmUgYXNzaWduZWQgdG8gcmV0cmlldmVkIGpvYlxuICAgICAqIEByZXR1cm5zIGEgSm9iIG9yIHVuZGVmaW5lZCBpZiBubyBqb2Igd2FzIGF2YWlsYWJsZSBpbiB0aGUgcXVldWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TmV4dEpvYih0b2tlbiwgeyBibG9jayA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG5leHRKb2IgPSBhd2FpdCB0aGlzLl9nZXROZXh0Sm9iKGF3YWl0IHRoaXMuY2xpZW50LCBhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5jbGllbnQsIHRva2VuLCB7IGJsb2NrIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ2dldE5leHRKb2InLCB0aGlzLm5hbWUsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VySWRdOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlTmFtZV06IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJOYW1lXTogdGhpcy5vcHRzLm5hbWUsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyT3B0aW9uc106IEpTT04uc3RyaW5naWZ5KHsgYmxvY2sgfSksXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iSWRdOiBuZXh0Sm9iID09PSBudWxsIHx8IG5leHRKb2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHRKb2IuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Sm9iO1xuICAgICAgICB9LCAoX2IgPSAoX2EgPSBuZXh0Sm9iID09PSBudWxsIHx8IG5leHRKb2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHRKb2Iub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRlbGVtZXRyeSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE5leHRKb2IoY2xpZW50LCBiY2xpZW50LCB0b2tlbiwgeyBibG9jayA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFpbmVkICYmIGJsb2NrICYmICF0aGlzLmxpbWl0VW50aWwgJiYgIXRoaXMud2FpdGluZykge1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nID0gdGhpcy53YWl0Rm9ySm9iKGJjbGllbnQsIHRoaXMuYmxvY2tVbnRpbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tVbnRpbCA9IGF3YWl0IHRoaXMud2FpdGluZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja1VudGlsIDw9IDAgfHwgdGhpcy5ibG9ja1VudGlsIC0gRGF0ZS5ub3coKSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIHRoaXMub3B0cy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBlcnJvciBpZiBsb2NhbGx5IG5vdCBwYXVzZWQgb3Igbm90IGNsb3Npbmcgc2luY2Ugd2UgZGlkIG5vdCBmb3JjZSBhIGRpc2Nvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnBhdXNlZCB8fCB0aGlzLmNsb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzTm90Q29ubmVjdGlvbkVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSYXRlTGltaXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIHRoaXMub3B0cy5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIHJhdGUgbGltaXQgdG8gYmUgYWN0aXZlIGZvciB0aGUgbmV4dCBqb2JzLlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2Ni4gVXNlIHF1ZXVlLnJhdGVMaW1pdCBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gZXhwaXJlVGltZU1zIC0gZXhwaXJlIHRpbWUgaW4gbXMgb2YgdGhpcyByYXRlIGxpbWl0LlxuICAgICAqL1xuICAgIGFzeW5jIHJhdGVMaW1pdChleHBpcmVUaW1lTXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3JhdGVMaW1pdCcsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJJZF06IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyUmF0ZUxpbWl0XTogZXhwaXJlVGltZU1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50aGVuKGNsaWVudCA9PiBjbGllbnQuc2V0KHRoaXMua2V5cy5saW1pdGVyLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgJ1BYJywgZXhwaXJlVGltZU1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluaW11bUJsb2NrVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tpbmdDb25uZWN0aW9uLmNhcGFiaWxpdGllcy5jYW5CbG9ja0ZvcjFNc1xuICAgICAgICAgICAgPyAvKiAxIG1pbGxpc2Vjb25kIGlzIGNob3NlbiBiZWNhdXNlIHRoZSBncmFudWxhcml0eSBvZiBvdXIgdGltZXN0YW1wcyBhcmUgbWlsbGlzZWNvbmRzLlxuICAgICAgT2J2aW91c2x5IHdlIGNhbiBzdGlsbCBwcm9jZXNzIG11Y2ggZmFzdGVyIHRoYW4gMSBqb2IgcGVyIG1pbGxpc2Vjb25kIGJ1dCBkZWxheXMgYW5kIHJhdGUgbGltaXRzXG4gICAgICB3aWxsIG5ldmVyIHdvcmsgd2l0aCBtb3JlIGFjY3VyYWN5IHRoYW4gMW1zLiAqL1xuICAgICAgICAgICAgICAgIDAuMDAxXG4gICAgICAgICAgICA6IDAuMDAyO1xuICAgIH1cbiAgICBpc1JhdGVMaW1pdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFVudGlsID4gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgYXN5bmMgbW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIG5hbWUpIHtcbiAgICAgICAgY29uc3QgW2pvYkRhdGEsIGlkLCByYXRlTGltaXREZWxheSwgZGVsYXlVbnRpbF0gPSBhd2FpdCB0aGlzLnNjcmlwdHMubW92ZVRvQWN0aXZlKGNsaWVudCwgdG9rZW4sIG5hbWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlbGF5cyhyYXRlTGltaXREZWxheSwgZGVsYXlVbnRpbCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRKb2JGcm9tSm9iRGF0YShqb2JEYXRhLCBpZCwgdG9rZW4pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9ySm9iKGJjbGllbnQsIGJsb2NrVW50aWwpIHtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2luZyAmJiAhdGhpcy5pc1JhdGVMaW1pdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tUaW1lb3V0ID0gdGhpcy5nZXRCbG9ja1RpbWVvdXQoYmxvY2tVbnRpbCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUaW1lb3V0ID0gdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24uY2FwYWJpbGl0aWVzLmNhbkRvdWJsZVRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYmxvY2tUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguY2VpbChibG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgdHJ1c3QgdGhhdCB0aGUgYmxvY2tpbmcgY29ubmVjdGlvbiBzdGF5cyBibG9ja2luZyBmb3JldmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBpc3N1ZXMgaW4gUmVkaXMgYW5kIElPUmVkaXMsIHNvIHdlIHdpbGwgcmVjb25uZWN0IGlmIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGdldCBhIHJlc3BvbnNlIGluIHRoZSBleHBlY3RlZCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiY2xpZW50LmRpc2Nvbm5lY3QoIXRoaXMuY2xvc2luZyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGJsb2NrVGltZW91dCAqIDEwMDAgKyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEZWxheXMoKTsgLy8gcmVzZXQgZGVsYXlzIHRvIGF2b2lkIHJldXNpbmcgc2FtZSB2YWx1ZXMgaW4gbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFya2VycyBzaG91bGQgb25seSBiZSB1c2VkIGZvciB1bi1ibG9ja2luZywgc28gd2Ugd2lsbCBoYW5kbGUgdGhlbSBpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJjbGllbnQuYnpwb3BtaW4odGhpcy5rZXlzLm1hcmtlciwgYmxvY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW19rZXksIG1lbWJlciwgc2NvcmVdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Jsb2NrVW50aWwgPSBwYXJzZUludChzY29yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGJ5IHBybyB2ZXJzaW9uIGFzIHJhdGUgbGltaXRlZCBncm91cHMgY291bGQgZ2VuZXJhdGUgbG93ZXIgYmxvY2tVbnRpbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJrZXJzIG9ubHkgcmV0dXJuIGRlbGF5cyBmb3IgZGVsYXllZCBqb2JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrVW50aWwgJiYgbmV3QmxvY2tVbnRpbCA+IGJsb2NrVW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdCbG9ja1VudGlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzTm90Q29ubmVjdGlvbkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGdldEJsb2NrVGltZW91dChibG9ja1VudGlsKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIC8vIHdoZW4gdGhlcmUgYXJlIGRlbGF5ZWQgam9ic1xuICAgICAgICBpZiAoYmxvY2tVbnRpbCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tEZWxheSA9IGJsb2NrVW50aWwgLSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSByZWFjaCB0aGUgdGltZSB0byBnZXQgbmV3IGpvYnNcbiAgICAgICAgICAgIGlmIChibG9ja0RlbGF5IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRGVsYXkgPCB0aGlzLm1pbmltdW1CbG9ja1RpbWVvdXQgKiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bUJsb2NrVGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlc3RyaWN0IHRoZSBtYXhpbXVtIGJsb2NrIHRpbWVvdXQgdG8gMTAgc2Vjb25kIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gYmxvY2tpbmcgdGhlIGNvbm5lY3Rpb24gZm9yIHRvbyBsb25nIGluIHRoZSBjYXNlIG9mIHJlY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS90YXNrZm9yY2VzaC9idWxsbXEvaXNzdWVzLzE2NThcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYmxvY2tEZWxheSAvIDEwMDAsIG1heGltdW1CbG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KG9wdHMuZHJhaW5EZWxheSwgdGhpcy5taW5pbXVtQmxvY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSYXRlTGltaXREZWxheShkZWxheSkge1xuICAgICAgICAvLyBXZSByZXN0cmljdCB0aGUgbWF4aW11bSBsaW1pdCB1bnRpbCB0byAzMCBzZWNvbmQgdG9cbiAgICAgICAgLy8gYmUgYWJsZSB0byBwcm9tb3RlIGRlbGF5ZWQgam9icyB3aGlsZSBxdWV1ZSBpcyByYXRlIGxpbWl0ZWRcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGRlbGF5LCBtYXhpbXVtUmF0ZUxpbWl0RGVsYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwb3NlZCBvbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGF5KG1pbGxpc2Vjb25kcywgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5KG1pbGxpc2Vjb25kcyB8fCBERUxBWV9USU1FXzEsIGFib3J0Q29udHJvbGxlcik7XG4gICAgfVxuICAgIHVwZGF0ZURlbGF5cyhsaW1pdERlbGF5ID0gMCwgZGVsYXlVbnRpbCA9IDApIHtcbiAgICAgICAgY29uc3QgY2xhbXBlZExpbWl0ID0gTWF0aC5tYXgobGltaXREZWxheSwgMCk7XG4gICAgICAgIGlmIChjbGFtcGVkTGltaXQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbWl0VW50aWwgPSBEYXRlLm5vdygpICsgY2xhbXBlZExpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saW1pdFVudGlsID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2NrVW50aWwgPSBNYXRoLm1heChkZWxheVVudGlsLCAwKSB8fCAwO1xuICAgIH1cbiAgICBhc3luYyBuZXh0Sm9iRnJvbUpvYkRhdGEoam9iRGF0YSwgam9iSWQsIHRva2VuKSB7XG4gICAgICAgIGlmICgham9iRGF0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYWluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLmNyZWF0ZUpvYihqb2JEYXRhLCBqb2JJZCk7XG4gICAgICAgICAgICBqb2IudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXRyeUlmRmFpbGVkKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvYi5yZXBlYXRKb2JLZXkgJiYgam9iLnJlcGVhdEpvYktleS5zcGxpdCgnOicpLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpvYlNjaGVkdWxlciA9IGF3YWl0IHRoaXMuam9iU2NoZWR1bGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgam9iU2NoZWR1bGVyLnVwc2VydEpvYlNjaGVkdWxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vc3Qgb2YgdGhlc2UgYXJndW1lbnRzIGFyZSBub3QgcmVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZSBhcyB3ZSByZWFkIHRoZW0gZnJvbSB0aGUgam9iIHNjaGVkdWxlciBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvYi5yZXBlYXRKb2JLZXksIGpvYi5vcHRzLnJlcGVhdCwgam9iLm5hbWUsIGpvYi5kYXRhLCBqb2Iub3B0cywgeyBvdmVycmlkZTogZmFsc2UsIHByb2R1Y2VySWQ6IGpvYi5pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2Iub3B0cy5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGVhdCA9IGF3YWl0IHRoaXMucmVwZWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVwZWF0LnVwZGF0ZVJlcGVhdGFibGVKb2Ioam9iLm5hbWUsIGpvYi5kYXRhLCBqb2Iub3B0cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMi41ICogT05FX1NFQ09ORCwgLy8gV2FpdCAyLjUgc2Vjb25kcyBiZXR3ZWVuIGF0dGVtcHRzXG4gICAgICAgICAgICAgICAgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCBlcnJvciBidXQgZG9uJ3QgdGhyb3cgdG8gYXZvaWQgYnJlYWtpbmcgY3VycmVudCBqb2IgY29tcGxldGlvblxuICAgICAgICAgICAgICAgIC8vIGFuZCBsZWF2aW5nIHRoZSBuZXcgam9iIGluIHN0YWxsZWQgc3RhdGVcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVycik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGluZ0Vycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gYWRkIHJlcGVhdGFibGUgam9iIGZvciBuZXh0IGl0ZXJhdGlvbjogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHNjaGVkdWxpbmdFcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIG1vdmUgdGhlIGpvYiB0byBkZWxheWVkIHdpdGggYmFja29mZiB0byBwcmV2ZW50IGluZmluaXRlIHJldHJ5IGxvb3BzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGJhY2tvZmYgZGVsYXk6IGJhc2UgZGVsYXkgb2YgNSBzZWNvbmRzLCBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgd2l0aCBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlRGVsYXkgPSBPTkVfU0VDT05EOyAvLyAxIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhEZWxheSA9IDMwMCAqIE9ORV9TRUNPTkQ7IC8vIDUgbWludXRlcyBtYXhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdCA9IGpvYi5hdHRlbXB0c1N0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVsYXkgPSBNYXRoLm1pbihiYXNlRGVsYXkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSwgbWF4RGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBqb2IubW92ZVRvRGVsYXllZChEYXRlLm5vdygpICsgZXhwb25lbnRpYWxEZWxheSwgam9iLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG1vdmVFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbW92ZSBpdCB0byBkZWxheWVkLCBlbWl0IGVycm9yIGFuZCBsZXQgaXQgYmVjb21lIHN0YWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhbGxlZCBqb2JzIHdpbGwgYmUgYXV0b21hdGljYWxseSByZXRyaWVkIGJ5IHRoZSBzdGFsbGVkIGNoZWNrZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW92ZUVycm9yTWVzc2FnZSA9IG1vdmVFcnIgaW5zdGFuY2VvZiBFcnJvciA/IG1vdmVFcnIubWVzc2FnZSA6IFN0cmluZyhtb3ZlRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihgRmFpbGVkIHRvIG1vdmUgam9iICR7am9iLmlkfSB0byBkZWxheWVkIGFmdGVyIHNjaGVkdWxpbmcgZXJyb3I6ICR7bW92ZUVycm9yTWVzc2FnZX0uIFxuICAgICAgICAgICAgICBKb2Igd2lsbCBiZWNvbWUgc3RhbGxlZCBhbmQgYmUgcmV0cmllZCBhdXRvbWF0aWNhbGx5LmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCB0byBpbmRpY2F0ZSBubyBuZXh0IGpvYiBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpvYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzSm9iKGpvYiwgdG9rZW4sIGZldGNoTmV4dENhbGxiYWNrID0gKCkgPT4gdHJ1ZSwgam9ic0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc3JjUHJvcGFnYXRpb25NZWRhdGFkYSA9IChfYiA9IChfYSA9IGpvYi5vcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVsZW1ldHJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNlKFNwYW5LaW5kLkNPTlNVTUVSLCAncHJvY2VzcycsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJJZF06IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyTmFtZV06IHRoaXMub3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkXTogam9iLmlkLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYk5hbWVdOiBqb2IubmFtZSxcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Kb2JBdHRlbXB0c01hZGVdOiBqb2IuYXR0ZW1wdHNNYWRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2ZScsIGpvYiwgJ3dhaXRpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZE9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NJdGVtID0geyBqb2IsIHRzOiBwcm9jZXNzZWRPbiB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnJlY292ZXJhYmxlRXJyb3JNZXNzYWdlID0gdGhpcy5nZXRVbnJlY292ZXJhYmxlRXJyb3JNZXNzYWdlKGpvYik7XG4gICAgICAgICAgICAgICAgaWYgKHVucmVjb3ZlcmFibGVFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFpbGVkID0gYXdhaXQgdGhpcy5oYW5kbGVGYWlsZWQobmV3IFVucmVjb3ZlcmFibGVFcnJvcih1bnJlY292ZXJhYmxlRXJyb3JNZXNzYWdlKSwgam9iLCB0b2tlbiwgZmV0Y2hOZXh0Q2FsbGJhY2ssIGpvYnNJblByb2dyZXNzLCBpblByb2dyZXNzSXRlbSwgc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpvYnNJblByb2dyZXNzLmFkZChpblByb2dyZXNzSXRlbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsUHJvY2Vzc0pvYihqb2IsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVDb21wbGV0ZWQocmVzdWx0LCBqb2IsIHRva2VuLCBmZXRjaE5leHRDYWxsYmFjaywgam9ic0luUHJvZ3Jlc3MsIGluUHJvZ3Jlc3NJdGVtLCBzcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBhd2FpdCB0aGlzLmhhbmRsZUZhaWxlZChlcnIsIGpvYiwgdG9rZW4sIGZldGNoTmV4dENhbGxiYWNrLCBqb2JzSW5Qcm9ncmVzcywgaW5Qcm9ncmVzc0l0ZW0sIHNwYW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYkZpbmlzaGVkVGltZXN0YW1wXTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuSm9iUHJvY2Vzc2VkVGltZXN0YW1wXTogcHJvY2Vzc2VkT24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEpO1xuICAgIH1cbiAgICBnZXRVbnJlY292ZXJhYmxlRXJyb3JNZXNzYWdlKGpvYikge1xuICAgICAgICBpZiAoam9iLmRlZmVycmVkRmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGpvYi5kZWZlcnJlZEZhaWx1cmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5tYXhTdGFydGVkQXR0ZW1wdHMgJiZcbiAgICAgICAgICAgIHRoaXMub3B0cy5tYXhTdGFydGVkQXR0ZW1wdHMgPCBqb2IuYXR0ZW1wdHNTdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2pvYiBzdGFydGVkIG1vcmUgdGhhbiBhbGxvd2FibGUgbGltaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNvbXBsZXRlZChyZXN1bHQsIGpvYiwgdG9rZW4sIGZldGNoTmV4dENhbGxiYWNrID0gKCkgPT4gdHJ1ZSwgam9ic0luUHJvZ3Jlc3MsIGluUHJvZ3Jlc3NJdGVtLCBzcGFuKSB7XG4gICAgICAgIGpvYnNJblByb2dyZXNzLmRlbGV0ZShpblByb2dyZXNzSXRlbSk7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uLmNsb3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IGF3YWl0IGpvYi5tb3ZlVG9Db21wbGV0ZWQocmVzdWx0LCB0b2tlbiwgZmV0Y2hOZXh0Q2FsbGJhY2soKSAmJiAhKHRoaXMuY2xvc2luZyB8fCB0aGlzLnBhdXNlZCkpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZWQnLCBqb2IsIHJlc3VsdCwgJ2FjdGl2ZScpO1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLmFkZEV2ZW50KCdqb2IgY29tcGxldGVkJywge1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYlJlc3VsdF06IEpTT04uc3RyaW5naWZ5KHJlc3VsdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IFtqb2JEYXRhLCBqb2JJZCwgcmF0ZUxpbWl0RGVsYXksIGRlbGF5VW50aWxdID0gY29tcGxldGVkIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWxheXMocmF0ZUxpbWl0RGVsYXksIGRlbGF5VW50aWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dEpvYkZyb21Kb2JEYXRhKGpvYkRhdGEsIGpvYklkLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRmFpbGVkKGVyciwgam9iLCB0b2tlbiwgZmV0Y2hOZXh0Q2FsbGJhY2sgPSAoKSA9PiB0cnVlLCBqb2JzSW5Qcm9ncmVzcywgaW5Qcm9ncmVzc0l0ZW0sIHNwYW4pIHtcbiAgICAgICAgam9ic0luUHJvZ3Jlc3MuZGVsZXRlKGluUHJvZ3Jlc3NJdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2xvc2luZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgam9iIHdhcyBtYW51YWxseSByYXRlLWxpbWl0ZWRcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT0gUkFURV9MSU1JVF9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXRlTGltaXRUdGwgPSBhd2FpdCB0aGlzLm1vdmVMaW1pdGVkQmFja1RvV2FpdChqb2IsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdFVudGlsID0gcmF0ZUxpbWl0VHRsID4gMCA/IERhdGUubm93KCkgKyByYXRlTGltaXRUdGwgOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBEZWxheWVkRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPT0gJ0RlbGF5ZWRFcnJvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgV2FpdGluZ0Vycm9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID09ICdXYWl0aW5nRXJyb3InIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIFdhaXRpbmdDaGlsZHJlbkVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID09ICdXYWl0aW5nQ2hpbGRyZW5FcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBqb2IubW92ZVRvRmFpbGVkKGVyciwgdG9rZW4sIGZldGNoTmV4dENhbGxiYWNrKCkgJiYgISh0aGlzLmNsb3NpbmcgfHwgdGhpcy5wYXVzZWQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIGpvYiwgZXJyLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLmFkZEV2ZW50KCdqb2IgZmFpbGVkJywge1xuICAgICAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Kb2JGYWlsZWRSZWFzb25dOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtqb2JEYXRhLCBqb2JJZCwgcmF0ZUxpbWl0RGVsYXksIGRlbGF5VW50aWxdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURlbGF5cyhyYXRlTGltaXREZWxheSwgZGVsYXlVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRKb2JGcm9tSm9iRGF0YShqb2JEYXRhLCBqb2JJZCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3RDb25uZWN0aW9uRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgam9iIGhhcyBsb3N0IHRoZSBsb2NrIGJlZm9yZSBjb21wbGV0aW9uXG4gICAgICAgICAgICAgICAgLy8gQSB3b3JrZXIgd2lsbCAob3IgYWxyZWFkeSBoYXMpIG1vdmVkIHRoZSBqb2IgYmFja1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSB3YWl0aW5nIGxpc3QgKGFzIHN0YWxsZWQpXG4gICAgICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGhpcyBxdWV1ZSBvbmx5IGZvciB0aGlzIHdvcmtlci5cbiAgICAgKi9cbiAgICBhc3luYyBwYXVzZShkb05vdFdhaXRBY3RpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3BhdXNlJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLldvcmtlcklkXTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJOYW1lXTogdGhpcy5vcHRzLm5hbWUsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyRG9Ob3RXYWl0QWN0aXZlXTogZG9Ob3RXYWl0QWN0aXZlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghZG9Ob3RXYWl0QWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud2hlbkN1cnJlbnRKb2JzRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5zdGFsbGVkQ2hlY2tTdG9wcGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXN1bWVzIHByb2Nlc3Npbmcgb2YgdGhpcyB3b3JrZXIgKGlmIHBhdXNlZCkuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICAgICAgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ3Jlc3VtZScsIHRoaXMubmFtZSwgc3BhbiA9PiB7XG4gICAgICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJJZF06IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLldvcmtlck5hbWVdOiB0aGlzLm9wdHMubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NGbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHdvcmtlciBpcyBwYXVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHdvcmtlciBpcyBwYXVzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHdvcmtlciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgd29ya2VyIGlzIHJ1bm5pbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2xvc2VzIHRoZSB3b3JrZXIgYW5kIHJlbGF0ZWQgcmVkaXMgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3YWl0cyBmb3IgY3VycmVudCBqb2JzIHRvIGZpbmFsaXplIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2UgLSBVc2UgZm9yY2UgYm9vbGVhbiBwYXJhbWV0ZXIgaWYgeW91IGRvIG5vdCB3YW50IHRvIHdhaXQgZm9yXG4gICAgICogY3VycmVudCBqb2JzIHRvIGJlIHByb2Nlc3NlZC4gV2hlbiB1c2luZyB0ZWxlbWV0cnksIGJlIG1pbmRmdWwgdGhhdCBpdCBjYW5cbiAgICAgKiBpbnRlcmZlcmUgd2l0aCB0aGUgcHJvcGVyIGNsb3N1cmUgb2Ygc3BhbnMsIHBvdGVudGlhbGx5IHByZXZlbnRpbmcgdGhlbSBmcm9tIGJlaW5nIGV4cG9ydGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHdvcmtlciBoYXMgYmVlbiBjbG9zZWQuXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2luZyA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAnY2xvc2UnLCB0aGlzLm5hbWUsIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBzcGFuID09PSBudWxsIHx8IHNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLldvcmtlcklkXTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyTmFtZV06IHRoaXMub3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJGb3JjZUNsb3NlXTogZm9yY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zaW5nJywgJ2Nsb3NpbmcgcXVldWUnKTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFib3J0RGVsYXlDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAvLyBEZWZpbmUgdGhlIGFzeW5jIGNsZWFudXAgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgY29uc3QgYXN5bmNDbGVhbnVwcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlIHx8IHRoaXMud2hlbkN1cnJlbnRKb2JzRmluaXNoZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuY2hpbGRQb29sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYW4oKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5ibG9ja2luZ0Nvbm5lY3Rpb24uY2xvc2UoZm9yY2UpLFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoZm9yY2UpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gUnVuIGNsZWFudXAgZnVuY3Rpb25zIHNlcXVlbnRpYWxseSBhbmQgbWFrZSBzdXJlIGFsbCBhcmUgcnVuIGRlc3BpdGUgYW55IGVycm9yc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2xlYW51cCBvZiBhc3luY0NsZWFudXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXh0ZW5kTG9ja3NUaW1lcik7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5zdGFsbGVkQ2hlY2tTdG9wcGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jbG9zaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE1hbnVhbGx5IHN0YXJ0cyB0aGUgc3RhbGxlZCBjaGVja2VyLlxuICAgICAqIFRoZSBjaGVjayB3aWxsIHJ1biBvbmNlIGFzIHNvb24gYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBhbmRcbiAgICAgKiB0aGVuIGV2ZXJ5IG9wdHMuc3RhbGxlZEludGVydmFsIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgd29ya2VyIGlzIGNsb3NlZC5cbiAgICAgKiBOb3RlOiBOb3JtYWxseSB5b3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCwgc2luY2UgdGhlIHN0YWxsZWQgY2hlY2tlclxuICAgICAqIGlzIGF1dG9tYXRpY2FsbHkgc3RhcnRlZCB3aGVuIHRoZSB3b3JrZXIgc3RhcnRzIHByb2Nlc3Npbmcgam9icyBhZnRlclxuICAgICAqIGNhbGxpbmcgcnVuLiBIb3dldmVyIGlmIHlvdSB3YW50IHRvIHByb2Nlc3MgdGhlIGpvYnMgbWFudWFsbHkgeW91IG5lZWRcbiAgICAgKiB0byBjYWxsIHRoaXMgbWV0aG9kIHRvIHN0YXJ0IHRoZSBzdGFsbGVkIGNoZWNrZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuYnVsbG1xLmlvL3BhdHRlcm5zL21hbnVhbGx5LWZldGNoaW5nLWpvYnN9XG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRTdGFsbGVkQ2hlY2tUaW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuc2tpcFN0YWxsZWRDaGVjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAnc3RhcnRTdGFsbGVkQ2hlY2tUaW1lcicsIHRoaXMubmFtZSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VySWRdOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyTmFtZV06IHRoaXMub3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFsbGVkQ2hlY2tlcigpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RhbGxlZENoZWNrZXIoKSB7XG4gICAgICAgIHdoaWxlICghKHRoaXMuY2xvc2luZyB8fCB0aGlzLnBhdXNlZCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2hlY2tDb25uZWN0aW9uRXJyb3IoKCkgPT4gdGhpcy5tb3ZlU3RhbGxlZEpvYnNUb1dhaXQoKSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLm9wdHMuc3RhbGxlZEludGVydmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWxsZWRDaGVja1N0b3BwZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydExvY2tFeHRlbmRlclRpbWVyKGpvYnNJblByb2dyZXNzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLnNraXBMb2NrUmVuZXdhbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXh0ZW5kTG9ja3NUaW1lcik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRMb2Nrc1RpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgdGhlIGpvYnMgd2hvc2UgbG9ja3MgZXhwaXJlIGluIGxlc3MgdGhhbiAxLzIgb2YgdGhlIGxvY2tSZW5ld1RpbWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgam9ic1RvRXh0ZW5kID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBqb2JzSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBqb2IsIHRzIH0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udHMgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHMgKyB0aGlzLm9wdHMubG9ja1JlbmV3VGltZSAvIDIgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRzID0gbm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYnNUb0V4dGVuZC5wdXNoKGpvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2JzVG9FeHRlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leHRlbmRMb2Nrcyhqb2JzVG9FeHRlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vdENvbm5lY3Rpb25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydExvY2tFeHRlbmRlclRpbWVyKGpvYnNJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdHMubG9ja1JlbmV3VGltZSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhY3RpdmUgam9icyBhcmUgY2xlYXJlZFxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyB3aGVuQ3VycmVudEpvYnNGaW5pc2hlZChyZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZvcmNlIHJlY29ubmVjdGlvbiBvZiBibG9ja2luZyBjb25uZWN0aW9uIHRvIGFib3J0IGJsb2NraW5nIHJlZGlzIGNhbGwgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLndhaXRpbmcpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3QgZ29pbmcgdG8gcmVjb25uZWN0LCB3ZSB3aWxsIG5vdCB3YWl0IGZvciB0aGUgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmxvY2tpbmdDb25uZWN0aW9uLmRpc2Nvbm5lY3QocmVjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1haW5Mb29wUnVubmluZykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tYWluTG9vcFJ1bm5pbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb25uZWN0ICYmIChhd2FpdCB0aGlzLmJsb2NraW5nQ29ubmVjdGlvbi5yZWNvbm5lY3QoKSk7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5SWZGYWlsZWQoZm4sIGRlbGF5SW5NcywgbWF4UmV0cmllcyA9IEluZmluaXR5KSB7XG4gICAgICAgIGxldCByZXRyeSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm90Q29ubmVjdGlvbkVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheUluTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXlJbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5ICsgMSA+PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIG1heCByZXRyaWVzLCB0aHJvdyB0aGUgbGFzdCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK3JldHJ5IDwgbWF4UmV0cmllcyk7XG4gICAgfVxuICAgIGFzeW5jIGV4dGVuZExvY2tzKGpvYnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cmFjZShTcGFuS2luZC5JTlRFUk5BTCwgJ2V4dGVuZExvY2tzJywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgc3BhbiA9PT0gbnVsbCB8fCBzcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLldvcmtlcklkXTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJOYW1lXTogdGhpcy5vcHRzLm5hbWUsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VySm9ic1RvRXh0ZW5kTG9ja3NdOiBqb2JzLm1hcChqb2IgPT4gam9iLmlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JlZEpvYklkcyA9IGF3YWl0IHRoaXMuc2NyaXB0cy5leHRlbmRMb2Nrcyhqb2JzLm1hcChqb2IgPT4gam9iLmlkKSwgam9icy5tYXAoam9iID0+IGpvYi50b2tlbiksIHRoaXMub3B0cy5sb2NrRHVyYXRpb24pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBqb2JJZCBvZiBlcnJvcmVkSm9iSWRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU2VuZCBzaWduYWwgdG8gcHJvY2VzcyBmdW5jdGlvbiB0aGF0IHRoZSBqb2IgaGFzIGJlZW4gbG9zdC5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBjb3VsZCBub3QgcmVuZXcgbG9jayBmb3Igam9iICR7am9iSWR9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbW92ZVN0YWxsZWRKb2JzVG9XYWl0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyYWNlKFNwYW5LaW5kLklOVEVSTkFMLCAnbW92ZVN0YWxsZWRKb2JzVG9XYWl0JywgdGhpcy5uYW1lLCBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhbGxlZCA9IGF3YWl0IHRoaXMuc2NyaXB0cy5tb3ZlU3RhbGxlZEpvYnNUb1dhaXQoKTtcbiAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICBbVGVsZW1ldHJ5QXR0cmlidXRlcy5Xb3JrZXJJZF06IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuV29ya2VyTmFtZV06IHRoaXMub3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLldvcmtlclN0YWxsZWRKb2JzXTogc3RhbGxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhbGxlZC5mb3JFYWNoKChqb2JJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4gPT09IG51bGwgfHwgc3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Bhbi5hZGRFdmVudCgnam9iIHN0YWxsZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLkpvYklkXTogam9iSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFsbGVkJywgam9iSWQsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW92ZUxpbWl0ZWRCYWNrVG9XYWl0KGpvYiwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGpvYi5tb3ZlVG9XYWl0KHRva2VuKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/classes/worker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/child-command.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildCommand: () => (/* binding */ ChildCommand)\n/* harmony export */ });\nvar ChildCommand;\n(function (ChildCommand) {\n    ChildCommand[ChildCommand[\"Init\"] = 0] = \"Init\";\n    ChildCommand[ChildCommand[\"Start\"] = 1] = \"Start\";\n    ChildCommand[ChildCommand[\"Stop\"] = 2] = \"Stop\";\n    ChildCommand[ChildCommand[\"GetChildrenValuesResponse\"] = 3] = \"GetChildrenValuesResponse\";\n    ChildCommand[ChildCommand[\"GetIgnoredChildrenFailuresResponse\"] = 4] = \"GetIgnoredChildrenFailuresResponse\";\n    ChildCommand[ChildCommand[\"MoveToWaitingChildrenResponse\"] = 5] = \"MoveToWaitingChildrenResponse\";\n})(ChildCommand || (ChildCommand = {}));\n//# sourceMappingURL=child-command.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2NoaWxkLWNvbW1hbmQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2NoaWxkLWNvbW1hbmQuanM/MWMwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIENoaWxkQ29tbWFuZDtcbihmdW5jdGlvbiAoQ2hpbGRDb21tYW5kKSB7XG4gICAgQ2hpbGRDb21tYW5kW0NoaWxkQ29tbWFuZFtcIkluaXRcIl0gPSAwXSA9IFwiSW5pdFwiO1xuICAgIENoaWxkQ29tbWFuZFtDaGlsZENvbW1hbmRbXCJTdGFydFwiXSA9IDFdID0gXCJTdGFydFwiO1xuICAgIENoaWxkQ29tbWFuZFtDaGlsZENvbW1hbmRbXCJTdG9wXCJdID0gMl0gPSBcIlN0b3BcIjtcbiAgICBDaGlsZENvbW1hbmRbQ2hpbGRDb21tYW5kW1wiR2V0Q2hpbGRyZW5WYWx1ZXNSZXNwb25zZVwiXSA9IDNdID0gXCJHZXRDaGlsZHJlblZhbHVlc1Jlc3BvbnNlXCI7XG4gICAgQ2hpbGRDb21tYW5kW0NoaWxkQ29tbWFuZFtcIkdldElnbm9yZWRDaGlsZHJlbkZhaWx1cmVzUmVzcG9uc2VcIl0gPSA0XSA9IFwiR2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXNSZXNwb25zZVwiO1xuICAgIENoaWxkQ29tbWFuZFtDaGlsZENvbW1hbmRbXCJNb3ZlVG9XYWl0aW5nQ2hpbGRyZW5SZXNwb25zZVwiXSA9IDVdID0gXCJNb3ZlVG9XYWl0aW5nQ2hpbGRyZW5SZXNwb25zZVwiO1xufSkoQ2hpbGRDb21tYW5kIHx8IChDaGlsZENvbW1hbmQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hpbGQtY29tbWFuZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/error-code.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode)\n/* harmony export */ });\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"JobNotExist\"] = -1] = \"JobNotExist\";\n    ErrorCode[ErrorCode[\"JobLockNotExist\"] = -2] = \"JobLockNotExist\";\n    ErrorCode[ErrorCode[\"JobNotInState\"] = -3] = \"JobNotInState\";\n    ErrorCode[ErrorCode[\"JobPendingChildren\"] = -4] = \"JobPendingChildren\";\n    ErrorCode[ErrorCode[\"ParentJobNotExist\"] = -5] = \"ParentJobNotExist\";\n    ErrorCode[ErrorCode[\"JobLockMismatch\"] = -6] = \"JobLockMismatch\";\n    ErrorCode[ErrorCode[\"ParentJobCannotBeReplaced\"] = -7] = \"ParentJobCannotBeReplaced\";\n    ErrorCode[ErrorCode[\"JobBelongsToJobScheduler\"] = -8] = \"JobBelongsToJobScheduler\";\n    ErrorCode[ErrorCode[\"JobHasFailedChildren\"] = -9] = \"JobHasFailedChildren\";\n    ErrorCode[ErrorCode[\"SchedulerJobIdCollision\"] = -10] = \"SchedulerJobIdCollision\";\n    ErrorCode[ErrorCode[\"SchedulerJobSlotsBusy\"] = -11] = \"SchedulerJobSlotsBusy\";\n})(ErrorCode || (ErrorCode = {}));\n//# sourceMappingURL=error-code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2Vycm9yLWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9lbnVtcy9lcnJvci1jb2RlLmpzPzFiNjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JOb3RFeGlzdFwiXSA9IC0xXSA9IFwiSm9iTm90RXhpc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSm9iTG9ja05vdEV4aXN0XCJdID0gLTJdID0gXCJKb2JMb2NrTm90RXhpc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSm9iTm90SW5TdGF0ZVwiXSA9IC0zXSA9IFwiSm9iTm90SW5TdGF0ZVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JQZW5kaW5nQ2hpbGRyZW5cIl0gPSAtNF0gPSBcIkpvYlBlbmRpbmdDaGlsZHJlblwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQYXJlbnRKb2JOb3RFeGlzdFwiXSA9IC01XSA9IFwiUGFyZW50Sm9iTm90RXhpc3RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSm9iTG9ja01pc21hdGNoXCJdID0gLTZdID0gXCJKb2JMb2NrTWlzbWF0Y2hcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUGFyZW50Sm9iQ2Fubm90QmVSZXBsYWNlZFwiXSA9IC03XSA9IFwiUGFyZW50Sm9iQ2Fubm90QmVSZXBsYWNlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JCZWxvbmdzVG9Kb2JTY2hlZHVsZXJcIl0gPSAtOF0gPSBcIkpvYkJlbG9uZ3NUb0pvYlNjaGVkdWxlclwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJKb2JIYXNGYWlsZWRDaGlsZHJlblwiXSA9IC05XSA9IFwiSm9iSGFzRmFpbGVkQ2hpbGRyZW5cIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU2NoZWR1bGVySm9iSWRDb2xsaXNpb25cIl0gPSAtMTBdID0gXCJTY2hlZHVsZXJKb2JJZENvbGxpc2lvblwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJTY2hlZHVsZXJKb2JTbG90c0J1c3lcIl0gPSAtMTFdID0gXCJTY2hlZHVsZXJKb2JTbG90c0J1c3lcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChildCommand: () => (/* reexport safe */ _child_command__WEBPACK_IMPORTED_MODULE_0__.ChildCommand),\n/* harmony export */   ErrorCode: () => (/* reexport safe */ _error_code__WEBPACK_IMPORTED_MODULE_1__.ErrorCode),\n/* harmony export */   MetricsTime: () => (/* reexport safe */ _metrics_time__WEBPACK_IMPORTED_MODULE_3__.MetricsTime),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _parent_command__WEBPACK_IMPORTED_MODULE_2__.ParentCommand),\n/* harmony export */   SpanKind: () => (/* reexport safe */ _telemetry_attributes__WEBPACK_IMPORTED_MODULE_4__.SpanKind),\n/* harmony export */   TelemetryAttributes: () => (/* reexport safe */ _telemetry_attributes__WEBPACK_IMPORTED_MODULE_4__.TelemetryAttributes)\n/* harmony export */ });\n/* harmony import */ var _child_command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./child-command */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/child-command.js\");\n/* harmony import */ var _error_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error-code */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/error-code.js\");\n/* harmony import */ var _parent_command__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parent-command */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js\");\n/* harmony import */ var _metrics_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metrics-time */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js\");\n/* harmony import */ var _telemetry_attributes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./telemetry-attributes */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/telemetry-attributes.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ0g7QUFDSTtBQUNGO0FBQ1E7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9lbnVtcy9pbmRleC5qcz9jMGY3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vY2hpbGQtY29tbWFuZCc7XG5leHBvcnQgKiBmcm9tICcuL2Vycm9yLWNvZGUnO1xuZXhwb3J0ICogZnJvbSAnLi9wYXJlbnQtY29tbWFuZCc7XG5leHBvcnQgKiBmcm9tICcuL21ldHJpY3MtdGltZSc7XG5leHBvcnQgKiBmcm9tICcuL3RlbGVtZXRyeS1hdHRyaWJ1dGVzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/metrics-time.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MetricsTime: () => (/* binding */ MetricsTime)\n/* harmony export */ });\nvar MetricsTime;\n(function (MetricsTime) {\n    MetricsTime[MetricsTime[\"ONE_MINUTE\"] = 1] = \"ONE_MINUTE\";\n    MetricsTime[MetricsTime[\"FIVE_MINUTES\"] = 5] = \"FIVE_MINUTES\";\n    MetricsTime[MetricsTime[\"FIFTEEN_MINUTES\"] = 15] = \"FIFTEEN_MINUTES\";\n    MetricsTime[MetricsTime[\"THIRTY_MINUTES\"] = 30] = \"THIRTY_MINUTES\";\n    MetricsTime[MetricsTime[\"ONE_HOUR\"] = 60] = \"ONE_HOUR\";\n    MetricsTime[MetricsTime[\"ONE_WEEK\"] = 10080] = \"ONE_WEEK\";\n    MetricsTime[MetricsTime[\"TWO_WEEKS\"] = 20160] = \"TWO_WEEKS\";\n    MetricsTime[MetricsTime[\"ONE_MONTH\"] = 80640] = \"ONE_MONTH\";\n})(MetricsTime || (MetricsTime = {}));\n//# sourceMappingURL=metrics-time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL21ldHJpY3MtdGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL21ldHJpY3MtdGltZS5qcz9lNjgzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgTWV0cmljc1RpbWU7XG4oZnVuY3Rpb24gKE1ldHJpY3NUaW1lKSB7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJPTkVfTUlOVVRFXCJdID0gMV0gPSBcIk9ORV9NSU5VVEVcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIkZJVkVfTUlOVVRFU1wiXSA9IDVdID0gXCJGSVZFX01JTlVURVNcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIkZJRlRFRU5fTUlOVVRFU1wiXSA9IDE1XSA9IFwiRklGVEVFTl9NSU5VVEVTXCI7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJUSElSVFlfTUlOVVRFU1wiXSA9IDMwXSA9IFwiVEhJUlRZX01JTlVURVNcIjtcbiAgICBNZXRyaWNzVGltZVtNZXRyaWNzVGltZVtcIk9ORV9IT1VSXCJdID0gNjBdID0gXCJPTkVfSE9VUlwiO1xuICAgIE1ldHJpY3NUaW1lW01ldHJpY3NUaW1lW1wiT05FX1dFRUtcIl0gPSAxMDA4MF0gPSBcIk9ORV9XRUVLXCI7XG4gICAgTWV0cmljc1RpbWVbTWV0cmljc1RpbWVbXCJUV09fV0VFS1NcIl0gPSAyMDE2MF0gPSBcIlRXT19XRUVLU1wiO1xuICAgIE1ldHJpY3NUaW1lW01ldHJpY3NUaW1lW1wiT05FX01PTlRIXCJdID0gODA2NDBdID0gXCJPTkVfTU9OVEhcIjtcbn0pKE1ldHJpY3NUaW1lIHx8IChNZXRyaWNzVGltZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLXRpbWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/metrics-time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/parent-command.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParentCommand: () => (/* binding */ ParentCommand)\n/* harmony export */ });\nvar ParentCommand;\n(function (ParentCommand) {\n    ParentCommand[ParentCommand[\"Completed\"] = 0] = \"Completed\";\n    ParentCommand[ParentCommand[\"Error\"] = 1] = \"Error\";\n    ParentCommand[ParentCommand[\"Failed\"] = 2] = \"Failed\";\n    ParentCommand[ParentCommand[\"InitFailed\"] = 3] = \"InitFailed\";\n    ParentCommand[ParentCommand[\"InitCompleted\"] = 4] = \"InitCompleted\";\n    ParentCommand[ParentCommand[\"Log\"] = 5] = \"Log\";\n    ParentCommand[ParentCommand[\"MoveToDelayed\"] = 6] = \"MoveToDelayed\";\n    ParentCommand[ParentCommand[\"MoveToWait\"] = 7] = \"MoveToWait\";\n    ParentCommand[ParentCommand[\"Progress\"] = 8] = \"Progress\";\n    ParentCommand[ParentCommand[\"Update\"] = 9] = \"Update\";\n    ParentCommand[ParentCommand[\"GetChildrenValues\"] = 10] = \"GetChildrenValues\";\n    ParentCommand[ParentCommand[\"GetIgnoredChildrenFailures\"] = 11] = \"GetIgnoredChildrenFailures\";\n    ParentCommand[ParentCommand[\"MoveToWaitingChildren\"] = 12] = \"MoveToWaitingChildren\";\n})(ParentCommand || (ParentCommand = {}));\n//# sourceMappingURL=parent-command.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL3BhcmVudC1jb21tYW5kLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL3BhcmVudC1jb21tYW5kLmpzPzI4MGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBQYXJlbnRDb21tYW5kO1xuKGZ1bmN0aW9uIChQYXJlbnRDb21tYW5kKSB7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiQ29tcGxldGVkXCJdID0gMF0gPSBcIkNvbXBsZXRlZFwiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgUGFyZW50Q29tbWFuZFtQYXJlbnRDb21tYW5kW1wiRmFpbGVkXCJdID0gMl0gPSBcIkZhaWxlZFwiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIkluaXRGYWlsZWRcIl0gPSAzXSA9IFwiSW5pdEZhaWxlZFwiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIkluaXRDb21wbGV0ZWRcIl0gPSA0XSA9IFwiSW5pdENvbXBsZXRlZFwiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIkxvZ1wiXSA9IDVdID0gXCJMb2dcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJNb3ZlVG9EZWxheWVkXCJdID0gNl0gPSBcIk1vdmVUb0RlbGF5ZWRcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJNb3ZlVG9XYWl0XCJdID0gN10gPSBcIk1vdmVUb1dhaXRcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJQcm9ncmVzc1wiXSA9IDhdID0gXCJQcm9ncmVzc1wiO1xuICAgIFBhcmVudENvbW1hbmRbUGFyZW50Q29tbWFuZFtcIlVwZGF0ZVwiXSA9IDldID0gXCJVcGRhdGVcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJHZXRDaGlsZHJlblZhbHVlc1wiXSA9IDEwXSA9IFwiR2V0Q2hpbGRyZW5WYWx1ZXNcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJHZXRJZ25vcmVkQ2hpbGRyZW5GYWlsdXJlc1wiXSA9IDExXSA9IFwiR2V0SWdub3JlZENoaWxkcmVuRmFpbHVyZXNcIjtcbiAgICBQYXJlbnRDb21tYW5kW1BhcmVudENvbW1hbmRbXCJNb3ZlVG9XYWl0aW5nQ2hpbGRyZW5cIl0gPSAxMl0gPSBcIk1vdmVUb1dhaXRpbmdDaGlsZHJlblwiO1xufSkoUGFyZW50Q29tbWFuZCB8fCAoUGFyZW50Q29tbWFuZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnQtY29tbWFuZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/parent-command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/enums/telemetry-attributes.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/enums/telemetry-attributes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpanKind: () => (/* binding */ SpanKind),\n/* harmony export */   TelemetryAttributes: () => (/* binding */ TelemetryAttributes)\n/* harmony export */ });\nvar TelemetryAttributes;\n(function (TelemetryAttributes) {\n    TelemetryAttributes[\"QueueName\"] = \"bullmq.queue.name\";\n    TelemetryAttributes[\"QueueOperation\"] = \"bullmq.queue.operation\";\n    TelemetryAttributes[\"BulkCount\"] = \"bullmq.job.bulk.count\";\n    TelemetryAttributes[\"BulkNames\"] = \"bullmq.job.bulk.names\";\n    TelemetryAttributes[\"JobName\"] = \"bullmq.job.name\";\n    TelemetryAttributes[\"JobId\"] = \"bullmq.job.id\";\n    TelemetryAttributes[\"JobKey\"] = \"bullmq.job.key\";\n    TelemetryAttributes[\"JobIds\"] = \"bullmq.job.ids\";\n    TelemetryAttributes[\"JobAttemptsMade\"] = \"bullmq.job.attempts.made\";\n    TelemetryAttributes[\"DeduplicationKey\"] = \"bullmq.job.deduplication.key\";\n    TelemetryAttributes[\"JobOptions\"] = \"bullmq.job.options\";\n    TelemetryAttributes[\"JobProgress\"] = \"bullmq.job.progress\";\n    TelemetryAttributes[\"QueueDrainDelay\"] = \"bullmq.queue.drain.delay\";\n    TelemetryAttributes[\"QueueGrace\"] = \"bullmq.queue.grace\";\n    TelemetryAttributes[\"QueueCleanLimit\"] = \"bullmq.queue.clean.limit\";\n    TelemetryAttributes[\"QueueRateLimit\"] = \"bullmq.queue.rate.limit\";\n    TelemetryAttributes[\"JobType\"] = \"bullmq.job.type\";\n    TelemetryAttributes[\"QueueOptions\"] = \"bullmq.queue.options\";\n    TelemetryAttributes[\"QueueEventMaxLength\"] = \"bullmq.queue.event.max.length\";\n    TelemetryAttributes[\"WorkerOptions\"] = \"bullmq.worker.options\";\n    TelemetryAttributes[\"WorkerName\"] = \"bullmq.worker.name\";\n    TelemetryAttributes[\"WorkerId\"] = \"bullmq.worker.id\";\n    TelemetryAttributes[\"WorkerRateLimit\"] = \"bullmq.worker.rate.limit\";\n    TelemetryAttributes[\"WorkerDoNotWaitActive\"] = \"bullmq.worker.do.not.wait.active\";\n    TelemetryAttributes[\"WorkerForceClose\"] = \"bullmq.worker.force.close\";\n    TelemetryAttributes[\"WorkerStalledJobs\"] = \"bullmq.worker.stalled.jobs\";\n    TelemetryAttributes[\"WorkerFailedJobs\"] = \"bullmq.worker.failed.jobs\";\n    TelemetryAttributes[\"WorkerJobsToExtendLocks\"] = \"bullmq.worker.jobs.to.extend.locks\";\n    TelemetryAttributes[\"JobFinishedTimestamp\"] = \"bullmq.job.finished.timestamp\";\n    TelemetryAttributes[\"JobProcessedTimestamp\"] = \"bullmq.job.processed.timestamp\";\n    TelemetryAttributes[\"JobResult\"] = \"bullmq.job.result\";\n    TelemetryAttributes[\"JobFailedReason\"] = \"bullmq.job.failed.reason\";\n    TelemetryAttributes[\"FlowName\"] = \"bullmq.flow.name\";\n    TelemetryAttributes[\"JobSchedulerId\"] = \"bullmq.job.scheduler.id\";\n})(TelemetryAttributes || (TelemetryAttributes = {}));\nvar SpanKind;\n(function (SpanKind) {\n    SpanKind[SpanKind[\"INTERNAL\"] = 0] = \"INTERNAL\";\n    SpanKind[SpanKind[\"SERVER\"] = 1] = \"SERVER\";\n    SpanKind[SpanKind[\"CLIENT\"] = 2] = \"CLIENT\";\n    SpanKind[SpanKind[\"PRODUCER\"] = 3] = \"PRODUCER\";\n    SpanKind[SpanKind[\"CONSUMER\"] = 4] = \"CONSUMER\";\n})(SpanKind || (SpanKind = {}));\n//# sourceMappingURL=telemetry-attributes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL3RlbGVtZXRyeS1hdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDNUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2VudW1zL3RlbGVtZXRyeS1hdHRyaWJ1dGVzLmpzP2Y4YzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBUZWxlbWV0cnlBdHRyaWJ1dGVzO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlBdHRyaWJ1dGVzKSB7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIlF1ZXVlTmFtZVwiXSA9IFwiYnVsbG1xLnF1ZXVlLm5hbWVcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiUXVldWVPcGVyYXRpb25cIl0gPSBcImJ1bGxtcS5xdWV1ZS5vcGVyYXRpb25cIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiQnVsa0NvdW50XCJdID0gXCJidWxsbXEuam9iLmJ1bGsuY291bnRcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiQnVsa05hbWVzXCJdID0gXCJidWxsbXEuam9iLmJ1bGsubmFtZXNcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiSm9iTmFtZVwiXSA9IFwiYnVsbG1xLmpvYi5uYW1lXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYklkXCJdID0gXCJidWxsbXEuam9iLmlkXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYktleVwiXSA9IFwiYnVsbG1xLmpvYi5rZXlcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiSm9iSWRzXCJdID0gXCJidWxsbXEuam9iLmlkc1wiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJKb2JBdHRlbXB0c01hZGVcIl0gPSBcImJ1bGxtcS5qb2IuYXR0ZW1wdHMubWFkZVwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJEZWR1cGxpY2F0aW9uS2V5XCJdID0gXCJidWxsbXEuam9iLmRlZHVwbGljYXRpb24ua2V5XCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYk9wdGlvbnNcIl0gPSBcImJ1bGxtcS5qb2Iub3B0aW9uc1wiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJKb2JQcm9ncmVzc1wiXSA9IFwiYnVsbG1xLmpvYi5wcm9ncmVzc1wiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJRdWV1ZURyYWluRGVsYXlcIl0gPSBcImJ1bGxtcS5xdWV1ZS5kcmFpbi5kZWxheVwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJRdWV1ZUdyYWNlXCJdID0gXCJidWxsbXEucXVldWUuZ3JhY2VcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiUXVldWVDbGVhbkxpbWl0XCJdID0gXCJidWxsbXEucXVldWUuY2xlYW4ubGltaXRcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiUXVldWVSYXRlTGltaXRcIl0gPSBcImJ1bGxtcS5xdWV1ZS5yYXRlLmxpbWl0XCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYlR5cGVcIl0gPSBcImJ1bGxtcS5qb2IudHlwZVwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJRdWV1ZU9wdGlvbnNcIl0gPSBcImJ1bGxtcS5xdWV1ZS5vcHRpb25zXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIlF1ZXVlRXZlbnRNYXhMZW5ndGhcIl0gPSBcImJ1bGxtcS5xdWV1ZS5ldmVudC5tYXgubGVuZ3RoXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIldvcmtlck9wdGlvbnNcIl0gPSBcImJ1bGxtcS53b3JrZXIub3B0aW9uc1wiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJXb3JrZXJOYW1lXCJdID0gXCJidWxsbXEud29ya2VyLm5hbWVcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiV29ya2VySWRcIl0gPSBcImJ1bGxtcS53b3JrZXIuaWRcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiV29ya2VyUmF0ZUxpbWl0XCJdID0gXCJidWxsbXEud29ya2VyLnJhdGUubGltaXRcIjtcbiAgICBUZWxlbWV0cnlBdHRyaWJ1dGVzW1wiV29ya2VyRG9Ob3RXYWl0QWN0aXZlXCJdID0gXCJidWxsbXEud29ya2VyLmRvLm5vdC53YWl0LmFjdGl2ZVwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJXb3JrZXJGb3JjZUNsb3NlXCJdID0gXCJidWxsbXEud29ya2VyLmZvcmNlLmNsb3NlXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIldvcmtlclN0YWxsZWRKb2JzXCJdID0gXCJidWxsbXEud29ya2VyLnN0YWxsZWQuam9ic1wiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJXb3JrZXJGYWlsZWRKb2JzXCJdID0gXCJidWxsbXEud29ya2VyLmZhaWxlZC5qb2JzXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIldvcmtlckpvYnNUb0V4dGVuZExvY2tzXCJdID0gXCJidWxsbXEud29ya2VyLmpvYnMudG8uZXh0ZW5kLmxvY2tzXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYkZpbmlzaGVkVGltZXN0YW1wXCJdID0gXCJidWxsbXEuam9iLmZpbmlzaGVkLnRpbWVzdGFtcFwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJKb2JQcm9jZXNzZWRUaW1lc3RhbXBcIl0gPSBcImJ1bGxtcS5qb2IucHJvY2Vzc2VkLnRpbWVzdGFtcFwiO1xuICAgIFRlbGVtZXRyeUF0dHJpYnV0ZXNbXCJKb2JSZXN1bHRcIl0gPSBcImJ1bGxtcS5qb2IucmVzdWx0XCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYkZhaWxlZFJlYXNvblwiXSA9IFwiYnVsbG1xLmpvYi5mYWlsZWQucmVhc29uXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkZsb3dOYW1lXCJdID0gXCJidWxsbXEuZmxvdy5uYW1lXCI7XG4gICAgVGVsZW1ldHJ5QXR0cmlidXRlc1tcIkpvYlNjaGVkdWxlcklkXCJdID0gXCJidWxsbXEuam9iLnNjaGVkdWxlci5pZFwiO1xufSkoVGVsZW1ldHJ5QXR0cmlidXRlcyB8fCAoVGVsZW1ldHJ5QXR0cmlidXRlcyA9IHt9KSk7XG5leHBvcnQgdmFyIFNwYW5LaW5kO1xuKGZ1bmN0aW9uIChTcGFuS2luZCkge1xuICAgIFNwYW5LaW5kW1NwYW5LaW5kW1wiSU5URVJOQUxcIl0gPSAwXSA9IFwiSU5URVJOQUxcIjtcbiAgICBTcGFuS2luZFtTcGFuS2luZFtcIlNFUlZFUlwiXSA9IDFdID0gXCJTRVJWRVJcIjtcbiAgICBTcGFuS2luZFtTcGFuS2luZFtcIkNMSUVOVFwiXSA9IDJdID0gXCJDTElFTlRcIjtcbiAgICBTcGFuS2luZFtTcGFuS2luZFtcIlBST0RVQ0VSXCJdID0gM10gPSBcIlBST0RVQ0VSXCI7XG4gICAgU3BhbktpbmRbU3BhbktpbmRbXCJDT05TVU1FUlwiXSA9IDRdID0gXCJDT05TVU1FUlwiO1xufSkoU3BhbktpbmQgfHwgKFNwYW5LaW5kID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbGVtZXRyeS1hdHRyaWJ1dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/enums/telemetry-attributes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/bullmq/dist/esm/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFifoQueue: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.AsyncFifoQueue),\n/* harmony export */   Backoffs: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Backoffs),\n/* harmony export */   Child: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Child),\n/* harmony export */   ChildCommand: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.ChildCommand),\n/* harmony export */   ChildPool: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.ChildPool),\n/* harmony export */   ChildProcessor: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.ChildProcessor),\n/* harmony export */   ClientType: () => (/* reexport safe */ _interfaces__WEBPACK_IMPORTED_MODULE_2__.ClientType),\n/* harmony export */   DELAYED_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.DELAYED_ERROR),\n/* harmony export */   DELAY_TIME_1: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.DELAY_TIME_1),\n/* harmony export */   DELAY_TIME_5: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.DELAY_TIME_5),\n/* harmony export */   DelayedError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.DelayedError),\n/* harmony export */   ErrorCode: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.ErrorCode),\n/* harmony export */   FlowProducer: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.FlowProducer),\n/* harmony export */   Job: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Job),\n/* harmony export */   JobScheduler: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.JobScheduler),\n/* harmony export */   MetricsTime: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.MetricsTime),\n/* harmony export */   PRIORITY_LIMIT: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.PRIORITY_LIMIT),\n/* harmony export */   ParentCommand: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.ParentCommand),\n/* harmony export */   QUEUE_EVENT_SUFFIX: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.QUEUE_EVENT_SUFFIX),\n/* harmony export */   Queue: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Queue),\n/* harmony export */   QueueBase: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueBase),\n/* harmony export */   QueueEvents: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueEvents),\n/* harmony export */   QueueEventsProducer: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueEventsProducer),\n/* harmony export */   QueueGetters: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueGetters),\n/* harmony export */   QueueKeys: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.QueueKeys),\n/* harmony export */   RATE_LIMIT_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RATE_LIMIT_ERROR),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RateLimitError),\n/* harmony export */   RedisConnection: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.RedisConnection),\n/* harmony export */   Repeat: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Repeat),\n/* harmony export */   Scripts: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Scripts),\n/* harmony export */   SpanKind: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.SpanKind),\n/* harmony export */   TelemetryAttributes: () => (/* reexport safe */ _enums__WEBPACK_IMPORTED_MODULE_1__.TelemetryAttributes),\n/* harmony export */   UNRECOVERABLE_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.UNRECOVERABLE_ERROR),\n/* harmony export */   UnrecoverableError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.UnrecoverableError),\n/* harmony export */   WAITING_CHILDREN_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.WAITING_CHILDREN_ERROR),\n/* harmony export */   WAITING_ERROR: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.WAITING_ERROR),\n/* harmony export */   WaitingChildrenError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.WaitingChildrenError),\n/* harmony export */   WaitingError: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.WaitingError),\n/* harmony export */   Worker: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.Worker),\n/* harmony export */   array2obj: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.array2obj),\n/* harmony export */   asyncSend: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.asyncSend),\n/* harmony export */   childSend: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.childSend),\n/* harmony export */   clientCommandMessageReg: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.clientCommandMessageReg),\n/* harmony export */   createScripts: () => (/* reexport safe */ _utils_create_scripts__WEBPACK_IMPORTED_MODULE_6__.createScripts),\n/* harmony export */   decreaseMaxListeners: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.decreaseMaxListeners),\n/* harmony export */   defaultRepeatStrategy: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.defaultRepeatStrategy),\n/* harmony export */   delay: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.delay),\n/* harmony export */   errorObject: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.errorObject),\n/* harmony export */   errorToJSON: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.errorToJSON),\n/* harmony export */   getNextMillis: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.getNextMillis),\n/* harmony export */   getParentKey: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.getParentKey),\n/* harmony export */   increaseMaxListeners: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.increaseMaxListeners),\n/* harmony export */   invertObject: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.invertObject),\n/* harmony export */   isEmpty: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.isEmpty),\n/* harmony export */   isNotConnectionError: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.isNotConnectionError),\n/* harmony export */   isRedisCluster: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.isRedisCluster),\n/* harmony export */   isRedisInstance: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.isRedisInstance),\n/* harmony export */   isRedisVersionLowerThan: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.isRedisVersionLowerThan),\n/* harmony export */   lengthInUtf8Bytes: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.lengthInUtf8Bytes),\n/* harmony export */   objectToFlatArray: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.objectToFlatArray),\n/* harmony export */   optsDecodeMap: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.optsDecodeMap),\n/* harmony export */   optsEncodeMap: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.optsEncodeMap),\n/* harmony export */   parseObjectValues: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.parseObjectValues),\n/* harmony export */   raw2NextJobData: () => (/* reexport safe */ _classes__WEBPACK_IMPORTED_MODULE_0__.raw2NextJobData),\n/* harmony export */   removeAllQueueData: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.removeAllQueueData),\n/* harmony export */   removeUndefinedFields: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.removeUndefinedFields),\n/* harmony export */   toString: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.toString),\n/* harmony export */   trace: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.trace),\n/* harmony export */   tryCatch: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.tryCatch)\n/* harmony export */ });\n/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/index.js\");\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interfaces */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/bullmq/dist/esm/types/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\");\n/* harmony import */ var _types_processor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types/processor */ \"(rsc)/./node_modules/bullmq/dist/esm/types/processor.js\");\n/* harmony import */ var _utils_create_scripts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/create-scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/utils/create-scripts.js\");\n\n\n\n\n\n// to prevent circular references\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDRjtBQUNLO0FBQ0w7QUFDQTtBQUN4QjtBQUNrQztBQUNLO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW5kZXguanM/ZjQ1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NsYXNzZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZXMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzJztcbi8vIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlc1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy9wcm9jZXNzb3InO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9jcmVhdGUtc2NyaXB0cyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/advanced-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=advanced-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYWR2YW5jZWQtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYWR2YW5jZWQtb3B0aW9ucy5qcz82NzZjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkdmFuY2VkLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/backoff-options.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=backoff-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFja29mZi1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9iYWNrb2ZmLW9wdGlvbnMuanM/NDM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrb2ZmLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/base-job-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=base-job-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFzZS1qb2Itb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvYmFzZS1qb2Itb3B0aW9ucy5qcz8wODY4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2Utam9iLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/child-message.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=child-message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY2hpbGQtbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY2hpbGQtbWVzc2FnZS5qcz8zMjNmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoaWxkLW1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/connection.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvY29ubmVjdGlvbi5qcz80Yjk5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/flow-job.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=flow-job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvZmxvdy1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2Zsb3ctam9iLmpzP2I3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmxvdy1qb2IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientType: () => (/* reexport safe */ _queue_options__WEBPACK_IMPORTED_MODULE_17__.ClientType)\n/* harmony export */ });\n/* harmony import */ var _advanced_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./advanced-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/advanced-options.js\");\n/* harmony import */ var _backoff_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./backoff-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/backoff-options.js\");\n/* harmony import */ var _base_job_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-job-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/base-job-options.js\");\n/* harmony import */ var _child_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./child-message */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/child-message.js\");\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/connection.js\");\n/* harmony import */ var _flow_job__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flow-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/flow-job.js\");\n/* harmony import */ var _ioredis_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ioredis-events */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js\");\n/* harmony import */ var _job_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./job-json */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js\");\n/* harmony import */ var _job_scheduler_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./job-scheduler-json */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-scheduler-json.js\");\n/* harmony import */ var _keep_jobs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./keep-jobs */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js\");\n/* harmony import */ var _metrics_options__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./metrics-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js\");\n/* harmony import */ var _metrics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./metrics */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js\");\n/* harmony import */ var _minimal_job__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./minimal-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js\");\n/* harmony import */ var _minimal_queue__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./minimal-queue */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-queue.js\");\n/* harmony import */ var _parent_message__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./parent-message */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js\");\n/* harmony import */ var _parent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./parent */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js\");\n/* harmony import */ var _parent_options__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./parent-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-options.js\");\n/* harmony import */ var _queue_options__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./queue-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js\");\n/* harmony import */ var _rate_limiter_options__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./rate-limiter-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js\");\n/* harmony import */ var _redis_options__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./redis-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js\");\n/* harmony import */ var _redis_streams__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./redis-streams */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js\");\n/* harmony import */ var _repeatable_job__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./repeatable-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js\");\n/* harmony import */ var _repeatable_options__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./repeatable-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-options.js\");\n/* harmony import */ var _repeat_options__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./repeat-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js\");\n/* harmony import */ var _script_queue_context__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./script-queue-context */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/script-queue-context.js\");\n/* harmony import */ var _sandboxed_job_processor__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./sandboxed-job-processor */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js\");\n/* harmony import */ var _sandboxed_job__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./sandboxed-job */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js\");\n/* harmony import */ var _sandboxed_options__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./sandboxed-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-options.js\");\n/* harmony import */ var _worker_options__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./worker-options */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js\");\n/* harmony import */ var _telemetry__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./telemetry */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/telemetry.js\");\n/* harmony import */ var _receiver__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/bullmq/dist/esm/interfaces/receiver.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDRDtBQUNDO0FBQ0g7QUFDSDtBQUNGO0FBQ007QUFDTjtBQUNVO0FBQ1Q7QUFDTTtBQUNSO0FBQ0k7QUFDRTtBQUNDO0FBQ1I7QUFDUTtBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0M7QUFDSTtBQUNKO0FBQ007QUFDRztBQUNWO0FBQ0k7QUFDSDtBQUNMO0FBQ0Q7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2luZGV4LmpzPzg1NjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hZHZhbmNlZC1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vYmFja29mZi1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vYmFzZS1qb2Itb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2NoaWxkLW1lc3NhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25uZWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vZmxvdy1qb2InO1xuZXhwb3J0ICogZnJvbSAnLi9pb3JlZGlzLWV2ZW50cyc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi1qc29uJztcbmV4cG9ydCAqIGZyb20gJy4vam9iLXNjaGVkdWxlci1qc29uJztcbmV4cG9ydCAqIGZyb20gJy4va2VlcC1qb2JzJztcbmV4cG9ydCAqIGZyb20gJy4vbWV0cmljcy1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vbWV0cmljcyc7XG5leHBvcnQgKiBmcm9tICcuL21pbmltYWwtam9iJztcbmV4cG9ydCAqIGZyb20gJy4vbWluaW1hbC1xdWV1ZSc7XG5leHBvcnQgKiBmcm9tICcuL3BhcmVudC1tZXNzYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vcGFyZW50JztcbmV4cG9ydCAqIGZyb20gJy4vcGFyZW50LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9xdWV1ZS1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vcmF0ZS1saW1pdGVyLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWRpcy1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vcmVkaXMtc3RyZWFtcyc7XG5leHBvcnQgKiBmcm9tICcuL3JlcGVhdGFibGUtam9iJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwZWF0YWJsZS1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwZWF0LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY3JpcHQtcXVldWUtY29udGV4dCc7XG5leHBvcnQgKiBmcm9tICcuL3NhbmRib3hlZC1qb2ItcHJvY2Vzc29yJztcbmV4cG9ydCAqIGZyb20gJy4vc2FuZGJveGVkLWpvYic7XG5leHBvcnQgKiBmcm9tICcuL3NhbmRib3hlZC1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vd29ya2VyLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZWxlbWV0cnknO1xuZXhwb3J0ICogZnJvbSAnLi9yZWNlaXZlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=ioredis-events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvaW9yZWRpcy1ldmVudHMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2lvcmVkaXMtZXZlbnRzLmpzPzdmMjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW9yZWRpcy1ldmVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/ioredis-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/job-json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvam9iLWpzb24uanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL2pvYi1qc29uLmpzP2ZkNjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLWpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-scheduler-json.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/job-scheduler-json.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-scheduler-json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvam9iLXNjaGVkdWxlci1qc29uLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9qb2Itc2NoZWR1bGVyLWpzb24uanM/NmI5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qb2Itc2NoZWR1bGVyLWpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/job-scheduler-json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=keep-jobs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMva2VlcC1qb2JzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9rZWVwLWpvYnMuanM/NTllYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWVwLWpvYnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/keep-jobs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/metrics-options.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=metrics-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9tZXRyaWNzLW9wdGlvbnMuanM/ZGIzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/metrics.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=metrics.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWV0cmljcy5qcz84OTliIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/metrics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/minimal-job.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=minimal-job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWluaW1hbC1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL21pbmltYWwtam9iLmpzPzViMWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluaW1hbC1qb2IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/minimal-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=minimal-queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWluaW1hbC1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvbWluaW1hbC1xdWV1ZS5qcz8xZWMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbmltYWwtcXVldWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/minimal-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/parent-message.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=parent-message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LW1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3BhcmVudC1tZXNzYWdlLmpzPzE0ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyZW50LW1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/parent-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=parent-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3BhcmVudC1vcHRpb25zLmpzPzZhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyZW50LW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/parent.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=parent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcGFyZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9wYXJlbnQuanM/OGI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/parent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/queue-options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientType: () => (/* binding */ ClientType)\n/* harmony export */ });\nvar ClientType;\n(function (ClientType) {\n    ClientType[\"blocking\"] = \"blocking\";\n    ClientType[\"normal\"] = \"normal\";\n})(ClientType || (ClientType = {}));\n//# sourceMappingURL=queue-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcXVldWUtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcXVldWUtb3B0aW9ucy5qcz85ODJjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgQ2xpZW50VHlwZTtcbihmdW5jdGlvbiAoQ2xpZW50VHlwZSkge1xuICAgIENsaWVudFR5cGVbXCJibG9ja2luZ1wiXSA9IFwiYmxvY2tpbmdcIjtcbiAgICBDbGllbnRUeXBlW1wibm9ybWFsXCJdID0gXCJub3JtYWxcIjtcbn0pKENsaWVudFR5cGUgfHwgKENsaWVudFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUtb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/queue-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=rate-limiter-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmF0ZS1saW1pdGVyLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JhdGUtbGltaXRlci1vcHRpb25zLmpzPzFhMjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF0ZS1saW1pdGVyLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/rate-limiter-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/receiver.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/receiver.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=receiver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JlY2VpdmVyLmpzPzU1N2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/redis-options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=redis-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtb3B0aW9ucy5qcz84ZjhlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlzLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/redis-streams.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=redis-streams.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtc3RyZWFtcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVkaXMtc3RyZWFtcy5qcz9hYTYwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlzLXN0cmVhbXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/redis-streams.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/repeat-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=repeat-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVwZWF0LW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JlcGVhdC1vcHRpb25zLmpzP2MzZWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeat-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=repeatable-job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVwZWF0YWJsZS1qb2IuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3JlcGVhdGFibGUtam9iLmpzPzkwYmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0YWJsZS1qb2IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-options.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/repeatable-options.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=repeatable-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvcmVwZWF0YWJsZS1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy9yZXBlYXRhYmxlLW9wdGlvbnMuanM/ZDBjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXRhYmxlLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/repeatable-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=sandboxed-job-processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLWpvYi1wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3NhbmRib3hlZC1qb2ItcHJvY2Vzc29yLmpzPzYzMmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FuZGJveGVkLWpvYi1wcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job-processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=sandboxed-job.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLWpvYi5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLWpvYi5qcz9jYzMwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbmRib3hlZC1qb2IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-options.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/sandboxed-options.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=sandboxed-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2FuZGJveGVkLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3NhbmRib3hlZC1vcHRpb25zLmpzP2IwNTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FuZGJveGVkLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/sandboxed-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/script-queue-context.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/script-queue-context.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=script-queue-context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvc2NyaXB0LXF1ZXVlLWNvbnRleHQuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3NjcmlwdC1xdWV1ZS1jb250ZXh0LmpzPzM2NjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0LXF1ZXVlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/script-queue-context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/telemetry.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/telemetry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=telemetry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvdGVsZW1ldHJ5LmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vaW50ZXJmYWNlcy90ZWxlbWV0cnkuanM/MWM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZWxlbWV0cnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/telemetry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/interfaces/worker-options.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=worker-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL2ludGVyZmFjZXMvd29ya2VyLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9pbnRlcmZhY2VzL3dvcmtlci1vcHRpb25zLmpzPzllZDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/interfaces/worker-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDelayedJob: () => (/* binding */ addDelayedJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a delayed job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - computes timestamp.\n    - adds to delayed zset.\n    - Emits a global event 'delayed' if the job is delayed.\n    Input:\n      KEYS[1] 'marker',\n      KEYS[2] 'meta'\n      KEYS[3] 'id'\n      KEYS[4] 'delayed'\n      KEYS[5] 'completed'\n      KEYS[6] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (use custom instead of one generated automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n          x [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal delayedKey = KEYS[4]\nlocal completedKey = KEYS[5]\nlocal eventsKey = KEYS[6]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event 'delayed' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall(\"ZREVRANGEBYSCORE\", delayedKey, maxScore,\n    minScore, \"WITHSCORES\",\"LIMIT\", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall(\"ZADD\", delayedKey, score, jobId)\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n    \"jobId\", jobId, \"delay\", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal function removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents, currentDeduplicatedJobId,\n    jobId, deduplicationId, prefix)\n    if rcall(\"ZREM\", delayedKey, currentDeduplicatedJobId) > 0 then\n        removeJobKeys(prefix .. currentDeduplicatedJobId)\n        rcall(\"XADD\", eventsKey, \"*\", \"event\", \"removed\", \"jobId\", currentDeduplicatedJobId,\n            \"prev\", \"delayed\")\n        -- TODO remove debounced event in next breaking change\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n            jobId, \"debounceId\", deduplicationId)\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n            jobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", currentDeduplicatedJobId)\n        return true\n    end\n    return false\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts['id']\n    if deduplicationId then\n        local ttl = deduplicationOpts['ttl']\n        if deduplicationOpts['replace'] then\n            if ttl and ttl > 0 then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        if deduplicationOpts['extend'] then\n                            rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        else\n                            rcall('SET', deduplicationKey, jobId, 'KEEPTTL')\n                        end\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                    return\n                end\n            else\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        rcall('SET', deduplicationKey, jobId)\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId)\n                    return\n                end\n            end\n        else\n            local deduplicationKeyExists\n            if ttl and ttl > 0 then\n                if deduplicationOpts['extend'] then\n                    local currentDebounceJobId = rcall('GET', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall('SET', deduplicationKey, currentDebounceJobId, 'PX', ttl)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\",\n                            \"jobId\", currentDebounceJobId, \"debounceId\", deduplicationId)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                            currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'PX', ttl, 'NX')\n                end\n            else\n                deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'NX')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                -- TODO remove debounced event in next breaking change\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n                    currentDebounceJobId, \"debounceId\", deduplicationId)\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                    currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. \":wait\"\n    local parentPausedKey = parentQueueKey .. \":paused\"\n    local parentActiveKey = parentQueueKey .. \":active\"\n    local parentMetaKey = parentQueueKey .. \":meta\"\n    local parentMarkerKey = parentQueueKey .. \":marker\"\n    local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. \":delayed\"\n        rcall(\"ZADD\", parentDelayedKey, score, parentId)\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\", \"jobId\", parentId, \"delay\",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. \":prioritized\", priority, parentId,\n                parentQueueKey .. \":pc\", isPausedOrMaxed)\n        end\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\",\n            \"waiting-children\")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then    \n      rcall(\"ZREM\", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall(\"SCARD\", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts['de'], jobId, delayedKey, deduplicationKey,\n  eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n    opts, timestamp, parentKey, parentData, repeatJobKey)\naddDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, KEYS[1], delay)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addDelayedJob = {\n    name: 'addDelayedJob',\n    content,\n    keys: 6,\n};\n//# sourceMappingURL=addDelayedJob-6.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkRGVsYXllZEpvYi02LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGREZWxheWVkSm9iLTYuanM/NjNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkcyBhIGRlbGF5ZWQgam9iIHRvIHRoZSBxdWV1ZSBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICAgIC0gSW5jcmVhc2VzIHRoZSBqb2IgY291bnRlciBpZiBuZWVkZWQuXG4gICAgLSBDcmVhdGVzIGEgbmV3IGpvYiBrZXkgd2l0aCB0aGUgam9iIGRhdGEuXG4gICAgLSBjb21wdXRlcyB0aW1lc3RhbXAuXG4gICAgLSBhZGRzIHRvIGRlbGF5ZWQgenNldC5cbiAgICAtIEVtaXRzIGEgZ2xvYmFsIGV2ZW50ICdkZWxheWVkJyBpZiB0aGUgam9iIGlzIGRlbGF5ZWQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdtYXJrZXInLFxuICAgICAgS0VZU1syXSAnbWV0YSdcbiAgICAgIEtFWVNbM10gJ2lkJ1xuICAgICAgS0VZU1s0XSAnZGVsYXllZCdcbiAgICAgIEtFWVNbNV0gJ2NvbXBsZXRlZCdcbiAgICAgIEtFWVNbNl0gZXZlbnRzIHN0cmVhbSBrZXlcbiAgICAgIEFSR1ZbMV0gbXNncGFja2VkIGFyZ3VtZW50cyBhcnJheVxuICAgICAgICAgICAgWzFdICBrZXkgcHJlZml4LFxuICAgICAgICAgICAgWzJdICBjdXN0b20gaWQgKHVzZSBjdXN0b20gaW5zdGVhZCBvZiBvbmUgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICBbM10gIG5hbWVcbiAgICAgICAgICAgIFs0XSAgdGltZXN0YW1wXG4gICAgICAgICAgICBbNV0gIHBhcmVudEtleT9cbiAgICAgICAgICB4IFs2XSAgd2FpdENoaWxkcmVuS2V5IGtleS5cbiAgICAgICAgICAgIFs3XSAgcGFyZW50IGRlcGVuZGVuY2llcyBrZXkuXG4gICAgICAgICAgICBbOF0gIHBhcmVudD8ge2lkLCBxdWV1ZUtleX1cbiAgICAgICAgICAgIFs5XSAgcmVwZWF0IGpvYiBrZXlcbiAgICAgICAgICAgIFsxMF0gZGVkdXBsaWNhdGlvbiBrZXlcbiAgICAgIEFSR1ZbMl0gSnNvbiBzdHJpbmdpZmllZCBqb2IgZGF0YVxuICAgICAgQVJHVlszXSBtc2dwYWNrZWQgb3B0aW9uc1xuICAgICAgT3V0cHV0OlxuICAgICAgICBqb2JJZCAgLSBPS1xuICAgICAgICAtNSAgICAgLSBNaXNzaW5nIHBhcmVudCBrZXlcbl1dXG5sb2NhbCBtZXRhS2V5ID0gS0VZU1syXVxubG9jYWwgaWRLZXkgPSBLRVlTWzNdXG5sb2NhbCBkZWxheWVkS2V5ID0gS0VZU1s0XVxubG9jYWwgY29tcGxldGVkS2V5ID0gS0VZU1s1XVxubG9jYWwgZXZlbnRzS2V5ID0gS0VZU1s2XVxubG9jYWwgam9iSWRcbmxvY2FsIGpvYklkS2V5XG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGFyZ3MgPSBjbXNncGFjay51bnBhY2soQVJHVlsxXSlcbmxvY2FsIGRhdGEgPSBBUkdWWzJdXG5sb2NhbCBwYXJlbnRLZXkgPSBhcmdzWzVdXG5sb2NhbCBwYXJlbnQgPSBhcmdzWzhdXG5sb2NhbCByZXBlYXRKb2JLZXkgPSBhcmdzWzldXG5sb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gYXJnc1sxMF1cbmxvY2FsIHBhcmVudERhdGFcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZHMgYSBkZWxheWVkIGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIENyZWF0ZXMgYSBuZXcgam9iIGtleSB3aXRoIHRoZSBqb2IgZGF0YS5cbiAgICAtIGFkZHMgdG8gZGVsYXllZCB6c2V0LlxuICAgIC0gRW1pdHMgYSBnbG9iYWwgZXZlbnQgJ2RlbGF5ZWQnIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAgIHJldHVybiBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAtLSBSZXBsYWNlIHRoZSBzY29yZSBvZiB0aGUgbWFya2VyIHdpdGggdGhlIG5ld2VzdCBrbm93blxuICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIG5leHRUaW1lc3RhbXAsIFwiMVwiKVxuICBlbmRcbmVuZFxuLS1bW1xuICBCYWtlIGluIHRoZSBqb2IgaWQgZmlyc3QgMTIgYml0cyBpbnRvIHRoZSB0aW1lc3RhbXBcbiAgdG8gZ3VhcmFudGVlIGNvcnJlY3QgZXhlY3V0aW9uIG9yZGVyIG9mIGRlbGF5ZWQgam9ic1xuICAodXAgdG8gNDA5NiBqb2JzIHBlciBnaXZlbiB0aW1lc3RhbXAgb3IgNDA5NiBqb2JzIGFwYXJ0IHBlciB0aW1lc3RhbXApXG4gIFdBUk5JTkc6IEpvYnMgdGhhdCBhcmUgc28gZmFyIGFwYXJ0IHRoYXQgdGhleSB3cmFwIGFyb3VuZCB3aWxsIGNhdXNlIEZJRk8gdG8gZmFpbFxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldERlbGF5ZWRTY29yZShkZWxheWVkS2V5LCB0aW1lc3RhbXAsIGRlbGF5KVxuICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gKGRlbGF5ID4gMCBhbmQgKHRvbnVtYmVyKHRpbWVzdGFtcCkgKyBkZWxheSkpIG9yIHRvbnVtYmVyKHRpbWVzdGFtcClcbiAgbG9jYWwgbWluU2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gIGxvY2FsIG1heFNjb3JlID0gKGRlbGF5ZWRUaW1lc3RhbXAgKyAxICkgKiAweDEwMDAgLSAxXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJFVlJBTkdFQllTQ09SRVwiLCBkZWxheWVkS2V5LCBtYXhTY29yZSxcbiAgICBtaW5TY29yZSwgXCJXSVRIU0NPUkVTXCIsXCJMSU1JVFwiLCAwLCAxKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBjdXJyZW50TWF4U2NvcmUgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgY3VycmVudE1heFNjb3JlIH49IG5pbCB0aGVuXG4gICAgICBpZiBjdXJyZW50TWF4U2NvcmUgPj0gbWF4U2NvcmUgdGhlblxuICAgICAgICByZXR1cm4gbWF4U2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRNYXhTY29yZSArIDEsIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIG1pblNjb3JlLCBkZWxheWVkVGltZXN0YW1wXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5ZWRKb2Ioam9iSWQsIGRlbGF5ZWRLZXksIGV2ZW50c0tleSwgdGltZXN0YW1wLFxuICBtYXhFdmVudHMsIG1hcmtlcktleSwgZGVsYXkpXG4gIGxvY2FsIHNjb3JlLCBkZWxheWVkVGltZXN0YW1wID0gZ2V0RGVsYXllZFNjb3JlKGRlbGF5ZWRLZXksIHRpbWVzdGFtcCwgdG9udW1iZXIoZGVsYXkpKVxuICByY2FsbChcIlpBRERcIiwgZGVsYXllZEtleSwgc2NvcmUsIGpvYklkKVxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIixcbiAgICBcImpvYklkXCIsIGpvYklkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4gIC0tIG1hcmsgdGhhdCBhIGRlbGF5ZWQgam9iIGlzIGF2YWlsYWJsZVxuICBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBkZWJvdW5jZSBhIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLCBqb2JLZXkgLi4gJzpkZXBlbmRlbmNpZXMnLFxuICAgIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcsIGpvYktleSAuLiAnOnVuc3VjY2Vzc2Z1bCcpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCxcbiAgICBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgaWYgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCkgPiAwIHRoZW5cbiAgICAgICAgcmVtb3ZlSm9iS2V5cyhwcmVmaXggLi4gY3VycmVudERlZHVwbGljYXRlZEpvYklkKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcInJlbW92ZWRcIiwgXCJqb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQsXG4gICAgICAgICAgICBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlYm91bmNlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICBqb2JJZCwgXCJkZWJvdW5jZUlkXCIsIGRlZHVwbGljYXRpb25JZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgam9iSWQsIFwiZGVkdXBsaWNhdGlvbklkXCIsIGRlZHVwbGljYXRpb25JZCwgXCJkZWR1cGxpY2F0ZWRKb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGRlZHVwbGljYXRlSm9iKGRlZHVwbGljYXRpb25PcHRzLCBqb2JJZCwgZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgcHJlZml4KVxuICAgIGxvY2FsIGRlZHVwbGljYXRpb25JZCA9IGRlZHVwbGljYXRpb25PcHRzIGFuZCBkZWR1cGxpY2F0aW9uT3B0c1snaWQnXVxuICAgIGlmIGRlZHVwbGljYXRpb25JZCB0aGVuXG4gICAgICAgIGxvY2FsIHR0bCA9IGRlZHVwbGljYXRpb25PcHRzWyd0dGwnXVxuICAgICAgICBpZiBkZWR1cGxpY2F0aW9uT3B0c1sncmVwbGFjZSddIHRoZW5cbiAgICAgICAgICAgIGlmIHR0bCBhbmQgdHRsID4gMCB0aGVuXG4gICAgICAgICAgICAgICAgbG9jYWwgY3VycmVudERlYm91bmNlSm9iSWQgPSByY2FsbCgnR0VUJywgZGVkdXBsaWNhdGlvbktleSlcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50RGVib3VuY2VKb2JJZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGlzUmVtb3ZlZCA9IHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgam9iSWQsIGRlZHVwbGljYXRpb25JZCwgcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICBpZiBpc1JlbW92ZWQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGVkdXBsaWNhdGlvbk9wdHNbJ2V4dGVuZCddIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdQWCcsIHR0bClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdLRUVQVFRMJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWwgaXNSZW1vdmVkID0gcmVtb3ZlRGVsYXllZEpvYihkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGlzUmVtb3ZlZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzXG4gICAgICAgICAgICBpZiB0dGwgYW5kIHR0bCA+IDAgdGhlblxuICAgICAgICAgICAgICAgIGlmIGRlZHVwbGljYXRpb25PcHRzWydleHRlbmQnXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1cnJlbnREZWJvdW5jZUpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBjdXJyZW50RGVib3VuY2VKb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWJvdW5jZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImpvYklkXCIsIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlYm91bmNlSWRcIiwgZGVkdXBsaWNhdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlZHVwbGljYXRpb25JZFwiLCBkZWR1cGxpY2F0aW9uSWQsIFwiZGVkdXBsaWNhdGVkSm9iSWRcIiwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERlYm91bmNlSm9iSWRcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnUFgnLCB0dGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzID0gbm90IHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsLCAnTlgnKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlZHVwbGljYXRpb25LZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnTlgnKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpZiBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzIHRoZW5cbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVib3VuY2VkXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlYm91bmNlSm9iSWQsIFwiZGVib3VuY2VJZFwiLCBkZWR1cGxpY2F0aW9uSWQpXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgXCJkZWR1cGxpY2F0aW9uSWRcIiwgZGVkdXBsaWNhdGlvbklkLCBcImRlZHVwbGljYXRlZEpvYklkXCIsIGpvYklkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVuIGpvYiBpcyBkdXBsaWNhdGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgcGFyZW50J3MgZGVwZW5kZW5jaWVzIGlmIHRoZSBqb2JcbiAgICBpcyBhbHJlYWR5IGNvbXBsZXRlZCBhbmQgYWJvdXQgdG8gYmUgaWdub3JlZC4gVGhlIHBhcmVudCBtdXN0IGdldCBpdHNcbiAgICBkZXBlbmRlbmNpZXMgdXBkYXRlZCB0byBhdm9pZCB0aGUgcGFyZW50IGpvYiBiZWluZyBzdHVjayBmb3JldmVyIGluIFxuICAgIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHN0YXRlLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIG9yIGFkZCBkZXBlbmRlbmNpZXMgdG8gcGFyZW50LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIHBhcmVudCB0byBhIHdhaXQgc3RhdHVzICh3YWl0aW5nLCBkZWxheWVkIG9yIHByaW9yaXRpemVkKVxuICBpZiBubyBwZW5kaW5nIGRlcGVuZGVuY2llcy5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBwYXJlbnQgdG8gYSB3YWl0IHN0YXR1cyAod2FpdGluZywgZGVsYXllZCBvciBwcmlvcml0aXplZCkgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIE1vdmUgcGFyZW50IHRvIGEgd2FpdCBzdGF0dXMgKHdhaXQsIHByaW9yaXRpemVkIG9yIGRlbGF5ZWQpXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgaWYgcXVldWUgaXMgcGF1c2VkIG9yIG1heGVkXG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkT3JNYXhlZChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gdHJ1ZVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIHJldHVybiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgbG9jYWwgcGFyZW50V2FpdEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRcIlxuICAgIGxvY2FsIHBhcmVudFBhdXNlZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBhdXNlZFwiXG4gICAgbG9jYWwgcGFyZW50QWN0aXZlS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6YWN0aXZlXCJcbiAgICBsb2NhbCBwYXJlbnRNZXRhS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWV0YVwiXG4gICAgbG9jYWwgcGFyZW50TWFya2VyS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWFya2VyXCJcbiAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1sxXSkgb3IgMFxuICAgIGxvY2FsIGRlbGF5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1syXSkgb3IgMFxuICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSB0b251bWJlcih0aW1lc3RhbXApICsgZGVsYXlcbiAgICAgICAgbG9jYWwgc2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHBhcmVudERlbGF5ZWRLZXksIHNjb3JlLCBwYXJlbnRJZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLFxuICAgICAgICAgICAgZGVsYXllZFRpbWVzdGFtcClcbiAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgZWxzZVxuICAgICAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudE1ldGFLZXksIHBhcmVudEFjdGl2ZUtleSxcbiAgICAgICAgICAgICAgICBwYXJlbnRXYWl0S2V5LCBwYXJlbnRQYXVzZWRLZXkpXG4gICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWRPck1heGVkLCBwYXJlbnRJZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9jYWwgaXNQYXVzZWRPck1heGVkID0gaXNRdWV1ZVBhdXNlZE9yTWF4ZWQocGFyZW50TWV0YUtleSwgcGFyZW50QWN0aXZlS2V5KVxuICAgICAgICAgICAgYWRkSm9iV2l0aFByaW9yaXR5KHBhcmVudE1hcmtlcktleSwgcGFyZW50UXVldWVLZXkgLi4gXCI6cHJpb3JpdGl6ZWRcIiwgcHJpb3JpdHksIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBjXCIsIGlzUGF1c2VkT3JNYXhlZClcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLFxuICAgICAgICAgICAgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBwYXJlbnRLZXkpID09IDEgdGhlblxuICAgIGxvY2FsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIlxuICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSwgcGFyZW50SWQpIHRoZW4gICAgXG4gICAgICByY2FsbChcIlpSRU1cIiwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5LCBwYXJlbnRJZClcbiAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksXG4gIHBhcmVudElkLCB0aW1lc3RhbXApXG4gIGxvY2FsIGRvTm90SGF2ZVBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSkgPT0gMFxuICBpZiBkb05vdEhhdmVQZW5kaW5nRGVwZW5kZW5jaWVzIHRoZW5cbiAgICBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gIHBhcmVudElkLCBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcCApXG4gIGxvY2FsIHByb2Nlc3NlZFNldCA9IHBhcmVudEtleSAuLiBcIjpwcm9jZXNzZWRcIlxuICByY2FsbChcIkhTRVRcIiwgcHJvY2Vzc2VkU2V0LCBqb2JJZEtleSwgcmV0dXJudmFsdWUpXG4gIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZUV4aXN0aW5nSm9ic1BhcmVudChwYXJlbnRLZXksIHBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgam9iSWQsIHRpbWVzdGFtcClcbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgaWYgcmNhbGwoXCJaU0NPUkVcIiwgY29tcGxldGVkS2V5LCBqb2JJZCkgdGhlblxuICAgICAgICAgICAgbG9jYWwgcmV0dXJudmFsdWUgPSByY2FsbChcIkhHRVRcIiwgam9iSWRLZXksIFwicmV0dXJudmFsdWVcIilcbiAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFsncXVldWVLZXknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudFsnaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwicGFyZW50S2V5XCIsIHBhcmVudEtleSwgXCJwYXJlbnRcIiwgcGFyZW50RGF0YSlcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gaGFuZGxlRHVwbGljYXRlZEpvYihqb2JLZXksIGpvYklkLCBjdXJyZW50UGFyZW50S2V5LCBjdXJyZW50UGFyZW50LFxuICBwYXJlbnREYXRhLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgbG9jYWwgZXhpc3RlZFBhcmVudEtleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIpXG4gIGlmIG5vdCBleGlzdGVkUGFyZW50S2V5IG9yIGV4aXN0ZWRQYXJlbnRLZXkgPT0gY3VycmVudFBhcmVudEtleSB0aGVuXG4gICAgdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgam9iS2V5LFxuICAgICAgam9iSWQsIHRpbWVzdGFtcClcbiAgZWxzZVxuICAgIGlmIGN1cnJlbnRQYXJlbnRLZXkgfj0gbmlsIGFuZCBjdXJyZW50UGFyZW50S2V5IH49IGV4aXN0ZWRQYXJlbnRLZXlcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgZXhpc3RlZFBhcmVudEtleSkgPT0gMSkgdGhlblxuICAgICAgcmV0dXJuIC03XG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLFxuICAgIFwiZHVwbGljYXRlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHN0b3JlIGEgam9iXG5dXVxubG9jYWwgZnVuY3Rpb24gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIG5hbWUsIGRhdGEsIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuICAgIGxvY2FsIGpzb25PcHRzID0gY2pzb24uZW5jb2RlKG9wdHMpXG4gICAgbG9jYWwgZGVsYXkgPSBvcHRzWydkZWxheSddIG9yIDBcbiAgICBsb2NhbCBwcmlvcml0eSA9IG9wdHNbJ3ByaW9yaXR5J10gb3IgMFxuICAgIGxvY2FsIGRlYm91bmNlSWQgPSBvcHRzWydkZSddIGFuZCBvcHRzWydkZSddWydpZCddXG4gICAgbG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50S2V5XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50S2V5KVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50RGF0YSlcbiAgICBlbmRcbiAgICBpZiByZXBlYXRKb2JLZXkgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicmprXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcmVwZWF0Sm9iS2V5KVxuICAgIGVuZFxuICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwiZGVpZFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIGRlYm91bmNlSWQpXG4gICAgZW5kXG4gICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJuYW1lXCIsIG5hbWUsIFwiZGF0YVwiLCBkYXRhLCBcIm9wdHNcIiwganNvbk9wdHMsXG4gICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgdGltZXN0YW1wLCBcImRlbGF5XCIsIGRlbGF5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5LFxuICAgICAgICAgIHVucGFjayhvcHRpb25hbFZhbHVlcykpXG4gICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhZGRlZFwiLCBcImpvYklkXCIsIGpvYklkLCBcIm5hbWVcIiwgbmFtZSlcbiAgICByZXR1cm4gZGVsYXksIHByaW9yaXR5XG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBpZEtleSlcbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBvcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbM10pXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksXG4gICAgICAgICAgICBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxubG9jYWwgZGVkdXBsaWNhdGlvbkpvYklkID0gZGVkdXBsaWNhdGVKb2Iob3B0c1snZGUnXSwgam9iSWQsIGRlbGF5ZWRLZXksIGRlZHVwbGljYXRpb25LZXksXG4gIGV2ZW50c0tleSwgbWF4RXZlbnRzLCBhcmdzWzFdKVxuaWYgZGVkdXBsaWNhdGlvbkpvYklkIHRoZW5cbiAgcmV0dXJuIGRlZHVwbGljYXRpb25Kb2JJZFxuZW5kXG5sb2NhbCBkZWxheSwgcHJpb3JpdHkgPSBzdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgYXJnc1szXSwgQVJHVlsyXSxcbiAgICBvcHRzLCB0aW1lc3RhbXAsIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuYWRkRGVsYXllZEpvYihqb2JJZCwgZGVsYXllZEtleSwgZXZlbnRzS2V5LCB0aW1lc3RhbXAsIG1heEV2ZW50cywgS0VZU1sxXSwgZGVsYXkpXG4tLSBDaGVjayBpZiB0aGlzIGpvYiBpcyBhIGNoaWxkIG9mIGFub3RoZXIgam9iLCBpZiBzbyBhZGQgaXQgdG8gdGhlIHBhcmVudHMgZGVwZW5kZW5jaWVzXG5pZiBwYXJlbnREZXBlbmRlbmNpZXNLZXkgfj0gbmlsIHRoZW5cbiAgICByY2FsbChcIlNBRERcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JJZEtleSlcbmVuZFxucmV0dXJuIGpvYklkIC4uIFwiXCIgLS0gY29udmVydCB0byBzdHJpbmdcbmA7XG5leHBvcnQgY29uc3QgYWRkRGVsYXllZEpvYiA9IHtcbiAgICBuYW1lOiAnYWRkRGVsYXllZEpvYicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA2LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZERlbGF5ZWRKb2ItNi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addJobScheduler-11.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addJobScheduler-11.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addJobScheduler: () => (/* binding */ addJobScheduler)\n/* harmony export */ });\nconst content = `--[[\n  Adds a job scheduler, i.e. a job factory that creates jobs based on a given schedule (repeat options).\n    Input:\n      KEYS[1]  'repeat' key\n      KEYS[2]  'delayed' key\n      KEYS[3]  'wait' key\n      KEYS[4]  'paused' key\n      KEYS[5]  'meta' key\n      KEYS[6]  'prioritized' key\n      KEYS[7]  'marker' key\n      KEYS[8]  'id' key\n      KEYS[9]  'events' key\n      KEYS[10] 'pc' priority counter\n      KEYS[11] 'active' key\n      ARGV[1] next milliseconds\n      ARGV[2] msgpacked options\n            [1]  name\n            [2]  tz?\n            [3]  pattern?\n            [4]  endDate?\n            [5]  every?\n      ARGV[3] jobs scheduler id\n      ARGV[4] Json stringified template data\n      ARGV[5] mspacked template opts\n      ARGV[6] msgpacked delayed opts\n      ARGV[7] timestamp\n      ARGV[8] prefix key\n      ARGV[9] producer key\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal waitKey = KEYS[3]\nlocal pausedKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal prioritizedKey = KEYS[6]\nlocal eventsKey = KEYS[9]\nlocal nextMillis = ARGV[1]\nlocal jobSchedulerId = ARGV[3]\nlocal templateOpts = cmsgpack.unpack(ARGV[5])\nlocal now = tonumber(ARGV[7])\nlocal prefixKey = ARGV[8]\nlocal jobOpts = cmsgpack.unpack(ARGV[6])\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event 'delayed' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall(\"ZREVRANGEBYSCORE\", delayedKey, maxScore,\n    minScore, \"WITHSCORES\",\"LIMIT\", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall(\"ZADD\", delayedKey, score, jobId)\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n    \"jobId\", jobId, \"delay\", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\nlocal function addJobFromScheduler(jobKey, jobId, opts, waitKey, pausedKey, activeKey, metaKey, \n  prioritizedKey, priorityCounter, delayedKey, markerKey, eventsKey, name, maxEvents, timestamp,\n  data, jobSchedulerId, repeatDelay)\n  opts['delay'] = repeatDelay\n  opts['jobId'] = jobId\n  local delay, priority = storeJob(eventsKey, jobKey, jobId, name, data,\n    opts, timestamp, nil, nil, jobSchedulerId)\n  if delay ~= 0 then\n    addDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, markerKey, delay)\n  else\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n    -- Standard or priority add\n    if priority == 0 then\n      local pushCmd = opts['lifo'] and 'RPUSH' or 'LPUSH'\n      addJobInTargetList(target, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n      -- Priority add\n      addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounter, isPausedOrMaxed)\n    end\n    -- Emit waiting event\n    rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents,  \"*\", \"event\", \"waiting\", \"jobId\", jobId)\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\n--[[\n  Function to store a job scheduler\n]]\nlocal function storeJobScheduler(schedulerId, schedulerKey, repeatKey, nextMillis, opts,\n  templateData, templateOpts)\n  rcall(\"ZADD\", repeatKey, nextMillis, schedulerId)\n  local optionalValues = {}\n  if opts['tz'] then\n    table.insert(optionalValues, \"tz\")\n    table.insert(optionalValues, opts['tz'])\n  end\n  if opts['limit'] then\n    table.insert(optionalValues, \"limit\")\n    table.insert(optionalValues, opts['limit'])\n  end\n  if opts['pattern'] then\n    table.insert(optionalValues, \"pattern\")\n    table.insert(optionalValues, opts['pattern'])\n  end\n  if opts['startDate'] then\n    table.insert(optionalValues, \"startDate\")\n    table.insert(optionalValues, opts['startDate'])\n  end\n  if opts['endDate'] then\n    table.insert(optionalValues, \"endDate\")\n    table.insert(optionalValues, opts['endDate'])\n  end\n  if opts['every'] then\n    table.insert(optionalValues, \"every\")\n    table.insert(optionalValues, opts['every'])\n  end\n  if opts['offset'] then\n    table.insert(optionalValues, \"offset\")\n    table.insert(optionalValues, opts['offset'])\n  else\n    local offset = rcall(\"HGET\", schedulerKey, \"offset\")\n    if offset then\n      table.insert(optionalValues, \"offset\")\n      table.insert(optionalValues, tonumber(offset))\n    end\n  end\n  local jsonTemplateOpts = cjson.encode(templateOpts)\n  if jsonTemplateOpts and jsonTemplateOpts ~= '{}' then\n    table.insert(optionalValues, \"opts\")\n    table.insert(optionalValues, jsonTemplateOpts)\n  end\n  if templateData and templateData ~= '{}' then\n    table.insert(optionalValues, \"data\")\n    table.insert(optionalValues, templateData)\n  end\n  table.insert(optionalValues, \"ic\")\n  table.insert(optionalValues, rcall(\"HGET\", schedulerKey, \"ic\") or 1)\n  rcall(\"DEL\", schedulerKey) -- remove all attributes and then re-insert new ones\n  rcall(\"HMSET\", schedulerKey, \"name\", opts['name'], unpack(optionalValues))\nend\nlocal function getJobSchedulerEveryNextMillis(prevMillis, every, now, offset, startDate)\n    local nextMillis\n    if not prevMillis then\n        if startDate then\n            -- Assuming startDate is passed as milliseconds from JavaScript\n            nextMillis = tonumber(startDate)\n            nextMillis = nextMillis > now and nextMillis or now\n        else\n            nextMillis = now\n        end\n    else\n        nextMillis = prevMillis + every\n        -- check if we may have missed some iterations\n        if nextMillis < now then\n            nextMillis = math.floor(now / every) * every + every + (offset or 0)\n        end\n    end\n    if not offset or offset == 0 then\n        local timeSlot = math.floor(nextMillis / every) * every;\n        offset = nextMillis - timeSlot;\n    end\n    -- Return a tuple nextMillis, offset\n    return math.floor(nextMillis), math.floor(offset)\nend\n-- If we are overriding a repeatable job we must delete the delayed job for\n-- the next iteration.\nlocal schedulerKey = repeatKey .. \":\" .. jobSchedulerId\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal templateData = ARGV[4]\nlocal prevMillis = rcall(\"ZSCORE\", repeatKey, jobSchedulerId)\nif prevMillis then\n    prevMillis = tonumber(prevMillis)\nend\nlocal schedulerOpts = cmsgpack.unpack(ARGV[2])\nlocal every = schedulerOpts['every']\n-- For backwards compatibility we also check the offset from the job itself.\n-- could be removed in future major versions.\nlocal jobOffset = jobOpts['repeat'] and jobOpts['repeat']['offset'] or 0\nlocal offset = schedulerOpts['offset'] or jobOffset or 0\nlocal newOffset = offset\nif every then\n    local startDate = schedulerOpts['startDate']\n    nextMillis, newOffset = getJobSchedulerEveryNextMillis(prevMillis, every, now, offset, startDate)\nend\nlocal function removeJobFromScheduler(prefixKey, delayedKey, prioritizedKey, waitKey, pausedKey, jobId,\n    metaKey, eventsKey)\n    if rcall(\"ZSCORE\", delayedKey, jobId) then\n        removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n        rcall(\"ZREM\", delayedKey, jobId)\n        return true\n    elseif rcall(\"ZSCORE\", prioritizedKey, jobId) then\n        removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n        rcall(\"ZREM\", prioritizedKey, jobId)\n        return true\n    else\n        local pausedOrWaitKey = waitKey\n        if isQueuePaused(metaKey) then\n            pausedOrWaitKey = pausedKey\n        end\n        if rcall(\"LREM\", pausedOrWaitKey, 1, jobId) > 0 then\n            removeJob(jobId, true, prefixKey, true --[[remove debounce key]] )\n            return true\n        end\n    end\n    return false\nend\nlocal hadPrevJob = false\nif prevMillis then    \n    local currentJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. prevMillis\n    local currentJobKey = schedulerKey .. \":\" .. prevMillis\n    -- In theory it should always exist the currentJobKey if there is a prevMillis unless something has\n    -- gone really wrong.\n    if rcall(\"EXISTS\", currentJobKey) == 1 then\n        hadPrevJob = removeJobFromScheduler(prefixKey, delayedKey, prioritizedKey, waitKey, pausedKey,\n            currentJobId, metaKey, eventsKey)\n    end\nend\nif hadPrevJob then\n    -- The jobs has been removed and we want to replace it, so lets use the same millis.\n    nextMillis = prevMillis\nelse \n    -- Special case where no job was removed, and we need to add the next iteration.\n    schedulerOpts['offset'] = newOffset\nend\n-- Check for job ID collision with existing jobs (in any state)\nlocal jobId = \"repeat:\" .. jobSchedulerId .. \":\" .. nextMillis\nlocal jobKey = prefixKey .. jobId\n-- If there's already a job with this ID, handle the collision\nif rcall(\"EXISTS\", jobKey) == 1 then\n    if every then\n        -- For 'every' case: try next time slot to avoid collision\n        local nextSlotMillis = nextMillis + every\n        local nextSlotJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. nextSlotMillis\n        local nextSlotJobKey = prefixKey .. nextSlotJobId\n        if rcall(\"EXISTS\", nextSlotJobKey) == 0 then\n            -- Next slot is free, use it\n            nextMillis = nextSlotMillis\n            jobId = nextSlotJobId\n        else\n            -- Next slot also has a job, return error code\n            return -11 -- SchedulerJobSlotsBusy\n        end\n    else\n        -- For 'pattern' case: return error code\n        return -10 -- SchedulerJobIdCollision\n    end\nend\nlocal delay = nextMillis - now\n-- Fast Clamp delay to minimum of 0\nif delay < 0 then\n    delay = 0\nend\nlocal nextJobKey = schedulerKey .. \":\" .. nextMillis\n-- jobId already calculated above during collision check\nstoreJobScheduler(jobSchedulerId, schedulerKey, repeatKey, nextMillis, schedulerOpts, templateData, templateOpts)\nrcall(\"INCR\", KEYS[8])\naddJobFromScheduler(nextJobKey, jobId, jobOpts, waitKey, pausedKey,\n    KEYS[11], metaKey, prioritizedKey, KEYS[10], delayedKey, KEYS[7], eventsKey,\n    schedulerOpts['name'], maxEvents, now, templateData, jobSchedulerId, delay)\nif ARGV[9] ~= \"\" then\n    rcall(\"HSET\", ARGV[9], \"nrjid\", jobId)\nend\nreturn {jobId .. \"\", delay}\n`;\nconst addJobScheduler = {\n    name: 'addJobScheduler',\n    content,\n    keys: 11,\n};\n//# sourceMappingURL=addJobScheduler-11.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkSm9iU2NoZWR1bGVyLTExLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGRKb2JTY2hlZHVsZXItMTEuanM/OWY3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkcyBhIGpvYiBzY2hlZHVsZXIsIGkuZS4gYSBqb2IgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgam9icyBiYXNlZCBvbiBhIGdpdmVuIHNjaGVkdWxlIChyZXBlYXQgb3B0aW9ucykuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICAncmVwZWF0JyBrZXlcbiAgICAgIEtFWVNbMl0gICdkZWxheWVkJyBrZXlcbiAgICAgIEtFWVNbM10gICd3YWl0JyBrZXlcbiAgICAgIEtFWVNbNF0gICdwYXVzZWQnIGtleVxuICAgICAgS0VZU1s1XSAgJ21ldGEnIGtleVxuICAgICAgS0VZU1s2XSAgJ3ByaW9yaXRpemVkJyBrZXlcbiAgICAgIEtFWVNbN10gICdtYXJrZXInIGtleVxuICAgICAgS0VZU1s4XSAgJ2lkJyBrZXlcbiAgICAgIEtFWVNbOV0gICdldmVudHMnIGtleVxuICAgICAgS0VZU1sxMF0gJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgICBLRVlTWzExXSAnYWN0aXZlJyBrZXlcbiAgICAgIEFSR1ZbMV0gbmV4dCBtaWxsaXNlY29uZHNcbiAgICAgIEFSR1ZbMl0gbXNncGFja2VkIG9wdGlvbnNcbiAgICAgICAgICAgIFsxXSAgbmFtZVxuICAgICAgICAgICAgWzJdICB0ej9cbiAgICAgICAgICAgIFszXSAgcGF0dGVybj9cbiAgICAgICAgICAgIFs0XSAgZW5kRGF0ZT9cbiAgICAgICAgICAgIFs1XSAgZXZlcnk/XG4gICAgICBBUkdWWzNdIGpvYnMgc2NoZWR1bGVyIGlkXG4gICAgICBBUkdWWzRdIEpzb24gc3RyaW5naWZpZWQgdGVtcGxhdGUgZGF0YVxuICAgICAgQVJHVls1XSBtc3BhY2tlZCB0ZW1wbGF0ZSBvcHRzXG4gICAgICBBUkdWWzZdIG1zZ3BhY2tlZCBkZWxheWVkIG9wdHNcbiAgICAgIEFSR1ZbN10gdGltZXN0YW1wXG4gICAgICBBUkdWWzhdIHByZWZpeCBrZXlcbiAgICAgIEFSR1ZbOV0gcHJvZHVjZXIga2V5XG4gICAgICBPdXRwdXQ6XG4gICAgICAgIHJlcGVhdGFibGVLZXkgIC0gT0tcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlcGVhdEtleSA9IEtFWVNbMV1cbmxvY2FsIGRlbGF5ZWRLZXkgPSBLRVlTWzJdXG5sb2NhbCB3YWl0S2V5ID0gS0VZU1szXVxubG9jYWwgcGF1c2VkS2V5ID0gS0VZU1s0XVxubG9jYWwgbWV0YUtleSA9IEtFWVNbNV1cbmxvY2FsIHByaW9yaXRpemVkS2V5ID0gS0VZU1s2XVxubG9jYWwgZXZlbnRzS2V5ID0gS0VZU1s5XVxubG9jYWwgbmV4dE1pbGxpcyA9IEFSR1ZbMV1cbmxvY2FsIGpvYlNjaGVkdWxlcklkID0gQVJHVlszXVxubG9jYWwgdGVtcGxhdGVPcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbNV0pXG5sb2NhbCBub3cgPSB0b251bWJlcihBUkdWWzddKVxubG9jYWwgcHJlZml4S2V5ID0gQVJHVls4XVxubG9jYWwgam9iT3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzZdKVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkcyBhIGRlbGF5ZWQgam9iIHRvIHRoZSBxdWV1ZSBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICAgIC0gQ3JlYXRlcyBhIG5ldyBqb2Iga2V5IHdpdGggdGhlIGpvYiBkYXRhLlxuICAgIC0gYWRkcyB0byBkZWxheWVkIHpzZXQuXG4gICAgLSBFbWl0cyBhIGdsb2JhbCBldmVudCAnZGVsYXllZCcgaWYgdGhlIGpvYiBpcyBkZWxheWVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbmV4dCBkZWxheWVkIGpvYiB0aW1lc3RhbXAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkFOR0VcIiwgZGVsYXllZEtleSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgcmV0dXJuIG5leHRUaW1lc3RhbXAgLyAweDEwMDBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgLS0gbmV4dCB0aW1lc3RhbXAuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEJha2UgaW4gdGhlIGpvYiBpZCBmaXJzdCAxMiBiaXRzIGludG8gdGhlIHRpbWVzdGFtcFxuICB0byBndWFyYW50ZWUgY29ycmVjdCBleGVjdXRpb24gb3JkZXIgb2YgZGVsYXllZCBqb2JzXG4gICh1cCB0byA0MDk2IGpvYnMgcGVyIGdpdmVuIHRpbWVzdGFtcCBvciA0MDk2IGpvYnMgYXBhcnQgcGVyIHRpbWVzdGFtcClcbiAgV0FSTklORzogSm9icyB0aGF0IGFyZSBzbyBmYXIgYXBhcnQgdGhhdCB0aGV5IHdyYXAgYXJvdW5kIHdpbGwgY2F1c2UgRklGTyB0byBmYWlsXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0RGVsYXllZFNjb3JlKGRlbGF5ZWRLZXksIHRpbWVzdGFtcCwgZGVsYXkpXG4gIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSAoZGVsYXkgPiAwIGFuZCAodG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5KSkgb3IgdG9udW1iZXIodGltZXN0YW1wKVxuICBsb2NhbCBtaW5TY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgbG9jYWwgbWF4U2NvcmUgPSAoZGVsYXllZFRpbWVzdGFtcCArIDEgKSAqIDB4MTAwMCAtIDFcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkVWUkFOR0VCWVNDT1JFXCIsIGRlbGF5ZWRLZXksIG1heFNjb3JlLFxuICAgIG1pblNjb3JlLCBcIldJVEhTQ09SRVNcIixcIkxJTUlUXCIsIDAsIDEpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIGN1cnJlbnRNYXhTY29yZSA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBjdXJyZW50TWF4U2NvcmUgfj0gbmlsIHRoZW5cbiAgICAgIGlmIGN1cnJlbnRNYXhTY29yZSA+PSBtYXhTY29yZSB0aGVuXG4gICAgICAgIHJldHVybiBtYXhTY29yZSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY3VycmVudE1heFNjb3JlICsgMSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gbWluU2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXllZEpvYihqb2JJZCwgZGVsYXllZEtleSwgZXZlbnRzS2V5LCB0aW1lc3RhbXAsXG4gIG1heEV2ZW50cywgbWFya2VyS2V5LCBkZWxheSlcbiAgbG9jYWwgc2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXAgPSBnZXREZWxheWVkU2NvcmUoZGVsYXllZEtleSwgdGltZXN0YW1wLCB0b251bWJlcihkZWxheSkpXG4gIHJjYWxsKFwiWkFERFwiLCBkZWxheWVkS2V5LCBzY29yZSwgam9iSWQpXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLFxuICAgIFwiam9iSWRcIiwgam9iSWQsIFwiZGVsYXlcIiwgZGVsYXllZFRpbWVzdGFtcClcbiAgLS0gbWFyayB0aGF0IGEgZGVsYXllZCBqb2IgaXMgYXZhaWxhYmxlXG4gIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkKHF1ZXVlTWV0YUtleSlcbiAgcmV0dXJuIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpID09IDFcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBzdG9yZSBhIGpvYlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHN0b3JlSm9iKGV2ZW50c0tleSwgam9iSWRLZXksIGpvYklkLCBuYW1lLCBkYXRhLCBvcHRzLCB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRLZXksIHBhcmVudERhdGEsIHJlcGVhdEpvYktleSlcbiAgICBsb2NhbCBqc29uT3B0cyA9IGNqc29uLmVuY29kZShvcHRzKVxuICAgIGxvY2FsIGRlbGF5ID0gb3B0c1snZGVsYXknXSBvciAwXG4gICAgbG9jYWwgcHJpb3JpdHkgPSBvcHRzWydwcmlvcml0eSddIG9yIDBcbiAgICBsb2NhbCBkZWJvdW5jZUlkID0gb3B0c1snZGUnXSBhbmQgb3B0c1snZGUnXVsnaWQnXVxuICAgIGxvY2FsIG9wdGlvbmFsVmFsdWVzID0ge31cbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudEtleVwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudEtleSlcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhcmVudFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHBhcmVudERhdGEpXG4gICAgZW5kXG4gICAgaWYgcmVwZWF0Sm9iS2V5IHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInJqa1wiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHJlcGVhdEpvYktleSlcbiAgICBlbmRcbiAgICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcImRlaWRcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBkZWJvdW5jZUlkKVxuICAgIGVuZFxuICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwibmFtZVwiLCBuYW1lLCBcImRhdGFcIiwgZGF0YSwgXCJvcHRzXCIsIGpzb25PcHRzLFxuICAgICAgICAgIFwidGltZXN0YW1wXCIsIHRpbWVzdGFtcCwgXCJkZWxheVwiLCBkZWxheSwgXCJwcmlvcml0eVwiLCBwcmlvcml0eSxcbiAgICAgICAgICB1bnBhY2sob3B0aW9uYWxWYWx1ZXMpKVxuICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiKlwiLCBcImV2ZW50XCIsIFwiYWRkZWRcIiwgXCJqb2JJZFwiLCBqb2JJZCwgXCJuYW1lXCIsIG5hbWUpXG4gICAgcmV0dXJuIGRlbGF5LCBwcmlvcml0eVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIsIFwibWF4XCIsIFwiZHVyYXRpb25cIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIGlmIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSkgdGhlblxuICAgICAgICByZXR1cm4gd2FpdEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWRPck1heGVkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JGcm9tU2NoZWR1bGVyKGpvYktleSwgam9iSWQsIG9wdHMsIHdhaXRLZXksIHBhdXNlZEtleSwgYWN0aXZlS2V5LCBtZXRhS2V5LCBcbiAgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5Q291bnRlciwgZGVsYXllZEtleSwgbWFya2VyS2V5LCBldmVudHNLZXksIG5hbWUsIG1heEV2ZW50cywgdGltZXN0YW1wLFxuICBkYXRhLCBqb2JTY2hlZHVsZXJJZCwgcmVwZWF0RGVsYXkpXG4gIG9wdHNbJ2RlbGF5J10gPSByZXBlYXREZWxheVxuICBvcHRzWydqb2JJZCddID0gam9iSWRcbiAgbG9jYWwgZGVsYXksIHByaW9yaXR5ID0gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JLZXksIGpvYklkLCBuYW1lLCBkYXRhLFxuICAgIG9wdHMsIHRpbWVzdGFtcCwgbmlsLCBuaWwsIGpvYlNjaGVkdWxlcklkKVxuICBpZiBkZWxheSB+PSAwIHRoZW5cbiAgICBhZGREZWxheWVkSm9iKGpvYklkLCBkZWxheWVkS2V5LCBldmVudHNLZXksIHRpbWVzdGFtcCwgbWF4RXZlbnRzLCBtYXJrZXJLZXksIGRlbGF5KVxuICBlbHNlXG4gICAgbG9jYWwgdGFyZ2V0LCBpc1BhdXNlZE9yTWF4ZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QobWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gICAgLS0gU3RhbmRhcmQgb3IgcHJpb3JpdHkgYWRkXG4gICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICBsb2NhbCBwdXNoQ21kID0gb3B0c1snbGlmbyddIGFuZCAnUlBVU0gnIG9yICdMUFVTSCdcbiAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWRPck1heGVkLCBqb2JJZClcbiAgICBlbHNlXG4gICAgICAtLSBQcmlvcml0eSBhZGRcbiAgICAgIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsIHByaW9yaXR5Q291bnRlciwgaXNQYXVzZWRPck1heGVkKVxuICAgIGVuZFxuICAgIC0tIEVtaXQgd2FpdGluZyBldmVudFxuICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsICBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBqb2JJZClcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gIGVuZFxuICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIGVtaXRFdmVudClcbiAgbG9jYWwgcGFyZW50VGFyZ2V0LCBpc1BhdXNlZE9yTWF4ZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50UHJlZml4IC4uIFwibWV0YVwiLCBwYXJlbnRQcmVmaXggLi4gXCJhY3RpdmVcIixcbiAgICBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0XCIsIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZE9yTWF4ZWQsIHBhcmVudElkKVxuICBpZiBlbWl0RXZlbnQgdGhlblxuICAgIGxvY2FsIHBhcmVudEV2ZW50U3RyZWFtID0gcGFyZW50UHJlZml4IC4uIFwiZXZlbnRzXCJcbiAgICByY2FsbChcIlhBRERcIiwgcGFyZW50RXZlbnRTdHJlYW0sIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgcGFyZW50S2V5LCBiYXNlS2V5LCBkZWJvdW5jZUlkKVxuICBpZiBwYXJlbnRLZXkgdGhlblxuICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KHBhcmVudEtleSlcbiAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KHBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgaWYgaGFyZCB0aGVuIC0tIHJlbW92ZSBwYXJlbnQgaW4gc2FtZSBxdWV1ZVxuICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KHBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5LCBuaWwpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIkRFTFwiLCBwYXJlbnRQcmVmaXggLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgcGFyZW50QXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiLCBcImRlaWRcIilcbiAgICBsb2NhbCBtaXNzZWRQYXJlbnRLZXkgPSBwYXJlbnRBdHRyaWJ1dGVzWzFdXG4gICAgaWYoICh0eXBlKG1pc3NlZFBhcmVudEtleSkgPT0gXCJzdHJpbmdcIikgYW5kIG1pc3NlZFBhcmVudEtleSB+PSBcIlwiXG4gICAgICBhbmQgKHJjYWxsKFwiRVhJU1RTXCIsIG1pc3NlZFBhcmVudEtleSkgPT0gMSkpIHRoZW5cbiAgICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IG1pc3NlZFBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KG1pc3NlZFBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgICAgaWYgaGFyZCB0aGVuXG4gICAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KG1pc3NlZFBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5LCBuaWwpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgICAgaWYgcGFyZW50QXR0cmlidXRlc1syXSB0aGVuXG4gICAgICAgICAgICAgICAgICByY2FsbChcIkRFTFwiLCBwYXJlbnRQcmVmaXggLi4gXCJkZTpcIiAuLiBwYXJlbnRBdHRyaWJ1dGVzWzJdKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2Ioam9iSWQsIGhhcmQsIGJhc2VLZXksIHNob3VsZFJlbW92ZURlZHVwbGljYXRpb25LZXkpXG4gIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4gam9iSWRcbiAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgaWYgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSB0aGVuXG4gICAgcmVtb3ZlRGVkdXBsaWNhdGlvbktleUlmTmVlZGVkT25SZW1vdmFsKGJhc2VLZXksIGpvYktleSwgam9iSWQpXG4gIGVuZFxuICByZW1vdmVKb2JLZXlzKGpvYktleSlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBzdG9yZSBhIGpvYiBzY2hlZHVsZXJcbl1dXG5sb2NhbCBmdW5jdGlvbiBzdG9yZUpvYlNjaGVkdWxlcihzY2hlZHVsZXJJZCwgc2NoZWR1bGVyS2V5LCByZXBlYXRLZXksIG5leHRNaWxsaXMsIG9wdHMsXG4gIHRlbXBsYXRlRGF0YSwgdGVtcGxhdGVPcHRzKVxuICByY2FsbChcIlpBRERcIiwgcmVwZWF0S2V5LCBuZXh0TWlsbGlzLCBzY2hlZHVsZXJJZClcbiAgbG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuICBpZiBvcHRzWyd0eiddIHRoZW5cbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwidHpcIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ3R6J10pXG4gIGVuZFxuICBpZiBvcHRzWydsaW1pdCddIHRoZW5cbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwibGltaXRcIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ2xpbWl0J10pXG4gIGVuZFxuICBpZiBvcHRzWydwYXR0ZXJuJ10gdGhlblxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXR0ZXJuXCIpXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBvcHRzWydwYXR0ZXJuJ10pXG4gIGVuZFxuICBpZiBvcHRzWydzdGFydERhdGUnXSB0aGVuXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInN0YXJ0RGF0ZVwiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgb3B0c1snc3RhcnREYXRlJ10pXG4gIGVuZFxuICBpZiBvcHRzWydlbmREYXRlJ10gdGhlblxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJlbmREYXRlXCIpXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBvcHRzWydlbmREYXRlJ10pXG4gIGVuZFxuICBpZiBvcHRzWydldmVyeSddIHRoZW5cbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwiZXZlcnlcIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ2V2ZXJ5J10pXG4gIGVuZFxuICBpZiBvcHRzWydvZmZzZXQnXSB0aGVuXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcIm9mZnNldFwiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgb3B0c1snb2Zmc2V0J10pXG4gIGVsc2VcbiAgICBsb2NhbCBvZmZzZXQgPSByY2FsbChcIkhHRVRcIiwgc2NoZWR1bGVyS2V5LCBcIm9mZnNldFwiKVxuICAgIGlmIG9mZnNldCB0aGVuXG4gICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwib2Zmc2V0XCIpXG4gICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIHRvbnVtYmVyKG9mZnNldCkpXG4gICAgZW5kXG4gIGVuZFxuICBsb2NhbCBqc29uVGVtcGxhdGVPcHRzID0gY2pzb24uZW5jb2RlKHRlbXBsYXRlT3B0cylcbiAgaWYganNvblRlbXBsYXRlT3B0cyBhbmQganNvblRlbXBsYXRlT3B0cyB+PSAne30nIHRoZW5cbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwib3B0c1wiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywganNvblRlbXBsYXRlT3B0cylcbiAgZW5kXG4gIGlmIHRlbXBsYXRlRGF0YSBhbmQgdGVtcGxhdGVEYXRhIH49ICd7fScgdGhlblxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJkYXRhXCIpXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCB0ZW1wbGF0ZURhdGEpXG4gIGVuZFxuICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwiaWNcIilcbiAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCByY2FsbChcIkhHRVRcIiwgc2NoZWR1bGVyS2V5LCBcImljXCIpIG9yIDEpXG4gIHJjYWxsKFwiREVMXCIsIHNjaGVkdWxlcktleSkgLS0gcmVtb3ZlIGFsbCBhdHRyaWJ1dGVzIGFuZCB0aGVuIHJlLWluc2VydCBuZXcgb25lc1xuICByY2FsbChcIkhNU0VUXCIsIHNjaGVkdWxlcktleSwgXCJuYW1lXCIsIG9wdHNbJ25hbWUnXSwgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gZ2V0Sm9iU2NoZWR1bGVyRXZlcnlOZXh0TWlsbGlzKHByZXZNaWxsaXMsIGV2ZXJ5LCBub3csIG9mZnNldCwgc3RhcnREYXRlKVxuICAgIGxvY2FsIG5leHRNaWxsaXNcbiAgICBpZiBub3QgcHJldk1pbGxpcyB0aGVuXG4gICAgICAgIGlmIHN0YXJ0RGF0ZSB0aGVuXG4gICAgICAgICAgICAtLSBBc3N1bWluZyBzdGFydERhdGUgaXMgcGFzc2VkIGFzIG1pbGxpc2Vjb25kcyBmcm9tIEphdmFTY3JpcHRcbiAgICAgICAgICAgIG5leHRNaWxsaXMgPSB0b251bWJlcihzdGFydERhdGUpXG4gICAgICAgICAgICBuZXh0TWlsbGlzID0gbmV4dE1pbGxpcyA+IG5vdyBhbmQgbmV4dE1pbGxpcyBvciBub3dcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmV4dE1pbGxpcyA9IG5vd1xuICAgICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAgIG5leHRNaWxsaXMgPSBwcmV2TWlsbGlzICsgZXZlcnlcbiAgICAgICAgLS0gY2hlY2sgaWYgd2UgbWF5IGhhdmUgbWlzc2VkIHNvbWUgaXRlcmF0aW9uc1xuICAgICAgICBpZiBuZXh0TWlsbGlzIDwgbm93IHRoZW5cbiAgICAgICAgICAgIG5leHRNaWxsaXMgPSBtYXRoLmZsb29yKG5vdyAvIGV2ZXJ5KSAqIGV2ZXJ5ICsgZXZlcnkgKyAob2Zmc2V0IG9yIDApXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIGlmIG5vdCBvZmZzZXQgb3Igb2Zmc2V0ID09IDAgdGhlblxuICAgICAgICBsb2NhbCB0aW1lU2xvdCA9IG1hdGguZmxvb3IobmV4dE1pbGxpcyAvIGV2ZXJ5KSAqIGV2ZXJ5O1xuICAgICAgICBvZmZzZXQgPSBuZXh0TWlsbGlzIC0gdGltZVNsb3Q7XG4gICAgZW5kXG4gICAgLS0gUmV0dXJuIGEgdHVwbGUgbmV4dE1pbGxpcywgb2Zmc2V0XG4gICAgcmV0dXJuIG1hdGguZmxvb3IobmV4dE1pbGxpcyksIG1hdGguZmxvb3Iob2Zmc2V0KVxuZW5kXG4tLSBJZiB3ZSBhcmUgb3ZlcnJpZGluZyBhIHJlcGVhdGFibGUgam9iIHdlIG11c3QgZGVsZXRlIHRoZSBkZWxheWVkIGpvYiBmb3Jcbi0tIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbmxvY2FsIHNjaGVkdWxlcktleSA9IHJlcGVhdEtleSAuLiBcIjpcIiAuLiBqb2JTY2hlZHVsZXJJZFxubG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbmxvY2FsIHRlbXBsYXRlRGF0YSA9IEFSR1ZbNF1cbmxvY2FsIHByZXZNaWxsaXMgPSByY2FsbChcIlpTQ09SRVwiLCByZXBlYXRLZXksIGpvYlNjaGVkdWxlcklkKVxuaWYgcHJldk1pbGxpcyB0aGVuXG4gICAgcHJldk1pbGxpcyA9IHRvbnVtYmVyKHByZXZNaWxsaXMpXG5lbmRcbmxvY2FsIHNjaGVkdWxlck9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVlsyXSlcbmxvY2FsIGV2ZXJ5ID0gc2NoZWR1bGVyT3B0c1snZXZlcnknXVxuLS0gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIGFsc28gY2hlY2sgdGhlIG9mZnNldCBmcm9tIHRoZSBqb2IgaXRzZWxmLlxuLS0gY291bGQgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMuXG5sb2NhbCBqb2JPZmZzZXQgPSBqb2JPcHRzWydyZXBlYXQnXSBhbmQgam9iT3B0c1sncmVwZWF0J11bJ29mZnNldCddIG9yIDBcbmxvY2FsIG9mZnNldCA9IHNjaGVkdWxlck9wdHNbJ29mZnNldCddIG9yIGpvYk9mZnNldCBvciAwXG5sb2NhbCBuZXdPZmZzZXQgPSBvZmZzZXRcbmlmIGV2ZXJ5IHRoZW5cbiAgICBsb2NhbCBzdGFydERhdGUgPSBzY2hlZHVsZXJPcHRzWydzdGFydERhdGUnXVxuICAgIG5leHRNaWxsaXMsIG5ld09mZnNldCA9IGdldEpvYlNjaGVkdWxlckV2ZXJ5TmV4dE1pbGxpcyhwcmV2TWlsbGlzLCBldmVyeSwgbm93LCBvZmZzZXQsIHN0YXJ0RGF0ZSlcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iRnJvbVNjaGVkdWxlcihwcmVmaXhLZXksIGRlbGF5ZWRLZXksIHByaW9yaXRpemVkS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXksIGpvYklkLFxuICAgIG1ldGFLZXksIGV2ZW50c0tleSlcbiAgICBpZiByY2FsbChcIlpTQ09SRVwiLCBkZWxheWVkS2V5LCBqb2JJZCkgdGhlblxuICAgICAgICByZW1vdmVKb2Ioam9iSWQsIHRydWUsIHByZWZpeEtleSwgdHJ1ZSAtLVtbcmVtb3ZlIGRlYm91bmNlIGtleV1dIClcbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIGpvYklkKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmlvcml0aXplZEtleSwgam9iSWQpIHRoZW5cbiAgICAgICAgcmVtb3ZlSm9iKGpvYklkLCB0cnVlLCBwcmVmaXhLZXksIHRydWUgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSApXG4gICAgICAgIHJjYWxsKFwiWlJFTVwiLCBwcmlvcml0aXplZEtleSwgam9iSWQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgICBsb2NhbCBwYXVzZWRPcldhaXRLZXkgPSB3YWl0S2V5XG4gICAgICAgIGlmIGlzUXVldWVQYXVzZWQobWV0YUtleSkgdGhlblxuICAgICAgICAgICAgcGF1c2VkT3JXYWl0S2V5ID0gcGF1c2VkS2V5XG4gICAgICAgIGVuZFxuICAgICAgICBpZiByY2FsbChcIkxSRU1cIiwgcGF1c2VkT3JXYWl0S2V5LCAxLCBqb2JJZCkgPiAwIHRoZW5cbiAgICAgICAgICAgIHJlbW92ZUpvYihqb2JJZCwgdHJ1ZSwgcHJlZml4S2V5LCB0cnVlIC0tW1tyZW1vdmUgZGVib3VuY2Uga2V5XV0gKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGhhZFByZXZKb2IgPSBmYWxzZVxuaWYgcHJldk1pbGxpcyB0aGVuICAgIFxuICAgIGxvY2FsIGN1cnJlbnRKb2JJZCA9IFwicmVwZWF0OlwiIC4uIGpvYlNjaGVkdWxlcklkIC4uIFwiOlwiIC4uIHByZXZNaWxsaXNcbiAgICBsb2NhbCBjdXJyZW50Sm9iS2V5ID0gc2NoZWR1bGVyS2V5IC4uIFwiOlwiIC4uIHByZXZNaWxsaXNcbiAgICAtLSBJbiB0aGVvcnkgaXQgc2hvdWxkIGFsd2F5cyBleGlzdCB0aGUgY3VycmVudEpvYktleSBpZiB0aGVyZSBpcyBhIHByZXZNaWxsaXMgdW5sZXNzIHNvbWV0aGluZyBoYXNcbiAgICAtLSBnb25lIHJlYWxseSB3cm9uZy5cbiAgICBpZiByY2FsbChcIkVYSVNUU1wiLCBjdXJyZW50Sm9iS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgaGFkUHJldkpvYiA9IHJlbW92ZUpvYkZyb21TY2hlZHVsZXIocHJlZml4S2V5LCBkZWxheWVkS2V5LCBwcmlvcml0aXplZEtleSwgd2FpdEtleSwgcGF1c2VkS2V5LFxuICAgICAgICAgICAgY3VycmVudEpvYklkLCBtZXRhS2V5LCBldmVudHNLZXkpXG4gICAgZW5kXG5lbmRcbmlmIGhhZFByZXZKb2IgdGhlblxuICAgIC0tIFRoZSBqb2JzIGhhcyBiZWVuIHJlbW92ZWQgYW5kIHdlIHdhbnQgdG8gcmVwbGFjZSBpdCwgc28gbGV0cyB1c2UgdGhlIHNhbWUgbWlsbGlzLlxuICAgIG5leHRNaWxsaXMgPSBwcmV2TWlsbGlzXG5lbHNlIFxuICAgIC0tIFNwZWNpYWwgY2FzZSB3aGVyZSBubyBqb2Igd2FzIHJlbW92ZWQsIGFuZCB3ZSBuZWVkIHRvIGFkZCB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgc2NoZWR1bGVyT3B0c1snb2Zmc2V0J10gPSBuZXdPZmZzZXRcbmVuZFxuLS0gQ2hlY2sgZm9yIGpvYiBJRCBjb2xsaXNpb24gd2l0aCBleGlzdGluZyBqb2JzIChpbiBhbnkgc3RhdGUpXG5sb2NhbCBqb2JJZCA9IFwicmVwZWF0OlwiIC4uIGpvYlNjaGVkdWxlcklkIC4uIFwiOlwiIC4uIG5leHRNaWxsaXNcbmxvY2FsIGpvYktleSA9IHByZWZpeEtleSAuLiBqb2JJZFxuLS0gSWYgdGhlcmUncyBhbHJlYWR5IGEgam9iIHdpdGggdGhpcyBJRCwgaGFuZGxlIHRoZSBjb2xsaXNpb25cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgPT0gMSB0aGVuXG4gICAgaWYgZXZlcnkgdGhlblxuICAgICAgICAtLSBGb3IgJ2V2ZXJ5JyBjYXNlOiB0cnkgbmV4dCB0aW1lIHNsb3QgdG8gYXZvaWQgY29sbGlzaW9uXG4gICAgICAgIGxvY2FsIG5leHRTbG90TWlsbGlzID0gbmV4dE1pbGxpcyArIGV2ZXJ5XG4gICAgICAgIGxvY2FsIG5leHRTbG90Sm9iSWQgPSBcInJlcGVhdDpcIiAuLiBqb2JTY2hlZHVsZXJJZCAuLiBcIjpcIiAuLiBuZXh0U2xvdE1pbGxpc1xuICAgICAgICBsb2NhbCBuZXh0U2xvdEpvYktleSA9IHByZWZpeEtleSAuLiBuZXh0U2xvdEpvYklkXG4gICAgICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIG5leHRTbG90Sm9iS2V5KSA9PSAwIHRoZW5cbiAgICAgICAgICAgIC0tIE5leHQgc2xvdCBpcyBmcmVlLCB1c2UgaXRcbiAgICAgICAgICAgIG5leHRNaWxsaXMgPSBuZXh0U2xvdE1pbGxpc1xuICAgICAgICAgICAgam9iSWQgPSBuZXh0U2xvdEpvYklkXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIE5leHQgc2xvdCBhbHNvIGhhcyBhIGpvYiwgcmV0dXJuIGVycm9yIGNvZGVcbiAgICAgICAgICAgIHJldHVybiAtMTEgLS0gU2NoZWR1bGVySm9iU2xvdHNCdXN5XG4gICAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICAgLS0gRm9yICdwYXR0ZXJuJyBjYXNlOiByZXR1cm4gZXJyb3IgY29kZVxuICAgICAgICByZXR1cm4gLTEwIC0tIFNjaGVkdWxlckpvYklkQ29sbGlzaW9uXG4gICAgZW5kXG5lbmRcbmxvY2FsIGRlbGF5ID0gbmV4dE1pbGxpcyAtIG5vd1xuLS0gRmFzdCBDbGFtcCBkZWxheSB0byBtaW5pbXVtIG9mIDBcbmlmIGRlbGF5IDwgMCB0aGVuXG4gICAgZGVsYXkgPSAwXG5lbmRcbmxvY2FsIG5leHRKb2JLZXkgPSBzY2hlZHVsZXJLZXkgLi4gXCI6XCIgLi4gbmV4dE1pbGxpc1xuLS0gam9iSWQgYWxyZWFkeSBjYWxjdWxhdGVkIGFib3ZlIGR1cmluZyBjb2xsaXNpb24gY2hlY2tcbnN0b3JlSm9iU2NoZWR1bGVyKGpvYlNjaGVkdWxlcklkLCBzY2hlZHVsZXJLZXksIHJlcGVhdEtleSwgbmV4dE1pbGxpcywgc2NoZWR1bGVyT3B0cywgdGVtcGxhdGVEYXRhLCB0ZW1wbGF0ZU9wdHMpXG5yY2FsbChcIklOQ1JcIiwgS0VZU1s4XSlcbmFkZEpvYkZyb21TY2hlZHVsZXIobmV4dEpvYktleSwgam9iSWQsIGpvYk9wdHMsIHdhaXRLZXksIHBhdXNlZEtleSxcbiAgICBLRVlTWzExXSwgbWV0YUtleSwgcHJpb3JpdGl6ZWRLZXksIEtFWVNbMTBdLCBkZWxheWVkS2V5LCBLRVlTWzddLCBldmVudHNLZXksXG4gICAgc2NoZWR1bGVyT3B0c1snbmFtZSddLCBtYXhFdmVudHMsIG5vdywgdGVtcGxhdGVEYXRhLCBqb2JTY2hlZHVsZXJJZCwgZGVsYXkpXG5pZiBBUkdWWzldIH49IFwiXCIgdGhlblxuICAgIHJjYWxsKFwiSFNFVFwiLCBBUkdWWzldLCBcIm5yamlkXCIsIGpvYklkKVxuZW5kXG5yZXR1cm4ge2pvYklkIC4uIFwiXCIsIGRlbGF5fVxuYDtcbmV4cG9ydCBjb25zdCBhZGRKb2JTY2hlZHVsZXIgPSB7XG4gICAgbmFtZTogJ2FkZEpvYlNjaGVkdWxlcicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRKb2JTY2hlZHVsZXItMTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addJobScheduler-11.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addLog-2.js":
/*!**********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addLog-2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addLog: () => (/* binding */ addLog)\n/* harmony export */ });\nconst content = `--[[\n  Add job log\n  Input:\n    KEYS[1] job id key\n    KEYS[2] job logs key\n    ARGV[1] id\n    ARGV[2] log\n    ARGV[3] keepLogs\n  Output:\n    -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n  local logCount = rcall(\"RPUSH\", KEYS[2], ARGV[2])\n  if ARGV[3] ~= '' then\n    local keepLogs = tonumber(ARGV[3])\n    rcall(\"LTRIM\", KEYS[2], -keepLogs, -1)\n    return math.min(keepLogs, logCount)\n  end\n  return logCount\nelse\n  return -1\nend\n`;\nconst addLog = {\n    name: 'addLog',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=addLog-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkTG9nLTIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkTG9nLTIuanM/NzVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQWRkIGpvYiBsb2dcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2IgaWQga2V5XG4gICAgS0VZU1syXSBqb2IgbG9ncyBrZXlcbiAgICBBUkdWWzFdIGlkXG4gICAgQVJHVlsyXSBsb2dcbiAgICBBUkdWWzNdIGtlZXBMb2dzXG4gIE91dHB1dDpcbiAgICAtMSAtIE1pc3Npbmcgam9iLlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuIC0tIC8vIE1ha2Ugc3VyZSBqb2IgZXhpc3RzXG4gIGxvY2FsIGxvZ0NvdW50ID0gcmNhbGwoXCJSUFVTSFwiLCBLRVlTWzJdLCBBUkdWWzJdKVxuICBpZiBBUkdWWzNdIH49ICcnIHRoZW5cbiAgICBsb2NhbCBrZWVwTG9ncyA9IHRvbnVtYmVyKEFSR1ZbM10pXG4gICAgcmNhbGwoXCJMVFJJTVwiLCBLRVlTWzJdLCAta2VlcExvZ3MsIC0xKVxuICAgIHJldHVybiBtYXRoLm1pbihrZWVwTG9ncywgbG9nQ291bnQpXG4gIGVuZFxuICByZXR1cm4gbG9nQ291bnRcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgYWRkTG9nID0ge1xuICAgIG5hbWU6ICdhZGRMb2cnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRMb2ctMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addLog-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-5.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addParentJob-5.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addParentJob: () => (/* binding */ addParentJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a parent job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - adds the job to the waiting-children zset\n    Input:\n      KEYS[1] 'meta'\n      KEYS[2] 'id'\n      KEYS[3] 'delayed'\n      KEYS[4] 'completed'\n      KEYS[5] events stream key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal metaKey = KEYS[1]\nlocal idKey = KEYS[2]\nlocal completedKey = KEYS[4]\nlocal eventsKey = KEYS[5]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal function removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents, currentDeduplicatedJobId,\n    jobId, deduplicationId, prefix)\n    if rcall(\"ZREM\", delayedKey, currentDeduplicatedJobId) > 0 then\n        removeJobKeys(prefix .. currentDeduplicatedJobId)\n        rcall(\"XADD\", eventsKey, \"*\", \"event\", \"removed\", \"jobId\", currentDeduplicatedJobId,\n            \"prev\", \"delayed\")\n        -- TODO remove debounced event in next breaking change\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n            jobId, \"debounceId\", deduplicationId)\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n            jobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", currentDeduplicatedJobId)\n        return true\n    end\n    return false\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts['id']\n    if deduplicationId then\n        local ttl = deduplicationOpts['ttl']\n        if deduplicationOpts['replace'] then\n            if ttl and ttl > 0 then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        if deduplicationOpts['extend'] then\n                            rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        else\n                            rcall('SET', deduplicationKey, jobId, 'KEEPTTL')\n                        end\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                    return\n                end\n            else\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        rcall('SET', deduplicationKey, jobId)\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId)\n                    return\n                end\n            end\n        else\n            local deduplicationKeyExists\n            if ttl and ttl > 0 then\n                if deduplicationOpts['extend'] then\n                    local currentDebounceJobId = rcall('GET', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall('SET', deduplicationKey, currentDebounceJobId, 'PX', ttl)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\",\n                            \"jobId\", currentDebounceJobId, \"debounceId\", deduplicationId)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                            currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'PX', ttl, 'NX')\n                end\n            else\n                deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'NX')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                -- TODO remove debounced event in next breaking change\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n                    currentDebounceJobId, \"debounceId\", deduplicationId)\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                    currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. \":wait\"\n    local parentPausedKey = parentQueueKey .. \":paused\"\n    local parentActiveKey = parentQueueKey .. \":active\"\n    local parentMetaKey = parentQueueKey .. \":meta\"\n    local parentMarkerKey = parentQueueKey .. \":marker\"\n    local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. \":delayed\"\n        rcall(\"ZADD\", parentDelayedKey, score, parentId)\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\", \"jobId\", parentId, \"delay\",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. \":prioritized\", priority, parentId,\n                parentQueueKey .. \":pc\", isPausedOrMaxed)\n        end\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\",\n            \"waiting-children\")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then    \n      rcall(\"ZREM\", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall(\"SCARD\", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts['de'], jobId, KEYS[3],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal waitChildrenKey = args[6]\nrcall(\"ZADD\", waitChildrenKey, timestamp, jobId)\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n      \"waiting-children\", \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addParentJob = {\n    name: 'addParentJob',\n    content,\n    keys: 5,\n};\n//# sourceMappingURL=addParentJob-5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUGFyZW50Sm9iLTUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGRQYXJlbnRKb2ItNS5qcz83NTNjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgcGFyZW50IGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIEluY3JlYXNlcyB0aGUgam9iIGNvdW50ZXIgaWYgbmVlZGVkLlxuICAgIC0gQ3JlYXRlcyBhIG5ldyBqb2Iga2V5IHdpdGggdGhlIGpvYiBkYXRhLlxuICAgIC0gYWRkcyB0aGUgam9iIHRvIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHpzZXRcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ21ldGEnXG4gICAgICBLRVlTWzJdICdpZCdcbiAgICAgIEtFWVNbM10gJ2RlbGF5ZWQnXG4gICAgICBLRVlTWzRdICdjb21wbGV0ZWQnXG4gICAgICBLRVlTWzVdIGV2ZW50cyBzdHJlYW0ga2V5XG4gICAgICBBUkdWWzFdIG1zZ3BhY2tlZCBhcmd1bWVudHMgYXJyYXlcbiAgICAgICAgICAgIFsxXSAga2V5IHByZWZpeCxcbiAgICAgICAgICAgIFsyXSAgY3VzdG9tIGlkICh3aWxsIG5vdCBnZW5lcmF0ZSBvbmUgYXV0b21hdGljYWxseSlcbiAgICAgICAgICAgIFszXSAgbmFtZVxuICAgICAgICAgICAgWzRdICB0aW1lc3RhbXBcbiAgICAgICAgICAgIFs1XSAgcGFyZW50S2V5P1xuICAgICAgICAgICAgWzZdICB3YWl0Q2hpbGRyZW5LZXkga2V5LlxuICAgICAgICAgICAgWzddICBwYXJlbnQgZGVwZW5kZW5jaWVzIGtleS5cbiAgICAgICAgICAgIFs4XSAgcGFyZW50PyB7aWQsIHF1ZXVlS2V5fVxuICAgICAgICAgICAgWzldICByZXBlYXQgam9iIGtleVxuICAgICAgICAgICAgWzEwXSBkZWR1cGxpY2F0aW9uIGtleVxuICAgICAgQVJHVlsyXSBKc29uIHN0cmluZ2lmaWVkIGpvYiBkYXRhXG4gICAgICBBUkdWWzNdIG1zZ3BhY2tlZCBvcHRpb25zXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIGpvYklkICAtIE9LXG4gICAgICAgIC01ICAgICAtIE1pc3NpbmcgcGFyZW50IGtleVxuXV1cbmxvY2FsIG1ldGFLZXkgPSBLRVlTWzFdXG5sb2NhbCBpZEtleSA9IEtFWVNbMl1cbmxvY2FsIGNvbXBsZXRlZEtleSA9IEtFWVNbNF1cbmxvY2FsIGV2ZW50c0tleSA9IEtFWVNbNV1cbmxvY2FsIGpvYklkXG5sb2NhbCBqb2JJZEtleVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBhcmdzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbMV0pXG5sb2NhbCBkYXRhID0gQVJHVlsyXVxubG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzNdKVxubG9jYWwgcGFyZW50S2V5ID0gYXJnc1s1XVxubG9jYWwgcGFyZW50ID0gYXJnc1s4XVxubG9jYWwgcmVwZWF0Sm9iS2V5ID0gYXJnc1s5XVxubG9jYWwgZGVkdXBsaWNhdGlvbktleSA9IGFyZ3NbMTBdXG5sb2NhbCBwYXJlbnREYXRhXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBkZWJvdW5jZSBhIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLCBqb2JLZXkgLi4gJzpkZXBlbmRlbmNpZXMnLFxuICAgIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcsIGpvYktleSAuLiAnOnVuc3VjY2Vzc2Z1bCcpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCxcbiAgICBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgaWYgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCkgPiAwIHRoZW5cbiAgICAgICAgcmVtb3ZlSm9iS2V5cyhwcmVmaXggLi4gY3VycmVudERlZHVwbGljYXRlZEpvYklkKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcInJlbW92ZWRcIiwgXCJqb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQsXG4gICAgICAgICAgICBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlYm91bmNlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICBqb2JJZCwgXCJkZWJvdW5jZUlkXCIsIGRlZHVwbGljYXRpb25JZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgam9iSWQsIFwiZGVkdXBsaWNhdGlvbklkXCIsIGRlZHVwbGljYXRpb25JZCwgXCJkZWR1cGxpY2F0ZWRKb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGRlZHVwbGljYXRlSm9iKGRlZHVwbGljYXRpb25PcHRzLCBqb2JJZCwgZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgcHJlZml4KVxuICAgIGxvY2FsIGRlZHVwbGljYXRpb25JZCA9IGRlZHVwbGljYXRpb25PcHRzIGFuZCBkZWR1cGxpY2F0aW9uT3B0c1snaWQnXVxuICAgIGlmIGRlZHVwbGljYXRpb25JZCB0aGVuXG4gICAgICAgIGxvY2FsIHR0bCA9IGRlZHVwbGljYXRpb25PcHRzWyd0dGwnXVxuICAgICAgICBpZiBkZWR1cGxpY2F0aW9uT3B0c1sncmVwbGFjZSddIHRoZW5cbiAgICAgICAgICAgIGlmIHR0bCBhbmQgdHRsID4gMCB0aGVuXG4gICAgICAgICAgICAgICAgbG9jYWwgY3VycmVudERlYm91bmNlSm9iSWQgPSByY2FsbCgnR0VUJywgZGVkdXBsaWNhdGlvbktleSlcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50RGVib3VuY2VKb2JJZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGlzUmVtb3ZlZCA9IHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgam9iSWQsIGRlZHVwbGljYXRpb25JZCwgcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICBpZiBpc1JlbW92ZWQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGVkdXBsaWNhdGlvbk9wdHNbJ2V4dGVuZCddIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdQWCcsIHR0bClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdLRUVQVFRMJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWwgaXNSZW1vdmVkID0gcmVtb3ZlRGVsYXllZEpvYihkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGlzUmVtb3ZlZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzXG4gICAgICAgICAgICBpZiB0dGwgYW5kIHR0bCA+IDAgdGhlblxuICAgICAgICAgICAgICAgIGlmIGRlZHVwbGljYXRpb25PcHRzWydleHRlbmQnXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1cnJlbnREZWJvdW5jZUpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBjdXJyZW50RGVib3VuY2VKb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWJvdW5jZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImpvYklkXCIsIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlYm91bmNlSWRcIiwgZGVkdXBsaWNhdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlZHVwbGljYXRpb25JZFwiLCBkZWR1cGxpY2F0aW9uSWQsIFwiZGVkdXBsaWNhdGVkSm9iSWRcIiwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERlYm91bmNlSm9iSWRcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnUFgnLCB0dGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzID0gbm90IHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsLCAnTlgnKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlZHVwbGljYXRpb25LZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnTlgnKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpZiBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzIHRoZW5cbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVib3VuY2VkXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlYm91bmNlSm9iSWQsIFwiZGVib3VuY2VJZFwiLCBkZWR1cGxpY2F0aW9uSWQpXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgXCJkZWR1cGxpY2F0aW9uSWRcIiwgZGVkdXBsaWNhdGlvbklkLCBcImRlZHVwbGljYXRlZEpvYklkXCIsIGpvYklkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVuIGpvYiBpcyBkdXBsaWNhdGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgcGFyZW50J3MgZGVwZW5kZW5jaWVzIGlmIHRoZSBqb2JcbiAgICBpcyBhbHJlYWR5IGNvbXBsZXRlZCBhbmQgYWJvdXQgdG8gYmUgaWdub3JlZC4gVGhlIHBhcmVudCBtdXN0IGdldCBpdHNcbiAgICBkZXBlbmRlbmNpZXMgdXBkYXRlZCB0byBhdm9pZCB0aGUgcGFyZW50IGpvYiBiZWluZyBzdHVjayBmb3JldmVyIGluIFxuICAgIHRoZSB3YWl0aW5nLWNoaWxkcmVuIHN0YXRlLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIG9yIGFkZCBkZXBlbmRlbmNpZXMgdG8gcGFyZW50LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIHBhcmVudCB0byBhIHdhaXQgc3RhdHVzICh3YWl0aW5nLCBkZWxheWVkIG9yIHByaW9yaXRpemVkKVxuICBpZiBubyBwZW5kaW5nIGRlcGVuZGVuY2llcy5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBwYXJlbnQgdG8gYSB3YWl0IHN0YXR1cyAod2FpdGluZywgZGVsYXllZCBvciBwcmlvcml0aXplZCkgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIE1vdmUgcGFyZW50IHRvIGEgd2FpdCBzdGF0dXMgKHdhaXQsIHByaW9yaXRpemVkIG9yIGRlbGF5ZWQpXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICByZXR1cm4gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG4gIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgLS0gUmVwbGFjZSB0aGUgc2NvcmUgb2YgdGhlIG1hcmtlciB3aXRoIHRoZSBuZXdlc3Qga25vd25cbiAgICAtLSBuZXh0IHRpbWVzdGFtcC5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgaWYgcXVldWUgaXMgcGF1c2VkIG9yIG1heGVkXG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkT3JNYXhlZChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gdHJ1ZVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIHJldHVybiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgbG9jYWwgcGFyZW50V2FpdEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRcIlxuICAgIGxvY2FsIHBhcmVudFBhdXNlZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBhdXNlZFwiXG4gICAgbG9jYWwgcGFyZW50QWN0aXZlS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6YWN0aXZlXCJcbiAgICBsb2NhbCBwYXJlbnRNZXRhS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWV0YVwiXG4gICAgbG9jYWwgcGFyZW50TWFya2VyS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWFya2VyXCJcbiAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1sxXSkgb3IgMFxuICAgIGxvY2FsIGRlbGF5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1syXSkgb3IgMFxuICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSB0b251bWJlcih0aW1lc3RhbXApICsgZGVsYXlcbiAgICAgICAgbG9jYWwgc2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHBhcmVudERlbGF5ZWRLZXksIHNjb3JlLCBwYXJlbnRJZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLFxuICAgICAgICAgICAgZGVsYXllZFRpbWVzdGFtcClcbiAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgZWxzZVxuICAgICAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudE1ldGFLZXksIHBhcmVudEFjdGl2ZUtleSxcbiAgICAgICAgICAgICAgICBwYXJlbnRXYWl0S2V5LCBwYXJlbnRQYXVzZWRLZXkpXG4gICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWRPck1heGVkLCBwYXJlbnRJZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9jYWwgaXNQYXVzZWRPck1heGVkID0gaXNRdWV1ZVBhdXNlZE9yTWF4ZWQocGFyZW50TWV0YUtleSwgcGFyZW50QWN0aXZlS2V5KVxuICAgICAgICAgICAgYWRkSm9iV2l0aFByaW9yaXR5KHBhcmVudE1hcmtlcktleSwgcGFyZW50UXVldWVLZXkgLi4gXCI6cHJpb3JpdGl6ZWRcIiwgcHJpb3JpdHksIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBjXCIsIGlzUGF1c2VkT3JNYXhlZClcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLFxuICAgICAgICAgICAgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBwYXJlbnRLZXkpID09IDEgdGhlblxuICAgIGxvY2FsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIlxuICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSwgcGFyZW50SWQpIHRoZW4gICAgXG4gICAgICByY2FsbChcIlpSRU1cIiwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5LCBwYXJlbnRJZClcbiAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksXG4gIHBhcmVudElkLCB0aW1lc3RhbXApXG4gIGxvY2FsIGRvTm90SGF2ZVBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSkgPT0gMFxuICBpZiBkb05vdEhhdmVQZW5kaW5nRGVwZW5kZW5jaWVzIHRoZW5cbiAgICBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gIHBhcmVudElkLCBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcCApXG4gIGxvY2FsIHByb2Nlc3NlZFNldCA9IHBhcmVudEtleSAuLiBcIjpwcm9jZXNzZWRcIlxuICByY2FsbChcIkhTRVRcIiwgcHJvY2Vzc2VkU2V0LCBqb2JJZEtleSwgcmV0dXJudmFsdWUpXG4gIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZUV4aXN0aW5nSm9ic1BhcmVudChwYXJlbnRLZXksIHBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgam9iSWQsIHRpbWVzdGFtcClcbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgaWYgcmNhbGwoXCJaU0NPUkVcIiwgY29tcGxldGVkS2V5LCBqb2JJZCkgdGhlblxuICAgICAgICAgICAgbG9jYWwgcmV0dXJudmFsdWUgPSByY2FsbChcIkhHRVRcIiwgam9iSWRLZXksIFwicmV0dXJudmFsdWVcIilcbiAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFsncXVldWVLZXknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudFsnaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwicGFyZW50S2V5XCIsIHBhcmVudEtleSwgXCJwYXJlbnRcIiwgcGFyZW50RGF0YSlcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gaGFuZGxlRHVwbGljYXRlZEpvYihqb2JLZXksIGpvYklkLCBjdXJyZW50UGFyZW50S2V5LCBjdXJyZW50UGFyZW50LFxuICBwYXJlbnREYXRhLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgbG9jYWwgZXhpc3RlZFBhcmVudEtleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIpXG4gIGlmIG5vdCBleGlzdGVkUGFyZW50S2V5IG9yIGV4aXN0ZWRQYXJlbnRLZXkgPT0gY3VycmVudFBhcmVudEtleSB0aGVuXG4gICAgdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgam9iS2V5LFxuICAgICAgam9iSWQsIHRpbWVzdGFtcClcbiAgZWxzZVxuICAgIGlmIGN1cnJlbnRQYXJlbnRLZXkgfj0gbmlsIGFuZCBjdXJyZW50UGFyZW50S2V5IH49IGV4aXN0ZWRQYXJlbnRLZXlcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgZXhpc3RlZFBhcmVudEtleSkgPT0gMSkgdGhlblxuICAgICAgcmV0dXJuIC03XG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLFxuICAgIFwiZHVwbGljYXRlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHN0b3JlIGEgam9iXG5dXVxubG9jYWwgZnVuY3Rpb24gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIG5hbWUsIGRhdGEsIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuICAgIGxvY2FsIGpzb25PcHRzID0gY2pzb24uZW5jb2RlKG9wdHMpXG4gICAgbG9jYWwgZGVsYXkgPSBvcHRzWydkZWxheSddIG9yIDBcbiAgICBsb2NhbCBwcmlvcml0eSA9IG9wdHNbJ3ByaW9yaXR5J10gb3IgMFxuICAgIGxvY2FsIGRlYm91bmNlSWQgPSBvcHRzWydkZSddIGFuZCBvcHRzWydkZSddWydpZCddXG4gICAgbG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50S2V5XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50S2V5KVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50RGF0YSlcbiAgICBlbmRcbiAgICBpZiByZXBlYXRKb2JLZXkgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicmprXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcmVwZWF0Sm9iS2V5KVxuICAgIGVuZFxuICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwiZGVpZFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIGRlYm91bmNlSWQpXG4gICAgZW5kXG4gICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJuYW1lXCIsIG5hbWUsIFwiZGF0YVwiLCBkYXRhLCBcIm9wdHNcIiwganNvbk9wdHMsXG4gICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgdGltZXN0YW1wLCBcImRlbGF5XCIsIGRlbGF5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5LFxuICAgICAgICAgIHVucGFjayhvcHRpb25hbFZhbHVlcykpXG4gICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhZGRlZFwiLCBcImpvYklkXCIsIGpvYklkLCBcIm5hbWVcIiwgbmFtZSlcbiAgICByZXR1cm4gZGVsYXksIHByaW9yaXR5XG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBpZEtleSlcbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksXG4gICAgICAgICAgICBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxubG9jYWwgZGVkdXBsaWNhdGlvbkpvYklkID0gZGVkdXBsaWNhdGVKb2Iob3B0c1snZGUnXSwgam9iSWQsIEtFWVNbM10sXG4gIGRlZHVwbGljYXRpb25LZXksIGV2ZW50c0tleSwgbWF4RXZlbnRzLCBhcmdzWzFdKVxuaWYgZGVkdXBsaWNhdGlvbkpvYklkIHRoZW5cbiAgcmV0dXJuIGRlZHVwbGljYXRpb25Kb2JJZFxuZW5kXG4tLSBTdG9yZSB0aGUgam9iLlxuc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIGFyZ3NbM10sIEFSR1ZbMl0sIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxubG9jYWwgd2FpdENoaWxkcmVuS2V5ID0gYXJnc1s2XVxucmNhbGwoXCJaQUREXCIsIHdhaXRDaGlsZHJlbktleSwgdGltZXN0YW1wLCBqb2JJZClcbnJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsXG4gICAgICBcIndhaXRpbmctY2hpbGRyZW5cIiwgXCJqb2JJZFwiLCBqb2JJZClcbi0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGEgY2hpbGQgb2YgYW5vdGhlciBqb2IsIGlmIHNvIGFkZCBpdCB0byB0aGUgcGFyZW50cyBkZXBlbmRlbmNpZXNcbmlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbmV4cG9ydCBjb25zdCBhZGRQYXJlbnRKb2IgPSB7XG4gICAgbmFtZTogJ2FkZFBhcmVudEpvYicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA1LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZFBhcmVudEpvYi01LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-9.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-9.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addPrioritizedJob: () => (/* binding */ addPrioritizedJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a priotitized job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'marker',\n      KEYS[2] 'meta'\n      KEYS[3] 'id'\n      KEYS[4] 'prioritized'\n      KEYS[5] 'delayed'\n      KEYS[6] 'completed'\n      KEYS[7] 'active'\n      KEYS[8] events stream key\n      KEYS[9] 'pc' priority counter\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]] \nlocal metaKey = KEYS[2]\nlocal idKey = KEYS[3]\nlocal priorityKey = KEYS[4]\nlocal completedKey = KEYS[6]\nlocal activeKey = KEYS[7]\nlocal eventsKey = KEYS[8]\nlocal priorityCounterKey = KEYS[9]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal function removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents, currentDeduplicatedJobId,\n    jobId, deduplicationId, prefix)\n    if rcall(\"ZREM\", delayedKey, currentDeduplicatedJobId) > 0 then\n        removeJobKeys(prefix .. currentDeduplicatedJobId)\n        rcall(\"XADD\", eventsKey, \"*\", \"event\", \"removed\", \"jobId\", currentDeduplicatedJobId,\n            \"prev\", \"delayed\")\n        -- TODO remove debounced event in next breaking change\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n            jobId, \"debounceId\", deduplicationId)\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n            jobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", currentDeduplicatedJobId)\n        return true\n    end\n    return false\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts['id']\n    if deduplicationId then\n        local ttl = deduplicationOpts['ttl']\n        if deduplicationOpts['replace'] then\n            if ttl and ttl > 0 then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        if deduplicationOpts['extend'] then\n                            rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        else\n                            rcall('SET', deduplicationKey, jobId, 'KEEPTTL')\n                        end\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                    return\n                end\n            else\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        rcall('SET', deduplicationKey, jobId)\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId)\n                    return\n                end\n            end\n        else\n            local deduplicationKeyExists\n            if ttl and ttl > 0 then\n                if deduplicationOpts['extend'] then\n                    local currentDebounceJobId = rcall('GET', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall('SET', deduplicationKey, currentDebounceJobId, 'PX', ttl)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\",\n                            \"jobId\", currentDebounceJobId, \"debounceId\", deduplicationId)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                            currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'PX', ttl, 'NX')\n                end\n            else\n                deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'NX')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                -- TODO remove debounced event in next breaking change\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n                    currentDebounceJobId, \"debounceId\", deduplicationId)\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                    currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. \":wait\"\n    local parentPausedKey = parentQueueKey .. \":paused\"\n    local parentActiveKey = parentQueueKey .. \":active\"\n    local parentMetaKey = parentQueueKey .. \":meta\"\n    local parentMarkerKey = parentQueueKey .. \":marker\"\n    local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. \":delayed\"\n        rcall(\"ZADD\", parentDelayedKey, score, parentId)\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\", \"jobId\", parentId, \"delay\",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. \":prioritized\", priority, parentId,\n                parentQueueKey .. \":pc\", isPausedOrMaxed)\n        end\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\",\n            \"waiting-children\")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then    \n      rcall(\"ZREM\", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall(\"SCARD\", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", idKey)\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, completedKey, eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts['de'], jobId, KEYS[5],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nlocal delay, priority = storeJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2],\n                                 opts, timestamp, parentKey, parentData,\n                                 repeatJobKey)\n-- Add the job to the prioritized set\nlocal isPausedOrMaxed = isQueuePausedOrMaxed(metaKey, activeKey)\naddJobWithPriority( KEYS[1], priorityKey, priority, jobId, priorityCounterKey, isPausedOrMaxed)\n-- Emit waiting event\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addPrioritizedJob = {\n    name: 'addPrioritizedJob',\n    content,\n    keys: 9,\n};\n//# sourceMappingURL=addPrioritizedJob-9.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUHJpb3JpdGl6ZWRKb2ItOS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUHJpb3JpdGl6ZWRKb2ItOS5qcz9lZjRiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgcHJpb3RpdGl6ZWQgam9iIHRvIHRoZSBxdWV1ZSBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICAgIC0gSW5jcmVhc2VzIHRoZSBqb2IgY291bnRlciBpZiBuZWVkZWQuXG4gICAgLSBDcmVhdGVzIGEgbmV3IGpvYiBrZXkgd2l0aCB0aGUgam9iIGRhdGEuXG4gICAgLSBBZGRzIHRoZSBqb2IgdG8gdGhlIFwiYWRkZWRcIiBsaXN0IHNvIHRoYXQgd29ya2VycyBnZXRzIG5vdGlmaWVkLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnbWFya2VyJyxcbiAgICAgIEtFWVNbMl0gJ21ldGEnXG4gICAgICBLRVlTWzNdICdpZCdcbiAgICAgIEtFWVNbNF0gJ3ByaW9yaXRpemVkJ1xuICAgICAgS0VZU1s1XSAnZGVsYXllZCdcbiAgICAgIEtFWVNbNl0gJ2NvbXBsZXRlZCdcbiAgICAgIEtFWVNbN10gJ2FjdGl2ZSdcbiAgICAgIEtFWVNbOF0gZXZlbnRzIHN0cmVhbSBrZXlcbiAgICAgIEtFWVNbOV0gJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgICBBUkdWWzFdIG1zZ3BhY2tlZCBhcmd1bWVudHMgYXJyYXlcbiAgICAgICAgICAgIFsxXSAga2V5IHByZWZpeCxcbiAgICAgICAgICAgIFsyXSAgY3VzdG9tIGlkICh3aWxsIG5vdCBnZW5lcmF0ZSBvbmUgYXV0b21hdGljYWxseSlcbiAgICAgICAgICAgIFszXSAgbmFtZVxuICAgICAgICAgICAgWzRdICB0aW1lc3RhbXBcbiAgICAgICAgICAgIFs1XSAgcGFyZW50S2V5P1xuICAgICAgICAgICAgWzZdICB3YWl0Q2hpbGRyZW5LZXkga2V5LlxuICAgICAgICAgICAgWzddICBwYXJlbnQgZGVwZW5kZW5jaWVzIGtleS5cbiAgICAgICAgICAgIFs4XSAgcGFyZW50PyB7aWQsIHF1ZXVlS2V5fVxuICAgICAgICAgICAgWzldICByZXBlYXQgam9iIGtleVxuICAgICAgICAgICAgWzEwXSBkZWR1cGxpY2F0aW9uIGtleVxuICAgICAgQVJHVlsyXSBKc29uIHN0cmluZ2lmaWVkIGpvYiBkYXRhXG4gICAgICBBUkdWWzNdIG1zZ3BhY2tlZCBvcHRpb25zXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIGpvYklkICAtIE9LXG4gICAgICAgIC01ICAgICAtIE1pc3NpbmcgcGFyZW50IGtleVxuXV0gXG5sb2NhbCBtZXRhS2V5ID0gS0VZU1syXVxubG9jYWwgaWRLZXkgPSBLRVlTWzNdXG5sb2NhbCBwcmlvcml0eUtleSA9IEtFWVNbNF1cbmxvY2FsIGNvbXBsZXRlZEtleSA9IEtFWVNbNl1cbmxvY2FsIGFjdGl2ZUtleSA9IEtFWVNbN11cbmxvY2FsIGV2ZW50c0tleSA9IEtFWVNbOF1cbmxvY2FsIHByaW9yaXR5Q291bnRlcktleSA9IEtFWVNbOV1cbmxvY2FsIGpvYklkXG5sb2NhbCBqb2JJZEtleVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBhcmdzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbMV0pXG5sb2NhbCBkYXRhID0gQVJHVlsyXVxubG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzNdKVxubG9jYWwgcGFyZW50S2V5ID0gYXJnc1s1XVxubG9jYWwgcGFyZW50ID0gYXJnc1s4XVxubG9jYWwgcmVwZWF0Sm9iS2V5ID0gYXJnc1s5XVxubG9jYWwgZGVkdXBsaWNhdGlvbktleSA9IGFyZ3NbMTBdXG5sb2NhbCBwYXJlbnREYXRhXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbiAgaWYgbm90IGlzUGF1c2VkT3JNYXhlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IHByaW9yaXR5IHNjb3JlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFByaW9yaXR5U2NvcmUocHJpb3JpdHksIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByZXR1cm4gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIHByaW9Db3VudGVyICUgMHgxMDAwMDAwMDBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LFxuICBpc1BhdXNlZE9yTWF4ZWQpXG4gIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdGl6ZWRLZXksIHNjb3JlLCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGRlYm91bmNlIGEgam9iLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlRGVsYXllZEpvYihkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cywgY3VycmVudERlZHVwbGljYXRlZEpvYklkLFxuICAgIGpvYklkLCBkZWR1cGxpY2F0aW9uSWQsIHByZWZpeClcbiAgICBpZiByY2FsbChcIlpSRU1cIiwgZGVsYXllZEtleSwgY3VycmVudERlZHVwbGljYXRlZEpvYklkKSA+IDAgdGhlblxuICAgICAgICByZW1vdmVKb2JLZXlzKHByZWZpeCAuLiBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQpXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLCBcImpvYklkXCIsIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCxcbiAgICAgICAgICAgIFwicHJldlwiLCBcImRlbGF5ZWRcIilcbiAgICAgICAgLS0gVE9ETyByZW1vdmUgZGVib3VuY2VkIGV2ZW50IGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVib3VuY2VkXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgIGpvYklkLCBcImRlYm91bmNlSWRcIiwgZGVkdXBsaWNhdGlvbklkKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlZHVwbGljYXRlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICBqb2JJZCwgXCJkZWR1cGxpY2F0aW9uSWRcIiwgZGVkdXBsaWNhdGlvbklkLCBcImRlZHVwbGljYXRlZEpvYklkXCIsIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICBlbmRcbiAgICByZXR1cm4gZmFsc2VcbmVuZFxubG9jYWwgZnVuY3Rpb24gZGVkdXBsaWNhdGVKb2IoZGVkdXBsaWNhdGlvbk9wdHMsIGpvYklkLCBkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cyxcbiAgICBwcmVmaXgpXG4gICAgbG9jYWwgZGVkdXBsaWNhdGlvbklkID0gZGVkdXBsaWNhdGlvbk9wdHMgYW5kIGRlZHVwbGljYXRpb25PcHRzWydpZCddXG4gICAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICAgICAgbG9jYWwgdHRsID0gZGVkdXBsaWNhdGlvbk9wdHNbJ3R0bCddXG4gICAgICAgIGlmIGRlZHVwbGljYXRpb25PcHRzWydyZXBsYWNlJ10gdGhlblxuICAgICAgICAgICAgaWYgdHRsIGFuZCB0dGwgPiAwIHRoZW5cbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWwgaXNSZW1vdmVkID0gcmVtb3ZlRGVsYXllZEpvYihkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGlzUmVtb3ZlZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBkZWR1cGxpY2F0aW9uT3B0c1snZXh0ZW5kJ10gdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ0tFRVBUVEwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnUFgnLCB0dGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIGN1cnJlbnREZWJvdW5jZUpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudERlYm91bmNlSm9iSWQgdGhlblxuICAgICAgICAgICAgICAgICAgICBsb2NhbCBpc1JlbW92ZWQgPSByZW1vdmVEZWxheWVkSm9iKGRlbGF5ZWRLZXksIGRlZHVwbGljYXRpb25LZXksIGV2ZW50c0tleSwgbWF4RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERlYm91bmNlSm9iSWQsIGpvYklkLCBkZWR1cGxpY2F0aW9uSWQsIHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgaWYgaXNSZW1vdmVkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERlYm91bmNlSm9iSWRcbiAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvY2FsIGRlZHVwbGljYXRpb25LZXlFeGlzdHNcbiAgICAgICAgICAgIGlmIHR0bCBhbmQgdHRsID4gMCB0aGVuXG4gICAgICAgICAgICAgICAgaWYgZGVkdXBsaWNhdGlvbk9wdHNbJ2V4dGVuZCddIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWwgY3VycmVudERlYm91bmNlSm9iSWQgPSByY2FsbCgnR0VUJywgZGVkdXBsaWNhdGlvbktleSlcbiAgICAgICAgICAgICAgICAgICAgaWYgY3VycmVudERlYm91bmNlSm9iSWQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGN1cnJlbnREZWJvdW5jZUpvYklkLCAnUFgnLCB0dGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlYm91bmNlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiam9iSWRcIiwgY3VycmVudERlYm91bmNlSm9iSWQsIFwiZGVib3VuY2VJZFwiLCBkZWR1cGxpY2F0aW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlZHVwbGljYXRlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERlYm91bmNlSm9iSWQsIFwiZGVkdXBsaWNhdGlvbklkXCIsIGRlZHVwbGljYXRpb25JZCwgXCJkZWR1cGxpY2F0ZWRKb2JJZFwiLCBqb2JJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdQWCcsIHR0bClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRlZHVwbGljYXRpb25LZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnUFgnLCB0dGwsICdOWCcpXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVkdXBsaWNhdGlvbktleUV4aXN0cyA9IG5vdCByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdOWCcpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGlmIGRlZHVwbGljYXRpb25LZXlFeGlzdHMgdGhlblxuICAgICAgICAgICAgICAgIGxvY2FsIGN1cnJlbnREZWJvdW5jZUpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgLS0gVE9ETyByZW1vdmUgZGVib3VuY2VkIGV2ZW50IGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWJvdW5jZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgXCJkZWJvdW5jZUlkXCIsIGRlZHVwbGljYXRpb25JZClcbiAgICAgICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlZHVwbGljYXRlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlZHVwbGljYXRpb25JZFwiLCBkZWR1cGxpY2F0aW9uSWQsIFwiZGVkdXBsaWNhdGVkSm9iSWRcIiwgam9iSWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gc3RvcmUgYSBqb2Jcbl1dXG5sb2NhbCBmdW5jdGlvbiBzdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgbmFtZSwgZGF0YSwgb3B0cywgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhLCByZXBlYXRKb2JLZXkpXG4gICAgbG9jYWwganNvbk9wdHMgPSBjanNvbi5lbmNvZGUob3B0cylcbiAgICBsb2NhbCBkZWxheSA9IG9wdHNbJ2RlbGF5J10gb3IgMFxuICAgIGxvY2FsIHByaW9yaXR5ID0gb3B0c1sncHJpb3JpdHknXSBvciAwXG4gICAgbG9jYWwgZGVib3VuY2VJZCA9IG9wdHNbJ2RlJ10gYW5kIG9wdHNbJ2RlJ11bJ2lkJ11cbiAgICBsb2NhbCBvcHRpb25hbFZhbHVlcyA9IHt9XG4gICAgaWYgcGFyZW50S2V5IH49IG5pbCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRLZXlcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnRLZXkpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnREYXRhKVxuICAgIGVuZFxuICAgIGlmIHJlcGVhdEpvYktleSB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJyamtcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCByZXBlYXRKb2JLZXkpXG4gICAgZW5kXG4gICAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJkZWlkXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgZGVib3VuY2VJZClcbiAgICBlbmRcbiAgICByY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcIm5hbWVcIiwgbmFtZSwgXCJkYXRhXCIsIGRhdGEsIFwib3B0c1wiLCBqc29uT3B0cyxcbiAgICAgICAgICBcInRpbWVzdGFtcFwiLCB0aW1lc3RhbXAsIFwiZGVsYXlcIiwgZGVsYXksIFwicHJpb3JpdHlcIiwgcHJpb3JpdHksXG4gICAgICAgICAgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbiAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcImFkZGVkXCIsIFwiam9iSWRcIiwgam9iSWQsIFwibmFtZVwiLCBuYW1lKVxuICAgIHJldHVybiBkZWxheSwgcHJpb3JpdHlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlbiBqb2IgaXMgZHVwbGljYXRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICAgIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1cGRhdGUgdGhlIHBhcmVudCdzIGRlcGVuZGVuY2llcyBpZiB0aGUgam9iXG4gICAgaXMgYWxyZWFkeSBjb21wbGV0ZWQgYW5kIGFib3V0IHRvIGJlIGlnbm9yZWQuIFRoZSBwYXJlbnQgbXVzdCBnZXQgaXRzXG4gICAgZGVwZW5kZW5jaWVzIHVwZGF0ZWQgdG8gYXZvaWQgdGhlIHBhcmVudCBqb2IgYmVpbmcgc3R1Y2sgZm9yZXZlciBpbiBcbiAgICB0aGUgd2FpdGluZy1jaGlsZHJlbiBzdGF0ZS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBvciBhZGQgZGVwZW5kZW5jaWVzIHRvIHBhcmVudC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBWYWxpZGF0ZSBhbmQgbW92ZSBwYXJlbnQgdG8gYSB3YWl0IHN0YXR1cyAod2FpdGluZywgZGVsYXllZCBvciBwcmlvcml0aXplZClcbiAgaWYgbm8gcGVuZGluZyBkZXBlbmRlbmNpZXMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGEgd2FpdCBzdGF0dXMgKHdhaXRpbmcsIGRlbGF5ZWQgb3IgcHJpb3JpdGl6ZWQpIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBNb3ZlIHBhcmVudCB0byBhIHdhaXQgc3RhdHVzICh3YWl0LCBwcmlvcml0aXplZCBvciBkZWxheWVkKVxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbmV4dCBkZWxheWVkIGpvYiB0aW1lc3RhbXAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkFOR0VcIiwgZGVsYXllZEtleSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgcmV0dXJuIG5leHRUaW1lc3RhbXAgLyAweDEwMDBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgLS0gbmV4dCB0aW1lc3RhbXAuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBpZiBxdWV1ZSBpcyBwYXVzZWQgb3IgbWF4ZWRcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzUXVldWVQYXVzZWRPck1heGVkKHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiB0cnVlXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgcmV0dXJuIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSlcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIsIFwibWF4XCIsIFwiZHVyYXRpb25cIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIGlmIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSkgdGhlblxuICAgICAgICByZXR1cm4gd2FpdEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgICBsb2NhbCBwYXJlbnRXYWl0S2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdFwiXG4gICAgbG9jYWwgcGFyZW50UGF1c2VkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6cGF1c2VkXCJcbiAgICBsb2NhbCBwYXJlbnRBY3RpdmVLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjphY3RpdmVcIlxuICAgIGxvY2FsIHBhcmVudE1ldGFLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptZXRhXCJcbiAgICBsb2NhbCBwYXJlbnRNYXJrZXJLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjptYXJrZXJcIlxuICAgIGxvY2FsIGpvYkF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHBhcmVudEtleSwgXCJwcmlvcml0eVwiLCBcImRlbGF5XCIpXG4gICAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzFdKSBvciAwXG4gICAgbG9jYWwgZGVsYXkgPSB0b251bWJlcihqb2JBdHRyaWJ1dGVzWzJdKSBvciAwXG4gICAgaWYgZGVsYXkgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgZGVsYXllZFRpbWVzdGFtcCA9IHRvbnVtYmVyKHRpbWVzdGFtcCkgKyBkZWxheVxuICAgICAgICBsb2NhbCBzY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgICAgICAgbG9jYWwgcGFyZW50RGVsYXllZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOmRlbGF5ZWRcIlxuICAgICAgICByY2FsbChcIlpBRERcIiwgcGFyZW50RGVsYXllZEtleSwgc2NvcmUsIHBhcmVudElkKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVsYXllZFwiLCBcImpvYklkXCIsIHBhcmVudElkLCBcImRlbGF5XCIsXG4gICAgICAgICAgICBkZWxheWVkVGltZXN0YW1wKVxuICAgICAgICBhZGREZWxheU1hcmtlcklmTmVlZGVkKHBhcmVudE1hcmtlcktleSwgcGFyZW50RGVsYXllZEtleSlcbiAgICBlbHNlXG4gICAgICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgICAgICAgbG9jYWwgcGFyZW50VGFyZ2V0LCBpc1BhcmVudFBhdXNlZE9yTWF4ZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50TWV0YUtleSwgcGFyZW50QWN0aXZlS2V5LFxuICAgICAgICAgICAgICAgIHBhcmVudFdhaXRLZXksIHBhcmVudFBhdXNlZEtleSlcbiAgICAgICAgICAgIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudE1hcmtlcktleSwgXCJSUFVTSFwiLCBpc1BhcmVudFBhdXNlZE9yTWF4ZWQsIHBhcmVudElkKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBpc1BhdXNlZE9yTWF4ZWQgPSBpc1F1ZXVlUGF1c2VkT3JNYXhlZChwYXJlbnRNZXRhS2V5LCBwYXJlbnRBY3RpdmVLZXkpXG4gICAgICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkocGFyZW50TWFya2VyS2V5LCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwcmlvcml0aXplZFwiLCBwcmlvcml0eSwgcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgcGFyZW50UXVldWVLZXkgLi4gXCI6cGNcIiwgaXNQYXVzZWRPck1heGVkKVxuICAgICAgICBlbmRcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJwcmV2XCIsXG4gICAgICAgICAgICBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgPT0gMSB0aGVuXG4gICAgbG9jYWwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdGluZy1jaGlsZHJlblwiXG4gICAgaWYgcmNhbGwoXCJaU0NPUkVcIiwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5LCBwYXJlbnRJZCkgdGhlbiAgICBcbiAgICAgIHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRXYWl0aW5nQ2hpbGRyZW5LZXksIHBhcmVudElkKVxuICAgICAgbW92ZVBhcmVudFRvV2FpdChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICAgIGVuZFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdElmTm9QZW5kaW5nRGVwZW5kZW5jaWVzKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudEtleSxcbiAgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgbG9jYWwgZG9Ob3RIYXZlUGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KSA9PSAwXG4gIGlmIGRvTm90SGF2ZVBlbmRpbmdEZXBlbmRlbmNpZXMgdGhlblxuICAgIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gdXBkYXRlUGFyZW50RGVwc0lmTmVlZGVkKHBhcmVudEtleSwgcGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSxcbiAgcGFyZW50SWQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSwgdGltZXN0YW1wIClcbiAgbG9jYWwgcHJvY2Vzc2VkU2V0ID0gcGFyZW50S2V5IC4uIFwiOnByb2Nlc3NlZFwiXG4gIHJjYWxsKFwiSFNFVFwiLCBwcm9jZXNzZWRTZXQsIGpvYklkS2V5LCByZXR1cm52YWx1ZSlcbiAgbW92ZVBhcmVudFRvV2FpdElmTm9QZW5kaW5nRGVwZW5kZW5jaWVzKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbmVuZFxubG9jYWwgZnVuY3Rpb24gdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KHBhcmVudEtleSwgcGFyZW50LCBwYXJlbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYklkS2V5LCBqb2JJZCwgdGltZXN0YW1wKVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICBpZiByY2FsbChcIlpTQ09SRVwiLCBjb21wbGV0ZWRLZXksIGpvYklkKSB0aGVuXG4gICAgICAgICAgICBsb2NhbCByZXR1cm52YWx1ZSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JJZEtleSwgXCJyZXR1cm52YWx1ZVwiKVxuICAgICAgICAgICAgdXBkYXRlUGFyZW50RGVwc0lmTmVlZGVkKHBhcmVudEtleSwgcGFyZW50WydxdWV1ZUtleSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50WydpZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYklkS2V5LCByZXR1cm52YWx1ZSwgdGltZXN0YW1wKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBwYXJlbnREZXBlbmRlbmNpZXNLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIlNBRERcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JJZEtleSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJwYXJlbnRLZXlcIiwgcGFyZW50S2V5LCBcInBhcmVudFwiLCBwYXJlbnREYXRhKVxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBoYW5kbGVEdXBsaWNhdGVkSm9iKGpvYktleSwgam9iSWQsIGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsXG4gIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksIG1heEV2ZW50cywgdGltZXN0YW1wKVxuICBsb2NhbCBleGlzdGVkUGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgaWYgbm90IGV4aXN0ZWRQYXJlbnRLZXkgb3IgZXhpc3RlZFBhcmVudEtleSA9PSBjdXJyZW50UGFyZW50S2V5IHRoZW5cbiAgICB1cGRhdGVFeGlzdGluZ0pvYnNQYXJlbnQoY3VycmVudFBhcmVudEtleSwgY3VycmVudFBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBqb2JLZXksXG4gICAgICBqb2JJZCwgdGltZXN0YW1wKVxuICBlbHNlXG4gICAgaWYgY3VycmVudFBhcmVudEtleSB+PSBuaWwgYW5kIGN1cnJlbnRQYXJlbnRLZXkgfj0gZXhpc3RlZFBhcmVudEtleVxuICAgICAgYW5kIChyY2FsbChcIkVYSVNUU1wiLCBleGlzdGVkUGFyZW50S2V5KSA9PSAxKSB0aGVuXG4gICAgICByZXR1cm4gLTdcbiAgICBlbmRcbiAgZW5kXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsXG4gICAgXCJkdXBsaWNhdGVkXCIsIFwiam9iSWRcIiwgam9iSWQpXG4gIHJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBpZEtleSlcbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgY29tcGxldGVkS2V5LCBldmVudHNLZXksXG4gICAgICAgICAgICBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxubG9jYWwgZGVkdXBsaWNhdGlvbkpvYklkID0gZGVkdXBsaWNhdGVKb2Iob3B0c1snZGUnXSwgam9iSWQsIEtFWVNbNV0sXG4gIGRlZHVwbGljYXRpb25LZXksIGV2ZW50c0tleSwgbWF4RXZlbnRzLCBhcmdzWzFdKVxuaWYgZGVkdXBsaWNhdGlvbkpvYklkIHRoZW5cbiAgcmV0dXJuIGRlZHVwbGljYXRpb25Kb2JJZFxuZW5kXG4tLSBTdG9yZSB0aGUgam9iLlxubG9jYWwgZGVsYXksIHByaW9yaXR5ID0gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIGFyZ3NbM10sIEFSR1ZbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLCB0aW1lc3RhbXAsIHBhcmVudEtleSwgcGFyZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdEpvYktleSlcbi0tIEFkZCB0aGUgam9iIHRvIHRoZSBwcmlvcml0aXplZCBzZXRcbmxvY2FsIGlzUGF1c2VkT3JNYXhlZCA9IGlzUXVldWVQYXVzZWRPck1heGVkKG1ldGFLZXksIGFjdGl2ZUtleSlcbmFkZEpvYldpdGhQcmlvcml0eSggS0VZU1sxXSwgcHJpb3JpdHlLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4tLSBFbWl0IHdhaXRpbmcgZXZlbnRcbnJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgXCJqb2JJZFwiLCBqb2JJZClcbi0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGEgY2hpbGQgb2YgYW5vdGhlciBqb2IsIGlmIHNvIGFkZCBpdCB0byB0aGUgcGFyZW50cyBkZXBlbmRlbmNpZXNcbmlmIHBhcmVudERlcGVuZGVuY2llc0tleSB+PSBuaWwgdGhlblxuICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYklkS2V5KVxuZW5kXG5yZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuYDtcbmV4cG9ydCBjb25zdCBhZGRQcmlvcml0aXplZEpvYiA9IHtcbiAgICBuYW1lOiAnYWRkUHJpb3JpdGl6ZWRKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogOSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRQcmlvcml0aXplZEpvYi05LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addRepeatableJob-2.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addRepeatableJob-2.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRepeatableJob: () => (/* binding */ addRepeatableJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a repeatable job\n    Input:\n      KEYS[1] 'repeat' key\n      KEYS[2] 'delayed' key\n      ARGV[1] next milliseconds\n      ARGV[2] msgpacked options\n            [1]  name\n            [2]  tz?\n            [3]  pattern?\n            [4]  endDate?\n            [5]  every?\n      ARGV[3] legacy custom key TODO: remove this logic in next breaking change\n      ARGV[4] custom key\n      ARGV[5] prefix key\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal nextMillis = ARGV[1]\nlocal legacyCustomKey = ARGV[3]\nlocal customKey = ARGV[4]\nlocal prefixKey = ARGV[5]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function storeRepeatableJob(repeatKey, customKey, nextMillis, rawOpts)\n  rcall(\"ZADD\", repeatKey, nextMillis, customKey)\n  local opts = cmsgpack.unpack(rawOpts)\n  local optionalValues = {}\n  if opts['tz'] then\n    table.insert(optionalValues, \"tz\")\n    table.insert(optionalValues, opts['tz'])\n  end\n  if opts['pattern'] then\n    table.insert(optionalValues, \"pattern\")\n    table.insert(optionalValues, opts['pattern'])\n  end\n  if opts['endDate'] then\n    table.insert(optionalValues, \"endDate\")\n    table.insert(optionalValues, opts['endDate'])\n  end\n  if opts['every'] then\n    table.insert(optionalValues, \"every\")\n    table.insert(optionalValues, opts['every'])\n  end\n  rcall(\"HMSET\", repeatKey .. \":\" .. customKey, \"name\", opts['name'],\n    unpack(optionalValues))\n  return customKey\nend\n-- If we are overriding a repeatable job we must delete the delayed job for\n-- the next iteration.\nlocal prevMillis = rcall(\"ZSCORE\", repeatKey, customKey)\nif prevMillis then\n  local delayedJobId =  \"repeat:\" .. customKey .. \":\" .. prevMillis\n  local nextDelayedJobId =  repeatKey .. \":\" .. customKey .. \":\" .. nextMillis\n  if rcall(\"ZSCORE\", delayedKey, delayedJobId)\n   and rcall(\"EXISTS\", nextDelayedJobId) ~= 1 then\n    removeJob(delayedJobId, true, prefixKey, true --[[remove debounce key]])\n    rcall(\"ZREM\", delayedKey, delayedJobId)\n  end\nend\n-- Keep backwards compatibility with old repeatable jobs (<= 3.0.0)\nif rcall(\"ZSCORE\", repeatKey, legacyCustomKey) ~= false then\n  return storeRepeatableJob(repeatKey, legacyCustomKey, nextMillis, ARGV[2])\nend\nreturn storeRepeatableJob(repeatKey, customKey, nextMillis, ARGV[2])\n`;\nconst addRepeatableJob = {\n    name: 'addRepeatableJob',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=addRepeatableJob-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUmVwZWF0YWJsZUpvYi0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkUmVwZWF0YWJsZUpvYi0yLmpzP2JhMmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEFkZHMgYSByZXBlYXRhYmxlIGpvYlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAncmVwZWF0JyBrZXlcbiAgICAgIEtFWVNbMl0gJ2RlbGF5ZWQnIGtleVxuICAgICAgQVJHVlsxXSBuZXh0IG1pbGxpc2Vjb25kc1xuICAgICAgQVJHVlsyXSBtc2dwYWNrZWQgb3B0aW9uc1xuICAgICAgICAgICAgWzFdICBuYW1lXG4gICAgICAgICAgICBbMl0gIHR6P1xuICAgICAgICAgICAgWzNdICBwYXR0ZXJuP1xuICAgICAgICAgICAgWzRdICBlbmREYXRlP1xuICAgICAgICAgICAgWzVdICBldmVyeT9cbiAgICAgIEFSR1ZbM10gbGVnYWN5IGN1c3RvbSBrZXkgVE9ETzogcmVtb3ZlIHRoaXMgbG9naWMgaW4gbmV4dCBicmVha2luZyBjaGFuZ2VcbiAgICAgIEFSR1ZbNF0gY3VzdG9tIGtleVxuICAgICAgQVJHVls1XSBwcmVmaXgga2V5XG4gICAgICBPdXRwdXQ6XG4gICAgICAgIHJlcGVhdGFibGVLZXkgIC0gT0tcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlcGVhdEtleSA9IEtFWVNbMV1cbmxvY2FsIGRlbGF5ZWRLZXkgPSBLRVlTWzJdXG5sb2NhbCBuZXh0TWlsbGlzID0gQVJHVlsxXVxubG9jYWwgbGVnYWN5Q3VzdG9tS2V5ID0gQVJHVlszXVxubG9jYWwgY3VzdG9tS2V5ID0gQVJHVls0XVxubG9jYWwgcHJlZml4S2V5ID0gQVJHVls1XVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSwgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICBpZiBzaG91bGRSZW1vdmVEZWR1cGxpY2F0aW9uS2V5IHRoZW5cbiAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwoYmFzZUtleSwgam9iS2V5LCBqb2JJZClcbiAgZW5kXG4gIHJlbW92ZUpvYktleXMoam9iS2V5KVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBzdG9yZVJlcGVhdGFibGVKb2IocmVwZWF0S2V5LCBjdXN0b21LZXksIG5leHRNaWxsaXMsIHJhd09wdHMpXG4gIHJjYWxsKFwiWkFERFwiLCByZXBlYXRLZXksIG5leHRNaWxsaXMsIGN1c3RvbUtleSlcbiAgbG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhyYXdPcHRzKVxuICBsb2NhbCBvcHRpb25hbFZhbHVlcyA9IHt9XG4gIGlmIG9wdHNbJ3R6J10gdGhlblxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJ0elwiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgb3B0c1sndHonXSlcbiAgZW5kXG4gIGlmIG9wdHNbJ3BhdHRlcm4nXSB0aGVuXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcInBhdHRlcm5cIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ3BhdHRlcm4nXSlcbiAgZW5kXG4gIGlmIG9wdHNbJ2VuZERhdGUnXSB0aGVuXG4gICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcImVuZERhdGVcIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ2VuZERhdGUnXSlcbiAgZW5kXG4gIGlmIG9wdHNbJ2V2ZXJ5J10gdGhlblxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJldmVyeVwiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgb3B0c1snZXZlcnknXSlcbiAgZW5kXG4gIHJjYWxsKFwiSE1TRVRcIiwgcmVwZWF0S2V5IC4uIFwiOlwiIC4uIGN1c3RvbUtleSwgXCJuYW1lXCIsIG9wdHNbJ25hbWUnXSxcbiAgICB1bnBhY2sob3B0aW9uYWxWYWx1ZXMpKVxuICByZXR1cm4gY3VzdG9tS2V5XG5lbmRcbi0tIElmIHdlIGFyZSBvdmVycmlkaW5nIGEgcmVwZWF0YWJsZSBqb2Igd2UgbXVzdCBkZWxldGUgdGhlIGRlbGF5ZWQgam9iIGZvclxuLS0gdGhlIG5leHQgaXRlcmF0aW9uLlxubG9jYWwgcHJldk1pbGxpcyA9IHJjYWxsKFwiWlNDT1JFXCIsIHJlcGVhdEtleSwgY3VzdG9tS2V5KVxuaWYgcHJldk1pbGxpcyB0aGVuXG4gIGxvY2FsIGRlbGF5ZWRKb2JJZCA9ICBcInJlcGVhdDpcIiAuLiBjdXN0b21LZXkgLi4gXCI6XCIgLi4gcHJldk1pbGxpc1xuICBsb2NhbCBuZXh0RGVsYXllZEpvYklkID0gIHJlcGVhdEtleSAuLiBcIjpcIiAuLiBjdXN0b21LZXkgLi4gXCI6XCIgLi4gbmV4dE1pbGxpc1xuICBpZiByY2FsbChcIlpTQ09SRVwiLCBkZWxheWVkS2V5LCBkZWxheWVkSm9iSWQpXG4gICBhbmQgcmNhbGwoXCJFWElTVFNcIiwgbmV4dERlbGF5ZWRKb2JJZCkgfj0gMSB0aGVuXG4gICAgcmVtb3ZlSm9iKGRlbGF5ZWRKb2JJZCwgdHJ1ZSwgcHJlZml4S2V5LCB0cnVlIC0tW1tyZW1vdmUgZGVib3VuY2Uga2V5XV0pXG4gICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIGRlbGF5ZWRKb2JJZClcbiAgZW5kXG5lbmRcbi0tIEtlZXAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgcmVwZWF0YWJsZSBqb2JzICg8PSAzLjAuMClcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIHJlcGVhdEtleSwgbGVnYWN5Q3VzdG9tS2V5KSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiBzdG9yZVJlcGVhdGFibGVKb2IocmVwZWF0S2V5LCBsZWdhY3lDdXN0b21LZXksIG5leHRNaWxsaXMsIEFSR1ZbMl0pXG5lbmRcbnJldHVybiBzdG9yZVJlcGVhdGFibGVKb2IocmVwZWF0S2V5LCBjdXN0b21LZXksIG5leHRNaWxsaXMsIEFSR1ZbMl0pXG5gO1xuZXhwb3J0IGNvbnN0IGFkZFJlcGVhdGFibGVKb2IgPSB7XG4gICAgbmFtZTogJ2FkZFJlcGVhdGFibGVKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRSZXBlYXRhYmxlSm9iLTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addRepeatableJob-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-9.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/addStandardJob-9.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addStandardJob: () => (/* binding */ addStandardJob)\n/* harmony export */ });\nconst content = `--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event 'delayed' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'wait',\n      KEYS[2] 'paused'\n      KEYS[3] 'meta'\n      KEYS[4] 'id'\n      KEYS[5] 'completed'\n      KEYS[6] 'delayed'\n      KEYS[7] 'active'\n      KEYS[8] events stream key\n      KEYS[9] marker key\n      ARGV[1] msgpacked arguments array\n            [1]  key prefix,\n            [2]  custom id (will not generate one automatically)\n            [3]  name\n            [4]  timestamp\n            [5]  parentKey?\n            [6]  waitChildrenKey key.\n            [7]  parent dependencies key.\n            [8]  parent? {id, queueKey}\n            [9]  repeat job key\n            [10] deduplication key\n      ARGV[2] Json stringified job data\n      ARGV[3] msgpacked options\n      Output:\n        jobId  - OK\n        -5     - Missing parent key\n]]\nlocal eventsKey = KEYS[8]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\nlocal args = cmsgpack.unpack(ARGV[1])\nlocal data = ARGV[2]\nlocal opts = cmsgpack.unpack(ARGV[3])\nlocal parentKey = args[5]\nlocal parent = args[8]\nlocal repeatJobKey = args[9]\nlocal deduplicationKey = args[10]\nlocal parentData\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to debounce a job.\n]]\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal function removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents, currentDeduplicatedJobId,\n    jobId, deduplicationId, prefix)\n    if rcall(\"ZREM\", delayedKey, currentDeduplicatedJobId) > 0 then\n        removeJobKeys(prefix .. currentDeduplicatedJobId)\n        rcall(\"XADD\", eventsKey, \"*\", \"event\", \"removed\", \"jobId\", currentDeduplicatedJobId,\n            \"prev\", \"delayed\")\n        -- TODO remove debounced event in next breaking change\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n            jobId, \"debounceId\", deduplicationId)\n        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n            jobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", currentDeduplicatedJobId)\n        return true\n    end\n    return false\nend\nlocal function deduplicateJob(deduplicationOpts, jobId, delayedKey, deduplicationKey, eventsKey, maxEvents,\n    prefix)\n    local deduplicationId = deduplicationOpts and deduplicationOpts['id']\n    if deduplicationId then\n        local ttl = deduplicationOpts['ttl']\n        if deduplicationOpts['replace'] then\n            if ttl and ttl > 0 then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        if deduplicationOpts['extend'] then\n                            rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        else\n                            rcall('SET', deduplicationKey, jobId, 'KEEPTTL')\n                        end\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                    return\n                end\n            else\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                if currentDebounceJobId then\n                    local isRemoved = removeDelayedJob(delayedKey, deduplicationKey, eventsKey, maxEvents,\n                        currentDebounceJobId, jobId, deduplicationId, prefix)\n                    if isRemoved then\n                        rcall('SET', deduplicationKey, jobId)\n                        return\n                    else\n                        return currentDebounceJobId\n                    end\n                else\n                    rcall('SET', deduplicationKey, jobId)\n                    return\n                end\n            end\n        else\n            local deduplicationKeyExists\n            if ttl and ttl > 0 then\n                if deduplicationOpts['extend'] then\n                    local currentDebounceJobId = rcall('GET', deduplicationKey)\n                    if currentDebounceJobId then\n                        rcall('SET', deduplicationKey, currentDebounceJobId, 'PX', ttl)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\",\n                            \"jobId\", currentDebounceJobId, \"debounceId\", deduplicationId)\n                        rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                            currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                        return currentDebounceJobId\n                    else\n                        rcall('SET', deduplicationKey, jobId, 'PX', ttl)\n                        return\n                    end\n                else\n                    deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'PX', ttl, 'NX')\n                end\n            else\n                deduplicationKeyExists = not rcall('SET', deduplicationKey, jobId, 'NX')\n            end\n            if deduplicationKeyExists then\n                local currentDebounceJobId = rcall('GET', deduplicationKey)\n                -- TODO remove debounced event in next breaking change\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"debounced\", \"jobId\",\n                    currentDebounceJobId, \"debounceId\", deduplicationId)\n                rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"deduplicated\", \"jobId\",\n                    currentDebounceJobId, \"deduplicationId\", deduplicationId, \"deduplicatedJobId\", jobId)\n                return currentDebounceJobId\n            end\n        end\n    end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to handle the case when job is duplicated.\n]]\n-- Includes\n--[[\n    This function is used to update the parent's dependencies if the job\n    is already completed and about to be ignored. The parent must get its\n    dependencies updated to avoid the parent job being stuck forever in \n    the waiting-children state.\n]]\n-- Includes\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. \":wait\"\n    local parentPausedKey = parentQueueKey .. \":paused\"\n    local parentActiveKey = parentQueueKey .. \":active\"\n    local parentMetaKey = parentQueueKey .. \":meta\"\n    local parentMarkerKey = parentQueueKey .. \":marker\"\n    local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. \":delayed\"\n        rcall(\"ZADD\", parentDelayedKey, score, parentId)\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\", \"jobId\", parentId, \"delay\",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. \":prioritized\", priority, parentId,\n                parentQueueKey .. \":pc\", isPausedOrMaxed)\n        end\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\",\n            \"waiting-children\")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then    \n      rcall(\"ZREM\", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall(\"SCARD\", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\nlocal function updateExistingJobsParent(parentKey, parent, parentData,\n                                        parentDependenciesKey, completedKey,\n                                        jobIdKey, jobId, timestamp)\n    if parentKey ~= nil then\n        if rcall(\"ZSCORE\", completedKey, jobId) then\n            local returnvalue = rcall(\"HGET\", jobIdKey, \"returnvalue\")\n            updateParentDepsIfNeeded(parentKey, parent['queueKey'],\n                                     parentDependenciesKey, parent['id'],\n                                     jobIdKey, returnvalue, timestamp)\n        else\n            if parentDependenciesKey ~= nil then\n                rcall(\"SADD\", parentDependenciesKey, jobIdKey)\n            end\n        end\n        rcall(\"HMSET\", jobIdKey, \"parentKey\", parentKey, \"parent\", parentData)\n    end\nend\nlocal function handleDuplicatedJob(jobKey, jobId, currentParentKey, currentParent,\n  parentData, parentDependenciesKey, completedKey, eventsKey, maxEvents, timestamp)\n  local existedParentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n  if not existedParentKey or existedParentKey == currentParentKey then\n    updateExistingJobsParent(currentParentKey, currentParent, parentData,\n      parentDependenciesKey, completedKey, jobKey,\n      jobId, timestamp)\n  else\n    if currentParentKey ~= nil and currentParentKey ~= existedParentKey\n      and (rcall(\"EXISTS\", existedParentKey) == 1) then\n      return -7\n    end\n  end\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n    \"duplicated\", \"jobId\", jobId)\n  return jobId .. \"\" -- convert to string\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\nif parentKey ~= nil then\n    if rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\n    parentData = cjson.encode(parent)\nend\nlocal jobCounter = rcall(\"INCR\", KEYS[4])\nlocal metaKey = KEYS[3]\nlocal maxEvents = getOrSetMaxEvents(metaKey)\nlocal parentDependenciesKey = args[7]\nlocal timestamp = args[4]\nif args[2] == \"\" then\n    jobId = jobCounter\n    jobIdKey = args[1] .. jobId\nelse\n    jobId = args[2]\n    jobIdKey = args[1] .. jobId\n    if rcall(\"EXISTS\", jobIdKey) == 1 then\n        return handleDuplicatedJob(jobIdKey, jobId, parentKey, parent,\n            parentData, parentDependenciesKey, KEYS[5], eventsKey,\n            maxEvents, timestamp)\n    end\nend\nlocal deduplicationJobId = deduplicateJob(opts['de'], jobId, KEYS[6],\n  deduplicationKey, eventsKey, maxEvents, args[1])\nif deduplicationJobId then\n  return deduplicationJobId\nend\n-- Store the job.\nstoreJob(eventsKey, jobIdKey, jobId, args[3], ARGV[2], opts, timestamp,\n         parentKey, parentData, repeatJobKey)\nlocal target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[7], KEYS[1], KEYS[2])\n-- LIFO or FIFO\nlocal pushCmd = opts['lifo'] and 'RPUSH' or 'LPUSH'\naddJobInTargetList(target, KEYS[9], pushCmd, isPausedOrMaxed, jobId)\n-- Emit waiting event\nrcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId)\n-- Check if this job is a child of another job, if so add it to the parents dependencies\nif parentDependenciesKey ~= nil then\n    rcall(\"SADD\", parentDependenciesKey, jobIdKey)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nconst addStandardJob = {\n    name: 'addStandardJob',\n    content,\n    keys: 9,\n};\n//# sourceMappingURL=addStandardJob-9.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvYWRkU3RhbmRhcmRKb2ItOS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9hZGRTdGFuZGFyZEpvYi05LmpzP2YxMjMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlIGJ5IGRvaW5nIHRoZSBmb2xsb3dpbmc6XG4gICAgLSBJbmNyZWFzZXMgdGhlIGpvYiBjb3VudGVyIGlmIG5lZWRlZC5cbiAgICAtIENyZWF0ZXMgYSBuZXcgam9iIGtleSB3aXRoIHRoZSBqb2IgZGF0YS5cbiAgICAtIGlmIGRlbGF5ZWQ6XG4gICAgICAtIGNvbXB1dGVzIHRpbWVzdGFtcC5cbiAgICAgIC0gYWRkcyB0byBkZWxheWVkIHpzZXQuXG4gICAgICAtIEVtaXRzIGEgZ2xvYmFsIGV2ZW50ICdkZWxheWVkJyBpZiB0aGUgam9iIGlzIGRlbGF5ZWQuXG4gICAgLSBpZiBub3QgZGVsYXllZFxuICAgICAgLSBBZGRzIHRoZSBqb2JJZCB0byB0aGUgd2FpdC9wYXVzZWQgbGlzdCBpbiBvbmUgb2YgdGhyZWUgd2F5czpcbiAgICAgICAgIC0gTElGT1xuICAgICAgICAgLSBGSUZPXG4gICAgICAgICAtIHByaW9yaXRpemVkLlxuICAgICAgLSBBZGRzIHRoZSBqb2IgdG8gdGhlIFwiYWRkZWRcIiBsaXN0IHNvIHRoYXQgd29ya2VycyBnZXRzIG5vdGlmaWVkLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnd2FpdCcsXG4gICAgICBLRVlTWzJdICdwYXVzZWQnXG4gICAgICBLRVlTWzNdICdtZXRhJ1xuICAgICAgS0VZU1s0XSAnaWQnXG4gICAgICBLRVlTWzVdICdjb21wbGV0ZWQnXG4gICAgICBLRVlTWzZdICdkZWxheWVkJ1xuICAgICAgS0VZU1s3XSAnYWN0aXZlJ1xuICAgICAgS0VZU1s4XSBldmVudHMgc3RyZWFtIGtleVxuICAgICAgS0VZU1s5XSBtYXJrZXIga2V5XG4gICAgICBBUkdWWzFdIG1zZ3BhY2tlZCBhcmd1bWVudHMgYXJyYXlcbiAgICAgICAgICAgIFsxXSAga2V5IHByZWZpeCxcbiAgICAgICAgICAgIFsyXSAgY3VzdG9tIGlkICh3aWxsIG5vdCBnZW5lcmF0ZSBvbmUgYXV0b21hdGljYWxseSlcbiAgICAgICAgICAgIFszXSAgbmFtZVxuICAgICAgICAgICAgWzRdICB0aW1lc3RhbXBcbiAgICAgICAgICAgIFs1XSAgcGFyZW50S2V5P1xuICAgICAgICAgICAgWzZdICB3YWl0Q2hpbGRyZW5LZXkga2V5LlxuICAgICAgICAgICAgWzddICBwYXJlbnQgZGVwZW5kZW5jaWVzIGtleS5cbiAgICAgICAgICAgIFs4XSAgcGFyZW50PyB7aWQsIHF1ZXVlS2V5fVxuICAgICAgICAgICAgWzldICByZXBlYXQgam9iIGtleVxuICAgICAgICAgICAgWzEwXSBkZWR1cGxpY2F0aW9uIGtleVxuICAgICAgQVJHVlsyXSBKc29uIHN0cmluZ2lmaWVkIGpvYiBkYXRhXG4gICAgICBBUkdWWzNdIG1zZ3BhY2tlZCBvcHRpb25zXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIGpvYklkICAtIE9LXG4gICAgICAgIC01ICAgICAtIE1pc3NpbmcgcGFyZW50IGtleVxuXV1cbmxvY2FsIGV2ZW50c0tleSA9IEtFWVNbOF1cbmxvY2FsIGpvYklkXG5sb2NhbCBqb2JJZEtleVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBhcmdzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbMV0pXG5sb2NhbCBkYXRhID0gQVJHVlsyXVxubG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzNdKVxubG9jYWwgcGFyZW50S2V5ID0gYXJnc1s1XVxubG9jYWwgcGFyZW50ID0gYXJnc1s4XVxubG9jYWwgcmVwZWF0Sm9iS2V5ID0gYXJnc1s5XVxubG9jYWwgZGVkdXBsaWNhdGlvbktleSA9IGFyZ3NbMTBdXG5sb2NhbCBwYXJlbnREYXRhXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBkZWJvdW5jZSBhIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgam9iIGtleXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iS2V5cyhqb2JLZXkpXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBqb2JLZXksIGpvYktleSAuLiAnOmxvZ3MnLCBqb2JLZXkgLi4gJzpkZXBlbmRlbmNpZXMnLFxuICAgIGpvYktleSAuLiAnOnByb2Nlc3NlZCcsIGpvYktleSAuLiAnOmZhaWxlZCcsIGpvYktleSAuLiAnOnVuc3VjY2Vzc2Z1bCcpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCxcbiAgICBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgaWYgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIGN1cnJlbnREZWR1cGxpY2F0ZWRKb2JJZCkgPiAwIHRoZW5cbiAgICAgICAgcmVtb3ZlSm9iS2V5cyhwcmVmaXggLi4gY3VycmVudERlZHVwbGljYXRlZEpvYklkKVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcInJlbW92ZWRcIiwgXCJqb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQsXG4gICAgICAgICAgICBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlYm91bmNlZFwiLCBcImpvYklkXCIsXG4gICAgICAgICAgICBqb2JJZCwgXCJkZWJvdW5jZUlkXCIsIGRlZHVwbGljYXRpb25JZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgam9iSWQsIFwiZGVkdXBsaWNhdGlvbklkXCIsIGRlZHVwbGljYXRpb25JZCwgXCJkZWR1cGxpY2F0ZWRKb2JJZFwiLCBjdXJyZW50RGVkdXBsaWNhdGVkSm9iSWQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGRlZHVwbGljYXRlSm9iKGRlZHVwbGljYXRpb25PcHRzLCBqb2JJZCwgZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgcHJlZml4KVxuICAgIGxvY2FsIGRlZHVwbGljYXRpb25JZCA9IGRlZHVwbGljYXRpb25PcHRzIGFuZCBkZWR1cGxpY2F0aW9uT3B0c1snaWQnXVxuICAgIGlmIGRlZHVwbGljYXRpb25JZCB0aGVuXG4gICAgICAgIGxvY2FsIHR0bCA9IGRlZHVwbGljYXRpb25PcHRzWyd0dGwnXVxuICAgICAgICBpZiBkZWR1cGxpY2F0aW9uT3B0c1sncmVwbGFjZSddIHRoZW5cbiAgICAgICAgICAgIGlmIHR0bCBhbmQgdHRsID4gMCB0aGVuXG4gICAgICAgICAgICAgICAgbG9jYWwgY3VycmVudERlYm91bmNlSm9iSWQgPSByY2FsbCgnR0VUJywgZGVkdXBsaWNhdGlvbktleSlcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50RGVib3VuY2VKb2JJZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGlzUmVtb3ZlZCA9IHJlbW92ZURlbGF5ZWRKb2IoZGVsYXllZEtleSwgZGVkdXBsaWNhdGlvbktleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgam9iSWQsIGRlZHVwbGljYXRpb25JZCwgcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICBpZiBpc1JlbW92ZWQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGVkdXBsaWNhdGlvbk9wdHNbJ2V4dGVuZCddIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdQWCcsIHR0bClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQsICdLRUVQVFRMJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgbG9jYWwgaXNSZW1vdmVkID0gcmVtb3ZlRGVsYXllZEpvYihkZWxheWVkS2V5LCBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBqb2JJZCwgZGVkdXBsaWNhdGlvbklkLCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGlzUmVtb3ZlZCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICByY2FsbCgnU0VUJywgZGVkdXBsaWNhdGlvbktleSwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzXG4gICAgICAgICAgICBpZiB0dGwgYW5kIHR0bCA+IDAgdGhlblxuICAgICAgICAgICAgICAgIGlmIGRlZHVwbGljYXRpb25PcHRzWydleHRlbmQnXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1cnJlbnREZWJvdW5jZUpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIGN1cnJlbnREZWJvdW5jZUpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBjdXJyZW50RGVib3VuY2VKb2JJZCwgJ1BYJywgdHRsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWJvdW5jZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImpvYklkXCIsIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlYm91bmNlSWRcIiwgZGVkdXBsaWNhdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWJvdW5jZUpvYklkLCBcImRlZHVwbGljYXRpb25JZFwiLCBkZWR1cGxpY2F0aW9uSWQsIFwiZGVkdXBsaWNhdGVkSm9iSWRcIiwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERlYm91bmNlSm9iSWRcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnUFgnLCB0dGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzID0gbm90IHJjYWxsKCdTRVQnLCBkZWR1cGxpY2F0aW9uS2V5LCBqb2JJZCwgJ1BYJywgdHRsLCAnTlgnKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlZHVwbGljYXRpb25LZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlZHVwbGljYXRpb25LZXksIGpvYklkLCAnTlgnKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpZiBkZWR1cGxpY2F0aW9uS2V5RXhpc3RzIHRoZW5cbiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgICAgICAgICAgIC0tIFRPRE8gcmVtb3ZlIGRlYm91bmNlZCBldmVudCBpbiBuZXh0IGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudHNLZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwiZGVib3VuY2VkXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlYm91bmNlSm9iSWQsIFwiZGVib3VuY2VJZFwiLCBkZWR1cGxpY2F0aW9uSWQpXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVib3VuY2VKb2JJZCwgXCJkZWR1cGxpY2F0aW9uSWRcIiwgZGVkdXBsaWNhdGlvbklkLCBcImRlZHVwbGljYXRlZEpvYklkXCIsIGpvYklkKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVib3VuY2VKb2JJZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIsIFwibWF4XCIsIFwiZHVyYXRpb25cIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIGlmIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSkgdGhlblxuICAgICAgICByZXR1cm4gd2FpdEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gam9iIGlzIGR1cGxpY2F0ZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBwYXJlbnQncyBkZXBlbmRlbmNpZXMgaWYgdGhlIGpvYlxuICAgIGlzIGFscmVhZHkgY29tcGxldGVkIGFuZCBhYm91dCB0byBiZSBpZ25vcmVkLiBUaGUgcGFyZW50IG11c3QgZ2V0IGl0c1xuICAgIGRlcGVuZGVuY2llcyB1cGRhdGVkIHRvIGF2b2lkIHRoZSBwYXJlbnQgam9iIGJlaW5nIHN0dWNrIGZvcmV2ZXIgaW4gXG4gICAgdGhlIHdhaXRpbmctY2hpbGRyZW4gc3RhdGUuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgb3IgYWRkIGRlcGVuZGVuY2llcyB0byBwYXJlbnQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGEgd2FpdCBzdGF0dXMgKHdhaXRpbmcsIGRlbGF5ZWQgb3IgcHJpb3JpdGl6ZWQpXG4gIGlmIG5vIHBlbmRpbmcgZGVwZW5kZW5jaWVzLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIHBhcmVudCB0byBhIHdhaXQgc3RhdHVzICh3YWl0aW5nLCBkZWxheWVkIG9yIHByaW9yaXRpemVkKSBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgTW92ZSBwYXJlbnQgdG8gYSB3YWl0IHN0YXR1cyAod2FpdCwgcHJpb3JpdGl6ZWQgb3IgZGVsYXllZClcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAgIHJldHVybiBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAtLSBSZXBsYWNlIHRoZSBzY29yZSBvZiB0aGUgbWFya2VyIHdpdGggdGhlIG5ld2VzdCBrbm93blxuICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIG5leHRUaW1lc3RhbXAsIFwiMVwiKVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBwcmlvcml0eSBzY29yZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHByaW9Db3VudGVyID0gcmNhbGwoXCJJTkNSXCIsIHByaW9yaXR5Q291bnRlcktleSlcbiAgcmV0dXJuIHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBwcmlvQ291bnRlciAlIDB4MTAwMDAwMDAwXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsIHByaW9yaXR5Q291bnRlcktleSxcbiAgaXNQYXVzZWRPck1heGVkKVxuICBsb2NhbCBzY29yZSA9IGdldFByaW9yaXR5U2NvcmUocHJpb3JpdHksIHByaW9yaXR5Q291bnRlcktleSlcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBpZiBxdWV1ZSBpcyBwYXVzZWQgb3IgbWF4ZWRcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzUXVldWVQYXVzZWRPck1heGVkKHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiB0cnVlXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgcmV0dXJuIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSlcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgbG9jYWwgcGFyZW50V2FpdEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRcIlxuICAgIGxvY2FsIHBhcmVudFBhdXNlZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBhdXNlZFwiXG4gICAgbG9jYWwgcGFyZW50QWN0aXZlS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6YWN0aXZlXCJcbiAgICBsb2NhbCBwYXJlbnRNZXRhS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWV0YVwiXG4gICAgbG9jYWwgcGFyZW50TWFya2VyS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6bWFya2VyXCJcbiAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBwYXJlbnRLZXksIFwicHJpb3JpdHlcIiwgXCJkZWxheVwiKVxuICAgIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1sxXSkgb3IgMFxuICAgIGxvY2FsIGRlbGF5ID0gdG9udW1iZXIoam9iQXR0cmlidXRlc1syXSkgb3IgMFxuICAgIGlmIGRlbGF5ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSB0b251bWJlcih0aW1lc3RhbXApICsgZGVsYXlcbiAgICAgICAgbG9jYWwgc2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gICAgICAgIGxvY2FsIHBhcmVudERlbGF5ZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpkZWxheWVkXCJcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHBhcmVudERlbGF5ZWRLZXksIHNjb3JlLCBwYXJlbnRJZClcbiAgICAgICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmV2ZW50c1wiLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJkZWxheVwiLFxuICAgICAgICAgICAgZGVsYXllZFRpbWVzdGFtcClcbiAgICAgICAgYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChwYXJlbnRNYXJrZXJLZXksIHBhcmVudERlbGF5ZWRLZXkpXG4gICAgZWxzZVxuICAgICAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXJlbnRQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudE1ldGFLZXksIHBhcmVudEFjdGl2ZUtleSxcbiAgICAgICAgICAgICAgICBwYXJlbnRXYWl0S2V5LCBwYXJlbnRQYXVzZWRLZXkpXG4gICAgICAgICAgICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRNYXJrZXJLZXksIFwiUlBVU0hcIiwgaXNQYXJlbnRQYXVzZWRPck1heGVkLCBwYXJlbnRJZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9jYWwgaXNQYXVzZWRPck1heGVkID0gaXNRdWV1ZVBhdXNlZE9yTWF4ZWQocGFyZW50TWV0YUtleSwgcGFyZW50QWN0aXZlS2V5KVxuICAgICAgICAgICAgYWRkSm9iV2l0aFByaW9yaXR5KHBhcmVudE1hcmtlcktleSwgcGFyZW50UXVldWVLZXkgLi4gXCI6cHJpb3JpdGl6ZWRcIiwgcHJpb3JpdHksIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnBjXCIsIGlzUGF1c2VkT3JNYXhlZClcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLFxuICAgICAgICAgICAgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gICAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBwYXJlbnRLZXkpID09IDEgdGhlblxuICAgIGxvY2FsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOndhaXRpbmctY2hpbGRyZW5cIlxuICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSwgcGFyZW50SWQpIHRoZW4gICAgXG4gICAgICByY2FsbChcIlpSRU1cIiwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5LCBwYXJlbnRJZClcbiAgICAgIG1vdmVQYXJlbnRUb1dhaXQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksXG4gIHBhcmVudElkLCB0aW1lc3RhbXApXG4gIGxvY2FsIGRvTm90SGF2ZVBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSkgPT0gMFxuICBpZiBkb05vdEhhdmVQZW5kaW5nRGVwZW5kZW5jaWVzIHRoZW5cbiAgICBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LCBwYXJlbnREZXBlbmRlbmNpZXNLZXksXG4gIHBhcmVudElkLCBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcCApXG4gIGxvY2FsIHByb2Nlc3NlZFNldCA9IHBhcmVudEtleSAuLiBcIjpwcm9jZXNzZWRcIlxuICByY2FsbChcIkhTRVRcIiwgcHJvY2Vzc2VkU2V0LCBqb2JJZEtleSwgcmV0dXJudmFsdWUpXG4gIG1vdmVQYXJlbnRUb1dhaXRJZk5vUGVuZGluZ0RlcGVuZGVuY2llcyhwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHVwZGF0ZUV4aXN0aW5nSm9ic1BhcmVudChwYXJlbnRLZXksIHBhcmVudCwgcGFyZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgam9iSWQsIHRpbWVzdGFtcClcbiAgICBpZiBwYXJlbnRLZXkgfj0gbmlsIHRoZW5cbiAgICAgICAgaWYgcmNhbGwoXCJaU0NPUkVcIiwgY29tcGxldGVkS2V5LCBqb2JJZCkgdGhlblxuICAgICAgICAgICAgbG9jYWwgcmV0dXJudmFsdWUgPSByY2FsbChcIkhHRVRcIiwgam9iSWRLZXksIFwicmV0dXJudmFsdWVcIilcbiAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFsncXVldWVLZXknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIHBhcmVudFsnaWQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2JJZEtleSwgcmV0dXJudmFsdWUsIHRpbWVzdGFtcClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwicGFyZW50S2V5XCIsIHBhcmVudEtleSwgXCJwYXJlbnRcIiwgcGFyZW50RGF0YSlcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gaGFuZGxlRHVwbGljYXRlZEpvYihqb2JLZXksIGpvYklkLCBjdXJyZW50UGFyZW50S2V5LCBjdXJyZW50UGFyZW50LFxuICBwYXJlbnREYXRhLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgZXZlbnRzS2V5LCBtYXhFdmVudHMsIHRpbWVzdGFtcClcbiAgbG9jYWwgZXhpc3RlZFBhcmVudEtleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIpXG4gIGlmIG5vdCBleGlzdGVkUGFyZW50S2V5IG9yIGV4aXN0ZWRQYXJlbnRLZXkgPT0gY3VycmVudFBhcmVudEtleSB0aGVuXG4gICAgdXBkYXRlRXhpc3RpbmdKb2JzUGFyZW50KGN1cnJlbnRQYXJlbnRLZXksIGN1cnJlbnRQYXJlbnQsIHBhcmVudERhdGEsXG4gICAgICBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGNvbXBsZXRlZEtleSwgam9iS2V5LFxuICAgICAgam9iSWQsIHRpbWVzdGFtcClcbiAgZWxzZVxuICAgIGlmIGN1cnJlbnRQYXJlbnRLZXkgfj0gbmlsIGFuZCBjdXJyZW50UGFyZW50S2V5IH49IGV4aXN0ZWRQYXJlbnRLZXlcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgZXhpc3RlZFBhcmVudEtleSkgPT0gMSkgdGhlblxuICAgICAgcmV0dXJuIC03XG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLFxuICAgIFwiZHVwbGljYXRlZFwiLCBcImpvYklkXCIsIGpvYklkKVxuICByZXR1cm4gam9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHN0b3JlIGEgam9iXG5dXVxubG9jYWwgZnVuY3Rpb24gc3RvcmVKb2IoZXZlbnRzS2V5LCBqb2JJZEtleSwgam9iSWQsIG5hbWUsIGRhdGEsIG9wdHMsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEtleSwgcGFyZW50RGF0YSwgcmVwZWF0Sm9iS2V5KVxuICAgIGxvY2FsIGpzb25PcHRzID0gY2pzb24uZW5jb2RlKG9wdHMpXG4gICAgbG9jYWwgZGVsYXkgPSBvcHRzWydkZWxheSddIG9yIDBcbiAgICBsb2NhbCBwcmlvcml0eSA9IG9wdHNbJ3ByaW9yaXR5J10gb3IgMFxuICAgIGxvY2FsIGRlYm91bmNlSWQgPSBvcHRzWydkZSddIGFuZCBvcHRzWydkZSddWydpZCddXG4gICAgbG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuICAgIGlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50S2V5XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50S2V5KVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGFyZW50XCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcGFyZW50RGF0YSlcbiAgICBlbmRcbiAgICBpZiByZXBlYXRKb2JLZXkgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicmprXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgcmVwZWF0Sm9iS2V5KVxuICAgIGVuZFxuICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwiZGVpZFwiKVxuICAgICAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIGRlYm91bmNlSWQpXG4gICAgZW5kXG4gICAgcmNhbGwoXCJITVNFVFwiLCBqb2JJZEtleSwgXCJuYW1lXCIsIG5hbWUsIFwiZGF0YVwiLCBkYXRhLCBcIm9wdHNcIiwganNvbk9wdHMsXG4gICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgdGltZXN0YW1wLCBcImRlbGF5XCIsIGRlbGF5LCBcInByaW9yaXR5XCIsIHByaW9yaXR5LFxuICAgICAgICAgIHVucGFjayhvcHRpb25hbFZhbHVlcykpXG4gICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhZGRlZFwiLCBcImpvYklkXCIsIGpvYklkLCBcIm5hbWVcIiwgbmFtZSlcbiAgICByZXR1cm4gZGVsYXksIHByaW9yaXR5XG5lbmRcbmlmIHBhcmVudEtleSB+PSBuaWwgdGhlblxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbiAgICBwYXJlbnREYXRhID0gY2pzb24uZW5jb2RlKHBhcmVudClcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBLRVlTWzRdKVxubG9jYWwgbWV0YUtleSA9IEtFWVNbM11cbmxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG5sb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBhcmdzWzddXG5sb2NhbCB0aW1lc3RhbXAgPSBhcmdzWzRdXG5pZiBhcmdzWzJdID09IFwiXCIgdGhlblxuICAgIGpvYklkID0gam9iQ291bnRlclxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuZWxzZVxuICAgIGpvYklkID0gYXJnc1syXVxuICAgIGpvYklkS2V5ID0gYXJnc1sxXSAuLiBqb2JJZFxuICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICAgICAgcmV0dXJuIGhhbmRsZUR1cGxpY2F0ZWRKb2Ioam9iSWRLZXksIGpvYklkLCBwYXJlbnRLZXksIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudERhdGEsIHBhcmVudERlcGVuZGVuY2llc0tleSwgS0VZU1s1XSwgZXZlbnRzS2V5LFxuICAgICAgICAgICAgbWF4RXZlbnRzLCB0aW1lc3RhbXApXG4gICAgZW5kXG5lbmRcbmxvY2FsIGRlZHVwbGljYXRpb25Kb2JJZCA9IGRlZHVwbGljYXRlSm9iKG9wdHNbJ2RlJ10sIGpvYklkLCBLRVlTWzZdLFxuICBkZWR1cGxpY2F0aW9uS2V5LCBldmVudHNLZXksIG1heEV2ZW50cywgYXJnc1sxXSlcbmlmIGRlZHVwbGljYXRpb25Kb2JJZCB0aGVuXG4gIHJldHVybiBkZWR1cGxpY2F0aW9uSm9iSWRcbmVuZFxuLS0gU3RvcmUgdGhlIGpvYi5cbnN0b3JlSm9iKGV2ZW50c0tleSwgam9iSWRLZXksIGpvYklkLCBhcmdzWzNdLCBBUkdWWzJdLCBvcHRzLCB0aW1lc3RhbXAsXG4gICAgICAgICBwYXJlbnRLZXksIHBhcmVudERhdGEsIHJlcGVhdEpvYktleSlcbmxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbN10sIEtFWVNbMV0sIEtFWVNbMl0pXG4tLSBMSUZPIG9yIEZJRk9cbmxvY2FsIHB1c2hDbWQgPSBvcHRzWydsaWZvJ10gYW5kICdSUFVTSCcgb3IgJ0xQVVNIJ1xuYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldCwgS0VZU1s5XSwgcHVzaENtZCwgaXNQYXVzZWRPck1heGVkLCBqb2JJZClcbi0tIEVtaXQgd2FpdGluZyBldmVudFxucmNhbGwoXCJYQUREXCIsIGV2ZW50c0tleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsXG4gICAgICBcImpvYklkXCIsIGpvYklkKVxuLS0gQ2hlY2sgaWYgdGhpcyBqb2IgaXMgYSBjaGlsZCBvZiBhbm90aGVyIGpvYiwgaWYgc28gYWRkIGl0IHRvIHRoZSBwYXJlbnRzIGRlcGVuZGVuY2llc1xuaWYgcGFyZW50RGVwZW5kZW5jaWVzS2V5IH49IG5pbCB0aGVuXG4gICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iSWRLZXkpXG5lbmRcbnJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG5gO1xuZXhwb3J0IGNvbnN0IGFkZFN0YW5kYXJkSm9iID0ge1xuICAgIG5hbWU6ICdhZGRTdGFuZGFyZEpvYicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA5LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZFN0YW5kYXJkSm9iLTkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeDelay: () => (/* binding */ changeDelay)\n/* harmony export */ });\nconst content = `--[[\n  Change job delay when it is in delayed set.\n  Input:\n    KEYS[1] delayed key\n    KEYS[2] meta key\n    KEYS[3] marker key\n    KEYS[4] events stream\n    ARGV[1] delay\n    ARGV[2] timestamp\n    ARGV[3] the id of the job\n    ARGV[4] job key\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in delayed set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall(\"ZREVRANGEBYSCORE\", delayedKey, maxScore,\n    minScore, \"WITHSCORES\",\"LIMIT\", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nif rcall(\"EXISTS\", ARGV[4]) == 1 then\n  local jobId = ARGV[3]\n  local delay = tonumber(ARGV[1])\n  local score, delayedTimestamp = getDelayedScore(KEYS[1], ARGV[2], delay)\n  local numRemovedElements = rcall(\"ZREM\", KEYS[1], jobId)\n  if numRemovedElements < 1 then\n    return -3\n  end\n  rcall(\"HSET\", ARGV[4], \"delay\", delay)\n  rcall(\"ZADD\", KEYS[1], score, jobId)\n  local maxEvents = getOrSetMaxEvents(KEYS[2])\n  rcall(\"XADD\", KEYS[4], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n    \"jobId\", jobId, \"delay\", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(KEYS[3], KEYS[1])\n  return 0\nelse\n  return -1\nend`;\nconst changeDelay = {\n    name: 'changeDelay',\n    content,\n    keys: 4,\n};\n//# sourceMappingURL=changeDelay-4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlRGVsYXktNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlRGVsYXktNC5qcz9jYWQ2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGFuZ2Ugam9iIGRlbGF5IHdoZW4gaXQgaXMgaW4gZGVsYXllZCBzZXQuXG4gIElucHV0OlxuICAgIEtFWVNbMV0gZGVsYXllZCBrZXlcbiAgICBLRVlTWzJdIG1ldGEga2V5XG4gICAgS0VZU1szXSBtYXJrZXIga2V5XG4gICAgS0VZU1s0XSBldmVudHMgc3RyZWFtXG4gICAgQVJHVlsxXSBkZWxheVxuICAgIEFSR1ZbMl0gdGltZXN0YW1wXG4gICAgQVJHVlszXSB0aGUgaWQgb2YgdGhlIGpvYlxuICAgIEFSR1ZbNF0gam9iIGtleVxuICBPdXRwdXQ6XG4gICAgMCAtIE9LXG4gICAtMSAtIE1pc3Npbmcgam9iLlxuICAgLTMgLSBKb2Igbm90IGluIGRlbGF5ZWQgc2V0LlxuICBFdmVudHM6XG4gICAgLSBkZWxheWVkIGtleS5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbmV4dCBkZWxheWVkIGpvYiB0aW1lc3RhbXAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkFOR0VcIiwgZGVsYXllZEtleSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgcmV0dXJuIG5leHRUaW1lc3RhbXAgLyAweDEwMDBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgLS0gbmV4dCB0aW1lc3RhbXAuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEJha2UgaW4gdGhlIGpvYiBpZCBmaXJzdCAxMiBiaXRzIGludG8gdGhlIHRpbWVzdGFtcFxuICB0byBndWFyYW50ZWUgY29ycmVjdCBleGVjdXRpb24gb3JkZXIgb2YgZGVsYXllZCBqb2JzXG4gICh1cCB0byA0MDk2IGpvYnMgcGVyIGdpdmVuIHRpbWVzdGFtcCBvciA0MDk2IGpvYnMgYXBhcnQgcGVyIHRpbWVzdGFtcClcbiAgV0FSTklORzogSm9icyB0aGF0IGFyZSBzbyBmYXIgYXBhcnQgdGhhdCB0aGV5IHdyYXAgYXJvdW5kIHdpbGwgY2F1c2UgRklGTyB0byBmYWlsXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0RGVsYXllZFNjb3JlKGRlbGF5ZWRLZXksIHRpbWVzdGFtcCwgZGVsYXkpXG4gIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSAoZGVsYXkgPiAwIGFuZCAodG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5KSkgb3IgdG9udW1iZXIodGltZXN0YW1wKVxuICBsb2NhbCBtaW5TY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgbG9jYWwgbWF4U2NvcmUgPSAoZGVsYXllZFRpbWVzdGFtcCArIDEgKSAqIDB4MTAwMCAtIDFcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkVWUkFOR0VCWVNDT1JFXCIsIGRlbGF5ZWRLZXksIG1heFNjb3JlLFxuICAgIG1pblNjb3JlLCBcIldJVEhTQ09SRVNcIixcIkxJTUlUXCIsIDAsIDEpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIGN1cnJlbnRNYXhTY29yZSA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBjdXJyZW50TWF4U2NvcmUgfj0gbmlsIHRoZW5cbiAgICAgIGlmIGN1cnJlbnRNYXhTY29yZSA+PSBtYXhTY29yZSB0aGVuXG4gICAgICAgIHJldHVybiBtYXhTY29yZSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY3VycmVudE1heFNjb3JlICsgMSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gbWluU2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgQVJHVls0XSkgPT0gMSB0aGVuXG4gIGxvY2FsIGpvYklkID0gQVJHVlszXVxuICBsb2NhbCBkZWxheSA9IHRvbnVtYmVyKEFSR1ZbMV0pXG4gIGxvY2FsIHNjb3JlLCBkZWxheWVkVGltZXN0YW1wID0gZ2V0RGVsYXllZFNjb3JlKEtFWVNbMV0sIEFSR1ZbMl0sIGRlbGF5KVxuICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgS0VZU1sxXSwgam9iSWQpXG4gIGlmIG51bVJlbW92ZWRFbGVtZW50cyA8IDEgdGhlblxuICAgIHJldHVybiAtM1xuICBlbmRcbiAgcmNhbGwoXCJIU0VUXCIsIEFSR1ZbNF0sIFwiZGVsYXlcIiwgZGVsYXkpXG4gIHJjYWxsKFwiWkFERFwiLCBLRVlTWzFdLCBzY29yZSwgam9iSWQpXG4gIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKEtFWVNbMl0pXG4gIHJjYWxsKFwiWEFERFwiLCBLRVlTWzRdLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIixcbiAgICBcImpvYklkXCIsIGpvYklkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4gIC0tIG1hcmsgdGhhdCBhIGRlbGF5ZWQgam9iIGlzIGF2YWlsYWJsZVxuICBhZGREZWxheU1hcmtlcklmTmVlZGVkKEtFWVNbM10sIEtFWVNbMV0pXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kYDtcbmV4cG9ydCBjb25zdCBjaGFuZ2VEZWxheSA9IHtcbiAgICBuYW1lOiAnY2hhbmdlRGVsYXknLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VEZWxheS00LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-7.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/changePriority-7.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changePriority: () => (/* binding */ changePriority)\n/* harmony export */ });\nconst content = `--[[\n  Change job priority\n  Input:\n    KEYS[1] 'wait',\n    KEYS[2] 'paused'\n    KEYS[3] 'meta'\n    KEYS[4] 'prioritized'\n    KEYS[5] 'active'\n    KEYS[6] 'pc' priority counter\n    KEYS[7] 'marker'\n    ARGV[1] priority value\n    ARGV[2] prefix key\n    ARGV[3] job id\n    ARGV[4] lifo\n    Output:\n       0  - OK\n      -1  - Missing job\n]]\nlocal jobId = ARGV[3]\nlocal jobKey = ARGV[2] .. jobId\nlocal priority = tonumber(ARGV[1])\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to push back job considering priority in front of same prioritized jobs.\n]]\nlocal function pushBackJobWithPriority(prioritizedKey, priority, jobId)\n  -- in order to put it at front of same prioritized jobs\n  -- we consider prioritized counter as 0\n  local score = priority * 0x100000000\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\nend\nlocal function reAddJobWithNewPriority( prioritizedKey, markerKey, targetKey,\n    priorityCounter, lifo, priority, jobId, isPausedOrMaxed)\n    if priority == 0 then\n        local pushCmd = lifo and 'RPUSH' or 'LPUSH'\n        addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n        if lifo then\n            pushBackJobWithPriority(prioritizedKey, priority, jobId)\n        else\n            addJobWithPriority(markerKey, prioritizedKey, priority, jobId,\n                priorityCounter, isPausedOrMaxed)\n        end\n    end\nend\nif rcall(\"EXISTS\", jobKey) == 1 then\n    local metaKey = KEYS[3]\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[5], KEYS[1], KEYS[2])\n    local prioritizedKey = KEYS[4]\n    local priorityCounterKey = KEYS[6]\n    local markerKey = KEYS[7]\n    -- Re-add with the new priority\n    if rcall(\"ZREM\", prioritizedKey, jobId) > 0 then\n        reAddJobWithNewPriority( prioritizedKey, markerKey, target,\n            priorityCounterKey, ARGV[4] == '1', priority, jobId, isPausedOrMaxed)\n    elseif rcall(\"LREM\", target, -1, jobId) > 0 then\n        reAddJobWithNewPriority( prioritizedKey, markerKey, target,\n            priorityCounterKey, ARGV[4] == '1', priority, jobId, isPausedOrMaxed)\n    end\n    rcall(\"HSET\", jobKey, \"priority\", priority)\n    return 0\nelse\n    return -1\nend\n`;\nconst changePriority = {\n    name: 'changePriority',\n    content,\n    keys: 7,\n};\n//# sourceMappingURL=changePriority-7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlUHJpb3JpdHktNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2hhbmdlUHJpb3JpdHktNy5qcz9hYjA3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGFuZ2Ugam9iIHByaW9yaXR5XG4gIElucHV0OlxuICAgIEtFWVNbMV0gJ3dhaXQnLFxuICAgIEtFWVNbMl0gJ3BhdXNlZCdcbiAgICBLRVlTWzNdICdtZXRhJ1xuICAgIEtFWVNbNF0gJ3ByaW9yaXRpemVkJ1xuICAgIEtFWVNbNV0gJ2FjdGl2ZSdcbiAgICBLRVlTWzZdICdwYycgcHJpb3JpdHkgY291bnRlclxuICAgIEtFWVNbN10gJ21hcmtlcidcbiAgICBBUkdWWzFdIHByaW9yaXR5IHZhbHVlXG4gICAgQVJHVlsyXSBwcmVmaXgga2V5XG4gICAgQVJHVlszXSBqb2IgaWRcbiAgICBBUkdWWzRdIGxpZm9cbiAgICBPdXRwdXQ6XG4gICAgICAgMCAgLSBPS1xuICAgICAgLTEgIC0gTWlzc2luZyBqb2Jcbl1dXG5sb2NhbCBqb2JJZCA9IEFSR1ZbM11cbmxvY2FsIGpvYktleSA9IEFSR1ZbMl0gLi4gam9iSWRcbmxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoQVJHVlsxXSlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBwdXNoIGJhY2sgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5IGluIGZyb250IG9mIHNhbWUgcHJpb3JpdGl6ZWQgam9icy5cbl1dXG5sb2NhbCBmdW5jdGlvbiBwdXNoQmFja0pvYldpdGhQcmlvcml0eShwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkKVxuICAtLSBpbiBvcmRlciB0byBwdXQgaXQgYXQgZnJvbnQgb2Ygc2FtZSBwcmlvcml0aXplZCBqb2JzXG4gIC0tIHdlIGNvbnNpZGVyIHByaW9yaXRpemVkIGNvdW50ZXIgYXMgMFxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDBcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlQWRkSm9iV2l0aE5ld1ByaW9yaXR5KCBwcmlvcml0aXplZEtleSwgbWFya2VyS2V5LCB0YXJnZXRLZXksXG4gICAgcHJpb3JpdHlDb3VudGVyLCBsaWZvLCBwcmlvcml0eSwgam9iSWQsIGlzUGF1c2VkT3JNYXhlZClcbiAgICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcHVzaENtZCA9IGxpZm8gYW5kICdSUFVTSCcgb3IgJ0xQVVNIJ1xuICAgICAgICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgICBpZiBsaWZvIHRoZW5cbiAgICAgICAgICAgIHB1c2hCYWNrSm9iV2l0aFByaW9yaXR5KHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlDb3VudGVyLCBpc1BhdXNlZE9yTWF4ZWQpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5pZiByY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkpID09IDEgdGhlblxuICAgIGxvY2FsIG1ldGFLZXkgPSBLRVlTWzNdXG4gICAgbG9jYWwgdGFyZ2V0LCBpc1BhdXNlZE9yTWF4ZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QobWV0YUtleSwgS0VZU1s1XSwgS0VZU1sxXSwgS0VZU1syXSlcbiAgICBsb2NhbCBwcmlvcml0aXplZEtleSA9IEtFWVNbNF1cbiAgICBsb2NhbCBwcmlvcml0eUNvdW50ZXJLZXkgPSBLRVlTWzZdXG4gICAgbG9jYWwgbWFya2VyS2V5ID0gS0VZU1s3XVxuICAgIC0tIFJlLWFkZCB3aXRoIHRoZSBuZXcgcHJpb3JpdHlcbiAgICBpZiByY2FsbChcIlpSRU1cIiwgcHJpb3JpdGl6ZWRLZXksIGpvYklkKSA+IDAgdGhlblxuICAgICAgICByZUFkZEpvYldpdGhOZXdQcmlvcml0eSggcHJpb3JpdGl6ZWRLZXksIG1hcmtlcktleSwgdGFyZ2V0LFxuICAgICAgICAgICAgcHJpb3JpdHlDb3VudGVyS2V5LCBBUkdWWzRdID09ICcxJywgcHJpb3JpdHksIGpvYklkLCBpc1BhdXNlZE9yTWF4ZWQpXG4gICAgZWxzZWlmIHJjYWxsKFwiTFJFTVwiLCB0YXJnZXQsIC0xLCBqb2JJZCkgPiAwIHRoZW5cbiAgICAgICAgcmVBZGRKb2JXaXRoTmV3UHJpb3JpdHkoIHByaW9yaXRpemVkS2V5LCBtYXJrZXJLZXksIHRhcmdldCxcbiAgICAgICAgICAgIHByaW9yaXR5Q291bnRlcktleSwgQVJHVls0XSA9PSAnMScsIHByaW9yaXR5LCBqb2JJZCwgaXNQYXVzZWRPck1heGVkKVxuICAgIGVuZFxuICAgIHJjYWxsKFwiSFNFVFwiLCBqb2JLZXksIFwicHJpb3JpdHlcIiwgcHJpb3JpdHkpXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBjaGFuZ2VQcmlvcml0eSA9IHtcbiAgICBuYW1lOiAnY2hhbmdlUHJpb3JpdHknLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogNyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VQcmlvcml0eS03LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-3.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-3.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanJobsInSet: () => (/* binding */ cleanJobsInSet)\n/* harmony export */ });\nconst content = `--[[\n  Remove jobs from the specific set.\n  Input:\n    KEYS[1]  set key,\n    KEYS[2]  events stream key\n    KEYS[3]  repeat key\n    ARGV[1]  jobKey prefix\n    ARGV[2]  timestamp\n    ARGV[3]  limit the number of jobs to be removed. 0 is unlimited\n    ARGV[4]  set name, can be any of 'wait', 'active', 'paused', 'delayed', 'completed', or 'failed'\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[3]\nlocal rangeStart = 0\nlocal rangeEnd = -1\nlocal limit = tonumber(ARGV[3])\n-- If we're only deleting _n_ items, avoid retrieving all items\n-- for faster performance\n--\n-- Start from the tail of the list, since that's where oldest elements\n-- are generally added for FIFO lists\nif limit > 0 then\n  rangeStart = -1 - limit + 1\n  rangeEnd = -1\nend\n-- Includes\n--[[\n  Function to clean job list.\n  Returns jobIds and deleted count number.\n]]\n-- Includes\n--[[\n  Function to get the latest saved timestamp.\n]]\nlocal function getTimestamp(jobKey, attributes)\n  if #attributes == 1 then\n    return rcall(\"HGET\", jobKey, attributes[1])\n  end\n  local jobTs\n  for _, ts in ipairs(rcall(\"HMGET\", jobKey, unpack(attributes))) do\n    if (ts) then\n      jobTs = ts\n      break\n    end\n  end\n  return jobTs\nend\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall(\"HGET\", jobKey, \"rjk\")\n  if repeatJobKey  then\n    local prevMillis = rcall(\"ZSCORE\", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = \"repeat:\" .. repeatJobKey .. \":\" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function cleanList(listKey, jobKeyPrefix, rangeStart, rangeEnd,\n  timestamp, isWaiting, jobSchedulersKey)\n  local jobs = rcall(\"LRANGE\", listKey, rangeStart, rangeEnd)\n  local deleted = {}\n  local deletedCount = 0\n  local jobTS\n  local deletionMarker = ''\n  local jobIdsLen = #jobs\n  for i, job in ipairs(jobs) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = jobKeyPrefix .. job\n    if (isWaiting or rcall(\"EXISTS\", jobKey .. \":lock\") == 0) and\n      not isJobSchedulerJob(job, jobKey, jobSchedulersKey) then\n      -- Find the right timestamp of the job to compare to maxTimestamp:\n      -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n      -- * processedOn represents when the job was last attempted, but it doesn't get populated until\n      --   the job is first tried\n      -- * timestamp is the original job submission time\n      -- Fetch all three of these (in that order) and use the first one that is set so that we'll leave jobs\n      -- that have been active within the grace period:\n      jobTS = getTimestamp(jobKey, {\"finishedOn\", \"processedOn\", \"timestamp\"})\n      if (not jobTS or jobTS <= timestamp) then\n        -- replace the entry with a deletion marker; the actual deletion will\n        -- occur at the end of the script\n        rcall(\"LSET\", listKey, rangeEnd - jobIdsLen + i, deletionMarker)\n        removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]])\n        deletedCount = deletedCount + 1\n        table.insert(deleted, job)\n      end\n    end\n  end\n  rcall(\"LREM\", listKey, 0, deletionMarker)\n  return {deleted, deletedCount}\nend\n--[[\n  Function to clean job set.\n  Returns jobIds and deleted count number.\n]] \n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  We use ZRANGEBYSCORE to make the case where we're deleting a limited number\n  of items in a sorted set only run a single iteration. If we simply used\n  ZRANGE, we may take a long time traversing through jobs that are within the\n  grace period.\n]]\nlocal function getJobsInZset(zsetKey, rangeEnd, limit)\n  if limit > 0 then\n    return rcall(\"ZRANGEBYSCORE\", zsetKey, 0, rangeEnd, \"LIMIT\", 0, limit)\n  else\n    return rcall(\"ZRANGEBYSCORE\", zsetKey, 0, rangeEnd)\n  end\nend\nlocal function cleanSet(\n    setKey,\n    jobKeyPrefix,\n    rangeEnd,\n    timestamp,\n    limit,\n    attributes,\n    isFinished,\n    jobSchedulersKey)\n    local jobs = getJobsInZset(setKey, rangeEnd, limit)\n    local deleted = {}\n    local deletedCount = 0\n    local jobTS\n    for i, job in ipairs(jobs) do\n        if limit > 0 and deletedCount >= limit then\n            break\n        end\n        local jobKey = jobKeyPrefix .. job\n        -- Extract a Job Scheduler Id from jobId (\"repeat:job-scheduler-id:millis\") \n        -- and check if it is in the scheduled jobs\n        if not (jobSchedulersKey and isJobSchedulerJob(job, jobKey, jobSchedulersKey)) then\n            if isFinished then\n                removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]] )\n                deletedCount = deletedCount + 1\n                table.insert(deleted, job)\n            else\n                -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n                jobTS = getTimestamp(jobKey, attributes)\n                if (not jobTS or jobTS <= timestamp) then\n                    removeJob(job, true, jobKeyPrefix, true --[[remove debounce key]] )\n                    deletedCount = deletedCount + 1\n                    table.insert(deleted, job)\n                end\n            end\n        end\n    end\n    if (#deleted > 0) then\n        for from, to in batches(#deleted, 7000) do\n            rcall(\"ZREM\", setKey, unpack(deleted, from, to))\n        end\n    end\n    return {deleted, deletedCount}\nend\nlocal result\nif ARGV[4] == \"active\" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], false --[[ hasFinished ]],\n                      repeatKey)\nelseif ARGV[4] == \"delayed\" then\n  rangeEnd = \"+inf\"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"processedOn\", \"timestamp\"}, false  --[[ hasFinished ]], repeatKey)\nelseif ARGV[4] == \"prioritized\" then\n  rangeEnd = \"+inf\"\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"timestamp\"}, false  --[[ hasFinished ]], repeatKey)\nelseif ARGV[4] == \"wait\" or ARGV[4] == \"paused\" then\n  result = cleanList(KEYS[1], ARGV[1], rangeStart, rangeEnd, ARGV[2], true --[[ hasFinished ]],\n                      repeatKey)\nelse\n  rangeEnd = ARGV[2]\n  -- No need to pass repeat key as in that moment job won't be related to a job scheduler\n  result = cleanSet(KEYS[1], ARGV[1], rangeEnd, ARGV[2], limit,\n                    {\"finishedOn\"}, true  --[[ hasFinished ]])\nend\nrcall(\"XADD\", KEYS[2], \"*\", \"event\", \"cleaned\", \"count\", result[2])\nreturn result[1]\n`;\nconst cleanJobsInSet = {\n    name: 'cleanJobsInSet',\n    content,\n    keys: 3,\n};\n//# sourceMappingURL=cleanJobsInSet-3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvY2xlYW5Kb2JzSW5TZXQtMy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2NsZWFuSm9ic0luU2V0LTMuanM/OWZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVtb3ZlIGpvYnMgZnJvbSB0aGUgc3BlY2lmaWMgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICBzZXQga2V5LFxuICAgIEtFWVNbMl0gIGV2ZW50cyBzdHJlYW0ga2V5XG4gICAgS0VZU1szXSAgcmVwZWF0IGtleVxuICAgIEFSR1ZbMV0gIGpvYktleSBwcmVmaXhcbiAgICBBUkdWWzJdICB0aW1lc3RhbXBcbiAgICBBUkdWWzNdICBsaW1pdCB0aGUgbnVtYmVyIG9mIGpvYnMgdG8gYmUgcmVtb3ZlZC4gMCBpcyB1bmxpbWl0ZWRcbiAgICBBUkdWWzRdICBzZXQgbmFtZSwgY2FuIGJlIGFueSBvZiAnd2FpdCcsICdhY3RpdmUnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAnY29tcGxldGVkJywgb3IgJ2ZhaWxlZCdcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlcGVhdEtleSA9IEtFWVNbM11cbmxvY2FsIHJhbmdlU3RhcnQgPSAwXG5sb2NhbCByYW5nZUVuZCA9IC0xXG5sb2NhbCBsaW1pdCA9IHRvbnVtYmVyKEFSR1ZbM10pXG4tLSBJZiB3ZSdyZSBvbmx5IGRlbGV0aW5nIF9uXyBpdGVtcywgYXZvaWQgcmV0cmlldmluZyBhbGwgaXRlbXNcbi0tIGZvciBmYXN0ZXIgcGVyZm9ybWFuY2Vcbi0tXG4tLSBTdGFydCBmcm9tIHRoZSB0YWlsIG9mIHRoZSBsaXN0LCBzaW5jZSB0aGF0J3Mgd2hlcmUgb2xkZXN0IGVsZW1lbnRzXG4tLSBhcmUgZ2VuZXJhbGx5IGFkZGVkIGZvciBGSUZPIGxpc3RzXG5pZiBsaW1pdCA+IDAgdGhlblxuICByYW5nZVN0YXJ0ID0gLTEgLSBsaW1pdCArIDFcbiAgcmFuZ2VFbmQgPSAtMVxuZW5kXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBjbGVhbiBqb2IgbGlzdC5cbiAgUmV0dXJucyBqb2JJZHMgYW5kIGRlbGV0ZWQgY291bnQgbnVtYmVyLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCB0aGUgbGF0ZXN0IHNhdmVkIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUaW1lc3RhbXAoam9iS2V5LCBhdHRyaWJ1dGVzKVxuICBpZiAjYXR0cmlidXRlcyA9PSAxIHRoZW5cbiAgICByZXR1cm4gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgYXR0cmlidXRlc1sxXSlcbiAgZW5kXG4gIGxvY2FsIGpvYlRzXG4gIGZvciBfLCB0cyBpbiBpcGFpcnMocmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIHVucGFjayhhdHRyaWJ1dGVzKSkpIGRvXG4gICAgaWYgKHRzKSB0aGVuXG4gICAgICBqb2JUcyA9IHRzXG4gICAgICBicmVha1xuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGpvYlRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGpvYiBiZWxvbmdzIHRvIGEgam9iIHNjaGVkdWxlciBhbmRcbiAgY3VycmVudCBkZWxheWVkIGpvYiBtYXRjaGVzIHdpdGggam9iSWRcbl1dXG5sb2NhbCBmdW5jdGlvbiBpc0pvYlNjaGVkdWxlckpvYihqb2JJZCwgam9iS2V5LCBqb2JTY2hlZHVsZXJzS2V5KVxuICBsb2NhbCByZXBlYXRKb2JLZXkgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInJqa1wiKVxuICBpZiByZXBlYXRKb2JLZXkgIHRoZW5cbiAgICBsb2NhbCBwcmV2TWlsbGlzID0gcmNhbGwoXCJaU0NPUkVcIiwgam9iU2NoZWR1bGVyc0tleSwgcmVwZWF0Sm9iS2V5KVxuICAgIGlmIHByZXZNaWxsaXMgdGhlblxuICAgICAgbG9jYWwgY3VycmVudERlbGF5ZWRKb2JJZCA9IFwicmVwZWF0OlwiIC4uIHJlcGVhdEpvYktleSAuLiBcIjpcIiAuLiBwcmV2TWlsbGlzXG4gICAgICByZXR1cm4gam9iSWQgPT0gY3VycmVudERlbGF5ZWRKb2JJZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSwgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICBpZiBzaG91bGRSZW1vdmVEZWR1cGxpY2F0aW9uS2V5IHRoZW5cbiAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwoYmFzZUtleSwgam9iS2V5LCBqb2JJZClcbiAgZW5kXG4gIHJlbW92ZUpvYktleXMoam9iS2V5KVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBjbGVhbkxpc3QobGlzdEtleSwgam9iS2V5UHJlZml4LCByYW5nZVN0YXJ0LCByYW5nZUVuZCxcbiAgdGltZXN0YW1wLCBpc1dhaXRpbmcsIGpvYlNjaGVkdWxlcnNLZXkpXG4gIGxvY2FsIGpvYnMgPSByY2FsbChcIkxSQU5HRVwiLCBsaXN0S2V5LCByYW5nZVN0YXJ0LCByYW5nZUVuZClcbiAgbG9jYWwgZGVsZXRlZCA9IHt9XG4gIGxvY2FsIGRlbGV0ZWRDb3VudCA9IDBcbiAgbG9jYWwgam9iVFNcbiAgbG9jYWwgZGVsZXRpb25NYXJrZXIgPSAnJ1xuICBsb2NhbCBqb2JJZHNMZW4gPSAjam9ic1xuICBmb3IgaSwgam9iIGluIGlwYWlycyhqb2JzKSBkb1xuICAgIGlmIGxpbWl0ID4gMCBhbmQgZGVsZXRlZENvdW50ID49IGxpbWl0IHRoZW5cbiAgICAgIGJyZWFrXG4gICAgZW5kXG4gICAgbG9jYWwgam9iS2V5ID0gam9iS2V5UHJlZml4IC4uIGpvYlxuICAgIGlmIChpc1dhaXRpbmcgb3IgcmNhbGwoXCJFWElTVFNcIiwgam9iS2V5IC4uIFwiOmxvY2tcIikgPT0gMCkgYW5kXG4gICAgICBub3QgaXNKb2JTY2hlZHVsZXJKb2Ioam9iLCBqb2JLZXksIGpvYlNjaGVkdWxlcnNLZXkpIHRoZW5cbiAgICAgIC0tIEZpbmQgdGhlIHJpZ2h0IHRpbWVzdGFtcCBvZiB0aGUgam9iIHRvIGNvbXBhcmUgdG8gbWF4VGltZXN0YW1wOlxuICAgICAgLS0gKiBmaW5pc2hlZE9uIHNheXMgd2hlbiB0aGUgam9iIHdhcyBjb21wbGV0ZWQsIGJ1dCBpdCBpc24ndCBzZXQgdW5sZXNzIHRoZSBqb2IgaGFzIGFjdHVhbGx5IGNvbXBsZXRlZFxuICAgICAgLS0gKiBwcm9jZXNzZWRPbiByZXByZXNlbnRzIHdoZW4gdGhlIGpvYiB3YXMgbGFzdCBhdHRlbXB0ZWQsIGJ1dCBpdCBkb2Vzbid0IGdldCBwb3B1bGF0ZWQgdW50aWxcbiAgICAgIC0tICAgdGhlIGpvYiBpcyBmaXJzdCB0cmllZFxuICAgICAgLS0gKiB0aW1lc3RhbXAgaXMgdGhlIG9yaWdpbmFsIGpvYiBzdWJtaXNzaW9uIHRpbWVcbiAgICAgIC0tIEZldGNoIGFsbCB0aHJlZSBvZiB0aGVzZSAoaW4gdGhhdCBvcmRlcikgYW5kIHVzZSB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgc2V0IHNvIHRoYXQgd2UnbGwgbGVhdmUgam9ic1xuICAgICAgLS0gdGhhdCBoYXZlIGJlZW4gYWN0aXZlIHdpdGhpbiB0aGUgZ3JhY2UgcGVyaW9kOlxuICAgICAgam9iVFMgPSBnZXRUaW1lc3RhbXAoam9iS2V5LCB7XCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJ0aW1lc3RhbXBcIn0pXG4gICAgICBpZiAobm90IGpvYlRTIG9yIGpvYlRTIDw9IHRpbWVzdGFtcCkgdGhlblxuICAgICAgICAtLSByZXBsYWNlIHRoZSBlbnRyeSB3aXRoIGEgZGVsZXRpb24gbWFya2VyOyB0aGUgYWN0dWFsIGRlbGV0aW9uIHdpbGxcbiAgICAgICAgLS0gb2NjdXIgYXQgdGhlIGVuZCBvZiB0aGUgc2NyaXB0XG4gICAgICAgIHJjYWxsKFwiTFNFVFwiLCBsaXN0S2V5LCByYW5nZUVuZCAtIGpvYklkc0xlbiArIGksIGRlbGV0aW9uTWFya2VyKVxuICAgICAgICByZW1vdmVKb2Ioam9iLCB0cnVlLCBqb2JLZXlQcmVmaXgsIHRydWUgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSlcbiAgICAgICAgZGVsZXRlZENvdW50ID0gZGVsZXRlZENvdW50ICsgMVxuICAgICAgICB0YWJsZS5pbnNlcnQoZGVsZXRlZCwgam9iKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByY2FsbChcIkxSRU1cIiwgbGlzdEtleSwgMCwgZGVsZXRpb25NYXJrZXIpXG4gIHJldHVybiB7ZGVsZXRlZCwgZGVsZXRlZENvdW50fVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNsZWFuIGpvYiBzZXQuXG4gIFJldHVybnMgam9iSWRzIGFuZCBkZWxldGVkIGNvdW50IG51bWJlci5cbl1dIFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbG9vcCBpbiBiYXRjaGVzLlxuICBKdXN0IGEgYml0IG9mIHdhcm5pbmcsIHNvbWUgY29tbWFuZHMgYXMgWlJFTVxuICBjb3VsZCByZWNlaXZlIGEgbWF4aW11bSBvZiA3MDAwIHBhcmFtZXRlcnMgcGVyIGNhbGwuXG5dXVxubG9jYWwgZnVuY3Rpb24gYmF0Y2hlcyhuLCBiYXRjaFNpemUpXG4gIGxvY2FsIGkgPSAwXG4gIHJldHVybiBmdW5jdGlvbigpXG4gICAgbG9jYWwgZnJvbSA9IGkgKiBiYXRjaFNpemUgKyAxXG4gICAgaSA9IGkgKyAxXG4gICAgaWYgKGZyb20gPD0gbikgdGhlblxuICAgICAgbG9jYWwgdG8gPSBtYXRoLm1pbihmcm9tICsgYmF0Y2hTaXplIC0gMSwgbilcbiAgICAgIHJldHVybiBmcm9tLCB0b1xuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBXZSB1c2UgWlJBTkdFQllTQ09SRSB0byBtYWtlIHRoZSBjYXNlIHdoZXJlIHdlJ3JlIGRlbGV0aW5nIGEgbGltaXRlZCBudW1iZXJcbiAgb2YgaXRlbXMgaW4gYSBzb3J0ZWQgc2V0IG9ubHkgcnVuIGEgc2luZ2xlIGl0ZXJhdGlvbi4gSWYgd2Ugc2ltcGx5IHVzZWRcbiAgWlJBTkdFLCB3ZSBtYXkgdGFrZSBhIGxvbmcgdGltZSB0cmF2ZXJzaW5nIHRocm91Z2ggam9icyB0aGF0IGFyZSB3aXRoaW4gdGhlXG4gIGdyYWNlIHBlcmlvZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRKb2JzSW5ac2V0KHpzZXRLZXksIHJhbmdlRW5kLCBsaW1pdClcbiAgaWYgbGltaXQgPiAwIHRoZW5cbiAgICByZXR1cm4gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIHpzZXRLZXksIDAsIHJhbmdlRW5kLCBcIkxJTUlUXCIsIDAsIGxpbWl0KVxuICBlbHNlXG4gICAgcmV0dXJuIHJjYWxsKFwiWlJBTkdFQllTQ09SRVwiLCB6c2V0S2V5LCAwLCByYW5nZUVuZClcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGNsZWFuU2V0KFxuICAgIHNldEtleSxcbiAgICBqb2JLZXlQcmVmaXgsXG4gICAgcmFuZ2VFbmQsXG4gICAgdGltZXN0YW1wLFxuICAgIGxpbWl0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNGaW5pc2hlZCxcbiAgICBqb2JTY2hlZHVsZXJzS2V5KVxuICAgIGxvY2FsIGpvYnMgPSBnZXRKb2JzSW5ac2V0KHNldEtleSwgcmFuZ2VFbmQsIGxpbWl0KVxuICAgIGxvY2FsIGRlbGV0ZWQgPSB7fVxuICAgIGxvY2FsIGRlbGV0ZWRDb3VudCA9IDBcbiAgICBsb2NhbCBqb2JUU1xuICAgIGZvciBpLCBqb2IgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgIGlmIGxpbWl0ID4gMCBhbmQgZGVsZXRlZENvdW50ID49IGxpbWl0IHRoZW5cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGVuZFxuICAgICAgICBsb2NhbCBqb2JLZXkgPSBqb2JLZXlQcmVmaXggLi4gam9iXG4gICAgICAgIC0tIEV4dHJhY3QgYSBKb2IgU2NoZWR1bGVyIElkIGZyb20gam9iSWQgKFwicmVwZWF0OmpvYi1zY2hlZHVsZXItaWQ6bWlsbGlzXCIpIFxuICAgICAgICAtLSBhbmQgY2hlY2sgaWYgaXQgaXMgaW4gdGhlIHNjaGVkdWxlZCBqb2JzXG4gICAgICAgIGlmIG5vdCAoam9iU2NoZWR1bGVyc0tleSBhbmQgaXNKb2JTY2hlZHVsZXJKb2Ioam9iLCBqb2JLZXksIGpvYlNjaGVkdWxlcnNLZXkpKSB0aGVuXG4gICAgICAgICAgICBpZiBpc0ZpbmlzaGVkIHRoZW5cbiAgICAgICAgICAgICAgICByZW1vdmVKb2Ioam9iLCB0cnVlLCBqb2JLZXlQcmVmaXgsIHRydWUgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSApXG4gICAgICAgICAgICAgICAgZGVsZXRlZENvdW50ID0gZGVsZXRlZENvdW50ICsgMVxuICAgICAgICAgICAgICAgIHRhYmxlLmluc2VydChkZWxldGVkLCBqb2IpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLS0gKiBmaW5pc2hlZE9uIHNheXMgd2hlbiB0aGUgam9iIHdhcyBjb21wbGV0ZWQsIGJ1dCBpdCBpc24ndCBzZXQgdW5sZXNzIHRoZSBqb2IgaGFzIGFjdHVhbGx5IGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIGpvYlRTID0gZ2V0VGltZXN0YW1wKGpvYktleSwgYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICBpZiAobm90IGpvYlRTIG9yIGpvYlRTIDw9IHRpbWVzdGFtcCkgdGhlblxuICAgICAgICAgICAgICAgICAgICByZW1vdmVKb2Ioam9iLCB0cnVlLCBqb2JLZXlQcmVmaXgsIHRydWUgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCA9IGRlbGV0ZWRDb3VudCArIDFcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuaW5zZXJ0KGRlbGV0ZWQsIGpvYilcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBpZiAoI2RlbGV0ZWQgPiAwKSB0aGVuXG4gICAgICAgIGZvciBmcm9tLCB0byBpbiBiYXRjaGVzKCNkZWxldGVkLCA3MDAwKSBkb1xuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHNldEtleSwgdW5wYWNrKGRlbGV0ZWQsIGZyb20sIHRvKSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIHtkZWxldGVkLCBkZWxldGVkQ291bnR9XG5lbmRcbmxvY2FsIHJlc3VsdFxuaWYgQVJHVls0XSA9PSBcImFjdGl2ZVwiIHRoZW5cbiAgcmVzdWx0ID0gY2xlYW5MaXN0KEtFWVNbMV0sIEFSR1ZbMV0sIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBBUkdWWzJdLCBmYWxzZSAtLVtbIGhhc0ZpbmlzaGVkIF1dLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdEtleSlcbmVsc2VpZiBBUkdWWzRdID09IFwiZGVsYXllZFwiIHRoZW5cbiAgcmFuZ2VFbmQgPSBcIitpbmZcIlxuICByZXN1bHQgPSBjbGVhblNldChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZUVuZCwgQVJHVlsyXSwgbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHtcInByb2Nlc3NlZE9uXCIsIFwidGltZXN0YW1wXCJ9LCBmYWxzZSAgLS1bWyBoYXNGaW5pc2hlZCBdXSwgcmVwZWF0S2V5KVxuZWxzZWlmIEFSR1ZbNF0gPT0gXCJwcmlvcml0aXplZFwiIHRoZW5cbiAgcmFuZ2VFbmQgPSBcIitpbmZcIlxuICByZXN1bHQgPSBjbGVhblNldChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZUVuZCwgQVJHVlsyXSwgbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHtcInRpbWVzdGFtcFwifSwgZmFsc2UgIC0tW1sgaGFzRmluaXNoZWQgXV0sIHJlcGVhdEtleSlcbmVsc2VpZiBBUkdWWzRdID09IFwid2FpdFwiIG9yIEFSR1ZbNF0gPT0gXCJwYXVzZWRcIiB0aGVuXG4gIHJlc3VsdCA9IGNsZWFuTGlzdChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgQVJHVlsyXSwgdHJ1ZSAtLVtbIGhhc0ZpbmlzaGVkIF1dLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdEtleSlcbmVsc2VcbiAgcmFuZ2VFbmQgPSBBUkdWWzJdXG4gIC0tIE5vIG5lZWQgdG8gcGFzcyByZXBlYXQga2V5IGFzIGluIHRoYXQgbW9tZW50IGpvYiB3b24ndCBiZSByZWxhdGVkIHRvIGEgam9iIHNjaGVkdWxlclxuICByZXN1bHQgPSBjbGVhblNldChLRVlTWzFdLCBBUkdWWzFdLCByYW5nZUVuZCwgQVJHVlsyXSwgbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHtcImZpbmlzaGVkT25cIn0sIHRydWUgIC0tW1sgaGFzRmluaXNoZWQgXV0pXG5lbmRcbnJjYWxsKFwiWEFERFwiLCBLRVlTWzJdLCBcIipcIiwgXCJldmVudFwiLCBcImNsZWFuZWRcIiwgXCJjb3VudFwiLCByZXN1bHRbMl0pXG5yZXR1cm4gcmVzdWx0WzFdXG5gO1xuZXhwb3J0IGNvbnN0IGNsZWFuSm9ic0luU2V0ID0ge1xuICAgIG5hbWU6ICdjbGVhbkpvYnNJblNldCcsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAzLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsZWFuSm9ic0luU2V0LTMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-5.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/drain-5.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drain: () => (/* binding */ drain)\n/* harmony export */ });\nconst content = `--[[\n  Drains the queue, removes all jobs that are waiting\n  or delayed, but not active, completed or failed\n  Input:\n    KEYS[1] 'wait',\n    KEYS[2] 'paused'\n    KEYS[3] 'delayed'\n    KEYS[4] 'prioritized'\n    KEYS[5] 'jobschedulers' (repeat)\n    ARGV[1]  queue key prefix\n    ARGV[2]  should clean delayed jobs\n]]\nlocal rcall = redis.call\nlocal queueBaseKey = ARGV[1]\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to filter out jobs to ignore from a table.\n]]\nlocal function filterOutJobsToIgnore(jobs, jobsToIgnore)\n  local filteredJobs = {}\n  for i = 1, #jobs do\n    if not jobsToIgnore[jobs[i]] then\n      table.insert(filteredJobs, jobs[i])\n    end\n  end\n  return filteredJobs\nend\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey, true --[[remove debounce key]])\n  end\n  return max - #keys\nend\nlocal function getListItems(keyName, max)\n  return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getListItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall(\"LTRIM\", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getZSetItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall(\"ZREM\", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\n-- We must not remove delayed jobs if they are associated to a job scheduler.\nlocal scheduledJobs = {}\nlocal jobSchedulers = rcall(\"ZRANGE\", KEYS[5], 0, -1, \"WITHSCORES\")\n-- For every job scheduler, get the current delayed job id.\nfor i = 1, #jobSchedulers, 2 do\n    local jobSchedulerId = jobSchedulers[i]\n    local jobSchedulerMillis = jobSchedulers[i + 1]\n    local delayedJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. jobSchedulerMillis\n    scheduledJobs[delayedJobId] = true\nend\nremoveListJobs(KEYS[1], true, queueBaseKey, 0, scheduledJobs) -- wait\nremoveListJobs(KEYS[2], true, queueBaseKey, 0, scheduledJobs) -- paused\nif ARGV[2] == \"1\" then\n  removeZSetJobs(KEYS[3], true, queueBaseKey, 0, scheduledJobs) -- delayed\nend\nremoveZSetJobs(KEYS[4], true, queueBaseKey, 0, scheduledJobs) -- prioritized\n`;\nconst drain = {\n    name: 'drain',\n    content,\n    keys: 5,\n};\n//# sourceMappingURL=drain-5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZHJhaW4tNS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZHJhaW4tNS5qcz9iYzRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBEcmFpbnMgdGhlIHF1ZXVlLCByZW1vdmVzIGFsbCBqb2JzIHRoYXQgYXJlIHdhaXRpbmdcbiAgb3IgZGVsYXllZCwgYnV0IG5vdCBhY3RpdmUsIGNvbXBsZXRlZCBvciBmYWlsZWRcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAnd2FpdCcsXG4gICAgS0VZU1syXSAncGF1c2VkJ1xuICAgIEtFWVNbM10gJ2RlbGF5ZWQnXG4gICAgS0VZU1s0XSAncHJpb3JpdGl6ZWQnXG4gICAgS0VZU1s1XSAnam9ic2NoZWR1bGVycycgKHJlcGVhdClcbiAgICBBUkdWWzFdICBxdWV1ZSBrZXkgcHJlZml4XG4gICAgQVJHVlsyXSAgc2hvdWxkIGNsZWFuIGRlbGF5ZWQgam9ic1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgcXVldWVCYXNlS2V5ID0gQVJHVlsxXVxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZmlsdGVyIG91dCBqb2JzIHRvIGlnbm9yZSBmcm9tIGEgdGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZmlsdGVyT3V0Sm9ic1RvSWdub3JlKGpvYnMsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgZmlsdGVyZWRKb2JzID0ge31cbiAgZm9yIGkgPSAxLCAjam9icyBkb1xuICAgIGlmIG5vdCBqb2JzVG9JZ25vcmVbam9ic1tpXV0gdGhlblxuICAgICAgdGFibGUuaW5zZXJ0KGZpbHRlcmVkSm9icywgam9ic1tpXSlcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmaWx0ZXJlZEpvYnNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSwgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICBpZiBzaG91bGRSZW1vdmVEZWR1cGxpY2F0aW9uS2V5IHRoZW5cbiAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwoYmFzZUtleSwgam9iS2V5LCBqb2JJZClcbiAgZW5kXG4gIHJlbW92ZUpvYktleXMoam9iS2V5KVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzKGtleXMsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgZm9yIGksIGtleSBpbiBpcGFpcnMoa2V5cykgZG9cbiAgICByZW1vdmVKb2Ioa2V5LCBoYXJkLCBiYXNlS2V5LCB0cnVlIC0tW1tyZW1vdmUgZGVib3VuY2Uga2V5XV0pXG4gIGVuZFxuICByZXR1cm4gbWF4IC0gI2tleXNcbmVuZFxubG9jYWwgZnVuY3Rpb24gZ2V0TGlzdEl0ZW1zKGtleU5hbWUsIG1heClcbiAgcmV0dXJuIHJjYWxsKCdMUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMaXN0Sm9icyhrZXlOYW1lLCBoYXJkLCBiYXNlS2V5LCBtYXgsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgam9icyA9IGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGlmIGpvYnNUb0lnbm9yZSB0aGVuXG4gICAgam9icyA9IGZpbHRlck91dEpvYnNUb0lnbm9yZShqb2JzLCBqb2JzVG9JZ25vcmUpXG4gIGVuZFxuICBsb2NhbCBjb3VudCA9IHJlbW92ZUpvYnMoam9icywgaGFyZCwgYmFzZUtleSwgbWF4KVxuICByY2FsbChcIkxUUklNXCIsIGtleU5hbWUsICNqb2JzLCAtMSlcbiAgcmV0dXJuIGNvdW50XG5lbmRcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IFpTZXQgaXRlbXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0WlNldEl0ZW1zKGtleU5hbWUsIG1heClcbiAgcmV0dXJuIHJjYWxsKCdaUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVaU2V0Sm9icyhrZXlOYW1lLCBoYXJkLCBiYXNlS2V5LCBtYXgsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgam9icyA9IGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGlmIGpvYnNUb0lnbm9yZSB0aGVuXG4gICAgam9icyA9IGZpbHRlck91dEpvYnNUb0lnbm9yZShqb2JzLCBqb2JzVG9JZ25vcmUpXG4gIGVuZFxuICBsb2NhbCBjb3VudCA9IHJlbW92ZUpvYnMoam9icywgaGFyZCwgYmFzZUtleSwgbWF4KVxuICBpZigjam9icyA+IDApIHRoZW5cbiAgICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjam9icywgNzAwMCkgZG9cbiAgICAgIHJjYWxsKFwiWlJFTVwiLCBrZXlOYW1lLCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGNvdW50XG5lbmRcbi0tIFdlIG11c3Qgbm90IHJlbW92ZSBkZWxheWVkIGpvYnMgaWYgdGhleSBhcmUgYXNzb2NpYXRlZCB0byBhIGpvYiBzY2hlZHVsZXIuXG5sb2NhbCBzY2hlZHVsZWRKb2JzID0ge31cbmxvY2FsIGpvYlNjaGVkdWxlcnMgPSByY2FsbChcIlpSQU5HRVwiLCBLRVlTWzVdLCAwLCAtMSwgXCJXSVRIU0NPUkVTXCIpXG4tLSBGb3IgZXZlcnkgam9iIHNjaGVkdWxlciwgZ2V0IHRoZSBjdXJyZW50IGRlbGF5ZWQgam9iIGlkLlxuZm9yIGkgPSAxLCAjam9iU2NoZWR1bGVycywgMiBkb1xuICAgIGxvY2FsIGpvYlNjaGVkdWxlcklkID0gam9iU2NoZWR1bGVyc1tpXVxuICAgIGxvY2FsIGpvYlNjaGVkdWxlck1pbGxpcyA9IGpvYlNjaGVkdWxlcnNbaSArIDFdXG4gICAgbG9jYWwgZGVsYXllZEpvYklkID0gXCJyZXBlYXQ6XCIgLi4gam9iU2NoZWR1bGVySWQgLi4gXCI6XCIgLi4gam9iU2NoZWR1bGVyTWlsbGlzXG4gICAgc2NoZWR1bGVkSm9ic1tkZWxheWVkSm9iSWRdID0gdHJ1ZVxuZW5kXG5yZW1vdmVMaXN0Sm9icyhLRVlTWzFdLCB0cnVlLCBxdWV1ZUJhc2VLZXksIDAsIHNjaGVkdWxlZEpvYnMpIC0tIHdhaXRcbnJlbW92ZUxpc3RKb2JzKEtFWVNbMl0sIHRydWUsIHF1ZXVlQmFzZUtleSwgMCwgc2NoZWR1bGVkSm9icykgLS0gcGF1c2VkXG5pZiBBUkdWWzJdID09IFwiMVwiIHRoZW5cbiAgcmVtb3ZlWlNldEpvYnMoS0VZU1szXSwgdHJ1ZSwgcXVldWVCYXNlS2V5LCAwLCBzY2hlZHVsZWRKb2JzKSAtLSBkZWxheWVkXG5lbmRcbnJlbW92ZVpTZXRKb2JzKEtFWVNbNF0sIHRydWUsIHF1ZXVlQmFzZUtleSwgMCwgc2NoZWR1bGVkSm9icykgLS0gcHJpb3JpdGl6ZWRcbmA7XG5leHBvcnQgY29uc3QgZHJhaW4gPSB7XG4gICAgbmFtZTogJ2RyYWluJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhaW4tNS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/extendLock-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendLock: () => (/* binding */ extendLock)\n/* harmony export */ });\nconst content = `--[[\n  Extend lock and removes the job from the stalled set.\n  Input:\n    KEYS[1] 'lock',\n    KEYS[2] 'stalled'\n    ARGV[1]  token\n    ARGV[2]  lock duration in milliseconds\n    ARGV[3]  jobid\n  Output:\n    \"1\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  --   if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2], \"XX\") then\n  if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2]) then\n    rcall(\"SREM\", KEYS[2], ARGV[3])\n    return 1\n  end\nend\nreturn 0\n`;\nconst extendLock = {\n    name: 'extendLock',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=extendLock-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZXh0ZW5kTG9jay0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2V4dGVuZExvY2stMi5qcz84MjA3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBFeHRlbmQgbG9jayBhbmQgcmVtb3ZlcyB0aGUgam9iIGZyb20gdGhlIHN0YWxsZWQgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICdsb2NrJyxcbiAgICBLRVlTWzJdICdzdGFsbGVkJ1xuICAgIEFSR1ZbMV0gIHRva2VuXG4gICAgQVJHVlsyXSAgbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICBBUkdWWzNdICBqb2JpZFxuICBPdXRwdXQ6XG4gICAgXCIxXCIgaWYgbG9jayBleHRlbnRlZCBzdWNjZXNmdWxseS5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiR0VUXCIsIEtFWVNbMV0pID09IEFSR1ZbMV0gdGhlblxuICAtLSAgIGlmIHJjYWxsKFwiU0VUXCIsIEtFWVNbMV0sIEFSR1ZbMV0sIFwiUFhcIiwgQVJHVlsyXSwgXCJYWFwiKSB0aGVuXG4gIGlmIHJjYWxsKFwiU0VUXCIsIEtFWVNbMV0sIEFSR1ZbMV0sIFwiUFhcIiwgQVJHVlsyXSkgdGhlblxuICAgIHJjYWxsKFwiU1JFTVwiLCBLRVlTWzJdLCBBUkdWWzNdKVxuICAgIHJldHVybiAxXG4gIGVuZFxuZW5kXG5yZXR1cm4gMFxuYDtcbmV4cG9ydCBjb25zdCBleHRlbmRMb2NrID0ge1xuICAgIG5hbWU6ICdleHRlbmRMb2NrJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDIsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW5kTG9jay0yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLocks-1.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/extendLocks-1.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extendLocks: () => (/* binding */ extendLocks)\n/* harmony export */ });\nconst content = `--[[\n  Extend locks for multiple jobs and remove them from the stalled set if successful.\n  Return the list of job IDs for which the operation failed.\n  KEYS[1] = stalledKey\n  ARGV[1] = baseKey\n  ARGV[2] = tokens\n  ARGV[3] = jobIds\n  ARGV[4] = lockDuration (ms)\n  Output:\n    An array of failed job IDs. If empty, all succeeded.\n]]\nlocal rcall = redis.call\nlocal stalledKey = KEYS[1]\nlocal baseKey = ARGV[1]\nlocal tokens = cmsgpack.unpack(ARGV[2])\nlocal jobIds = cmsgpack.unpack(ARGV[3])\nlocal lockDuration = ARGV[4]\nlocal jobCount = #jobIds\nlocal failedJobs = {}\nfor i = 1, jobCount, 1 do\n    local lockKey = baseKey .. jobIds[i] .. ':lock'\n    local jobId = jobIds[i]\n    local token = tokens[i]\n    local currentToken = rcall(\"GET\", lockKey)\n    if currentToken == token then\n        local setResult = rcall(\"SET\", lockKey, token, \"PX\", lockDuration)\n        if setResult then\n            rcall(\"SREM\", stalledKey, jobId)\n        else\n            table.insert(failedJobs, jobId)\n        end\n    else\n        table.insert(failedJobs, jobId)\n    end\nend\nreturn failedJobs\n`;\nconst extendLocks = {\n    name: 'extendLocks',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=extendLocks-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZXh0ZW5kTG9ja3MtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2V4dGVuZExvY2tzLTEuanM/MWVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgRXh0ZW5kIGxvY2tzIGZvciBtdWx0aXBsZSBqb2JzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdGFsbGVkIHNldCBpZiBzdWNjZXNzZnVsLlxuICBSZXR1cm4gdGhlIGxpc3Qgb2Ygam9iIElEcyBmb3Igd2hpY2ggdGhlIG9wZXJhdGlvbiBmYWlsZWQuXG4gIEtFWVNbMV0gPSBzdGFsbGVkS2V5XG4gIEFSR1ZbMV0gPSBiYXNlS2V5XG4gIEFSR1ZbMl0gPSB0b2tlbnNcbiAgQVJHVlszXSA9IGpvYklkc1xuICBBUkdWWzRdID0gbG9ja0R1cmF0aW9uIChtcylcbiAgT3V0cHV0OlxuICAgIEFuIGFycmF5IG9mIGZhaWxlZCBqb2IgSURzLiBJZiBlbXB0eSwgYWxsIHN1Y2NlZWRlZC5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHN0YWxsZWRLZXkgPSBLRVlTWzFdXG5sb2NhbCBiYXNlS2V5ID0gQVJHVlsxXVxubG9jYWwgdG9rZW5zID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbMl0pXG5sb2NhbCBqb2JJZHMgPSBjbXNncGFjay51bnBhY2soQVJHVlszXSlcbmxvY2FsIGxvY2tEdXJhdGlvbiA9IEFSR1ZbNF1cbmxvY2FsIGpvYkNvdW50ID0gI2pvYklkc1xubG9jYWwgZmFpbGVkSm9icyA9IHt9XG5mb3IgaSA9IDEsIGpvYkNvdW50LCAxIGRvXG4gICAgbG9jYWwgbG9ja0tleSA9IGJhc2VLZXkgLi4gam9iSWRzW2ldIC4uICc6bG9jaydcbiAgICBsb2NhbCBqb2JJZCA9IGpvYklkc1tpXVxuICAgIGxvY2FsIHRva2VuID0gdG9rZW5zW2ldXG4gICAgbG9jYWwgY3VycmVudFRva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICBpZiBjdXJyZW50VG9rZW4gPT0gdG9rZW4gdGhlblxuICAgICAgICBsb2NhbCBzZXRSZXN1bHQgPSByY2FsbChcIlNFVFwiLCBsb2NrS2V5LCB0b2tlbiwgXCJQWFwiLCBsb2NrRHVyYXRpb24pXG4gICAgICAgIGlmIHNldFJlc3VsdCB0aGVuXG4gICAgICAgICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhYmxlLmluc2VydChmYWlsZWRKb2JzLCBqb2JJZClcbiAgICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgICB0YWJsZS5pbnNlcnQoZmFpbGVkSm9icywgam9iSWQpXG4gICAgZW5kXG5lbmRcbnJldHVybiBmYWlsZWRKb2JzXG5gO1xuZXhwb3J0IGNvbnN0IGV4dGVuZExvY2tzID0ge1xuICAgIG5hbWU6ICdleHRlbmRMb2NrcycsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuZExvY2tzLTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLocks-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getCounts-1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCounts: () => (/* binding */ getCounts)\n/* harmony export */ });\nconst content = `--[[\n  Get counts per provided states\n    Input:\n      KEYS[1]    'prefix'\n      ARGV[1...] types\n]]\nlocal rcall = redis.call;\nlocal prefix = KEYS[1]\nlocal results = {}\nfor i = 1, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == \"wait\" or ARGV[i] == \"paused\" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall(\"LINDEX\", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then\n      local count = rcall(\"LLEN\", stateKey)\n      if count > 1 then\n        rcall(\"RPOP\", stateKey)\n        results[#results+1] = count-1\n      else\n        results[#results+1] = 0\n      end\n    else\n      results[#results+1] = rcall(\"LLEN\", stateKey)\n    end\n  elseif ARGV[i] == \"active\" then\n    results[#results+1] = rcall(\"LLEN\", stateKey)\n  else\n    results[#results+1] = rcall(\"ZCARD\", stateKey)\n  end\nend\nreturn results\n`;\nconst getCounts = {\n    name: 'getCounts',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=getCounts-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0Q291bnRzLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0Q291bnRzLTEuanM/YzRiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IGNvdW50cyBwZXIgcHJvdmlkZWQgc3RhdGVzXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICAgICdwcmVmaXgnXG4gICAgICBBUkdWWzEuLi5dIHR5cGVzXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsO1xubG9jYWwgcHJlZml4ID0gS0VZU1sxXVxubG9jYWwgcmVzdWx0cyA9IHt9XG5mb3IgaSA9IDEsICNBUkdWIGRvXG4gIGxvY2FsIHN0YXRlS2V5ID0gcHJlZml4IC4uIEFSR1ZbaV1cbiAgaWYgQVJHVltpXSA9PSBcIndhaXRcIiBvciBBUkdWW2ldID09IFwicGF1c2VkXCIgdGhlblxuICAgIC0tIE1hcmtlcnMgaW4gd2FpdGxpc3QgREVQUkVDQVRFRCBpbiB2NTogUmVtb3ZlIGluIHY2LlxuICAgIGxvY2FsIG1hcmtlciA9IHJjYWxsKFwiTElOREVYXCIsIHN0YXRlS2V5LCAtMSlcbiAgICBpZiBtYXJrZXIgYW5kIHN0cmluZy5zdWIobWFya2VyLCAxLCAyKSA9PSBcIjA6XCIgdGhlblxuICAgICAgbG9jYWwgY291bnQgPSByY2FsbChcIkxMRU5cIiwgc3RhdGVLZXkpXG4gICAgICBpZiBjb3VudCA+IDEgdGhlblxuICAgICAgICByY2FsbChcIlJQT1BcIiwgc3RhdGVLZXkpXG4gICAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSBjb3VudC0xXG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSAwXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJMTEVOXCIsIHN0YXRlS2V5KVxuICAgIGVuZFxuICBlbHNlaWYgQVJHVltpXSA9PSBcImFjdGl2ZVwiIHRoZW5cbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJMTEVOXCIsIHN0YXRlS2V5KVxuICBlbHNlXG4gICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiWkNBUkRcIiwgc3RhdGVLZXkpXG4gIGVuZFxuZW5kXG5yZXR1cm4gcmVzdWx0c1xuYDtcbmV4cG9ydCBjb25zdCBnZXRDb3VudHMgPSB7XG4gICAgbmFtZTogJ2dldENvdW50cycsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENvdW50cy0xLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getCountsPerPriority-4.js":
/*!************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getCountsPerPriority-4.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCountsPerPriority: () => (/* binding */ getCountsPerPriority)\n/* harmony export */ });\nconst content = `--[[\n  Get counts per provided states\n    Input:\n      KEYS[1] wait key\n      KEYS[2] paused key\n      KEYS[3] meta key\n      KEYS[4] prioritized key\n      ARGV[1...] priorities\n]]\nlocal rcall = redis.call\nlocal results = {}\nlocal waitKey = KEYS[1]\nlocal pausedKey = KEYS[2]\nlocal prioritizedKey = KEYS[4]\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\nfor i = 1, #ARGV do\n  local priority = tonumber(ARGV[i])\n  if priority == 0 then\n    if isQueuePaused(KEYS[3]) then\n      results[#results+1] = rcall(\"LLEN\", pausedKey)\n    else\n      results[#results+1] = rcall(\"LLEN\", waitKey)\n    end\n  else\n    results[#results+1] = rcall(\"ZCOUNT\", prioritizedKey,\n      priority * 0x100000000, (priority + 1)  * 0x100000000 - 1)\n  end\nend\nreturn results\n`;\nconst getCountsPerPriority = {\n    name: 'getCountsPerPriority',\n    content,\n    keys: 4,\n};\n//# sourceMappingURL=getCountsPerPriority-4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0Q291bnRzUGVyUHJpb3JpdHktNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2dldENvdW50c1BlclByaW9yaXR5LTQuanM/NDkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IGNvdW50cyBwZXIgcHJvdmlkZWQgc3RhdGVzXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgICBLRVlTWzJdIHBhdXNlZCBrZXlcbiAgICAgIEtFWVNbM10gbWV0YSBrZXlcbiAgICAgIEtFWVNbNF0gcHJpb3JpdGl6ZWQga2V5XG4gICAgICBBUkdWWzEuLi5dIHByaW9yaXRpZXNcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlc3VsdHMgPSB7fVxubG9jYWwgd2FpdEtleSA9IEtFWVNbMV1cbmxvY2FsIHBhdXNlZEtleSA9IEtFWVNbMl1cbmxvY2FsIHByaW9yaXRpemVkS2V5ID0gS0VZU1s0XVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkKHF1ZXVlTWV0YUtleSlcbiAgcmV0dXJuIHJjYWxsKFwiSEVYSVNUU1wiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIpID09IDFcbmVuZFxuZm9yIGkgPSAxLCAjQVJHViBkb1xuICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKEFSR1ZbaV0pXG4gIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgIGlmIGlzUXVldWVQYXVzZWQoS0VZU1szXSkgdGhlblxuICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiTExFTlwiLCBwYXVzZWRLZXkpXG4gICAgZWxzZVxuICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiTExFTlwiLCB3YWl0S2V5KVxuICAgIGVuZFxuICBlbHNlXG4gICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiWkNPVU5UXCIsIHByaW9yaXRpemVkS2V5LFxuICAgICAgcHJpb3JpdHkgKiAweDEwMDAwMDAwMCwgKHByaW9yaXR5ICsgMSkgICogMHgxMDAwMDAwMDAgLSAxKVxuICBlbmRcbmVuZFxucmV0dXJuIHJlc3VsdHNcbmA7XG5leHBvcnQgY29uc3QgZ2V0Q291bnRzUGVyUHJpb3JpdHkgPSB7XG4gICAgbmFtZTogJ2dldENvdW50c1BlclByaW9yaXR5JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q291bnRzUGVyUHJpb3JpdHktNC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getCountsPerPriority-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getDependencyCounts-4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getDependencyCounts-4.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDependencyCounts: () => (/* binding */ getDependencyCounts)\n/* harmony export */ });\nconst content = `--[[\n  Get counts per child states\n    Input:\n      KEYS[1]    processed key\n      KEYS[2]    unprocessed key\n      KEYS[3]    ignored key\n      KEYS[4]    failed key\n      ARGV[1...] types\n]]\nlocal rcall = redis.call;\nlocal processedKey = KEYS[1]\nlocal unprocessedKey = KEYS[2]\nlocal ignoredKey = KEYS[3]\nlocal failedKey = KEYS[4]\nlocal results = {}\nfor i = 1, #ARGV do\n  if ARGV[i] == \"processed\" then\n    results[#results+1] = rcall(\"HLEN\", processedKey)\n  elseif ARGV[i] == \"unprocessed\" then\n    results[#results+1] = rcall(\"SCARD\", unprocessedKey)\n  elseif ARGV[i] == \"ignored\" then\n    results[#results+1] = rcall(\"HLEN\", ignoredKey)\n  else\n    results[#results+1] = rcall(\"ZCARD\", failedKey)\n  end\nend\nreturn results\n`;\nconst getDependencyCounts = {\n    name: 'getDependencyCounts',\n    content,\n    keys: 4,\n};\n//# sourceMappingURL=getDependencyCounts-4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0RGVwZW5kZW5jeUNvdW50cy00LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0RGVwZW5kZW5jeUNvdW50cy00LmpzPzliZGIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEdldCBjb3VudHMgcGVyIGNoaWxkIHN0YXRlc1xuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAgICBwcm9jZXNzZWQga2V5XG4gICAgICBLRVlTWzJdICAgIHVucHJvY2Vzc2VkIGtleVxuICAgICAgS0VZU1szXSAgICBpZ25vcmVkIGtleVxuICAgICAgS0VZU1s0XSAgICBmYWlsZWQga2V5XG4gICAgICBBUkdWWzEuLi5dIHR5cGVzXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsO1xubG9jYWwgcHJvY2Vzc2VkS2V5ID0gS0VZU1sxXVxubG9jYWwgdW5wcm9jZXNzZWRLZXkgPSBLRVlTWzJdXG5sb2NhbCBpZ25vcmVkS2V5ID0gS0VZU1szXVxubG9jYWwgZmFpbGVkS2V5ID0gS0VZU1s0XVxubG9jYWwgcmVzdWx0cyA9IHt9XG5mb3IgaSA9IDEsICNBUkdWIGRvXG4gIGlmIEFSR1ZbaV0gPT0gXCJwcm9jZXNzZWRcIiB0aGVuXG4gICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiSExFTlwiLCBwcm9jZXNzZWRLZXkpXG4gIGVsc2VpZiBBUkdWW2ldID09IFwidW5wcm9jZXNzZWRcIiB0aGVuXG4gICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiU0NBUkRcIiwgdW5wcm9jZXNzZWRLZXkpXG4gIGVsc2VpZiBBUkdWW2ldID09IFwiaWdub3JlZFwiIHRoZW5cbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJITEVOXCIsIGlnbm9yZWRLZXkpXG4gIGVsc2VcbiAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gcmNhbGwoXCJaQ0FSRFwiLCBmYWlsZWRLZXkpXG4gIGVuZFxuZW5kXG5yZXR1cm4gcmVzdWx0c1xuYDtcbmV4cG9ydCBjb25zdCBnZXREZXBlbmRlbmN5Q291bnRzID0ge1xuICAgIG5hbWU6ICdnZXREZXBlbmRlbmN5Q291bnRzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RGVwZW5kZW5jeUNvdW50cy00LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getDependencyCounts-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getJobScheduler-1.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getJobScheduler-1.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getJobScheduler: () => (/* binding */ getJobScheduler)\n/* harmony export */ });\nconst content = `--[[\n  Get job scheduler record.\n  Input:\n    KEYS[1] 'repeat' key\n    ARGV[1] id\n]]\nlocal rcall = redis.call\nlocal jobSchedulerKey = KEYS[1] .. \":\" .. ARGV[1]\nlocal score = rcall(\"ZSCORE\", KEYS[1], ARGV[1])\nif score then\n  return {rcall(\"HGETALL\", jobSchedulerKey), score} -- get job data\nend\nreturn {nil, nil}\n`;\nconst getJobScheduler = {\n    name: 'getJobScheduler',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=getJobScheduler-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0Sm9iU2NoZWR1bGVyLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQSxRQUFRO0FBQ1I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2dldEpvYlNjaGVkdWxlci0xLmpzPzUxMjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEdldCBqb2Igc2NoZWR1bGVyIHJlY29yZC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAncmVwZWF0JyBrZXlcbiAgICBBUkdWWzFdIGlkXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCBqb2JTY2hlZHVsZXJLZXkgPSBLRVlTWzFdIC4uIFwiOlwiIC4uIEFSR1ZbMV1cbmxvY2FsIHNjb3JlID0gcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1sxXSwgQVJHVlsxXSlcbmlmIHNjb3JlIHRoZW5cbiAgcmV0dXJuIHtyY2FsbChcIkhHRVRBTExcIiwgam9iU2NoZWR1bGVyS2V5KSwgc2NvcmV9IC0tIGdldCBqb2IgZGF0YVxuZW5kXG5yZXR1cm4ge25pbCwgbmlsfVxuYDtcbmV4cG9ydCBjb25zdCBnZXRKb2JTY2hlZHVsZXIgPSB7XG4gICAgbmFtZTogJ2dldEpvYlNjaGVkdWxlcicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEpvYlNjaGVkdWxlci0xLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getJobScheduler-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getMetrics-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getMetrics-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMetrics: () => (/* binding */ getMetrics)\n/* harmony export */ });\nconst content = `--[[\n  Get metrics\n  Input:\n    KEYS[1] 'metrics' key\n    KEYS[2] 'metrics data' key\n    ARGV[1] start index\n    ARGV[2] end index\n]]\nlocal rcall = redis.call;\nlocal metricsKey = KEYS[1]\nlocal dataKey = KEYS[2]\nlocal metrics = rcall(\"HMGET\", metricsKey, \"count\", \"prevTS\", \"prevCount\")\nlocal data = rcall(\"LRANGE\", dataKey, tonumber(ARGV[1]), tonumber(ARGV[2]))\nlocal numPoints = rcall(\"LLEN\", dataKey)\nreturn {metrics, data, numPoints}\n`;\nconst getMetrics = {\n    name: 'getMetrics',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=getMetrics-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0TWV0cmljcy0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9nZXRNZXRyaWNzLTIuanM/NDk0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IG1ldHJpY3NcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAnbWV0cmljcycga2V5XG4gICAgS0VZU1syXSAnbWV0cmljcyBkYXRhJyBrZXlcbiAgICBBUkdWWzFdIHN0YXJ0IGluZGV4XG4gICAgQVJHVlsyXSBlbmQgaW5kZXhcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG5sb2NhbCBtZXRyaWNzS2V5ID0gS0VZU1sxXVxubG9jYWwgZGF0YUtleSA9IEtFWVNbMl1cbmxvY2FsIG1ldHJpY3MgPSByY2FsbChcIkhNR0VUXCIsIG1ldHJpY3NLZXksIFwiY291bnRcIiwgXCJwcmV2VFNcIiwgXCJwcmV2Q291bnRcIilcbmxvY2FsIGRhdGEgPSByY2FsbChcIkxSQU5HRVwiLCBkYXRhS2V5LCB0b251bWJlcihBUkdWWzFdKSwgdG9udW1iZXIoQVJHVlsyXSkpXG5sb2NhbCBudW1Qb2ludHMgPSByY2FsbChcIkxMRU5cIiwgZGF0YUtleSlcbnJldHVybiB7bWV0cmljcywgZGF0YSwgbnVtUG9pbnRzfVxuYDtcbmV4cG9ydCBjb25zdCBnZXRNZXRyaWNzID0ge1xuICAgIG5hbWU6ICdnZXRNZXRyaWNzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDIsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TWV0cmljcy0yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getMetrics-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getRanges-1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRanges: () => (/* binding */ getRanges)\n/* harmony export */ });\nconst content = `--[[\n  Get job ids per provided states\n    Input:\n      KEYS[1]    'prefix'\n      ARGV[1]    start\n      ARGV[2]    end\n      ARGV[3]    asc\n      ARGV[4...] types\n]]\nlocal rcall = redis.call\nlocal prefix = KEYS[1]\nlocal rangeStart = tonumber(ARGV[1])\nlocal rangeEnd = tonumber(ARGV[2])\nlocal asc = ARGV[3]\nlocal results = {}\nlocal function getRangeInList(listKey, asc, rangeStart, rangeEnd, results)\n  if asc == \"1\" then\n    local modifiedRangeStart\n    local modifiedRangeEnd\n    if rangeStart == -1 then\n      modifiedRangeStart = 0\n    else\n      modifiedRangeStart = -(rangeStart + 1)\n    end\n    if rangeEnd == -1 then\n      modifiedRangeEnd = 0\n    else\n      modifiedRangeEnd = -(rangeEnd + 1)\n    end\n    results[#results+1] = rcall(\"LRANGE\", listKey,\n      modifiedRangeEnd,\n      modifiedRangeStart)\n  else\n    results[#results+1] = rcall(\"LRANGE\", listKey, rangeStart, rangeEnd)\n  end\nend\nfor i = 4, #ARGV do\n  local stateKey = prefix .. ARGV[i]\n  if ARGV[i] == \"wait\" or ARGV[i] == \"paused\" then\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local marker = rcall(\"LINDEX\", stateKey, -1)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then\n      local count = rcall(\"LLEN\", stateKey)\n      if count > 1 then\n        rcall(\"RPOP\", stateKey)\n        getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n      else\n        results[#results+1] = {}\n      end\n    else\n      getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n    end\n  elseif ARGV[i] == \"active\" then\n    getRangeInList(stateKey, asc, rangeStart, rangeEnd, results)\n  else\n    if asc == \"1\" then\n      results[#results+1] = rcall(\"ZRANGE\", stateKey, rangeStart, rangeEnd)\n    else\n      results[#results+1] = rcall(\"ZREVRANGE\", stateKey, rangeStart, rangeEnd)\n    end\n  end\nend\nreturn results\n`;\nconst getRanges = {\n    name: 'getRanges',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=getRanges-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0UmFuZ2VzLTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9nZXRSYW5nZXMtMS5qcz82ZmNhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBHZXQgam9iIGlkcyBwZXIgcHJvdmlkZWQgc3RhdGVzXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICAgICdwcmVmaXgnXG4gICAgICBBUkdWWzFdICAgIHN0YXJ0XG4gICAgICBBUkdWWzJdICAgIGVuZFxuICAgICAgQVJHVlszXSAgICBhc2NcbiAgICAgIEFSR1ZbNC4uLl0gdHlwZXNcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHByZWZpeCA9IEtFWVNbMV1cbmxvY2FsIHJhbmdlU3RhcnQgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgcmFuZ2VFbmQgPSB0b251bWJlcihBUkdWWzJdKVxubG9jYWwgYXNjID0gQVJHVlszXVxubG9jYWwgcmVzdWx0cyA9IHt9XG5sb2NhbCBmdW5jdGlvbiBnZXRSYW5nZUluTGlzdChsaXN0S2V5LCBhc2MsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCByZXN1bHRzKVxuICBpZiBhc2MgPT0gXCIxXCIgdGhlblxuICAgIGxvY2FsIG1vZGlmaWVkUmFuZ2VTdGFydFxuICAgIGxvY2FsIG1vZGlmaWVkUmFuZ2VFbmRcbiAgICBpZiByYW5nZVN0YXJ0ID09IC0xIHRoZW5cbiAgICAgIG1vZGlmaWVkUmFuZ2VTdGFydCA9IDBcbiAgICBlbHNlXG4gICAgICBtb2RpZmllZFJhbmdlU3RhcnQgPSAtKHJhbmdlU3RhcnQgKyAxKVxuICAgIGVuZFxuICAgIGlmIHJhbmdlRW5kID09IC0xIHRoZW5cbiAgICAgIG1vZGlmaWVkUmFuZ2VFbmQgPSAwXG4gICAgZWxzZVxuICAgICAgbW9kaWZpZWRSYW5nZUVuZCA9IC0ocmFuZ2VFbmQgKyAxKVxuICAgIGVuZFxuICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIkxSQU5HRVwiLCBsaXN0S2V5LFxuICAgICAgbW9kaWZpZWRSYW5nZUVuZCxcbiAgICAgIG1vZGlmaWVkUmFuZ2VTdGFydClcbiAgZWxzZVxuICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIkxSQU5HRVwiLCBsaXN0S2V5LCByYW5nZVN0YXJ0LCByYW5nZUVuZClcbiAgZW5kXG5lbmRcbmZvciBpID0gNCwgI0FSR1YgZG9cbiAgbG9jYWwgc3RhdGVLZXkgPSBwcmVmaXggLi4gQVJHVltpXVxuICBpZiBBUkdWW2ldID09IFwid2FpdFwiIG9yIEFSR1ZbaV0gPT0gXCJwYXVzZWRcIiB0aGVuXG4gICAgLS0gTWFya2VycyBpbiB3YWl0bGlzdCBERVBSRUNBVEVEIGluIHY1OiBSZW1vdmUgaW4gdjYuXG4gICAgbG9jYWwgbWFya2VyID0gcmNhbGwoXCJMSU5ERVhcIiwgc3RhdGVLZXksIC0xKVxuICAgIGlmIG1hcmtlciBhbmQgc3RyaW5nLnN1YihtYXJrZXIsIDEsIDIpID09IFwiMDpcIiB0aGVuXG4gICAgICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiTExFTlwiLCBzdGF0ZUtleSlcbiAgICAgIGlmIGNvdW50ID4gMSB0aGVuXG4gICAgICAgIHJjYWxsKFwiUlBPUFwiLCBzdGF0ZUtleSlcbiAgICAgICAgZ2V0UmFuZ2VJbkxpc3Qoc3RhdGVLZXksIGFzYywgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIHJlc3VsdHMpXG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSB7fVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZ2V0UmFuZ2VJbkxpc3Qoc3RhdGVLZXksIGFzYywgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIHJlc3VsdHMpXG4gICAgZW5kXG4gIGVsc2VpZiBBUkdWW2ldID09IFwiYWN0aXZlXCIgdGhlblxuICAgIGdldFJhbmdlSW5MaXN0KHN0YXRlS2V5LCBhc2MsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCByZXN1bHRzKVxuICBlbHNlXG4gICAgaWYgYXNjID09IFwiMVwiIHRoZW5cbiAgICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIlpSQU5HRVwiLCBzdGF0ZUtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gICAgZWxzZVxuICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IHJjYWxsKFwiWlJFVlJBTkdFXCIsIHN0YXRlS2V5LCByYW5nZVN0YXJ0LCByYW5nZUVuZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbnJldHVybiByZXN1bHRzXG5gO1xuZXhwb3J0IGNvbnN0IGdldFJhbmdlcyA9IHtcbiAgICBuYW1lOiAnZ2V0UmFuZ2VzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0UmFuZ2VzLTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getRateLimitTtl-2.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getRateLimitTtl-2.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRateLimitTtl: () => (/* binding */ getRateLimitTtl)\n/* harmony export */ });\nconst content = `--[[\n  Get rate limit ttl\n    Input:\n      KEYS[1] 'limiter'\n      KEYS[2] 'meta'\n      ARGV[1] maxJobs\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall(\"GET\", rateLimiterKey) or 0) then\n    local pttl = rcall(\"PTTL\", rateLimiterKey)\n    if pttl == 0 then\n      rcall(\"DEL\", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\nlocal rateLimiterKey = KEYS[1]\nif ARGV[1] ~= \"0\" then\n  return getRateLimitTTL(tonumber(ARGV[1]), rateLimiterKey)\nelse\n  local rateLimitMax = rcall(\"HGET\", KEYS[2], \"max\")\n  if rateLimitMax then\n    return getRateLimitTTL(tonumber(rateLimitMax), rateLimiterKey)\n  end\n  return rcall(\"PTTL\", rateLimiterKey)\nend\n`;\nconst getRateLimitTtl = {\n    name: 'getRateLimitTtl',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=getRateLimitTtl-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0UmF0ZUxpbWl0VHRsLTIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2dldFJhdGVMaW1pdFR0bC0yLmpzP2U2OTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEdldCByYXRlIGxpbWl0IHR0bFxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnbGltaXRlcidcbiAgICAgIEtFWVNbMl0gJ21ldGEnXG4gICAgICBBUkdWWzFdIG1heEpvYnNcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHJhdGUgbGltaXQgdHRsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFJhdGVMaW1pdFRUTChtYXhKb2JzLCByYXRlTGltaXRlcktleSlcbiAgaWYgbWF4Sm9icyBhbmQgbWF4Sm9icyA8PSB0b251bWJlcihyY2FsbChcIkdFVFwiLCByYXRlTGltaXRlcktleSkgb3IgMCkgdGhlblxuICAgIGxvY2FsIHB0dGwgPSByY2FsbChcIlBUVExcIiwgcmF0ZUxpbWl0ZXJLZXkpXG4gICAgaWYgcHR0bCA9PSAwIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIHJhdGVMaW1pdGVyS2V5KVxuICAgIGVuZFxuICAgIGlmIHB0dGwgPiAwIHRoZW5cbiAgICAgIHJldHVybiBwdHRsXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gMFxuZW5kXG5sb2NhbCByYXRlTGltaXRlcktleSA9IEtFWVNbMV1cbmlmIEFSR1ZbMV0gfj0gXCIwXCIgdGhlblxuICByZXR1cm4gZ2V0UmF0ZUxpbWl0VFRMKHRvbnVtYmVyKEFSR1ZbMV0pLCByYXRlTGltaXRlcktleSlcbmVsc2VcbiAgbG9jYWwgcmF0ZUxpbWl0TWF4ID0gcmNhbGwoXCJIR0VUXCIsIEtFWVNbMl0sIFwibWF4XCIpXG4gIGlmIHJhdGVMaW1pdE1heCB0aGVuXG4gICAgcmV0dXJuIGdldFJhdGVMaW1pdFRUTCh0b251bWJlcihyYXRlTGltaXRNYXgpLCByYXRlTGltaXRlcktleSlcbiAgZW5kXG4gIHJldHVybiByY2FsbChcIlBUVExcIiwgcmF0ZUxpbWl0ZXJLZXkpXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgZ2V0UmF0ZUxpbWl0VHRsID0ge1xuICAgIG5hbWU6ICdnZXRSYXRlTGltaXRUdGwnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRSYXRlTGltaXRUdGwtMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getRateLimitTtl-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getState-8.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getState: () => (/* binding */ getState)\n/* harmony export */ });\nconst content = `--[[\n  Get a job state\n  Input: \n    KEYS[1] 'completed' key,\n    KEYS[2] 'failed' key\n    KEYS[3] 'delayed' key\n    KEYS[4] 'active' key\n    KEYS[5] 'wait' key\n    KEYS[6] 'paused' key\n    KEYS[7] 'waiting-children' key\n    KEYS[8] 'prioritized' key\n    ARGV[1] job id\n  Output:\n    'completed'\n    'failed'\n    'delayed'\n    'active'\n    'prioritized'\n    'waiting'\n    'waiting-children'\n    'unknown'\n]]\nlocal rcall = redis.call\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) then\n  return \"completed\"\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) then\n  return \"failed\"\nend\nif rcall(\"ZSCORE\", KEYS[3], ARGV[1]) then\n  return \"delayed\"\nend\nif rcall(\"ZSCORE\", KEYS[8], ARGV[1]) then\n  return \"prioritized\"\nend\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal active_items = rcall(\"LRANGE\", KEYS[4] , 0, -1)\nif checkItemInList(active_items, ARGV[1]) ~= nil then\n  return \"active\"\nend\nlocal wait_items = rcall(\"LRANGE\", KEYS[5] , 0, -1)\nif checkItemInList(wait_items, ARGV[1]) ~= nil then\n  return \"waiting\"\nend\nlocal paused_items = rcall(\"LRANGE\", KEYS[6] , 0, -1)\nif checkItemInList(paused_items, ARGV[1]) ~= nil then\n  return \"waiting\"\nend\nif rcall(\"ZSCORE\", KEYS[7], ARGV[1]) then\n  return \"waiting-children\"\nend\nreturn \"unknown\"\n`;\nconst getState = {\n    name: 'getState',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=getState-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0U3RhdGUtOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2dldFN0YXRlLTguanM/MzhhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgR2V0IGEgam9iIHN0YXRlXG4gIElucHV0OiBcbiAgICBLRVlTWzFdICdjb21wbGV0ZWQnIGtleSxcbiAgICBLRVlTWzJdICdmYWlsZWQnIGtleVxuICAgIEtFWVNbM10gJ2RlbGF5ZWQnIGtleVxuICAgIEtFWVNbNF0gJ2FjdGl2ZScga2V5XG4gICAgS0VZU1s1XSAnd2FpdCcga2V5XG4gICAgS0VZU1s2XSAncGF1c2VkJyBrZXlcbiAgICBLRVlTWzddICd3YWl0aW5nLWNoaWxkcmVuJyBrZXlcbiAgICBLRVlTWzhdICdwcmlvcml0aXplZCcga2V5XG4gICAgQVJHVlsxXSBqb2IgaWRcbiAgT3V0cHV0OlxuICAgICdjb21wbGV0ZWQnXG4gICAgJ2ZhaWxlZCdcbiAgICAnZGVsYXllZCdcbiAgICAnYWN0aXZlJ1xuICAgICdwcmlvcml0aXplZCdcbiAgICAnd2FpdGluZydcbiAgICAnd2FpdGluZy1jaGlsZHJlbidcbiAgICAndW5rbm93bidcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMV0sIEFSR1ZbMV0pIHRoZW5cbiAgcmV0dXJuIFwiY29tcGxldGVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1syXSwgQVJHVlsxXSkgdGhlblxuICByZXR1cm4gXCJmYWlsZWRcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzNdLCBBUkdWWzFdKSB0aGVuXG4gIHJldHVybiBcImRlbGF5ZWRcIlxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzhdLCBBUkdWWzFdKSB0aGVuXG4gIHJldHVybiBcInByaW9yaXRpemVkXCJcbmVuZFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGNoZWNrIGlmIGEgaXRlbSBiZWxvbmdzIHRvIGEgbGlzdC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBjaGVja0l0ZW1Jbkxpc3QobGlzdCwgaXRlbSlcbiAgZm9yIF8sIHYgaW4gcGFpcnMobGlzdCkgZG9cbiAgICBpZiB2ID09IGl0ZW0gdGhlblxuICAgICAgcmV0dXJuIDFcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBuaWxcbmVuZFxubG9jYWwgYWN0aXZlX2l0ZW1zID0gcmNhbGwoXCJMUkFOR0VcIiwgS0VZU1s0XSAsIDAsIC0xKVxuaWYgY2hlY2tJdGVtSW5MaXN0KGFjdGl2ZV9pdGVtcywgQVJHVlsxXSkgfj0gbmlsIHRoZW5cbiAgcmV0dXJuIFwiYWN0aXZlXCJcbmVuZFxubG9jYWwgd2FpdF9pdGVtcyA9IHJjYWxsKFwiTFJBTkdFXCIsIEtFWVNbNV0gLCAwLCAtMSlcbmlmIGNoZWNrSXRlbUluTGlzdCh3YWl0X2l0ZW1zLCBBUkdWWzFdKSB+PSBuaWwgdGhlblxuICByZXR1cm4gXCJ3YWl0aW5nXCJcbmVuZFxubG9jYWwgcGF1c2VkX2l0ZW1zID0gcmNhbGwoXCJMUkFOR0VcIiwgS0VZU1s2XSAsIDAsIC0xKVxuaWYgY2hlY2tJdGVtSW5MaXN0KHBhdXNlZF9pdGVtcywgQVJHVlsxXSkgfj0gbmlsIHRoZW5cbiAgcmV0dXJuIFwid2FpdGluZ1wiXG5lbmRcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbN10sIEFSR1ZbMV0pIHRoZW5cbiAgcmV0dXJuIFwid2FpdGluZy1jaGlsZHJlblwiXG5lbmRcbnJldHVybiBcInVua25vd25cIlxuYDtcbmV4cG9ydCBjb25zdCBnZXRTdGF0ZSA9IHtcbiAgICBuYW1lOiAnZ2V0U3RhdGUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogOCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRTdGF0ZS04LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getStateV2: () => (/* binding */ getStateV2)\n/* harmony export */ });\nconst content = `--[[\n  Get a job state\n  Input: \n    KEYS[1] 'completed' key,\n    KEYS[2] 'failed' key\n    KEYS[3] 'delayed' key\n    KEYS[4] 'active' key\n    KEYS[5] 'wait' key\n    KEYS[6] 'paused' key\n    KEYS[7] 'waiting-children' key\n    KEYS[8] 'prioritized' key\n    ARGV[1] job id\n  Output:\n    'completed'\n    'failed'\n    'delayed'\n    'active'\n    'waiting'\n    'waiting-children'\n    'unknown'\n]]\nlocal rcall = redis.call\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) then\n  return \"completed\"\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) then\n  return \"failed\"\nend\nif rcall(\"ZSCORE\", KEYS[3], ARGV[1]) then\n  return \"delayed\"\nend\nif rcall(\"ZSCORE\", KEYS[8], ARGV[1]) then\n  return \"prioritized\"\nend\nif rcall(\"LPOS\", KEYS[4] , ARGV[1]) then\n  return \"active\"\nend\nif rcall(\"LPOS\", KEYS[5] , ARGV[1]) then\n  return \"waiting\"\nend\nif rcall(\"LPOS\", KEYS[6] , ARGV[1]) then\n  return \"waiting\"\nend\nif rcall(\"ZSCORE\", KEYS[7] , ARGV[1]) then\n  return \"waiting-children\"\nend\nreturn \"unknown\"\n`;\nconst getStateV2 = {\n    name: 'getStateV2',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=getStateV2-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvZ2V0U3RhdGVWMi04LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL2dldFN0YXRlVjItOC5qcz83ZTlmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBHZXQgYSBqb2Igc3RhdGVcbiAgSW5wdXQ6IFxuICAgIEtFWVNbMV0gJ2NvbXBsZXRlZCcga2V5LFxuICAgIEtFWVNbMl0gJ2ZhaWxlZCcga2V5XG4gICAgS0VZU1szXSAnZGVsYXllZCcga2V5XG4gICAgS0VZU1s0XSAnYWN0aXZlJyBrZXlcbiAgICBLRVlTWzVdICd3YWl0JyBrZXlcbiAgICBLRVlTWzZdICdwYXVzZWQnIGtleVxuICAgIEtFWVNbN10gJ3dhaXRpbmctY2hpbGRyZW4nIGtleVxuICAgIEtFWVNbOF0gJ3ByaW9yaXRpemVkJyBrZXlcbiAgICBBUkdWWzFdIGpvYiBpZFxuICBPdXRwdXQ6XG4gICAgJ2NvbXBsZXRlZCdcbiAgICAnZmFpbGVkJ1xuICAgICdkZWxheWVkJ1xuICAgICdhY3RpdmUnXG4gICAgJ3dhaXRpbmcnXG4gICAgJ3dhaXRpbmctY2hpbGRyZW4nXG4gICAgJ3Vua25vd24nXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzFdLCBBUkdWWzFdKSB0aGVuXG4gIHJldHVybiBcImNvbXBsZXRlZFwiXG5lbmRcbmlmIHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMl0sIEFSR1ZbMV0pIHRoZW5cbiAgcmV0dXJuIFwiZmFpbGVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1szXSwgQVJHVlsxXSkgdGhlblxuICByZXR1cm4gXCJkZWxheWVkXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1s4XSwgQVJHVlsxXSkgdGhlblxuICByZXR1cm4gXCJwcmlvcml0aXplZFwiXG5lbmRcbmlmIHJjYWxsKFwiTFBPU1wiLCBLRVlTWzRdICwgQVJHVlsxXSkgdGhlblxuICByZXR1cm4gXCJhY3RpdmVcIlxuZW5kXG5pZiByY2FsbChcIkxQT1NcIiwgS0VZU1s1XSAsIEFSR1ZbMV0pIHRoZW5cbiAgcmV0dXJuIFwid2FpdGluZ1wiXG5lbmRcbmlmIHJjYWxsKFwiTFBPU1wiLCBLRVlTWzZdICwgQVJHVlsxXSkgdGhlblxuICByZXR1cm4gXCJ3YWl0aW5nXCJcbmVuZFxuaWYgcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1s3XSAsIEFSR1ZbMV0pIHRoZW5cbiAgcmV0dXJuIFwid2FpdGluZy1jaGlsZHJlblwiXG5lbmRcbnJldHVybiBcInVua25vd25cIlxuYDtcbmV4cG9ydCBjb25zdCBnZXRTdGF0ZVYyID0ge1xuICAgIG5hbWU6ICdnZXRTdGF0ZVYyJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0U3RhdGVWMi04LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDelayedJob: () => (/* reexport safe */ _addDelayedJob_6__WEBPACK_IMPORTED_MODULE_0__.addDelayedJob),\n/* harmony export */   addJobScheduler: () => (/* reexport safe */ _addJobScheduler_11__WEBPACK_IMPORTED_MODULE_1__.addJobScheduler),\n/* harmony export */   addLog: () => (/* reexport safe */ _addLog_2__WEBPACK_IMPORTED_MODULE_2__.addLog),\n/* harmony export */   addParentJob: () => (/* reexport safe */ _addParentJob_5__WEBPACK_IMPORTED_MODULE_3__.addParentJob),\n/* harmony export */   addPrioritizedJob: () => (/* reexport safe */ _addPrioritizedJob_9__WEBPACK_IMPORTED_MODULE_4__.addPrioritizedJob),\n/* harmony export */   addRepeatableJob: () => (/* reexport safe */ _addRepeatableJob_2__WEBPACK_IMPORTED_MODULE_5__.addRepeatableJob),\n/* harmony export */   addStandardJob: () => (/* reexport safe */ _addStandardJob_9__WEBPACK_IMPORTED_MODULE_6__.addStandardJob),\n/* harmony export */   changeDelay: () => (/* reexport safe */ _changeDelay_4__WEBPACK_IMPORTED_MODULE_7__.changeDelay),\n/* harmony export */   changePriority: () => (/* reexport safe */ _changePriority_7__WEBPACK_IMPORTED_MODULE_8__.changePriority),\n/* harmony export */   cleanJobsInSet: () => (/* reexport safe */ _cleanJobsInSet_3__WEBPACK_IMPORTED_MODULE_9__.cleanJobsInSet),\n/* harmony export */   drain: () => (/* reexport safe */ _drain_5__WEBPACK_IMPORTED_MODULE_10__.drain),\n/* harmony export */   extendLock: () => (/* reexport safe */ _extendLock_2__WEBPACK_IMPORTED_MODULE_11__.extendLock),\n/* harmony export */   extendLocks: () => (/* reexport safe */ _extendLocks_1__WEBPACK_IMPORTED_MODULE_12__.extendLocks),\n/* harmony export */   getCounts: () => (/* reexport safe */ _getCounts_1__WEBPACK_IMPORTED_MODULE_13__.getCounts),\n/* harmony export */   getCountsPerPriority: () => (/* reexport safe */ _getCountsPerPriority_4__WEBPACK_IMPORTED_MODULE_14__.getCountsPerPriority),\n/* harmony export */   getDependencyCounts: () => (/* reexport safe */ _getDependencyCounts_4__WEBPACK_IMPORTED_MODULE_15__.getDependencyCounts),\n/* harmony export */   getJobScheduler: () => (/* reexport safe */ _getJobScheduler_1__WEBPACK_IMPORTED_MODULE_16__.getJobScheduler),\n/* harmony export */   getMetrics: () => (/* reexport safe */ _getMetrics_2__WEBPACK_IMPORTED_MODULE_17__.getMetrics),\n/* harmony export */   getRanges: () => (/* reexport safe */ _getRanges_1__WEBPACK_IMPORTED_MODULE_18__.getRanges),\n/* harmony export */   getRateLimitTtl: () => (/* reexport safe */ _getRateLimitTtl_2__WEBPACK_IMPORTED_MODULE_19__.getRateLimitTtl),\n/* harmony export */   getState: () => (/* reexport safe */ _getState_8__WEBPACK_IMPORTED_MODULE_20__.getState),\n/* harmony export */   getStateV2: () => (/* reexport safe */ _getStateV2_8__WEBPACK_IMPORTED_MODULE_21__.getStateV2),\n/* harmony export */   isFinished: () => (/* reexport safe */ _isFinished_3__WEBPACK_IMPORTED_MODULE_22__.isFinished),\n/* harmony export */   isJobInList: () => (/* reexport safe */ _isJobInList_1__WEBPACK_IMPORTED_MODULE_23__.isJobInList),\n/* harmony export */   isMaxed: () => (/* reexport safe */ _isMaxed_2__WEBPACK_IMPORTED_MODULE_24__.isMaxed),\n/* harmony export */   moveJobFromActiveToWait: () => (/* reexport safe */ _moveJobFromActiveToWait_9__WEBPACK_IMPORTED_MODULE_25__.moveJobFromActiveToWait),\n/* harmony export */   moveJobsToWait: () => (/* reexport safe */ _moveJobsToWait_8__WEBPACK_IMPORTED_MODULE_26__.moveJobsToWait),\n/* harmony export */   moveStalledJobsToWait: () => (/* reexport safe */ _moveStalledJobsToWait_8__WEBPACK_IMPORTED_MODULE_27__.moveStalledJobsToWait),\n/* harmony export */   moveToActive: () => (/* reexport safe */ _moveToActive_11__WEBPACK_IMPORTED_MODULE_28__.moveToActive),\n/* harmony export */   moveToDelayed: () => (/* reexport safe */ _moveToDelayed_8__WEBPACK_IMPORTED_MODULE_29__.moveToDelayed),\n/* harmony export */   moveToFinished: () => (/* reexport safe */ _moveToFinished_14__WEBPACK_IMPORTED_MODULE_30__.moveToFinished),\n/* harmony export */   moveToWaitingChildren: () => (/* reexport safe */ _moveToWaitingChildren_7__WEBPACK_IMPORTED_MODULE_31__.moveToWaitingChildren),\n/* harmony export */   obliterate: () => (/* reexport safe */ _obliterate_2__WEBPACK_IMPORTED_MODULE_32__.obliterate),\n/* harmony export */   paginate: () => (/* reexport safe */ _paginate_1__WEBPACK_IMPORTED_MODULE_33__.paginate),\n/* harmony export */   pause: () => (/* reexport safe */ _pause_7__WEBPACK_IMPORTED_MODULE_34__.pause),\n/* harmony export */   promote: () => (/* reexport safe */ _promote_9__WEBPACK_IMPORTED_MODULE_35__.promote),\n/* harmony export */   releaseLock: () => (/* reexport safe */ _releaseLock_1__WEBPACK_IMPORTED_MODULE_36__.releaseLock),\n/* harmony export */   removeChildDependency: () => (/* reexport safe */ _removeChildDependency_1__WEBPACK_IMPORTED_MODULE_37__.removeChildDependency),\n/* harmony export */   removeJob: () => (/* reexport safe */ _removeJob_2__WEBPACK_IMPORTED_MODULE_38__.removeJob),\n/* harmony export */   removeJobScheduler: () => (/* reexport safe */ _removeJobScheduler_3__WEBPACK_IMPORTED_MODULE_39__.removeJobScheduler),\n/* harmony export */   removeRepeatable: () => (/* reexport safe */ _removeRepeatable_3__WEBPACK_IMPORTED_MODULE_40__.removeRepeatable),\n/* harmony export */   removeUnprocessedChildren: () => (/* reexport safe */ _removeUnprocessedChildren_2__WEBPACK_IMPORTED_MODULE_41__.removeUnprocessedChildren),\n/* harmony export */   reprocessJob: () => (/* reexport safe */ _reprocessJob_8__WEBPACK_IMPORTED_MODULE_42__.reprocessJob),\n/* harmony export */   retryJob: () => (/* reexport safe */ _retryJob_11__WEBPACK_IMPORTED_MODULE_43__.retryJob),\n/* harmony export */   saveStacktrace: () => (/* reexport safe */ _saveStacktrace_1__WEBPACK_IMPORTED_MODULE_44__.saveStacktrace),\n/* harmony export */   updateData: () => (/* reexport safe */ _updateData_1__WEBPACK_IMPORTED_MODULE_45__.updateData),\n/* harmony export */   updateJobScheduler: () => (/* reexport safe */ _updateJobScheduler_12__WEBPACK_IMPORTED_MODULE_46__.updateJobScheduler),\n/* harmony export */   updateProgress: () => (/* reexport safe */ _updateProgress_3__WEBPACK_IMPORTED_MODULE_47__.updateProgress),\n/* harmony export */   updateRepeatableJobMillis: () => (/* reexport safe */ _updateRepeatableJobMillis_1__WEBPACK_IMPORTED_MODULE_48__.updateRepeatableJobMillis)\n/* harmony export */ });\n/* harmony import */ var _addDelayedJob_6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addDelayedJob-6 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addDelayedJob-6.js\");\n/* harmony import */ var _addJobScheduler_11__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addJobScheduler-11 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addJobScheduler-11.js\");\n/* harmony import */ var _addLog_2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addLog-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addLog-2.js\");\n/* harmony import */ var _addParentJob_5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addParentJob-5 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addParentJob-5.js\");\n/* harmony import */ var _addPrioritizedJob_9__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./addPrioritizedJob-9 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addPrioritizedJob-9.js\");\n/* harmony import */ var _addRepeatableJob_2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./addRepeatableJob-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addRepeatableJob-2.js\");\n/* harmony import */ var _addStandardJob_9__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./addStandardJob-9 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/addStandardJob-9.js\");\n/* harmony import */ var _changeDelay_4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./changeDelay-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/changeDelay-4.js\");\n/* harmony import */ var _changePriority_7__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./changePriority-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/changePriority-7.js\");\n/* harmony import */ var _cleanJobsInSet_3__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cleanJobsInSet-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/cleanJobsInSet-3.js\");\n/* harmony import */ var _drain_5__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./drain-5 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/drain-5.js\");\n/* harmony import */ var _extendLock_2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extendLock-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLock-2.js\");\n/* harmony import */ var _extendLocks_1__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./extendLocks-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/extendLocks-1.js\");\n/* harmony import */ var _getCounts_1__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./getCounts-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getCounts-1.js\");\n/* harmony import */ var _getCountsPerPriority_4__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./getCountsPerPriority-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getCountsPerPriority-4.js\");\n/* harmony import */ var _getDependencyCounts_4__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./getDependencyCounts-4 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getDependencyCounts-4.js\");\n/* harmony import */ var _getJobScheduler_1__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./getJobScheduler-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getJobScheduler-1.js\");\n/* harmony import */ var _getMetrics_2__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./getMetrics-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getMetrics-2.js\");\n/* harmony import */ var _getRanges_1__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./getRanges-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getRanges-1.js\");\n/* harmony import */ var _getRateLimitTtl_2__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./getRateLimitTtl-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getRateLimitTtl-2.js\");\n/* harmony import */ var _getState_8__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./getState-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getState-8.js\");\n/* harmony import */ var _getStateV2_8__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./getStateV2-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/getStateV2-8.js\");\n/* harmony import */ var _isFinished_3__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./isFinished-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js\");\n/* harmony import */ var _isJobInList_1__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./isJobInList-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js\");\n/* harmony import */ var _isMaxed_2__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./isMaxed-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/isMaxed-2.js\");\n/* harmony import */ var _moveJobFromActiveToWait_9__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./moveJobFromActiveToWait-9 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-9.js\");\n/* harmony import */ var _moveJobsToWait_8__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./moveJobsToWait-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-8.js\");\n/* harmony import */ var _moveStalledJobsToWait_8__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./moveStalledJobsToWait-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-8.js\");\n/* harmony import */ var _moveToActive_11__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./moveToActive-11 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js\");\n/* harmony import */ var _moveToDelayed_8__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./moveToDelayed-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-8.js\");\n/* harmony import */ var _moveToFinished_14__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./moveToFinished-14 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js\");\n/* harmony import */ var _moveToWaitingChildren_7__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./moveToWaitingChildren-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-7.js\");\n/* harmony import */ var _obliterate_2__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./obliterate-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js\");\n/* harmony import */ var _paginate_1__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./paginate-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js\");\n/* harmony import */ var _pause_7__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./pause-7 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js\");\n/* harmony import */ var _promote_9__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./promote-9 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-9.js\");\n/* harmony import */ var _releaseLock_1__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./releaseLock-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js\");\n/* harmony import */ var _removeChildDependency_1__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./removeChildDependency-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js\");\n/* harmony import */ var _removeJob_2__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./removeJob-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-2.js\");\n/* harmony import */ var _removeJobScheduler_3__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./removeJobScheduler-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJobScheduler-3.js\");\n/* harmony import */ var _removeRepeatable_3__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./removeRepeatable-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-3.js\");\n/* harmony import */ var _removeUnprocessedChildren_2__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./removeUnprocessedChildren-2 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/removeUnprocessedChildren-2.js\");\n/* harmony import */ var _reprocessJob_8__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./reprocessJob-8 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-8.js\");\n/* harmony import */ var _retryJob_11__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./retryJob-11 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-11.js\");\n/* harmony import */ var _saveStacktrace_1__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./saveStacktrace-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js\");\n/* harmony import */ var _updateData_1__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./updateData-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js\");\n/* harmony import */ var _updateJobScheduler_12__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./updateJobScheduler-12 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateJobScheduler-12.js\");\n/* harmony import */ var _updateProgress_3__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./updateProgress-3 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js\");\n/* harmony import */ var _updateRepeatableJobMillis_1__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./updateRepeatableJobMillis-1 */ \"(rsc)/./node_modules/bullmq/dist/esm/scripts/updateRepeatableJobMillis-1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRztBQUNWO0FBQ007QUFDSztBQUNEO0FBQ0Y7QUFDSDtBQUNHO0FBQ0E7QUFDVDtBQUNLO0FBQ0M7QUFDRjtBQUNXO0FBQ0Q7QUFDSjtBQUNMO0FBQ0Q7QUFDTTtBQUNQO0FBQ0U7QUFDQTtBQUNDO0FBQ0o7QUFDZ0I7QUFDVDtBQUNPO0FBQ1I7QUFDQTtBQUNFO0FBQ007QUFDWDtBQUNGO0FBQ0g7QUFDRTtBQUNJO0FBQ1U7QUFDWjtBQUNTO0FBQ0Y7QUFDUztBQUNiO0FBQ0g7QUFDSztBQUNKO0FBQ1M7QUFDTDtBQUNXO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9pbmRleC5qcz82NmQ2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYWRkRGVsYXllZEpvYi02JztcbmV4cG9ydCAqIGZyb20gJy4vYWRkSm9iU2NoZWR1bGVyLTExJztcbmV4cG9ydCAqIGZyb20gJy4vYWRkTG9nLTInO1xuZXhwb3J0ICogZnJvbSAnLi9hZGRQYXJlbnRKb2ItNSc7XG5leHBvcnQgKiBmcm9tICcuL2FkZFByaW9yaXRpemVkSm9iLTknO1xuZXhwb3J0ICogZnJvbSAnLi9hZGRSZXBlYXRhYmxlSm9iLTInO1xuZXhwb3J0ICogZnJvbSAnLi9hZGRTdGFuZGFyZEpvYi05JztcbmV4cG9ydCAqIGZyb20gJy4vY2hhbmdlRGVsYXktNCc7XG5leHBvcnQgKiBmcm9tICcuL2NoYW5nZVByaW9yaXR5LTcnO1xuZXhwb3J0ICogZnJvbSAnLi9jbGVhbkpvYnNJblNldC0zJztcbmV4cG9ydCAqIGZyb20gJy4vZHJhaW4tNSc7XG5leHBvcnQgKiBmcm9tICcuL2V4dGVuZExvY2stMic7XG5leHBvcnQgKiBmcm9tICcuL2V4dGVuZExvY2tzLTEnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRDb3VudHMtMSc7XG5leHBvcnQgKiBmcm9tICcuL2dldENvdW50c1BlclByaW9yaXR5LTQnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXREZXBlbmRlbmN5Q291bnRzLTQnO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRKb2JTY2hlZHVsZXItMSc7XG5leHBvcnQgKiBmcm9tICcuL2dldE1ldHJpY3MtMic7XG5leHBvcnQgKiBmcm9tICcuL2dldFJhbmdlcy0xJztcbmV4cG9ydCAqIGZyb20gJy4vZ2V0UmF0ZUxpbWl0VHRsLTInO1xuZXhwb3J0ICogZnJvbSAnLi9nZXRTdGF0ZS04JztcbmV4cG9ydCAqIGZyb20gJy4vZ2V0U3RhdGVWMi04JztcbmV4cG9ydCAqIGZyb20gJy4vaXNGaW5pc2hlZC0zJztcbmV4cG9ydCAqIGZyb20gJy4vaXNKb2JJbkxpc3QtMSc7XG5leHBvcnQgKiBmcm9tICcuL2lzTWF4ZWQtMic7XG5leHBvcnQgKiBmcm9tICcuL21vdmVKb2JGcm9tQWN0aXZlVG9XYWl0LTknO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlSm9ic1RvV2FpdC04JztcbmV4cG9ydCAqIGZyb20gJy4vbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTgnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9BY3RpdmUtMTEnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9EZWxheWVkLTgnO1xuZXhwb3J0ICogZnJvbSAnLi9tb3ZlVG9GaW5pc2hlZC0xNCc7XG5leHBvcnQgKiBmcm9tICcuL21vdmVUb1dhaXRpbmdDaGlsZHJlbi03JztcbmV4cG9ydCAqIGZyb20gJy4vb2JsaXRlcmF0ZS0yJztcbmV4cG9ydCAqIGZyb20gJy4vcGFnaW5hdGUtMSc7XG5leHBvcnQgKiBmcm9tICcuL3BhdXNlLTcnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9tb3RlLTknO1xuZXhwb3J0ICogZnJvbSAnLi9yZWxlYXNlTG9jay0xJztcbmV4cG9ydCAqIGZyb20gJy4vcmVtb3ZlQ2hpbGREZXBlbmRlbmN5LTEnO1xuZXhwb3J0ICogZnJvbSAnLi9yZW1vdmVKb2ItMic7XG5leHBvcnQgKiBmcm9tICcuL3JlbW92ZUpvYlNjaGVkdWxlci0zJztcbmV4cG9ydCAqIGZyb20gJy4vcmVtb3ZlUmVwZWF0YWJsZS0zJztcbmV4cG9ydCAqIGZyb20gJy4vcmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbi0yJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwcm9jZXNzSm9iLTgnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXRyeUpvYi0xMSc7XG5leHBvcnQgKiBmcm9tICcuL3NhdmVTdGFja3RyYWNlLTEnO1xuZXhwb3J0ICogZnJvbSAnLi91cGRhdGVEYXRhLTEnO1xuZXhwb3J0ICogZnJvbSAnLi91cGRhdGVKb2JTY2hlZHVsZXItMTInO1xuZXhwb3J0ICogZnJvbSAnLi91cGRhdGVQcm9ncmVzcy0zJztcbmV4cG9ydCAqIGZyb20gJy4vdXBkYXRlUmVwZWF0YWJsZUpvYk1pbGxpcy0xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/isFinished-3.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isFinished: () => (/* binding */ isFinished)\n/* harmony export */ });\nconst content = `--[[\n  Checks if a job is finished (.i.e. is in the completed or failed set)\n  Input: \n    KEYS[1] completed key\n    KEYS[2] failed key\n    KEYS[3] job key\n    ARGV[1] job id\n    ARGV[2] return value?\n  Output:\n    0 - Not finished.\n    1 - Completed.\n    2 - Failed.\n   -1 - Missing job. \n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[3]) ~= 1 then\n  if ARGV[2] == \"1\" then\n    return {-1,\"Missing key for job \" .. KEYS[3] .. \". isFinished\"}\n  end  \n  return -1\nend\nif rcall(\"ZSCORE\", KEYS[1], ARGV[1]) then\n  if ARGV[2] == \"1\" then\n    local returnValue = rcall(\"HGET\", KEYS[3], \"returnvalue\")\n    return {1,returnValue}\n  end\n  return 1\nend\nif rcall(\"ZSCORE\", KEYS[2], ARGV[1]) then\n  if ARGV[2] == \"1\" then\n    local failedReason = rcall(\"HGET\", KEYS[3], \"failedReason\")\n    return {2,failedReason}\n  end\n  return 2\nend\nif ARGV[2] == \"1\" then\n  return {0}\nend\nreturn 0\n`;\nconst isFinished = {\n    name: 'isFinished',\n    content,\n    keys: 3,\n};\n//# sourceMappingURL=isFinished-3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNGaW5pc2hlZC0zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9pc0ZpbmlzaGVkLTMuanM/ZTMyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQ2hlY2tzIGlmIGEgam9iIGlzIGZpbmlzaGVkICguaS5lLiBpcyBpbiB0aGUgY29tcGxldGVkIG9yIGZhaWxlZCBzZXQpXG4gIElucHV0OiBcbiAgICBLRVlTWzFdIGNvbXBsZXRlZCBrZXlcbiAgICBLRVlTWzJdIGZhaWxlZCBrZXlcbiAgICBLRVlTWzNdIGpvYiBrZXlcbiAgICBBUkdWWzFdIGpvYiBpZFxuICAgIEFSR1ZbMl0gcmV0dXJuIHZhbHVlP1xuICBPdXRwdXQ6XG4gICAgMCAtIE5vdCBmaW5pc2hlZC5cbiAgICAxIC0gQ29tcGxldGVkLlxuICAgIDIgLSBGYWlsZWQuXG4gICAtMSAtIE1pc3Npbmcgam9iLiBcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbM10pIH49IDEgdGhlblxuICBpZiBBUkdWWzJdID09IFwiMVwiIHRoZW5cbiAgICByZXR1cm4gey0xLFwiTWlzc2luZyBrZXkgZm9yIGpvYiBcIiAuLiBLRVlTWzNdIC4uIFwiLiBpc0ZpbmlzaGVkXCJ9XG4gIGVuZCAgXG4gIHJldHVybiAtMVxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzFdLCBBUkdWWzFdKSB0aGVuXG4gIGlmIEFSR1ZbMl0gPT0gXCIxXCIgdGhlblxuICAgIGxvY2FsIHJldHVyblZhbHVlID0gcmNhbGwoXCJIR0VUXCIsIEtFWVNbM10sIFwicmV0dXJudmFsdWVcIilcbiAgICByZXR1cm4gezEscmV0dXJuVmFsdWV9XG4gIGVuZFxuICByZXR1cm4gMVxuZW5kXG5pZiByY2FsbChcIlpTQ09SRVwiLCBLRVlTWzJdLCBBUkdWWzFdKSB0aGVuXG4gIGlmIEFSR1ZbMl0gPT0gXCIxXCIgdGhlblxuICAgIGxvY2FsIGZhaWxlZFJlYXNvbiA9IHJjYWxsKFwiSEdFVFwiLCBLRVlTWzNdLCBcImZhaWxlZFJlYXNvblwiKVxuICAgIHJldHVybiB7MixmYWlsZWRSZWFzb259XG4gIGVuZFxuICByZXR1cm4gMlxuZW5kXG5pZiBBUkdWWzJdID09IFwiMVwiIHRoZW5cbiAgcmV0dXJuIHswfVxuZW5kXG5yZXR1cm4gMFxuYDtcbmV4cG9ydCBjb25zdCBpc0ZpbmlzaGVkID0ge1xuICAgIG5hbWU6ICdpc0ZpbmlzaGVkJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGaW5pc2hlZC0zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/isFinished-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isJobInList: () => (/* binding */ isJobInList)\n/* harmony export */ });\nconst content = `--[[\n  Checks if job is in a given list.\n  Input:\n    KEYS[1]\n    ARGV[1]\n  Output:\n    1 if element found in the list.\n]]\n-- Includes\n--[[\n  Functions to check if a item belongs to a list.\n]]\nlocal function checkItemInList(list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal items = redis.call(\"LRANGE\", KEYS[1] , 0, -1)\nreturn checkItemInList(items, ARGV[1])\n`;\nconst isJobInList = {\n    name: 'isJobInList',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=isJobInList-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNKb2JJbkxpc3QtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNKb2JJbkxpc3QtMS5qcz8zNmJhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBDaGVja3MgaWYgam9iIGlzIGluIGEgZ2l2ZW4gbGlzdC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXVxuICAgIEFSR1ZbMV1cbiAgT3V0cHV0OlxuICAgIDEgaWYgZWxlbWVudCBmb3VuZCBpbiB0aGUgbGlzdC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gY2hlY2sgaWYgYSBpdGVtIGJlbG9uZ3MgdG8gYSBsaXN0LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGNoZWNrSXRlbUluTGlzdChsaXN0LCBpdGVtKVxuICBmb3IgXywgdiBpbiBwYWlycyhsaXN0KSBkb1xuICAgIGlmIHYgPT0gaXRlbSB0aGVuXG4gICAgICByZXR1cm4gMVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIG5pbFxuZW5kXG5sb2NhbCBpdGVtcyA9IHJlZGlzLmNhbGwoXCJMUkFOR0VcIiwgS0VZU1sxXSAsIDAsIC0xKVxucmV0dXJuIGNoZWNrSXRlbUluTGlzdChpdGVtcywgQVJHVlsxXSlcbmA7XG5leHBvcnQgY29uc3QgaXNKb2JJbkxpc3QgPSB7XG4gICAgbmFtZTogJ2lzSm9iSW5MaXN0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNKb2JJbkxpc3QtMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/isJobInList-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/isMaxed-2.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/isMaxed-2.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isMaxed: () => (/* binding */ isMaxed)\n/* harmony export */ });\nconst content = `--[[\n  Checks if queue is maxed.\n  Input:\n    KEYS[1] meta key\n    KEYS[2] active key\n  Output:\n    1 if element found in the list.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to check if queue is maxed or not.\n]]\nlocal function isQueueMaxed(queueMetaKey, activeKey)\n  local maxConcurrency = rcall(\"HGET\", queueMetaKey, \"concurrency\")\n  if maxConcurrency then\n    local activeCount = rcall(\"LLEN\", activeKey)\n    if activeCount >= tonumber(maxConcurrency) then\n      return true\n    end\n  end\n  return false\nend\nreturn isQueueMaxed(KEYS[1], KEYS[2])\n`;\nconst isMaxed = {\n    name: 'isMaxed',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=isMaxed-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNNYXhlZC0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvaXNNYXhlZC0yLmpzP2Y1YWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIENoZWNrcyBpZiBxdWV1ZSBpcyBtYXhlZC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBtZXRhIGtleVxuICAgIEtFWVNbMl0gYWN0aXZlIGtleVxuICBPdXRwdXQ6XG4gICAgMSBpZiBlbGVtZW50IGZvdW5kIGluIHRoZSBsaXN0LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgaWYgcXVldWUgaXMgbWF4ZWQgb3Igbm90LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzUXVldWVNYXhlZChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSlcbiAgbG9jYWwgbWF4Q29uY3VycmVuY3kgPSByY2FsbChcIkhHRVRcIiwgcXVldWVNZXRhS2V5LCBcImNvbmN1cnJlbmN5XCIpXG4gIGlmIG1heENvbmN1cnJlbmN5IHRoZW5cbiAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIobWF4Q29uY3VycmVuY3kpIHRoZW5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxucmV0dXJuIGlzUXVldWVNYXhlZChLRVlTWzFdLCBLRVlTWzJdKVxuYDtcbmV4cG9ydCBjb25zdCBpc01heGVkID0ge1xuICAgIG5hbWU6ICdpc01heGVkJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDIsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNNYXhlZC0yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/isMaxed-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-9.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-9.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveJobFromActiveToWait: () => (/* binding */ moveJobFromActiveToWait)\n/* harmony export */ });\nconst content = `--[[\n  Function to move job from active state to wait.\n  Input:\n    KEYS[1]  active key\n    KEYS[2]  wait key\n    KEYS[3]  stalled key\n    KEYS[4]  paused key\n    KEYS[5]  meta key\n    KEYS[6]  limiter key\n    KEYS[7]  prioritized key\n    KEYS[8]  marker key\n    KEYS[9]  event key\n    ARGV[1] job id\n    ARGV[2] lock token\n    ARGV[3] job id key\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to push back job considering priority in front of same prioritized jobs.\n]]\nlocal function pushBackJobWithPriority(prioritizedKey, priority, jobId)\n  -- in order to put it at front of same prioritized jobs\n  -- we consider prioritized counter as 0\n  local score = priority * 0x100000000\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nlocal jobId = ARGV[1]\nlocal token = ARGV[2]\nlocal jobKey = ARGV[3]\nif rcall(\"EXISTS\", jobKey) == 0 then\n  return -1\nend\nlocal errorCode = removeLock(jobKey, KEYS[3], token, jobId)\nif errorCode < 0 then\n  return errorCode\nend\nlocal metaKey = KEYS[5]\nlocal removed = rcall(\"LREM\", KEYS[1], 1, jobId)\nif removed > 0 then\n  local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[1], KEYS[2], KEYS[4])\n  local priority = tonumber(rcall(\"HGET\", ARGV[3], \"priority\")) or 0\n  if priority > 0 then\n    pushBackJobWithPriority(KEYS[7], priority, jobId)\n  else\n    addJobInTargetList(target, KEYS[8], \"RPUSH\", isPausedOrMaxed, jobId)\n  end\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  -- Emit waiting event\n  rcall(\"XADD\", KEYS[9], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n    \"jobId\", jobId, \"prev\", \"active\")\nend\nlocal pttl = rcall(\"PTTL\", KEYS[6])\nif pttl > 0 then\n  return pttl\nelse\n  return 0\nend\n`;\nconst moveJobFromActiveToWait = {\n    name: 'moveJobFromActiveToWait',\n    content,\n    keys: 9,\n};\n//# sourceMappingURL=moveJobFromActiveToWait-9.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtOS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtOS5qcz8zODM4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBGdW5jdGlvbiB0byBtb3ZlIGpvYiBmcm9tIGFjdGl2ZSBzdGF0ZSB0byB3YWl0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICBhY3RpdmUga2V5XG4gICAgS0VZU1syXSAgd2FpdCBrZXlcbiAgICBLRVlTWzNdICBzdGFsbGVkIGtleVxuICAgIEtFWVNbNF0gIHBhdXNlZCBrZXlcbiAgICBLRVlTWzVdICBtZXRhIGtleVxuICAgIEtFWVNbNl0gIGxpbWl0ZXIga2V5XG4gICAgS0VZU1s3XSAgcHJpb3JpdGl6ZWQga2V5XG4gICAgS0VZU1s4XSAgbWFya2VyIGtleVxuICAgIEtFWVNbOV0gIGV2ZW50IGtleVxuICAgIEFSR1ZbMV0gam9iIGlkXG4gICAgQVJHVlsyXSBsb2NrIHRva2VuXG4gICAgQVJHVlszXSBqb2IgaWQga2V5XG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBwdXNoIGJhY2sgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5IGluIGZyb250IG9mIHNhbWUgcHJpb3JpdGl6ZWQgam9icy5cbl1dXG5sb2NhbCBmdW5jdGlvbiBwdXNoQmFja0pvYldpdGhQcmlvcml0eShwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkKVxuICAtLSBpbiBvcmRlciB0byBwdXQgaXQgYXQgZnJvbnQgb2Ygc2FtZSBwcmlvcml0aXplZCBqb2JzXG4gIC0tIHdlIGNvbnNpZGVyIHByaW9yaXRpemVkIGNvdW50ZXIgYXMgMFxuICBsb2NhbCBzY29yZSA9IHByaW9yaXR5ICogMHgxMDAwMDAwMDBcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gIGVuZFxuICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTG9jayhqb2JLZXksIHN0YWxsZWRLZXksIHRva2VuLCBqb2JJZClcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIGxvY2FsIGxvY2tUb2tlbiA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgLS0gTG9jayBleGlzdHMgYnV0IHRva2VuIGRvZXMgbm90IG1hdGNoXG4gICAgICAgIHJldHVybiAtNlxuICAgICAgZWxzZVxuICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICByZXR1cm4gLTJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxubG9jYWwgam9iSWQgPSBBUkdWWzFdXG5sb2NhbCB0b2tlbiA9IEFSR1ZbMl1cbmxvY2FsIGpvYktleSA9IEFSR1ZbM11cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgPT0gMCB0aGVuXG4gIHJldHVybiAtMVxuZW5kXG5sb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKGpvYktleSwgS0VZU1szXSwgdG9rZW4sIGpvYklkKVxuaWYgZXJyb3JDb2RlIDwgMCB0aGVuXG4gIHJldHVybiBlcnJvckNvZGVcbmVuZFxubG9jYWwgbWV0YUtleSA9IEtFWVNbNV1cbmxvY2FsIHJlbW92ZWQgPSByY2FsbChcIkxSRU1cIiwgS0VZU1sxXSwgMSwgam9iSWQpXG5pZiByZW1vdmVkID4gMCB0aGVuXG4gIGxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbMV0sIEtFWVNbMl0sIEtFWVNbNF0pXG4gIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIEFSR1ZbM10sIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgaWYgcHJpb3JpdHkgPiAwIHRoZW5cbiAgICBwdXNoQmFja0pvYldpdGhQcmlvcml0eShLRVlTWzddLCBwcmlvcml0eSwgam9iSWQpXG4gIGVsc2VcbiAgICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0LCBLRVlTWzhdLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIGVuZFxuICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgcmNhbGwoXCJYQUREXCIsIEtFWVNbOV0sIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgIFwiam9iSWRcIiwgam9iSWQsIFwicHJldlwiLCBcImFjdGl2ZVwiKVxuZW5kXG5sb2NhbCBwdHRsID0gcmNhbGwoXCJQVFRMXCIsIEtFWVNbNl0pXG5pZiBwdHRsID4gMCB0aGVuXG4gIHJldHVybiBwdHRsXG5lbHNlXG4gIHJldHVybiAwXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgbW92ZUpvYkZyb21BY3RpdmVUb1dhaXQgPSB7XG4gICAgbmFtZTogJ21vdmVKb2JGcm9tQWN0aXZlVG9XYWl0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZUpvYkZyb21BY3RpdmVUb1dhaXQtOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobFromActiveToWait-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-8.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-8.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveJobsToWait: () => (/* binding */ moveJobsToWait)\n/* harmony export */ });\nconst content = `--[[\n  Move completed, failed or delayed jobs to wait.\n  Note: Does not support jobs with priorities.\n  Input:\n    KEYS[1] base key\n    KEYS[2] events stream\n    KEYS[3] state key (failed, completed, delayed)\n    KEYS[4] 'wait'\n    KEYS[5] 'paused'\n    KEYS[6] 'meta'\n    KEYS[7] 'active'\n    KEYS[8] 'marker'\n    ARGV[1] count\n    ARGV[2] timestamp\n    ARGV[3] prev state\n  Output:\n    1  means the operation is not completed\n    0  means the operation is completed\n]]\nlocal maxCount = tonumber(ARGV[1])\nlocal timestamp = tonumber(ARGV[2])\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal metaKey = KEYS[6]\nlocal target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[7], KEYS[4], KEYS[5])\nlocal jobs = rcall('ZRANGEBYSCORE', KEYS[3], 0, timestamp, 'LIMIT', 0, maxCount)\nif (#jobs > 0) then\n    if ARGV[3] == \"failed\" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"failedReason\")\n        end\n    elseif ARGV[3] == \"completed\" then\n        for i, key in ipairs(jobs) do\n            local jobKey = KEYS[1] .. key\n            rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"returnvalue\")\n        end\n    end\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    for i, key in ipairs(jobs) do\n        -- Emit waiting event\n        rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\",\n              \"waiting\", \"jobId\", key, \"prev\", ARGV[3]);\n    end\n    for from, to in batches(#jobs, 7000) do\n        rcall(\"ZREM\", KEYS[3], unpack(jobs, from, to))\n        rcall(\"LPUSH\", target, unpack(jobs, from, to))\n    end\n    addBaseMarkerIfNeeded(KEYS[8], isPausedOrMaxed)\nend\nmaxCount = maxCount - #jobs\nif (maxCount <= 0) then return 1 end\nreturn 0\n`;\nconst moveJobsToWait = {\n    name: 'moveJobsToWait',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=moveJobsToWait-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZUpvYnNUb1dhaXQtOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVKb2JzVG9XYWl0LTguanM/ZWU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZSBjb21wbGV0ZWQsIGZhaWxlZCBvciBkZWxheWVkIGpvYnMgdG8gd2FpdC5cbiAgTm90ZTogRG9lcyBub3Qgc3VwcG9ydCBqb2JzIHdpdGggcHJpb3JpdGllcy5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBiYXNlIGtleVxuICAgIEtFWVNbMl0gZXZlbnRzIHN0cmVhbVxuICAgIEtFWVNbM10gc3RhdGUga2V5IChmYWlsZWQsIGNvbXBsZXRlZCwgZGVsYXllZClcbiAgICBLRVlTWzRdICd3YWl0J1xuICAgIEtFWVNbNV0gJ3BhdXNlZCdcbiAgICBLRVlTWzZdICdtZXRhJ1xuICAgIEtFWVNbN10gJ2FjdGl2ZSdcbiAgICBLRVlTWzhdICdtYXJrZXInXG4gICAgQVJHVlsxXSBjb3VudFxuICAgIEFSR1ZbMl0gdGltZXN0YW1wXG4gICAgQVJHVlszXSBwcmV2IHN0YXRlXG4gIE91dHB1dDpcbiAgICAxICBtZWFucyB0aGUgb3BlcmF0aW9uIGlzIG5vdCBjb21wbGV0ZWRcbiAgICAwICBtZWFucyB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlZFxuXV1cbmxvY2FsIG1heENvdW50ID0gdG9udW1iZXIoQVJHVlsxXSlcbmxvY2FsIHRpbWVzdGFtcCA9IHRvbnVtYmVyKEFSR1ZbMl0pXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gIGVuZFxuICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgbWV0YUtleSA9IEtFWVNbNl1cbmxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbN10sIEtFWVNbNF0sIEtFWVNbNV0pXG5sb2NhbCBqb2JzID0gcmNhbGwoJ1pSQU5HRUJZU0NPUkUnLCBLRVlTWzNdLCAwLCB0aW1lc3RhbXAsICdMSU1JVCcsIDAsIG1heENvdW50KVxuaWYgKCNqb2JzID4gMCkgdGhlblxuICAgIGlmIEFSR1ZbM10gPT0gXCJmYWlsZWRcIiB0aGVuXG4gICAgICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBLRVlTWzFdIC4uIGtleVxuICAgICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJmYWlsZWRSZWFzb25cIilcbiAgICAgICAgZW5kXG4gICAgZWxzZWlmIEFSR1ZbM10gPT0gXCJjb21wbGV0ZWRcIiB0aGVuXG4gICAgICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBLRVlTWzFdIC4uIGtleVxuICAgICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJyZXR1cm52YWx1ZVwiKVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgIC0tIEVtaXQgd2FpdGluZyBldmVudFxuICAgICAgICByY2FsbChcIlhBRERcIiwgS0VZU1syXSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cywgXCIqXCIsIFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwga2V5LCBcInByZXZcIiwgQVJHVlszXSk7XG4gICAgZW5kXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2pvYnMsIDcwMDApIGRvXG4gICAgICAgIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzNdLCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgICAgICByY2FsbChcIkxQVVNIXCIsIHRhcmdldCwgdW5wYWNrKGpvYnMsIGZyb20sIHRvKSlcbiAgICBlbmRcbiAgICBhZGRCYXNlTWFya2VySWZOZWVkZWQoS0VZU1s4XSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG5tYXhDb3VudCA9IG1heENvdW50IC0gI2pvYnNcbmlmIChtYXhDb3VudCA8PSAwKSB0aGVuIHJldHVybiAxIGVuZFxucmV0dXJuIDBcbmA7XG5leHBvcnQgY29uc3QgbW92ZUpvYnNUb1dhaXQgPSB7XG4gICAgbmFtZTogJ21vdmVKb2JzVG9XYWl0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZUpvYnNUb1dhaXQtOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveJobsToWait-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-8.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-8.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveStalledJobsToWait: () => (/* binding */ moveStalledJobsToWait)\n/* harmony export */ });\nconst content = `--[[\n  Move stalled jobs to wait.\n    Input:\n      KEYS[1] 'stalled' (SET)\n      KEYS[2] 'wait',   (LIST)\n      KEYS[3] 'active', (LIST)\n      KEYS[4] 'stalled-check', (KEY)\n      KEYS[5] 'meta', (KEY)\n      KEYS[6] 'paused', (LIST)\n      KEYS[7] 'marker'\n      KEYS[8] 'event stream' (STREAM)\n      ARGV[1]  Max stalled job count\n      ARGV[2]  queue.toKey('')\n      ARGV[3]  timestamp\n      ARGV[4]  max check time\n    Events:\n      'stalled' with stalled job id.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to move job to wait to be picked up by a waiting worker.\n]]\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function moveJobToWait(metaKey, activeKey, waitKey, pausedKey, markerKey, eventStreamKey,\n  jobId, pushCmd)\n  local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n  addJobInTargetList(target, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\", jobId, 'prev', 'active')\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents then\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", maxEvents)\n  else\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", 10000)\n  end\nend\nlocal stalledKey = KEYS[1]\nlocal waitKey = KEYS[2]\nlocal activeKey = KEYS[3]\nlocal stalledCheckKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal pausedKey = KEYS[6]\nlocal markerKey = KEYS[7]\nlocal eventStreamKey = KEYS[8]\nlocal maxStalledJobCount = tonumber(ARGV[1])\nlocal queueKeyPrefix = ARGV[2]\nlocal timestamp = ARGV[3]\nlocal maxCheckTime = ARGV[4]\nif rcall(\"EXISTS\", stalledCheckKey) == 1 then\n    return {}\nend\nrcall(\"SET\", stalledCheckKey, timestamp, \"PX\", maxCheckTime)\n-- Trim events before emiting them to avoid trimming events emitted in this script\ntrimEvents(metaKey, eventStreamKey)\n-- Move all stalled jobs to wait\nlocal stalling = rcall('SMEMBERS', stalledKey)\nlocal stalled = {}\nif (#stalling > 0) then\n    rcall('DEL', stalledKey)\n    -- Remove from active list\n    for i, jobId in ipairs(stalling) do\n        -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n        if string.sub(jobId, 1, 2) == \"0:\" then\n            -- If the jobId is a delay marker ID we just remove it.\n            rcall(\"LREM\", activeKey, 1, jobId)\n        else\n            local jobKey = queueKeyPrefix .. jobId\n            -- Check that the lock is also missing, then we can handle this job as really stalled.\n            if (rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n                --  Remove from the active queue.\n                local removed = rcall(\"LREM\", activeKey, 1, jobId)\n                if (removed > 0) then\n                    -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.\n                    local stalledCount = rcall(\"HINCRBY\", jobKey, \"stc\", 1)\n                    -- Check if this is a repeatable job by looking at job options\n                    local jobOpts = rcall(\"HGET\", jobKey, \"opts\")\n                    local isRepeatableJob = false\n                    if jobOpts then\n                        local opts = cjson.decode(jobOpts)\n                        if opts and opts[\"repeat\"] then\n                            isRepeatableJob = true\n                        end\n                    end\n                    -- Only fail job if it exceeds stall limit AND is not a repeatable job\n                    if stalledCount > maxStalledJobCount and not isRepeatableJob then\n                        local failedReason = \"job stalled more than allowable limit\"\n                        rcall(\"HSET\", jobKey, \"defa\", failedReason)\n                    end\n                    moveJobToWait(metaKey, activeKey, waitKey, pausedKey, markerKey, eventStreamKey, jobId,\n                        \"RPUSH\")\n                    -- Emit the stalled event\n                    rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"stalled\", \"jobId\", jobId)\n                    table.insert(stalled, jobId)\n                end\n            end\n        end\n    end\nend\n-- Mark potentially stalled jobs\nlocal active = rcall('LRANGE', activeKey, 0, -1)\nif (#active > 0) then\n    for from, to in batches(#active, 7000) do\n        rcall('SADD', stalledKey, unpack(active, from, to))\n    end\nend\nreturn stalled\n`;\nconst moveStalledJobsToWait = {\n    name: 'moveStalledJobsToWait',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=moveStalledJobsToWait-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVTdGFsbGVkSm9ic1RvV2FpdC04LmpzPzNhMTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIE1vdmUgc3RhbGxlZCBqb2JzIHRvIHdhaXQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdzdGFsbGVkJyAoU0VUKVxuICAgICAgS0VZU1syXSAnd2FpdCcsICAgKExJU1QpXG4gICAgICBLRVlTWzNdICdhY3RpdmUnLCAoTElTVClcbiAgICAgIEtFWVNbNF0gJ3N0YWxsZWQtY2hlY2snLCAoS0VZKVxuICAgICAgS0VZU1s1XSAnbWV0YScsIChLRVkpXG4gICAgICBLRVlTWzZdICdwYXVzZWQnLCAoTElTVClcbiAgICAgIEtFWVNbN10gJ21hcmtlcidcbiAgICAgIEtFWVNbOF0gJ2V2ZW50IHN0cmVhbScgKFNUUkVBTSlcbiAgICAgIEFSR1ZbMV0gIE1heCBzdGFsbGVkIGpvYiBjb3VudFxuICAgICAgQVJHVlsyXSAgcXVldWUudG9LZXkoJycpXG4gICAgICBBUkdWWzNdICB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbNF0gIG1heCBjaGVjayB0aW1lXG4gICAgRXZlbnRzOlxuICAgICAgJ3N0YWxsZWQnIHdpdGggc3RhbGxlZCBqb2IgaWQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBsb29wIGluIGJhdGNoZXMuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgc29tZSBjb21tYW5kcyBhcyBaUkVNXG4gIGNvdWxkIHJlY2VpdmUgYSBtYXhpbXVtIG9mIDcwMDAgcGFyYW1ldGVycyBwZXIgY2FsbC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBiYXRjaGVzKG4sIGJhdGNoU2l6ZSlcbiAgbG9jYWwgaSA9IDBcbiAgcmV0dXJuIGZ1bmN0aW9uKClcbiAgICBsb2NhbCBmcm9tID0gaSAqIGJhdGNoU2l6ZSArIDFcbiAgICBpID0gaSArIDFcbiAgICBpZiAoZnJvbSA8PSBuKSB0aGVuXG4gICAgICBsb2NhbCB0byA9IG1hdGgubWluKGZyb20gKyBiYXRjaFNpemUgLSAxLCBuKVxuICAgICAgcmV0dXJuIGZyb20sIHRvXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIG1vdmUgam9iIHRvIHdhaXQgdG8gYmUgcGlja2VkIHVwIGJ5IGEgd2FpdGluZyB3b3JrZXIuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZUpvYlRvV2FpdChtZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSwgbWFya2VyS2V5LCBldmVudFN0cmVhbUtleSxcbiAgam9iSWQsIHB1c2hDbWQpXG4gIGxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgam9iSWQsICdwcmV2JywgJ2FjdGl2ZScpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gdHJpbSBldmVudHMsIGRlZmF1bHQgMTAwMDAuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gIGVuZFxuICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHRyaW1FdmVudHMobWV0YUtleSwgZXZlbnRTdHJlYW1LZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGlmIG1heEV2ZW50cyB0aGVuXG4gICAgcmNhbGwoXCJYVFJJTVwiLCBldmVudFN0cmVhbUtleSwgXCJNQVhMRU5cIiwgXCJ+XCIsIG1heEV2ZW50cylcbiAgZWxzZVxuICAgIHJjYWxsKFwiWFRSSU1cIiwgZXZlbnRTdHJlYW1LZXksIFwiTUFYTEVOXCIsIFwiflwiLCAxMDAwMClcbiAgZW5kXG5lbmRcbmxvY2FsIHN0YWxsZWRLZXkgPSBLRVlTWzFdXG5sb2NhbCB3YWl0S2V5ID0gS0VZU1syXVxubG9jYWwgYWN0aXZlS2V5ID0gS0VZU1szXVxubG9jYWwgc3RhbGxlZENoZWNrS2V5ID0gS0VZU1s0XVxubG9jYWwgbWV0YUtleSA9IEtFWVNbNV1cbmxvY2FsIHBhdXNlZEtleSA9IEtFWVNbNl1cbmxvY2FsIG1hcmtlcktleSA9IEtFWVNbN11cbmxvY2FsIGV2ZW50U3RyZWFtS2V5ID0gS0VZU1s4XVxubG9jYWwgbWF4U3RhbGxlZEpvYkNvdW50ID0gdG9udW1iZXIoQVJHVlsxXSlcbmxvY2FsIHF1ZXVlS2V5UHJlZml4ID0gQVJHVlsyXVxubG9jYWwgdGltZXN0YW1wID0gQVJHVlszXVxubG9jYWwgbWF4Q2hlY2tUaW1lID0gQVJHVls0XVxuaWYgcmNhbGwoXCJFWElTVFNcIiwgc3RhbGxlZENoZWNrS2V5KSA9PSAxIHRoZW5cbiAgICByZXR1cm4ge31cbmVuZFxucmNhbGwoXCJTRVRcIiwgc3RhbGxlZENoZWNrS2V5LCB0aW1lc3RhbXAsIFwiUFhcIiwgbWF4Q2hlY2tUaW1lKVxuLS0gVHJpbSBldmVudHMgYmVmb3JlIGVtaXRpbmcgdGhlbSB0byBhdm9pZCB0cmltbWluZyBldmVudHMgZW1pdHRlZCBpbiB0aGlzIHNjcmlwdFxudHJpbUV2ZW50cyhtZXRhS2V5LCBldmVudFN0cmVhbUtleSlcbi0tIE1vdmUgYWxsIHN0YWxsZWQgam9icyB0byB3YWl0XG5sb2NhbCBzdGFsbGluZyA9IHJjYWxsKCdTTUVNQkVSUycsIHN0YWxsZWRLZXkpXG5sb2NhbCBzdGFsbGVkID0ge31cbmlmICgjc3RhbGxpbmcgPiAwKSB0aGVuXG4gICAgcmNhbGwoJ0RFTCcsIHN0YWxsZWRLZXkpXG4gICAgLS0gUmVtb3ZlIGZyb20gYWN0aXZlIGxpc3RcbiAgICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKHN0YWxsaW5nKSBkb1xuICAgICAgICAtLSBNYXJrZXJzIGluIHdhaXRsaXN0IERFUFJFQ0FURUQgaW4gdjU6IFJlbW92ZSBpbiB2Ni5cbiAgICAgICAgaWYgc3RyaW5nLnN1Yihqb2JJZCwgMSwgMikgPT0gXCIwOlwiIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBqb2JJZCBpcyBhIGRlbGF5IG1hcmtlciBJRCB3ZSBqdXN0IHJlbW92ZSBpdC5cbiAgICAgICAgICAgIHJjYWxsKFwiTFJFTVwiLCBhY3RpdmVLZXksIDEsIGpvYklkKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsb2NhbCBqb2JLZXkgPSBxdWV1ZUtleVByZWZpeCAuLiBqb2JJZFxuICAgICAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGUgbG9jayBpcyBhbHNvIG1pc3NpbmcsIHRoZW4gd2UgY2FuIGhhbmRsZSB0aGlzIGpvYiBhcyByZWFsbHkgc3RhbGxlZC5cbiAgICAgICAgICAgIGlmIChyY2FsbChcIkVYSVNUU1wiLCBqb2JLZXkgLi4gXCI6bG9ja1wiKSA9PSAwKSB0aGVuXG4gICAgICAgICAgICAgICAgLS0gIFJlbW92ZSBmcm9tIHRoZSBhY3RpdmUgcXVldWUuXG4gICAgICAgICAgICAgICAgbG9jYWwgcmVtb3ZlZCA9IHJjYWxsKFwiTFJFTVwiLCBhY3RpdmVLZXksIDEsIGpvYklkKVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkID4gMCkgdGhlblxuICAgICAgICAgICAgICAgICAgICAtLSBJZiB0aGlzIGpvYiBoYXMgYmVlbiBzdGFsbGVkIHRvbyBtYW55IHRpbWVzLCBzdWNoIGFzIGlmIGl0IGNyYXNoZXMgdGhlIHdvcmtlciwgdGhlbiBmYWlsIGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2NhbCBzdGFsbGVkQ291bnQgPSByY2FsbChcIkhJTkNSQllcIiwgam9iS2V5LCBcInN0Y1wiLCAxKVxuICAgICAgICAgICAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGEgcmVwZWF0YWJsZSBqb2IgYnkgbG9va2luZyBhdCBqb2Igb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBsb2NhbCBqb2JPcHRzID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJvcHRzXCIpXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsIGlzUmVwZWF0YWJsZUpvYiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmIGpvYk9wdHMgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgb3B0cyA9IGNqc29uLmRlY29kZShqb2JPcHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3B0cyBhbmQgb3B0c1tcInJlcGVhdFwiXSB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXBlYXRhYmxlSm9iID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICAtLSBPbmx5IGZhaWwgam9iIGlmIGl0IGV4Y2VlZHMgc3RhbGwgbGltaXQgQU5EIGlzIG5vdCBhIHJlcGVhdGFibGUgam9iXG4gICAgICAgICAgICAgICAgICAgIGlmIHN0YWxsZWRDb3VudCA+IG1heFN0YWxsZWRKb2JDb3VudCBhbmQgbm90IGlzUmVwZWF0YWJsZUpvYiB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCBmYWlsZWRSZWFzb24gPSBcImpvYiBzdGFsbGVkIG1vcmUgdGhhbiBhbGxvd2FibGUgbGltaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJkZWZhXCIsIGZhaWxlZFJlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgICAgIG1vdmVKb2JUb1dhaXQobWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXksIG1hcmtlcktleSwgZXZlbnRTdHJlYW1LZXksIGpvYklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJSUFVTSFwiKVxuICAgICAgICAgICAgICAgICAgICAtLSBFbWl0IHRoZSBzdGFsbGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJzdGFsbGVkXCIsIFwiam9iSWRcIiwgam9iSWQpXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlLmluc2VydChzdGFsbGVkLCBqb2JJZClcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxuLS0gTWFyayBwb3RlbnRpYWxseSBzdGFsbGVkIGpvYnNcbmxvY2FsIGFjdGl2ZSA9IHJjYWxsKCdMUkFOR0UnLCBhY3RpdmVLZXksIDAsIC0xKVxuaWYgKCNhY3RpdmUgPiAwKSB0aGVuXG4gICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI2FjdGl2ZSwgNzAwMCkgZG9cbiAgICAgICAgcmNhbGwoJ1NBREQnLCBzdGFsbGVkS2V5LCB1bnBhY2soYWN0aXZlLCBmcm9tLCB0bykpXG4gICAgZW5kXG5lbmRcbnJldHVybiBzdGFsbGVkXG5gO1xuZXhwb3J0IGNvbnN0IG1vdmVTdGFsbGVkSm9ic1RvV2FpdCA9IHtcbiAgICBuYW1lOiAnbW92ZVN0YWxsZWRKb2JzVG9XYWl0JyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVN0YWxsZWRKb2JzVG9XYWl0LTguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveStalledJobsToWait-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToActive: () => (/* binding */ moveToActive)\n/* harmony export */ });\nconst content = `--[[\n  Move next job to be processed to active, lock it and fetch its data. The job\n  may be delayed, in that case we need to move it to the delayed set instead.\n  This operation guarantees that the worker owns the job during the lock\n  expiration time. The worker is responsible of keeping the lock fresh\n  so that no other worker picks this job again.\n  Input:\n    KEYS[1] wait key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] stream events key\n    KEYS[5] stalled key\n    -- Rate limiting\n    KEYS[6] rate limiter key\n    KEYS[7] delayed key\n    -- Delayed jobs\n    KEYS[8] paused key\n    KEYS[9] meta key\n    KEYS[10] pc priority counter\n    -- Marker\n    KEYS[11] marker key\n    -- Arguments\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] opts\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n    opts - name - worker name\n]]\nlocal rcall = redis.call\nlocal waitKey = KEYS[1]\nlocal activeKey = KEYS[2]\nlocal eventStreamKey = KEYS[4]\nlocal rateLimiterKey = KEYS[6]\nlocal delayedKey = KEYS[7]\nlocal opts = cmsgpack.unpack(ARGV[3])\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall(\"GET\", rateLimiterKey) or 0) then\n    local pttl = rcall(\"PTTL\", rateLimiterKey)\n    if pttl == 0 then\n      rcall(\"DEL\", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPrioritizedToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall(\"ZPOPMIN\", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall(\"LPUSH\", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall(\"DEL\", priorityCounterKey)\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, limiterDuration, markerKey, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall(\"INCR\", rateLimiterKey))\n    if jobCounter == 1 then\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall(\"PEXPIRE\", rateLimiterKey, integerDuration)\n    end\n  end\n  -- get a lock\n  if opts['token'] ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    rcall(\"SET\", lockKey, opts['token'], \"PX\", opts['lockDuration'])\n  end\n  local optionalValues = {}\n  if opts['name'] then\n    -- Set \"processedBy\" field to the worker name\n    table.insert(optionalValues, \"pb\")\n    table.insert(optionalValues, opts['name'])\n  end\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"active\", \"jobId\", jobId, \"prev\", \"waiting\")\n  rcall(\"HMSET\", jobKey, \"processedOn\", processedOn, unpack(optionalValues))\n  rcall(\"HINCRBY\", jobKey, \"ats\", 1)\n  addBaseMarkerIfNeeded(markerKey, false)\n  -- rate limit delay must be 0 in this case to prevent adding more delay\n  -- when job that is moved to active needs to be processed\n  return {rcall(\"HGETALL\", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall(\"LPUSH\", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall(\"ZADD\", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\nlocal target, isPausedOrMaxed, rateLimitMax, rateLimitDuration = getTargetQueueList(KEYS[9],\n    activeKey, waitKey, KEYS[8])\n-- Check if there are delayed jobs that we can move to wait.\nlocal markerKey = KEYS[11]\npromoteDelayedJobs(delayedKey, markerKey, target, KEYS[3], eventStreamKey, ARGV[1],\n                   ARGV[2], KEYS[10], isPausedOrMaxed)\nlocal maxJobs = tonumber(rateLimitMax or (opts['limiter'] and opts['limiter']['max']))\nlocal expireTime = getRateLimitTTL(maxJobs, rateLimiterKey)\n-- Check if we are rate limited first.\nif expireTime > 0 then return {0, 0, expireTime, 0} end\n-- paused or maxed queue\nif isPausedOrMaxed then return {0, 0, 0, 0} end\nlocal limiterDuration = (opts['limiter'] and opts['limiter']['duration']) or rateLimitDuration\n-- no job ID, try non-blocking move from wait to active\nlocal jobId = rcall(\"RPOPLPUSH\", waitKey, activeKey)\n-- Markers in waitlist DEPRECATED in v5: Will be completely removed in v6.\nif jobId and string.sub(jobId, 1, 2) == \"0:\" then\n    rcall(\"LREM\", activeKey, 1, jobId)\n    jobId = rcall(\"RPOPLPUSH\", waitKey, activeKey)\nend\nif jobId then\n    return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                   maxJobs, limiterDuration, markerKey, opts)\nelse\n    jobId = moveJobFromPrioritizedToActive(KEYS[3], activeKey, KEYS[10])\n    if jobId then\n        return prepareJobForProcessing(ARGV[1], rateLimiterKey, eventStreamKey, jobId, ARGV[2],\n                                       maxJobs, limiterDuration, markerKey, opts)\n    end\nend\n-- Return the timestamp for the next delayed job if any.\nlocal nextTimestamp = getNextDelayedTimestamp(delayedKey)\nif nextTimestamp ~= nil then return {0, 0, 0, nextTimestamp} end\nreturn {0, 0, 0, 0}\n`;\nconst moveToActive = {\n    name: 'moveToActive',\n    content,\n    keys: 11,\n};\n//# sourceMappingURL=moveToActive-11.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvQWN0aXZlLTExLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdCQUF3QjtBQUM3RCxRQUFRO0FBQ1I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVUb0FjdGl2ZS0xMS5qcz85ODg1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIG5leHQgam9iIHRvIGJlIHByb2Nlc3NlZCB0byBhY3RpdmUsIGxvY2sgaXQgYW5kIGZldGNoIGl0cyBkYXRhLiBUaGUgam9iXG4gIG1heSBiZSBkZWxheWVkLCBpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHRoZSBkZWxheWVkIHNldCBpbnN0ZWFkLlxuICBUaGlzIG9wZXJhdGlvbiBndWFyYW50ZWVzIHRoYXQgdGhlIHdvcmtlciBvd25zIHRoZSBqb2IgZHVyaW5nIHRoZSBsb2NrXG4gIGV4cGlyYXRpb24gdGltZS4gVGhlIHdvcmtlciBpcyByZXNwb25zaWJsZSBvZiBrZWVwaW5nIHRoZSBsb2NrIGZyZXNoXG4gIHNvIHRoYXQgbm8gb3RoZXIgd29ya2VyIHBpY2tzIHRoaXMgam9iIGFnYWluLlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgS0VZU1syXSBhY3RpdmUga2V5XG4gICAgS0VZU1szXSBwcmlvcml0aXplZCBrZXlcbiAgICBLRVlTWzRdIHN0cmVhbSBldmVudHMga2V5XG4gICAgS0VZU1s1XSBzdGFsbGVkIGtleVxuICAgIC0tIFJhdGUgbGltaXRpbmdcbiAgICBLRVlTWzZdIHJhdGUgbGltaXRlciBrZXlcbiAgICBLRVlTWzddIGRlbGF5ZWQga2V5XG4gICAgLS0gRGVsYXllZCBqb2JzXG4gICAgS0VZU1s4XSBwYXVzZWQga2V5XG4gICAgS0VZU1s5XSBtZXRhIGtleVxuICAgIEtFWVNbMTBdIHBjIHByaW9yaXR5IGNvdW50ZXJcbiAgICAtLSBNYXJrZXJcbiAgICBLRVlTWzExXSBtYXJrZXIga2V5XG4gICAgLS0gQXJndW1lbnRzXG4gICAgQVJHVlsxXSBrZXkgcHJlZml4XG4gICAgQVJHVlsyXSB0aW1lc3RhbXBcbiAgICBBUkdWWzNdIG9wdHNcbiAgICBvcHRzIC0gdG9rZW4gLSBsb2NrIHRva2VuXG4gICAgb3B0cyAtIGxvY2tEdXJhdGlvblxuICAgIG9wdHMgLSBsaW1pdGVyXG4gICAgb3B0cyAtIG5hbWUgLSB3b3JrZXIgbmFtZVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgd2FpdEtleSA9IEtFWVNbMV1cbmxvY2FsIGFjdGl2ZUtleSA9IEtFWVNbMl1cbmxvY2FsIGV2ZW50U3RyZWFtS2V5ID0gS0VZU1s0XVxubG9jYWwgcmF0ZUxpbWl0ZXJLZXkgPSBLRVlTWzZdXG5sb2NhbCBkZWxheWVkS2V5ID0gS0VZU1s3XVxubG9jYWwgb3B0cyA9IGNtc2dwYWNrLnVucGFjayhBUkdWWzNdKVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICByZXR1cm4gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgY3VycmVudCByYXRlIGxpbWl0IHR0bC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRSYXRlTGltaXRUVEwobWF4Sm9icywgcmF0ZUxpbWl0ZXJLZXkpXG4gIGlmIG1heEpvYnMgYW5kIG1heEpvYnMgPD0gdG9udW1iZXIocmNhbGwoXCJHRVRcIiwgcmF0ZUxpbWl0ZXJLZXkpIG9yIDApIHRoZW5cbiAgICBsb2NhbCBwdHRsID0gcmNhbGwoXCJQVFRMXCIsIHJhdGVMaW1pdGVyS2V5KVxuICAgIGlmIHB0dGwgPT0gMCB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCByYXRlTGltaXRlcktleSlcbiAgICBlbmRcbiAgICBpZiBwdHRsID4gMCB0aGVuXG4gICAgICByZXR1cm4gcHR0bFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIG1vdmUgam9iIGZyb20gcHJpb3JpdGl6ZWQgc3RhdGUgdG8gYWN0aXZlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIG1vdmVKb2JGcm9tUHJpb3JpdGl6ZWRUb0FjdGl2ZShwcmlvcml0eUtleSwgYWN0aXZlS2V5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHByaW9yaXRpemVkSm9iID0gcmNhbGwoXCJaUE9QTUlOXCIsIHByaW9yaXR5S2V5KVxuICBpZiAjcHJpb3JpdGl6ZWRKb2IgPiAwIHRoZW5cbiAgICByY2FsbChcIkxQVVNIXCIsIGFjdGl2ZUtleSwgcHJpb3JpdGl6ZWRKb2JbMV0pXG4gICAgcmV0dXJuIHByaW9yaXRpemVkSm9iWzFdXG4gIGVsc2VcbiAgICByY2FsbChcIkRFTFwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIG1vdmUgam9iIGZyb20gd2FpdCBzdGF0ZSB0byBhY3RpdmUuXG4gIElucHV0OlxuICAgIG9wdHMgLSB0b2tlbiAtIGxvY2sgdG9rZW5cbiAgICBvcHRzIC0gbG9ja0R1cmF0aW9uXG4gICAgb3B0cyAtIGxpbWl0ZXJcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhrZXlQcmVmaXgsIHJhdGVMaW1pdGVyS2V5LCBldmVudFN0cmVhbUtleSxcbiAgICBqb2JJZCwgcHJvY2Vzc2VkT24sIG1heEpvYnMsIGxpbWl0ZXJEdXJhdGlvbiwgbWFya2VyS2V5LCBvcHRzKVxuICBsb2NhbCBqb2JLZXkgPSBrZXlQcmVmaXggLi4gam9iSWRcbiAgLS0gQ2hlY2sgaWYgd2UgbmVlZCB0byBwZXJmb3JtIHJhdGUgbGltaXRpbmcuXG4gIGlmIG1heEpvYnMgdGhlblxuICAgIGxvY2FsIGpvYkNvdW50ZXIgPSB0b251bWJlcihyY2FsbChcIklOQ1JcIiwgcmF0ZUxpbWl0ZXJLZXkpKVxuICAgIGlmIGpvYkNvdW50ZXIgPT0gMSB0aGVuXG4gICAgICBsb2NhbCBpbnRlZ2VyRHVyYXRpb24gPSBtYXRoLmZsb29yKG1hdGguYWJzKGxpbWl0ZXJEdXJhdGlvbikpXG4gICAgICByY2FsbChcIlBFWFBJUkVcIiwgcmF0ZUxpbWl0ZXJLZXksIGludGVnZXJEdXJhdGlvbilcbiAgICBlbmRcbiAgZW5kXG4gIC0tIGdldCBhIGxvY2tcbiAgaWYgb3B0c1sndG9rZW4nXSB+PSBcIjBcIiB0aGVuXG4gICAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gICAgcmNhbGwoXCJTRVRcIiwgbG9ja0tleSwgb3B0c1sndG9rZW4nXSwgXCJQWFwiLCBvcHRzWydsb2NrRHVyYXRpb24nXSlcbiAgZW5kXG4gIGxvY2FsIG9wdGlvbmFsVmFsdWVzID0ge31cbiAgaWYgb3B0c1snbmFtZSddIHRoZW5cbiAgICAtLSBTZXQgXCJwcm9jZXNzZWRCeVwiIGZpZWxkIHRvIHRoZSB3b3JrZXIgbmFtZVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYlwiKVxuICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgb3B0c1snbmFtZSddKVxuICBlbmRcbiAgcmNhbGwoXCJYQUREXCIsIGV2ZW50U3RyZWFtS2V5LCBcIipcIiwgXCJldmVudFwiLCBcImFjdGl2ZVwiLCBcImpvYklkXCIsIGpvYklkLCBcInByZXZcIiwgXCJ3YWl0aW5nXCIpXG4gIHJjYWxsKFwiSE1TRVRcIiwgam9iS2V5LCBcInByb2Nlc3NlZE9uXCIsIHByb2Nlc3NlZE9uLCB1bnBhY2sob3B0aW9uYWxWYWx1ZXMpKVxuICByY2FsbChcIkhJTkNSQllcIiwgam9iS2V5LCBcImF0c1wiLCAxKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBmYWxzZSlcbiAgLS0gcmF0ZSBsaW1pdCBkZWxheSBtdXN0IGJlIDAgaW4gdGhpcyBjYXNlIHRvIHByZXZlbnQgYWRkaW5nIG1vcmUgZGVsYXlcbiAgLS0gd2hlbiBqb2IgdGhhdCBpcyBtb3ZlZCB0byBhY3RpdmUgbmVlZHMgdG8gYmUgcHJvY2Vzc2VkXG4gIHJldHVybiB7cmNhbGwoXCJIR0VUQUxMXCIsIGpvYktleSksIGpvYklkLCAwLCAwfSAtLSBnZXQgam9iIGRhdGFcbmVuZFxuLS1bW1xuICBVcGRhdGVzIHRoZSBkZWxheSBzZXQsIGJ5IG1vdmluZyBkZWxheWVkIGpvYnMgdGhhdCBzaG91bGRcbiAgYmUgcHJvY2Vzc2VkIG5vdyB0byBcIndhaXRcIi5cbiAgICAgRXZlbnRzOlxuICAgICAgJ3dhaXRpbmcnXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWRPck1heGVkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IHByaW9yaXR5IHNjb3JlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFByaW9yaXR5U2NvcmUocHJpb3JpdHksIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByZXR1cm4gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIHByaW9Db3VudGVyICUgMHgxMDAwMDAwMDBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LFxuICBpc1BhdXNlZE9yTWF4ZWQpXG4gIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdGl6ZWRLZXksIHNjb3JlLCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG4tLSBUcnkgdG8gZ2V0IGFzIG11Y2ggYXMgMTAwMCBqb2JzIGF0IG9uY2VcbmxvY2FsIGZ1bmN0aW9uIHByb21vdGVEZWxheWVkSm9icyhkZWxheWVkS2V5LCBtYXJrZXJLZXksIHRhcmdldEtleSwgcHJpb3JpdGl6ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdHJlYW1LZXksIHByZWZpeCwgdGltZXN0YW1wLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICAgIGxvY2FsIGpvYnMgPSByY2FsbChcIlpSQU5HRUJZU0NPUkVcIiwgZGVsYXllZEtleSwgMCwgKHRpbWVzdGFtcCArIDEpICogMHgxMDAwIC0gMSwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuICAgIGlmICgjam9icyA+IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIHVucGFjayhqb2JzKSlcbiAgICAgICAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0eSA9XG4gICAgICAgICAgICAgICAgdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgIGpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgICAgIGVuZFxuICAgICAgICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgICBlbmRcbmVuZFxubG9jYWwgdGFyZ2V0LCBpc1BhdXNlZE9yTWF4ZWQsIHJhdGVMaW1pdE1heCwgcmF0ZUxpbWl0RHVyYXRpb24gPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s5XSxcbiAgICBhY3RpdmVLZXksIHdhaXRLZXksIEtFWVNbOF0pXG4tLSBDaGVjayBpZiB0aGVyZSBhcmUgZGVsYXllZCBqb2JzIHRoYXQgd2UgY2FuIG1vdmUgdG8gd2FpdC5cbmxvY2FsIG1hcmtlcktleSA9IEtFWVNbMTFdXG5wcm9tb3RlRGVsYXllZEpvYnMoZGVsYXllZEtleSwgbWFya2VyS2V5LCB0YXJnZXQsIEtFWVNbM10sIGV2ZW50U3RyZWFtS2V5LCBBUkdWWzFdLFxuICAgICAgICAgICAgICAgICAgIEFSR1ZbMl0sIEtFWVNbMTBdLCBpc1BhdXNlZE9yTWF4ZWQpXG5sb2NhbCBtYXhKb2JzID0gdG9udW1iZXIocmF0ZUxpbWl0TWF4IG9yIChvcHRzWydsaW1pdGVyJ10gYW5kIG9wdHNbJ2xpbWl0ZXInXVsnbWF4J10pKVxubG9jYWwgZXhwaXJlVGltZSA9IGdldFJhdGVMaW1pdFRUTChtYXhKb2JzLCByYXRlTGltaXRlcktleSlcbi0tIENoZWNrIGlmIHdlIGFyZSByYXRlIGxpbWl0ZWQgZmlyc3QuXG5pZiBleHBpcmVUaW1lID4gMCB0aGVuIHJldHVybiB7MCwgMCwgZXhwaXJlVGltZSwgMH0gZW5kXG4tLSBwYXVzZWQgb3IgbWF4ZWQgcXVldWVcbmlmIGlzUGF1c2VkT3JNYXhlZCB0aGVuIHJldHVybiB7MCwgMCwgMCwgMH0gZW5kXG5sb2NhbCBsaW1pdGVyRHVyYXRpb24gPSAob3B0c1snbGltaXRlciddIGFuZCBvcHRzWydsaW1pdGVyJ11bJ2R1cmF0aW9uJ10pIG9yIHJhdGVMaW1pdER1cmF0aW9uXG4tLSBubyBqb2IgSUQsIHRyeSBub24tYmxvY2tpbmcgbW92ZSBmcm9tIHdhaXQgdG8gYWN0aXZlXG5sb2NhbCBqb2JJZCA9IHJjYWxsKFwiUlBPUExQVVNIXCIsIHdhaXRLZXksIGFjdGl2ZUtleSlcbi0tIE1hcmtlcnMgaW4gd2FpdGxpc3QgREVQUkVDQVRFRCBpbiB2NTogV2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQgaW4gdjYuXG5pZiBqb2JJZCBhbmQgc3RyaW5nLnN1Yihqb2JJZCwgMSwgMikgPT0gXCIwOlwiIHRoZW5cbiAgICByY2FsbChcIkxSRU1cIiwgYWN0aXZlS2V5LCAxLCBqb2JJZClcbiAgICBqb2JJZCA9IHJjYWxsKFwiUlBPUExQVVNIXCIsIHdhaXRLZXksIGFjdGl2ZUtleSlcbmVuZFxuaWYgam9iSWQgdGhlblxuICAgIHJldHVybiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhBUkdWWzFdLCByYXRlTGltaXRlcktleSwgZXZlbnRTdHJlYW1LZXksIGpvYklkLCBBUkdWWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhKb2JzLCBsaW1pdGVyRHVyYXRpb24sIG1hcmtlcktleSwgb3B0cylcbmVsc2VcbiAgICBqb2JJZCA9IG1vdmVKb2JGcm9tUHJpb3JpdGl6ZWRUb0FjdGl2ZShLRVlTWzNdLCBhY3RpdmVLZXksIEtFWVNbMTBdKVxuICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgcmV0dXJuIHByZXBhcmVKb2JGb3JQcm9jZXNzaW5nKEFSR1ZbMV0sIHJhdGVMaW1pdGVyS2V5LCBldmVudFN0cmVhbUtleSwgam9iSWQsIEFSR1ZbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhKb2JzLCBsaW1pdGVyRHVyYXRpb24sIG1hcmtlcktleSwgb3B0cylcbiAgICBlbmRcbmVuZFxuLS0gUmV0dXJuIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSBuZXh0IGRlbGF5ZWQgam9iIGlmIGFueS5cbmxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlbiByZXR1cm4gezAsIDAsIDAsIG5leHRUaW1lc3RhbXB9IGVuZFxucmV0dXJuIHswLCAwLCAwLCAwfVxuYDtcbmV4cG9ydCBjb25zdCBtb3ZlVG9BY3RpdmUgPSB7XG4gICAgbmFtZTogJ21vdmVUb0FjdGl2ZScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3ZlVG9BY3RpdmUtMTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToActive-11.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-8.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToDelayed-8.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToDelayed: () => (/* binding */ moveToDelayed)\n/* harmony export */ });\nconst content = `--[[\n  Moves job from active to delayed set.\n  Input:\n    KEYS[1] marker key\n    KEYS[2] active key\n    KEYS[3] prioritized key\n    KEYS[4] delayed key\n    KEYS[5] job key\n    KEYS[6] events stream\n    KEYS[7] meta key\n    KEYS[8] stalled key\n    ARGV[1] key prefix\n    ARGV[2] timestamp\n    ARGV[3] the id of the job\n    ARGV[4] queue token\n    ARGV[5] delay value\n    ARGV[6] skip attempt\n    ARGV[7] optional job fields to update\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -3 - Job not in active set.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall(\"ZREVRANGEBYSCORE\", delayedKey, maxScore,\n    minScore, \"WITHSCORES\",\"LIMIT\", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall(\"HMSET\", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal jobKey = KEYS[5]\nlocal metaKey = KEYS[7]\nlocal token = ARGV[4] \nif rcall(\"EXISTS\", jobKey) == 1 then\n    local errorCode = removeLock(jobKey, KEYS[8], token, ARGV[3])\n    if errorCode < 0 then\n        return errorCode\n    end\n    updateJobFields(jobKey, ARGV[7])\n    local delayedKey = KEYS[4]\n    local jobId = ARGV[3]\n    local delay = tonumber(ARGV[5])\n    local numRemovedElements = rcall(\"LREM\", KEYS[2], -1, jobId)\n    if numRemovedElements < 1 then return -3 end\n    local score, delayedTimestamp = getDelayedScore(delayedKey, ARGV[2], delay)\n    if ARGV[6] == \"0\" then\n        rcall(\"HINCRBY\", jobKey, \"atm\", 1)\n    end\n    rcall(\"HSET\", jobKey, \"delay\", ARGV[5])\n    local maxEvents = getOrSetMaxEvents(metaKey)\n    rcall(\"ZADD\", delayedKey, score, jobId)\n    rcall(\"XADD\", KEYS[6], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n          \"jobId\", jobId, \"delay\", delayedTimestamp)\n    -- Check if we need to push a marker job to wake up sleeping workers.\n    local markerKey = KEYS[1]\n    addDelayMarkerIfNeeded(markerKey, delayedKey)\n    return 0\nelse\n    return -1\nend\n`;\nconst moveToDelayed = {\n    name: 'moveToDelayed',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=moveToDelayed-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvRGVsYXllZC04LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVUb0RlbGF5ZWQtOC5qcz9kMzFmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlcyBqb2IgZnJvbSBhY3RpdmUgdG8gZGVsYXllZCBzZXQuXG4gIElucHV0OlxuICAgIEtFWVNbMV0gbWFya2VyIGtleVxuICAgIEtFWVNbMl0gYWN0aXZlIGtleVxuICAgIEtFWVNbM10gcHJpb3JpdGl6ZWQga2V5XG4gICAgS0VZU1s0XSBkZWxheWVkIGtleVxuICAgIEtFWVNbNV0gam9iIGtleVxuICAgIEtFWVNbNl0gZXZlbnRzIHN0cmVhbVxuICAgIEtFWVNbN10gbWV0YSBrZXlcbiAgICBLRVlTWzhdIHN0YWxsZWQga2V5XG4gICAgQVJHVlsxXSBrZXkgcHJlZml4XG4gICAgQVJHVlsyXSB0aW1lc3RhbXBcbiAgICBBUkdWWzNdIHRoZSBpZCBvZiB0aGUgam9iXG4gICAgQVJHVls0XSBxdWV1ZSB0b2tlblxuICAgIEFSR1ZbNV0gZGVsYXkgdmFsdWVcbiAgICBBUkdWWzZdIHNraXAgYXR0ZW1wdFxuICAgIEFSR1ZbN10gb3B0aW9uYWwgam9iIGZpZWxkcyB0byB1cGRhdGVcbiAgT3V0cHV0OlxuICAgIDAgLSBPS1xuICAgLTEgLSBNaXNzaW5nIGpvYi5cbiAgIC0zIC0gSm9iIG5vdCBpbiBhY3RpdmUgc2V0LlxuICBFdmVudHM6XG4gICAgLSBkZWxheWVkIGtleS5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbmV4dCBkZWxheWVkIGpvYiB0aW1lc3RhbXAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkFOR0VcIiwgZGVsYXllZEtleSwgMCwgMCwgXCJXSVRIU0NPUkVTXCIpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgICAgcmV0dXJuIG5leHRUaW1lc3RhbXAgLyAweDEwMDBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICBsb2NhbCBuZXh0VGltZXN0YW1wID0gZ2V0TmV4dERlbGF5ZWRUaW1lc3RhbXAoZGVsYXllZEtleSlcbiAgaWYgbmV4dFRpbWVzdGFtcCB+PSBuaWwgdGhlblxuICAgIC0tIFJlcGxhY2UgdGhlIHNjb3JlIG9mIHRoZSBtYXJrZXIgd2l0aCB0aGUgbmV3ZXN0IGtub3duXG4gICAgLS0gbmV4dCB0aW1lc3RhbXAuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgbmV4dFRpbWVzdGFtcCwgXCIxXCIpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEJha2UgaW4gdGhlIGpvYiBpZCBmaXJzdCAxMiBiaXRzIGludG8gdGhlIHRpbWVzdGFtcFxuICB0byBndWFyYW50ZWUgY29ycmVjdCBleGVjdXRpb24gb3JkZXIgb2YgZGVsYXllZCBqb2JzXG4gICh1cCB0byA0MDk2IGpvYnMgcGVyIGdpdmVuIHRpbWVzdGFtcCBvciA0MDk2IGpvYnMgYXBhcnQgcGVyIHRpbWVzdGFtcClcbiAgV0FSTklORzogSm9icyB0aGF0IGFyZSBzbyBmYXIgYXBhcnQgdGhhdCB0aGV5IHdyYXAgYXJvdW5kIHdpbGwgY2F1c2UgRklGTyB0byBmYWlsXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0RGVsYXllZFNjb3JlKGRlbGF5ZWRLZXksIHRpbWVzdGFtcCwgZGVsYXkpXG4gIGxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSAoZGVsYXkgPiAwIGFuZCAodG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5KSkgb3IgdG9udW1iZXIodGltZXN0YW1wKVxuICBsb2NhbCBtaW5TY29yZSA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDBcbiAgbG9jYWwgbWF4U2NvcmUgPSAoZGVsYXllZFRpbWVzdGFtcCArIDEgKSAqIDB4MTAwMCAtIDFcbiAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJaUkVWUkFOR0VCWVNDT1JFXCIsIGRlbGF5ZWRLZXksIG1heFNjb3JlLFxuICAgIG1pblNjb3JlLCBcIldJVEhTQ09SRVNcIixcIkxJTUlUXCIsIDAsIDEpXG4gIGlmICNyZXN1bHQgdGhlblxuICAgIGxvY2FsIGN1cnJlbnRNYXhTY29yZSA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBjdXJyZW50TWF4U2NvcmUgfj0gbmlsIHRoZW5cbiAgICAgIGlmIGN1cnJlbnRNYXhTY29yZSA+PSBtYXhTY29yZSB0aGVuXG4gICAgICAgIHJldHVybiBtYXhTY29yZSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY3VycmVudE1heFNjb3JlICsgMSwgZGVsYXllZFRpbWVzdGFtcFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gbWluU2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTG9jayhqb2JLZXksIHN0YWxsZWRLZXksIHRva2VuLCBqb2JJZClcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIGxvY2FsIGxvY2tUb2tlbiA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgLS0gTG9jayBleGlzdHMgYnV0IHRva2VuIGRvZXMgbm90IG1hdGNoXG4gICAgICAgIHJldHVybiAtNlxuICAgICAgZWxzZVxuICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICByZXR1cm4gLTJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byB1cGRhdGUgYSBidW5jaCBvZiBmaWVsZHMgaW4gYSBqb2IuXG5dXVxubG9jYWwgZnVuY3Rpb24gdXBkYXRlSm9iRmllbGRzKGpvYktleSwgbXNncGFja2VkRmllbGRzKVxuICBpZiBtc2dwYWNrZWRGaWVsZHMgYW5kICNtc2dwYWNrZWRGaWVsZHMgPiAwIHRoZW5cbiAgICBsb2NhbCBmaWVsZHNUb1VwZGF0ZSA9IGNtc2dwYWNrLnVucGFjayhtc2dwYWNrZWRGaWVsZHMpXG4gICAgaWYgZmllbGRzVG9VcGRhdGUgdGhlblxuICAgICAgcmNhbGwoXCJITVNFVFwiLCBqb2JLZXksIHVucGFjayhmaWVsZHNUb1VwZGF0ZSkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBqb2JLZXkgPSBLRVlTWzVdXG5sb2NhbCBtZXRhS2V5ID0gS0VZU1s3XVxubG9jYWwgdG9rZW4gPSBBUkdWWzRdIFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgam9iS2V5KSA9PSAxIHRoZW5cbiAgICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKGpvYktleSwgS0VZU1s4XSwgdG9rZW4sIEFSR1ZbM10pXG4gICAgaWYgZXJyb3JDb2RlIDwgMCB0aGVuXG4gICAgICAgIHJldHVybiBlcnJvckNvZGVcbiAgICBlbmRcbiAgICB1cGRhdGVKb2JGaWVsZHMoam9iS2V5LCBBUkdWWzddKVxuICAgIGxvY2FsIGRlbGF5ZWRLZXkgPSBLRVlTWzRdXG4gICAgbG9jYWwgam9iSWQgPSBBUkdWWzNdXG4gICAgbG9jYWwgZGVsYXkgPSB0b251bWJlcihBUkdWWzVdKVxuICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzJdLCAtMSwgam9iSWQpXG4gICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzIDwgMSB0aGVuIHJldHVybiAtMyBlbmRcbiAgICBsb2NhbCBzY29yZSwgZGVsYXllZFRpbWVzdGFtcCA9IGdldERlbGF5ZWRTY29yZShkZWxheWVkS2V5LCBBUkdWWzJdLCBkZWxheSlcbiAgICBpZiBBUkdWWzZdID09IFwiMFwiIHRoZW5cbiAgICAgICAgcmNhbGwoXCJISU5DUkJZXCIsIGpvYktleSwgXCJhdG1cIiwgMSlcbiAgICBlbmRcbiAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIEFSR1ZbNV0pXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgICByY2FsbChcIlpBRERcIiwgZGVsYXllZEtleSwgc2NvcmUsIGpvYklkKVxuICAgIHJjYWxsKFwiWEFERFwiLCBLRVlTWzZdLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIixcbiAgICAgICAgICBcImpvYklkXCIsIGpvYklkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4gICAgLS0gQ2hlY2sgaWYgd2UgbmVlZCB0byBwdXNoIGEgbWFya2VyIGpvYiB0byB3YWtlIHVwIHNsZWVwaW5nIHdvcmtlcnMuXG4gICAgbG9jYWwgbWFya2VyS2V5ID0gS0VZU1sxXVxuICAgIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBkZWxheWVkS2V5KVxuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIC0xXG5lbmRcbmA7XG5leHBvcnQgY29uc3QgbW92ZVRvRGVsYXllZCA9IHtcbiAgICBuYW1lOiAnbW92ZVRvRGVsYXllZCcsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA4LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vdmVUb0RlbGF5ZWQtOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToDelayed-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToFinished: () => (/* binding */ moveToFinished)\n/* harmony export */ });\nconst content = `--[[\n  Move job from active to a finished status (completed o failed)\n  A job can only be moved to completed if it was active.\n  The job must be locked before it can be moved to a finished status,\n  and the lock must be released in this script.\n    Input:\n      KEYS[1] wait key\n      KEYS[2] active key\n      KEYS[3] prioritized key\n      KEYS[4] event stream key\n      KEYS[5] stalled key\n      -- Rate limiting\n      KEYS[6] rate limiter key\n      KEYS[7] delayed key\n      KEYS[8] paused key\n      KEYS[9] meta key\n      KEYS[10] pc priority counter\n      KEYS[11] completed/failed key\n      KEYS[12] jobId key\n      KEYS[13] metrics key\n      KEYS[14] marker key\n      ARGV[1]  jobId\n      ARGV[2]  timestamp\n      ARGV[3]  msg property returnvalue / failedReason\n      ARGV[4]  return value / failed reason\n      ARGV[5]  target (completed/failed)\n      ARGV[6]  fetch next?\n      ARGV[7]  keys prefix\n      ARGV[8]  opts\n      ARGV[9]  job fields to update\n      opts - token - lock token\n      opts - keepJobs\n      opts - lockDuration - lock duration in milliseconds\n      opts - attempts max attempts\n      opts - maxMetricsSize\n      opts - fpof - fail parent on fail\n      opts - cpof - continue parent on fail\n      opts - idof - ignore dependency on fail\n      opts - rdof - remove dependency on fail\n      opts - name - worker name\n    Output:\n      0 OK\n      -1 Missing key.\n      -2 Missing lock.\n      -3 Job not in active set\n      -4 Job has pending children\n      -6 Lock is not owned by this client\n      -9 Job has failed children\n    Events:\n      'completed/failed'\n]]\nlocal rcall = redis.call\n--- Includes\n--[[\n  Functions to collect metrics based on a current and previous count of jobs.\n  Granualarity is fixed at 1 minute.\n]]\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function collectMetrics(metaKey, dataPointsList, maxDataPoints,\n                                 timestamp)\n    -- Increment current count\n    local count = rcall(\"HINCRBY\", metaKey, \"count\", 1) - 1\n    -- Compute how many data points we need to add to the list, N.\n    local prevTS = rcall(\"HGET\", metaKey, \"prevTS\")\n    if not prevTS then\n        -- If prevTS is nil, set it to the current timestamp\n        rcall(\"HSET\", metaKey, \"prevTS\", timestamp, \"prevCount\", 0)\n        return\n    end\n    local N = math.min(math.floor(timestamp / 60000) - math.floor(prevTS / 60000), tonumber(maxDataPoints))\n    if N > 0 then\n        local delta = count - rcall(\"HGET\", metaKey, \"prevCount\")\n        -- If N > 1, add N-1 zeros to the list\n        if N > 1 then\n            local points = {}\n            points[1] = delta\n            for i = 2, N do\n                points[i] = 0\n            end\n            for from, to in batches(#points, 7000) do\n                rcall(\"LPUSH\", dataPointsList, unpack(points, from, to))\n            end\n        else\n            -- LPUSH delta to the list\n            rcall(\"LPUSH\", dataPointsList, delta)\n        end\n        -- LTRIM to keep list to its max size\n        rcall(\"LTRIM\", dataPointsList, 0, maxDataPoints - 1)\n        -- update prev count with current count\n        rcall(\"HSET\", metaKey, \"prevCount\", count, \"prevTS\", timestamp)\n    end\nend\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\n--[[\n  Function to get current rate limit ttl.\n]]\nlocal function getRateLimitTTL(maxJobs, rateLimiterKey)\n  if maxJobs and maxJobs <= tonumber(rcall(\"GET\", rateLimiterKey) or 0) then\n    local pttl = rcall(\"PTTL\", rateLimiterKey)\n    if pttl == 0 then\n      rcall(\"DEL\", rateLimiterKey)\n    end\n    if pttl > 0 then\n      return pttl\n    end\n  end\n  return 0\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to move job from prioritized state to active.\n]]\nlocal function moveJobFromPrioritizedToActive(priorityKey, activeKey, priorityCounterKey)\n  local prioritizedJob = rcall(\"ZPOPMIN\", priorityKey)\n  if #prioritizedJob > 0 then\n    rcall(\"LPUSH\", activeKey, prioritizedJob[1])\n    return prioritizedJob[1]\n  else\n    rcall(\"DEL\", priorityCounterKey)\n  end\nend\n--[[\n  Function to recursively move from waitingChildren to failed.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized)\n  if no pending dependencies.\n]]\n-- Includes\n--[[\n  Validate and move parent to a wait status (waiting, delayed or prioritized) if needed.\n]]\n-- Includes\n--[[\n  Move parent to a wait status (wait, prioritized or delayed)\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\nlocal function moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    local parentWaitKey = parentQueueKey .. \":wait\"\n    local parentPausedKey = parentQueueKey .. \":paused\"\n    local parentActiveKey = parentQueueKey .. \":active\"\n    local parentMetaKey = parentQueueKey .. \":meta\"\n    local parentMarkerKey = parentQueueKey .. \":marker\"\n    local jobAttributes = rcall(\"HMGET\", parentKey, \"priority\", \"delay\")\n    local priority = tonumber(jobAttributes[1]) or 0\n    local delay = tonumber(jobAttributes[2]) or 0\n    if delay > 0 then\n        local delayedTimestamp = tonumber(timestamp) + delay\n        local score = delayedTimestamp * 0x1000\n        local parentDelayedKey = parentQueueKey .. \":delayed\"\n        rcall(\"ZADD\", parentDelayedKey, score, parentId)\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"delayed\", \"jobId\", parentId, \"delay\",\n            delayedTimestamp)\n        addDelayMarkerIfNeeded(parentMarkerKey, parentDelayedKey)\n    else\n        if priority == 0 then\n            local parentTarget, isParentPausedOrMaxed = getTargetQueueList(parentMetaKey, parentActiveKey,\n                parentWaitKey, parentPausedKey)\n            addJobInTargetList(parentTarget, parentMarkerKey, \"RPUSH\", isParentPausedOrMaxed, parentId)\n        else\n            local isPausedOrMaxed = isQueuePausedOrMaxed(parentMetaKey, parentActiveKey)\n            addJobWithPriority(parentMarkerKey, parentQueueKey .. \":prioritized\", priority, parentId,\n                parentQueueKey .. \":pc\", isPausedOrMaxed)\n        end\n        rcall(\"XADD\", parentQueueKey .. \":events\", \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\",\n            \"waiting-children\")\n    end\nend\nlocal function moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then    \n      rcall(\"ZREM\", parentWaitingChildrenKey, parentId)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    end\n  end\nend\nlocal function moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey,\n  parentId, timestamp)\n  local doNotHavePendingDependencies = rcall(\"SCARD\", parentDependenciesKey) == 0\n  if doNotHavePendingDependencies then\n    moveParentToWaitIfNeeded(parentQueueKey, parentKey, parentId, timestamp)\n  end\nend\n--[[\n  Functions to remove jobs when removeOnFail option is provided.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\n--[[\n  Functions to remove jobs by max age.\n]]\n-- Includes\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix,\n  shouldRemoveDebounceKey)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\nend\n--[[\n  Functions to remove jobs by max count.\n]]\n-- Includes\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, false, prefix, false --[[remove debounce key]])\n  end\n  rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1))\nend\nlocal function removeJobsOnFail(queueKeyPrefix, failedKey, jobId, opts, timestamp)\n  local removeOnFailType = type(opts[\"removeOnFail\"])\n  if removeOnFailType == \"number\" then\n    removeJobsByMaxCount(opts[\"removeOnFail\"],\n                        failedKey, queueKeyPrefix)\n  elseif removeOnFailType == \"boolean\" then\n    if opts[\"removeOnFail\"] then\n      removeJob(jobId, false, queueKeyPrefix,\n                false --[[remove debounce key]])\n      rcall(\"ZREM\", failedKey, jobId)\n    end\n  elseif removeOnFailType ~= \"nil\" then\n    local maxAge = opts[\"removeOnFail\"][\"age\"]\n    local maxCount = opts[\"removeOnFail\"][\"count\"]\n    if maxAge ~= nil then\n      removeJobsByMaxAge(timestamp, maxAge,\n                        failedKey, queueKeyPrefix)\n    end\n    if maxCount ~= nil and maxCount > 0 then\n      removeJobsByMaxCount(maxCount, failedKey,\n                            queueKeyPrefix)\n    end\n  end \nend\nlocal moveParentToFailedIfNeeded = function (parentQueueKey, parentKey, parentId, jobIdKey, timestamp)\n  if rcall(\"EXISTS\", parentKey) == 1 then\n    local parentWaitingChildrenKey = parentQueueKey .. \":waiting-children\"\n    local parentDelayedKey = parentQueueKey .. \":delayed\"\n    local parentPrioritizedKey = parentQueueKey .. \":prioritized\"\n    local parentWaitingChildrenOrDelayedKey\n    local prevState\n    if rcall(\"ZSCORE\", parentWaitingChildrenKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentWaitingChildrenKey\n      prevState = \"waiting-children\"\n    elseif rcall(\"ZSCORE\", parentDelayedKey, parentId) then\n      parentWaitingChildrenOrDelayedKey = parentDelayedKey\n      prevState = \"delayed\"\n      rcall(\"HSET\", parentKey, \"delay\", 0)\n    end\n    if parentWaitingChildrenOrDelayedKey then\n      rcall(\"ZREM\", parentWaitingChildrenOrDelayedKey, parentId)\n      local parentQueuePrefix = parentQueueKey .. \":\"\n      local parentFailedKey = parentQueueKey .. \":failed\"\n      local deferredFailure = \"child \" .. jobIdKey .. \" failed\"\n      rcall(\"HSET\", parentKey, \"defa\", deferredFailure)\n      moveParentToWait(parentQueueKey, parentKey, parentId, timestamp)\n    else\n      if not rcall(\"ZSCORE\", parentQueueKey .. \":failed\", parentId) then\n        local deferredFailure = \"child \" .. jobIdKey .. \" failed\"\n        rcall(\"HSET\", parentKey, \"defa\", deferredFailure)\n      end\n    end\n  end\nend\nlocal moveChildFromDependenciesIfNeeded = function (rawParentData, childKey, failedReason, timestamp)\n  if rawParentData then\n    local parentData = cjson.decode(rawParentData)\n    local parentKey = parentData['queueKey'] .. ':' .. parentData['id']\n    local parentDependenciesChildrenKey = parentKey .. \":dependencies\"\n    if parentData['fpof'] then\n      if rcall(\"SREM\", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentUnsuccesssfulChildrenKey = parentKey .. \":unsuccessful\"\n        rcall(\"ZADD\", parentUnsuccesssfulChildrenKey, timestamp, childKey)\n        moveParentToFailedIfNeeded(\n          parentData['queueKey'],\n          parentKey,\n          parentData['id'],\n          childKey,\n          timestamp\n        )\n      end\n    elseif parentData['cpof'] then\n      if rcall(\"SREM\", parentDependenciesChildrenKey, childKey) == 1 then\n        local parentFailedChildrenKey = parentKey .. \":failed\"\n        rcall(\"HSET\", parentFailedChildrenKey, childKey, failedReason)\n        moveParentToWaitIfNeeded(parentData['queueKey'], parentKey, parentData['id'], timestamp)\n      end\n    elseif parentData['idof'] or parentData['rdof'] then\n      if rcall(\"SREM\", parentDependenciesChildrenKey, childKey) == 1 then\n        moveParentToWaitIfNoPendingDependencies(parentData['queueKey'], parentDependenciesChildrenKey,\n          parentKey, parentData['id'], timestamp)\n        if parentData['idof'] then\n          local parentFailedChildrenKey = parentKey .. \":failed\"\n          rcall(\"HSET\", parentFailedChildrenKey, childKey, failedReason)\n        end\n      end\n    end\n  end\nend\n--[[\n  Function to move job from wait state to active.\n  Input:\n    opts - token - lock token\n    opts - lockDuration\n    opts - limiter\n]]\n-- Includes\nlocal function prepareJobForProcessing(keyPrefix, rateLimiterKey, eventStreamKey,\n    jobId, processedOn, maxJobs, limiterDuration, markerKey, opts)\n  local jobKey = keyPrefix .. jobId\n  -- Check if we need to perform rate limiting.\n  if maxJobs then\n    local jobCounter = tonumber(rcall(\"INCR\", rateLimiterKey))\n    if jobCounter == 1 then\n      local integerDuration = math.floor(math.abs(limiterDuration))\n      rcall(\"PEXPIRE\", rateLimiterKey, integerDuration)\n    end\n  end\n  -- get a lock\n  if opts['token'] ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    rcall(\"SET\", lockKey, opts['token'], \"PX\", opts['lockDuration'])\n  end\n  local optionalValues = {}\n  if opts['name'] then\n    -- Set \"processedBy\" field to the worker name\n    table.insert(optionalValues, \"pb\")\n    table.insert(optionalValues, opts['name'])\n  end\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"active\", \"jobId\", jobId, \"prev\", \"waiting\")\n  rcall(\"HMSET\", jobKey, \"processedOn\", processedOn, unpack(optionalValues))\n  rcall(\"HINCRBY\", jobKey, \"ats\", 1)\n  addBaseMarkerIfNeeded(markerKey, false)\n  -- rate limit delay must be 0 in this case to prevent adding more delay\n  -- when job that is moved to active needs to be processed\n  return {rcall(\"HGETALL\", jobKey), jobId, 0, 0} -- get job data\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall(\"LPUSH\", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall(\"ZADD\", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is moved to completed or failed states.\n]]\nlocal function removeDeduplicationKeyIfNeededOnFinalization(prefixKey,\n  deduplicationId, jobId)\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local pttl = rcall(\"PTTL\", deduplicationKey)\n    if pttl == 0 then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n    if pttl == -1 then\n      local currentJobId = rcall('GET', deduplicationKey)\n      if currentJobId and currentJobId == jobId then\n        return rcall(\"DEL\", deduplicationKey)\n      end\n    end\n  end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to trim events, default 10000.\n]]\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nlocal function trimEvents(metaKey, eventStreamKey)\n  local maxEvents = getOrSetMaxEvents(metaKey)\n  if maxEvents then\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", maxEvents)\n  else\n    rcall(\"XTRIM\", eventStreamKey, \"MAXLEN\", \"~\", 10000)\n  end\nend\n--[[\n  Validate and move or add dependencies to parent.\n]]\n-- Includes\nlocal function updateParentDepsIfNeeded(parentKey, parentQueueKey, parentDependenciesKey,\n  parentId, jobIdKey, returnvalue, timestamp )\n  local processedSet = parentKey .. \":processed\"\n  rcall(\"HSET\", processedSet, jobIdKey, returnvalue)\n  moveParentToWaitIfNoPendingDependencies(parentQueueKey, parentDependenciesKey, parentKey, parentId, timestamp)\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall(\"HMSET\", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal jobIdKey = KEYS[12]\nif rcall(\"EXISTS\", jobIdKey) == 1 then -- Make sure job exists\n    -- Make sure it does not have pending dependencies\n    -- It must happen before removing lock\n    if ARGV[5] == \"completed\" then\n        if rcall(\"SCARD\", jobIdKey .. \":dependencies\") ~= 0 then\n            return -4\n        end\n        if rcall(\"ZCARD\", jobIdKey .. \":unsuccessful\") ~= 0 then\n            return -9\n        end\n    end\n    local opts = cmsgpack.unpack(ARGV[8])\n    local token = opts['token']\n    local errorCode = removeLock(jobIdKey, KEYS[5], token, ARGV[1])\n    if errorCode < 0 then\n        return errorCode\n    end\n    updateJobFields(jobIdKey, ARGV[9]);\n    local attempts = opts['attempts']\n    local maxMetricsSize = opts['maxMetricsSize']\n    local maxCount = opts['keepJobs']['count']\n    local maxAge = opts['keepJobs']['age']\n    local jobAttributes = rcall(\"HMGET\", jobIdKey, \"parentKey\", \"parent\", \"deid\")\n    local parentKey = jobAttributes[1] or \"\"\n    local parentId = \"\"\n    local parentQueueKey = \"\"\n    if jobAttributes[2] then -- TODO: need to revisit this logic if it's still needed\n        local jsonDecodedParent = cjson.decode(jobAttributes[2])\n        parentId = jsonDecodedParent['id']\n        parentQueueKey = jsonDecodedParent['queueKey']\n    end\n    local jobId = ARGV[1]\n    local timestamp = ARGV[2]\n    -- Remove from active list (if not active we shall return error)\n    local numRemovedElements = rcall(\"LREM\", KEYS[2], -1, jobId)\n    if (numRemovedElements < 1) then\n        return -3\n    end\n    local eventStreamKey = KEYS[4]\n    local metaKey = KEYS[9]\n    -- Trim events before emiting them to avoid trimming events emitted in this script\n    trimEvents(metaKey, eventStreamKey)\n    local prefix = ARGV[7]\n    removeDeduplicationKeyIfNeededOnFinalization(prefix, jobAttributes[3], jobId)\n    -- If job has a parent we need to\n    -- 1) remove this job id from parents dependencies\n    -- 2) move the job Id to parent \"processed\" set\n    -- 3) push the results into parent \"results\" list\n    -- 4) if parent's dependencies is empty, then move parent to \"wait/paused\". Note it may be a different queue!.\n    if parentId == \"\" and parentKey ~= \"\" then\n        parentId = getJobIdFromKey(parentKey)\n        parentQueueKey = getJobKeyPrefix(parentKey, \":\" .. parentId)\n    end\n    if parentId ~= \"\" then\n        if ARGV[5] == \"completed\" then\n            local dependenciesSet = parentKey .. \":dependencies\"\n            if rcall(\"SREM\", dependenciesSet, jobIdKey) == 1 then\n                updateParentDepsIfNeeded(parentKey, parentQueueKey, dependenciesSet, parentId, jobIdKey, ARGV[4],\n                    timestamp)\n            end\n        else\n            moveChildFromDependenciesIfNeeded(jobAttributes[2], jobIdKey, ARGV[4], timestamp)\n        end\n    end\n    local attemptsMade = rcall(\"HINCRBY\", jobIdKey, \"atm\", 1)\n    -- Remove job?\n    if maxCount ~= 0 then\n        local targetSet = KEYS[11]\n        -- Add to complete/failed set\n        rcall(\"ZADD\", targetSet, timestamp, jobId)\n        rcall(\"HSET\", jobIdKey, ARGV[3], ARGV[4], \"finishedOn\", timestamp)\n        -- \"returnvalue\" / \"failedReason\" and \"finishedOn\"\n        if ARGV[5] == \"failed\" then\n            rcall(\"HDEL\", jobIdKey, \"defa\")\n        end\n        -- Remove old jobs?\n        if maxAge ~= nil then\n            removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n        end\n        if maxCount ~= nil and maxCount > 0 then\n            removeJobsByMaxCount(maxCount, targetSet, prefix)\n        end\n    else\n        removeJobKeys(jobIdKey)\n        if parentKey ~= \"\" then\n            -- TODO: when a child is removed when finished, result or failure in parent\n            -- must not be deleted, those value references should be deleted when the parent\n            -- is deleted\n            removeParentDependencyKey(jobIdKey, false, parentKey, jobAttributes[3])\n        end\n    end\n    rcall(\"XADD\", eventStreamKey, \"*\", \"event\", ARGV[5], \"jobId\", jobId, ARGV[3], ARGV[4], \"prev\", \"active\")\n    if ARGV[5] == \"failed\" then\n        if tonumber(attemptsMade) >= tonumber(attempts) then\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"retries-exhausted\", \"jobId\", jobId, \"attemptsMade\",\n                attemptsMade)\n        end\n    end\n    -- Collect metrics\n    if maxMetricsSize ~= \"\" then\n        collectMetrics(KEYS[13], KEYS[13] .. ':data', maxMetricsSize, timestamp)\n    end\n    -- Try to get next job to avoid an extra roundtrip if the queue is not closing,\n    -- and not rate limited.\n    if (ARGV[6] == \"1\") then\n        local target, isPausedOrMaxed, rateLimitMax, rateLimitDuration = getTargetQueueList(metaKey, KEYS[2],\n            KEYS[1], KEYS[8])\n        local markerKey = KEYS[14]\n        -- Check if there are delayed jobs that can be promoted\n        promoteDelayedJobs(KEYS[7], markerKey, target, KEYS[3], eventStreamKey, prefix, timestamp, KEYS[10],\n            isPausedOrMaxed)\n        local maxJobs = tonumber(rateLimitMax or (opts['limiter'] and opts['limiter']['max']))\n        -- Check if we are rate limited first.\n        local expireTime = getRateLimitTTL(maxJobs, KEYS[6])\n        if expireTime > 0 then\n            return {0, 0, expireTime, 0}\n        end\n        -- paused or maxed queue\n        if isPausedOrMaxed then\n            return {0, 0, 0, 0}\n        end\n        local limiterDuration = (opts['limiter'] and opts['limiter']['duration']) or rateLimitDuration\n        jobId = rcall(\"RPOPLPUSH\", KEYS[1], KEYS[2])\n        if jobId then\n            -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n            if string.sub(jobId, 1, 2) == \"0:\" then\n                rcall(\"LREM\", KEYS[2], 1, jobId)\n                -- If jobId is special ID 0:delay (delay greater than 0), then there is no job to process\n                -- but if ID is 0:0, then there is at least 1 prioritized job to process\n                if jobId == \"0:0\" then\n                    jobId = moveJobFromPrioritizedToActive(KEYS[3], KEYS[2], KEYS[10])\n                    return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs,\n                        limiterDuration, markerKey, opts)\n                end\n            else\n                return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs,\n                    limiterDuration, markerKey, opts)\n            end\n        else\n            jobId = moveJobFromPrioritizedToActive(KEYS[3], KEYS[2], KEYS[10])\n            if jobId then\n                return prepareJobForProcessing(prefix, KEYS[6], eventStreamKey, jobId, timestamp, maxJobs,\n                    limiterDuration, markerKey, opts)\n            end\n        end\n        -- Return the timestamp for the next delayed job if any.\n        local nextTimestamp = getNextDelayedTimestamp(KEYS[7])\n        if nextTimestamp ~= nil then\n            -- The result is guaranteed to be positive, since the\n            -- ZRANGEBYSCORE command would have return a job otherwise.\n            return {0, 0, 0, nextTimestamp}\n        end\n    end\n    local waitLen = rcall(\"LLEN\", KEYS[1])\n    if waitLen == 0 then\n        local activeLen = rcall(\"LLEN\", KEYS[2])\n        if activeLen == 0 then\n            local prioritizedLen = rcall(\"ZCARD\", KEYS[3])\n            if prioritizedLen == 0 then\n                rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"drained\")\n            end\n        end\n    end\n    return 0\nelse\n    return -1\nend\n`;\nconst moveToFinished = {\n    name: 'moveToFinished',\n    content,\n    keys: 14,\n};\n//# sourceMappingURL=moveToFinished-14.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvRmluaXNoZWQtMTQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvRmluaXNoZWQtMTQuanM/ZjUwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZSBqb2IgZnJvbSBhY3RpdmUgdG8gYSBmaW5pc2hlZCBzdGF0dXMgKGNvbXBsZXRlZCBvIGZhaWxlZClcbiAgQSBqb2IgY2FuIG9ubHkgYmUgbW92ZWQgdG8gY29tcGxldGVkIGlmIGl0IHdhcyBhY3RpdmUuXG4gIFRoZSBqb2IgbXVzdCBiZSBsb2NrZWQgYmVmb3JlIGl0IGNhbiBiZSBtb3ZlZCB0byBhIGZpbmlzaGVkIHN0YXR1cyxcbiAgYW5kIHRoZSBsb2NrIG11c3QgYmUgcmVsZWFzZWQgaW4gdGhpcyBzY3JpcHQuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgICBLRVlTWzJdIGFjdGl2ZSBrZXlcbiAgICAgIEtFWVNbM10gcHJpb3JpdGl6ZWQga2V5XG4gICAgICBLRVlTWzRdIGV2ZW50IHN0cmVhbSBrZXlcbiAgICAgIEtFWVNbNV0gc3RhbGxlZCBrZXlcbiAgICAgIC0tIFJhdGUgbGltaXRpbmdcbiAgICAgIEtFWVNbNl0gcmF0ZSBsaW1pdGVyIGtleVxuICAgICAgS0VZU1s3XSBkZWxheWVkIGtleVxuICAgICAgS0VZU1s4XSBwYXVzZWQga2V5XG4gICAgICBLRVlTWzldIG1ldGEga2V5XG4gICAgICBLRVlTWzEwXSBwYyBwcmlvcml0eSBjb3VudGVyXG4gICAgICBLRVlTWzExXSBjb21wbGV0ZWQvZmFpbGVkIGtleVxuICAgICAgS0VZU1sxMl0gam9iSWQga2V5XG4gICAgICBLRVlTWzEzXSBtZXRyaWNzIGtleVxuICAgICAgS0VZU1sxNF0gbWFya2VyIGtleVxuICAgICAgQVJHVlsxXSAgam9iSWRcbiAgICAgIEFSR1ZbMl0gIHRpbWVzdGFtcFxuICAgICAgQVJHVlszXSAgbXNnIHByb3BlcnR5IHJldHVybnZhbHVlIC8gZmFpbGVkUmVhc29uXG4gICAgICBBUkdWWzRdICByZXR1cm4gdmFsdWUgLyBmYWlsZWQgcmVhc29uXG4gICAgICBBUkdWWzVdICB0YXJnZXQgKGNvbXBsZXRlZC9mYWlsZWQpXG4gICAgICBBUkdWWzZdICBmZXRjaCBuZXh0P1xuICAgICAgQVJHVls3XSAga2V5cyBwcmVmaXhcbiAgICAgIEFSR1ZbOF0gIG9wdHNcbiAgICAgIEFSR1ZbOV0gIGpvYiBmaWVsZHMgdG8gdXBkYXRlXG4gICAgICBvcHRzIC0gdG9rZW4gLSBsb2NrIHRva2VuXG4gICAgICBvcHRzIC0ga2VlcEpvYnNcbiAgICAgIG9wdHMgLSBsb2NrRHVyYXRpb24gLSBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgb3B0cyAtIGF0dGVtcHRzIG1heCBhdHRlbXB0c1xuICAgICAgb3B0cyAtIG1heE1ldHJpY3NTaXplXG4gICAgICBvcHRzIC0gZnBvZiAtIGZhaWwgcGFyZW50IG9uIGZhaWxcbiAgICAgIG9wdHMgLSBjcG9mIC0gY29udGludWUgcGFyZW50IG9uIGZhaWxcbiAgICAgIG9wdHMgLSBpZG9mIC0gaWdub3JlIGRlcGVuZGVuY3kgb24gZmFpbFxuICAgICAgb3B0cyAtIHJkb2YgLSByZW1vdmUgZGVwZW5kZW5jeSBvbiBmYWlsXG4gICAgICBvcHRzIC0gbmFtZSAtIHdvcmtlciBuYW1lXG4gICAgT3V0cHV0OlxuICAgICAgMCBPS1xuICAgICAgLTEgTWlzc2luZyBrZXkuXG4gICAgICAtMiBNaXNzaW5nIGxvY2suXG4gICAgICAtMyBKb2Igbm90IGluIGFjdGl2ZSBzZXRcbiAgICAgIC00IEpvYiBoYXMgcGVuZGluZyBjaGlsZHJlblxuICAgICAgLTYgTG9jayBpcyBub3Qgb3duZWQgYnkgdGhpcyBjbGllbnRcbiAgICAgIC05IEpvYiBoYXMgZmFpbGVkIGNoaWxkcmVuXG4gICAgRXZlbnRzOlxuICAgICAgJ2NvbXBsZXRlZC9mYWlsZWQnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGNvbGxlY3QgbWV0cmljcyBiYXNlZCBvbiBhIGN1cnJlbnQgYW5kIHByZXZpb3VzIGNvdW50IG9mIGpvYnMuXG4gIEdyYW51YWxhcml0eSBpcyBmaXhlZCBhdCAxIG1pbnV0ZS5cbl1dXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKG1ldGFLZXksIGRhdGFQb2ludHNMaXN0LCBtYXhEYXRhUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wKVxuICAgIC0tIEluY3JlbWVudCBjdXJyZW50IGNvdW50XG4gICAgbG9jYWwgY291bnQgPSByY2FsbChcIkhJTkNSQllcIiwgbWV0YUtleSwgXCJjb3VudFwiLCAxKSAtIDFcbiAgICAtLSBDb21wdXRlIGhvdyBtYW55IGRhdGEgcG9pbnRzIHdlIG5lZWQgdG8gYWRkIHRvIHRoZSBsaXN0LCBOLlxuICAgIGxvY2FsIHByZXZUUyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcInByZXZUU1wiKVxuICAgIGlmIG5vdCBwcmV2VFMgdGhlblxuICAgICAgICAtLSBJZiBwcmV2VFMgaXMgbmlsLCBzZXQgaXQgdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcInByZXZUU1wiLCB0aW1lc3RhbXAsIFwicHJldkNvdW50XCIsIDApXG4gICAgICAgIHJldHVyblxuICAgIGVuZFxuICAgIGxvY2FsIE4gPSBtYXRoLm1pbihtYXRoLmZsb29yKHRpbWVzdGFtcCAvIDYwMDAwKSAtIG1hdGguZmxvb3IocHJldlRTIC8gNjAwMDApLCB0b251bWJlcihtYXhEYXRhUG9pbnRzKSlcbiAgICBpZiBOID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIGRlbHRhID0gY291bnQgLSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIilcbiAgICAgICAgLS0gSWYgTiA+IDEsIGFkZCBOLTEgemVyb3MgdG8gdGhlIGxpc3RcbiAgICAgICAgaWYgTiA+IDEgdGhlblxuICAgICAgICAgICAgbG9jYWwgcG9pbnRzID0ge31cbiAgICAgICAgICAgIHBvaW50c1sxXSA9IGRlbHRhXG4gICAgICAgICAgICBmb3IgaSA9IDIsIE4gZG9cbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAwXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGZvciBmcm9tLCB0byBpbiBiYXRjaGVzKCNwb2ludHMsIDcwMDApIGRvXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCBkYXRhUG9pbnRzTGlzdCwgdW5wYWNrKHBvaW50cywgZnJvbSwgdG8pKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIExQVVNIIGRlbHRhIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICByY2FsbChcIkxQVVNIXCIsIGRhdGFQb2ludHNMaXN0LCBkZWx0YSlcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIExUUklNIHRvIGtlZXAgbGlzdCB0byBpdHMgbWF4IHNpemVcbiAgICAgICAgcmNhbGwoXCJMVFJJTVwiLCBkYXRhUG9pbnRzTGlzdCwgMCwgbWF4RGF0YVBvaW50cyAtIDEpXG4gICAgICAgIC0tIHVwZGF0ZSBwcmV2IGNvdW50IHdpdGggY3VycmVudCBjb3VudFxuICAgICAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJwcmV2Q291bnRcIiwgY291bnQsIFwicHJldlRTXCIsIHRpbWVzdGFtcClcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAgIHJldHVybiBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHJhdGUgbGltaXQgdHRsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFJhdGVMaW1pdFRUTChtYXhKb2JzLCByYXRlTGltaXRlcktleSlcbiAgaWYgbWF4Sm9icyBhbmQgbWF4Sm9icyA8PSB0b251bWJlcihyY2FsbChcIkdFVFwiLCByYXRlTGltaXRlcktleSkgb3IgMCkgdGhlblxuICAgIGxvY2FsIHB0dGwgPSByY2FsbChcIlBUVExcIiwgcmF0ZUxpbWl0ZXJLZXkpXG4gICAgaWYgcHR0bCA9PSAwIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIHJhdGVMaW1pdGVyS2V5KVxuICAgIGVuZFxuICAgIGlmIHB0dGwgPiAwIHRoZW5cbiAgICAgIHJldHVybiBwdHRsXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gMFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIsIFwibWF4XCIsIFwiZHVyYXRpb25cIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIGlmIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSkgdGhlblxuICAgICAgICByZXR1cm4gd2FpdEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gbW92ZSBqb2IgZnJvbSBwcmlvcml0aXplZCBzdGF0ZSB0byBhY3RpdmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gbW92ZUpvYkZyb21Qcmlvcml0aXplZFRvQWN0aXZlKHByaW9yaXR5S2V5LCBhY3RpdmVLZXksIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgcHJpb3JpdGl6ZWRKb2IgPSByY2FsbChcIlpQT1BNSU5cIiwgcHJpb3JpdHlLZXkpXG4gIGlmICNwcmlvcml0aXplZEpvYiA+IDAgdGhlblxuICAgIHJjYWxsKFwiTFBVU0hcIiwgYWN0aXZlS2V5LCBwcmlvcml0aXplZEpvYlsxXSlcbiAgICByZXR1cm4gcHJpb3JpdGl6ZWRKb2JbMV1cbiAgZWxzZVxuICAgIHJjYWxsKFwiREVMXCIsIHByaW9yaXR5Q291bnRlcktleSlcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVjdXJzaXZlbHkgbW92ZSBmcm9tIHdhaXRpbmdDaGlsZHJlbiB0byBmYWlsZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgVmFsaWRhdGUgYW5kIG1vdmUgcGFyZW50IHRvIGEgd2FpdCBzdGF0dXMgKHdhaXRpbmcsIGRlbGF5ZWQgb3IgcHJpb3JpdGl6ZWQpXG4gIGlmIG5vIHBlbmRpbmcgZGVwZW5kZW5jaWVzLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIHBhcmVudCB0byBhIHdhaXQgc3RhdHVzICh3YWl0aW5nLCBkZWxheWVkIG9yIHByaW9yaXRpemVkKSBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgTW92ZSBwYXJlbnQgdG8gYSB3YWl0IHN0YXR1cyAod2FpdCwgcHJpb3JpdGl6ZWQgb3IgZGVsYXllZClcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG4gIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgLS0gUmVwbGFjZSB0aGUgc2NvcmUgb2YgdGhlIG1hcmtlciB3aXRoIHRoZSBuZXdlc3Qga25vd25cbiAgICAtLSBuZXh0IHRpbWVzdGFtcC5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgaWYgcXVldWUgaXMgcGF1c2VkIG9yIG1heGVkXG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpc1F1ZXVlUGF1c2VkT3JNYXhlZChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gdHJ1ZVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIHJldHVybiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVBhcmVudFRvV2FpdChwYXJlbnRRdWV1ZUtleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICAgIGxvY2FsIHBhcmVudFdhaXRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0XCJcbiAgICBsb2NhbCBwYXJlbnRQYXVzZWRLZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwYXVzZWRcIlxuICAgIGxvY2FsIHBhcmVudEFjdGl2ZUtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOmFjdGl2ZVwiXG4gICAgbG9jYWwgcGFyZW50TWV0YUtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1ldGFcIlxuICAgIGxvY2FsIHBhcmVudE1hcmtlcktleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOm1hcmtlclwiXG4gICAgbG9jYWwgam9iQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcGFyZW50S2V5LCBcInByaW9yaXR5XCIsIFwiZGVsYXlcIilcbiAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMV0pIG9yIDBcbiAgICBsb2NhbCBkZWxheSA9IHRvbnVtYmVyKGpvYkF0dHJpYnV0ZXNbMl0pIG9yIDBcbiAgICBpZiBkZWxheSA+IDAgdGhlblxuICAgICAgICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gdG9udW1iZXIodGltZXN0YW1wKSArIGRlbGF5XG4gICAgICAgIGxvY2FsIHNjb3JlID0gZGVsYXllZFRpbWVzdGFtcCAqIDB4MTAwMFxuICAgICAgICBsb2NhbCBwYXJlbnREZWxheWVkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6ZGVsYXllZFwiXG4gICAgICAgIHJjYWxsKFwiWkFERFwiLCBwYXJlbnREZWxheWVkS2V5LCBzY29yZSwgcGFyZW50SWQpXG4gICAgICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRRdWV1ZUtleSAuLiBcIjpldmVudHNcIiwgXCIqXCIsIFwiZXZlbnRcIiwgXCJkZWxheWVkXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwiZGVsYXlcIixcbiAgICAgICAgICAgIGRlbGF5ZWRUaW1lc3RhbXApXG4gICAgICAgIGFkZERlbGF5TWFya2VySWZOZWVkZWQocGFyZW50TWFya2VyS2V5LCBwYXJlbnREZWxheWVkS2V5KVxuICAgIGVsc2VcbiAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGFyZW50UGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRNZXRhS2V5LCBwYXJlbnRBY3RpdmVLZXksXG4gICAgICAgICAgICAgICAgcGFyZW50V2FpdEtleSwgcGFyZW50UGF1c2VkS2V5KVxuICAgICAgICAgICAgYWRkSm9iSW5UYXJnZXRMaXN0KHBhcmVudFRhcmdldCwgcGFyZW50TWFya2VyS2V5LCBcIlJQVVNIXCIsIGlzUGFyZW50UGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvY2FsIGlzUGF1c2VkT3JNYXhlZCA9IGlzUXVldWVQYXVzZWRPck1heGVkKHBhcmVudE1ldGFLZXksIHBhcmVudEFjdGl2ZUtleSlcbiAgICAgICAgICAgIGFkZEpvYldpdGhQcmlvcml0eShwYXJlbnRNYXJrZXJLZXksIHBhcmVudFF1ZXVlS2V5IC4uIFwiOnByaW9yaXRpemVkXCIsIHByaW9yaXR5LCBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRRdWV1ZUtleSAuLiBcIjpwY1wiLCBpc1BhdXNlZE9yTWF4ZWQpXG4gICAgICAgIGVuZFxuICAgICAgICByY2FsbChcIlhBRERcIiwgcGFyZW50UXVldWVLZXkgLi4gXCI6ZXZlbnRzXCIsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIixcbiAgICAgICAgICAgIFwid2FpdGluZy1jaGlsZHJlblwiKVxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0SWZOZWVkZWQocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIHRpbWVzdGFtcClcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcGFyZW50S2V5KSA9PSAxIHRoZW5cbiAgICBsb2NhbCBwYXJlbnRXYWl0aW5nQ2hpbGRyZW5LZXkgPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjp3YWl0aW5nLWNoaWxkcmVuXCJcbiAgICBpZiByY2FsbChcIlpTQ09SRVwiLCBwYXJlbnRXYWl0aW5nQ2hpbGRyZW5LZXksIHBhcmVudElkKSB0aGVuICAgIFxuICAgICAgcmNhbGwoXCJaUkVNXCIsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSwgcGFyZW50SWQpXG4gICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBtb3ZlUGFyZW50VG9XYWl0SWZOb1BlbmRpbmdEZXBlbmRlbmNpZXMocGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50S2V5LFxuICBwYXJlbnRJZCwgdGltZXN0YW1wKVxuICBsb2NhbCBkb05vdEhhdmVQZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpID09IDBcbiAgaWYgZG9Ob3RIYXZlUGVuZGluZ0RlcGVuZGVuY2llcyB0aGVuXG4gICAgbW92ZVBhcmVudFRvV2FpdElmTmVlZGVkKHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9ucyB0byByZW1vdmUgam9icyB3aGVuIHJlbW92ZU9uRmFpbCBvcHRpb24gaXMgcHJvdmlkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIGVtaXRFdmVudClcbiAgbG9jYWwgcGFyZW50VGFyZ2V0LCBpc1BhdXNlZE9yTWF4ZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QocGFyZW50UHJlZml4IC4uIFwibWV0YVwiLCBwYXJlbnRQcmVmaXggLi4gXCJhY3RpdmVcIixcbiAgICBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0XCIsIHBhcmVudFByZWZpeCAuLiBcInBhdXNlZFwiKVxuICBhZGRKb2JJblRhcmdldExpc3QocGFyZW50VGFyZ2V0LCBwYXJlbnRQcmVmaXggLi4gXCJtYXJrZXJcIiwgXCJSUFVTSFwiLCBpc1BhdXNlZE9yTWF4ZWQsIHBhcmVudElkKVxuICBpZiBlbWl0RXZlbnQgdGhlblxuICAgIGxvY2FsIHBhcmVudEV2ZW50U3RyZWFtID0gcGFyZW50UHJlZml4IC4uIFwiZXZlbnRzXCJcbiAgICByY2FsbChcIlhBRERcIiwgcGFyZW50RXZlbnRTdHJlYW0sIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLCBcImpvYklkXCIsIHBhcmVudElkLCBcInByZXZcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIpXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgcGFyZW50S2V5LCBiYXNlS2V5LCBkZWJvdW5jZUlkKVxuICBpZiBwYXJlbnRLZXkgdGhlblxuICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KHBhcmVudEtleSlcbiAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KHBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgaWYgaGFyZCB0aGVuIC0tIHJlbW92ZSBwYXJlbnQgaW4gc2FtZSBxdWV1ZVxuICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KHBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5LCBuaWwpXG4gICAgICAgICAgICAgIHJlbW92ZUpvYktleXMocGFyZW50S2V5KVxuICAgICAgICAgICAgICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIkRFTFwiLCBwYXJlbnRQcmVmaXggLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVuZFxuICBlbHNlXG4gICAgbG9jYWwgcGFyZW50QXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgam9iS2V5LCBcInBhcmVudEtleVwiLCBcImRlaWRcIilcbiAgICBsb2NhbCBtaXNzZWRQYXJlbnRLZXkgPSBwYXJlbnRBdHRyaWJ1dGVzWzFdXG4gICAgaWYoICh0eXBlKG1pc3NlZFBhcmVudEtleSkgPT0gXCJzdHJpbmdcIikgYW5kIG1pc3NlZFBhcmVudEtleSB+PSBcIlwiXG4gICAgICBhbmQgKHJjYWxsKFwiRVhJU1RTXCIsIG1pc3NlZFBhcmVudEtleSkgPT0gMSkpIHRoZW5cbiAgICAgIGxvY2FsIHBhcmVudERlcGVuZGVuY2llc0tleSA9IG1pc3NlZFBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICAgIGxvY2FsIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSByY2FsbChcIlNDQVJEXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSlcbiAgICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgbG9jYWwgcGFyZW50UHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KG1pc3NlZFBhcmVudEtleSwgcGFyZW50SWQpXG4gICAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgICAgaWYgaGFyZCB0aGVuXG4gICAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KG1pc3NlZFBhcmVudEtleSwgaGFyZCwgbmlsLCBiYXNlS2V5LCBuaWwpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhtaXNzZWRQYXJlbnRLZXkpXG4gICAgICAgICAgICAgICAgaWYgcGFyZW50QXR0cmlidXRlc1syXSB0aGVuXG4gICAgICAgICAgICAgICAgICByY2FsbChcIkRFTFwiLCBwYXJlbnRQcmVmaXggLi4gXCJkZTpcIiAuLiBwYXJlbnRBdHRyaWJ1dGVzWzJdKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZClcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQsIHRydWUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmYWxzZVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2Ioam9iSWQsIGhhcmQsIGJhc2VLZXksIHNob3VsZFJlbW92ZURlZHVwbGljYXRpb25LZXkpXG4gIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4gam9iSWRcbiAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIG5pbCwgYmFzZUtleSlcbiAgaWYgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSB0aGVuXG4gICAgcmVtb3ZlRGVkdXBsaWNhdGlvbktleUlmTmVlZGVkT25SZW1vdmFsKGJhc2VLZXksIGpvYktleSwgam9iSWQpXG4gIGVuZFxuICByZW1vdmVKb2JLZXlzKGpvYktleSlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMgYnkgbWF4IGFnZS5cbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9ic0J5TWF4QWdlKHRpbWVzdGFtcCwgbWF4QWdlLCB0YXJnZXRTZXQsIHByZWZpeCxcbiAgc2hvdWxkUmVtb3ZlRGVib3VuY2VLZXkpXG4gIGxvY2FsIHN0YXJ0ID0gdGltZXN0YW1wIC0gbWF4QWdlICogMTAwMFxuICBsb2NhbCBqb2JJZHMgPSByY2FsbChcIlpSRVZSQU5HRUJZU0NPUkVcIiwgdGFyZ2V0U2V0LCBzdGFydCwgXCItaW5mXCIpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeCwgZmFsc2UgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSlcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIFwiLWluZlwiLCBzdGFydClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMgYnkgbWF4IGNvdW50LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzQnlNYXhDb3VudChtYXhDb3VudCwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gbWF4Q291bnRcbiAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VcIiwgdGFyZ2V0U2V0LCBzdGFydCwgLTEpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHByZWZpeCwgZmFsc2UgLS1bW3JlbW92ZSBkZWJvdW5jZSBrZXldXSlcbiAgZW5kXG4gIHJjYWxsKFwiWlJFTVJBTkdFQllSQU5LXCIsIHRhcmdldFNldCwgMCwgLShtYXhDb3VudCArIDEpKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzT25GYWlsKHF1ZXVlS2V5UHJlZml4LCBmYWlsZWRLZXksIGpvYklkLCBvcHRzLCB0aW1lc3RhbXApXG4gIGxvY2FsIHJlbW92ZU9uRmFpbFR5cGUgPSB0eXBlKG9wdHNbXCJyZW1vdmVPbkZhaWxcIl0pXG4gIGlmIHJlbW92ZU9uRmFpbFR5cGUgPT0gXCJudW1iZXJcIiB0aGVuXG4gICAgcmVtb3ZlSm9ic0J5TWF4Q291bnQob3B0c1tcInJlbW92ZU9uRmFpbFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZEtleSwgcXVldWVLZXlQcmVmaXgpXG4gIGVsc2VpZiByZW1vdmVPbkZhaWxUeXBlID09IFwiYm9vbGVhblwiIHRoZW5cbiAgICBpZiBvcHRzW1wicmVtb3ZlT25GYWlsXCJdIHRoZW5cbiAgICAgIHJlbW92ZUpvYihqb2JJZCwgZmFsc2UsIHF1ZXVlS2V5UHJlZml4LFxuICAgICAgICAgICAgICAgIGZhbHNlIC0tW1tyZW1vdmUgZGVib3VuY2Uga2V5XV0pXG4gICAgICByY2FsbChcIlpSRU1cIiwgZmFpbGVkS2V5LCBqb2JJZClcbiAgICBlbmRcbiAgZWxzZWlmIHJlbW92ZU9uRmFpbFR5cGUgfj0gXCJuaWxcIiB0aGVuXG4gICAgbG9jYWwgbWF4QWdlID0gb3B0c1tcInJlbW92ZU9uRmFpbFwiXVtcImFnZVwiXVxuICAgIGxvY2FsIG1heENvdW50ID0gb3B0c1tcInJlbW92ZU9uRmFpbFwiXVtcImNvdW50XCJdXG4gICAgaWYgbWF4QWdlIH49IG5pbCB0aGVuXG4gICAgICByZW1vdmVKb2JzQnlNYXhBZ2UodGltZXN0YW1wLCBtYXhBZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRLZXksIHF1ZXVlS2V5UHJlZml4KVxuICAgIGVuZFxuICAgIGlmIG1heENvdW50IH49IG5pbCBhbmQgbWF4Q291bnQgPiAwIHRoZW5cbiAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG1heENvdW50LCBmYWlsZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVLZXlQcmVmaXgpXG4gICAgZW5kXG4gIGVuZCBcbmVuZFxubG9jYWwgbW92ZVBhcmVudFRvRmFpbGVkSWZOZWVkZWQgPSBmdW5jdGlvbiAocGFyZW50UXVldWVLZXksIHBhcmVudEtleSwgcGFyZW50SWQsIGpvYklkS2V5LCB0aW1lc3RhbXApXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgPT0gMSB0aGVuXG4gICAgbG9jYWwgcGFyZW50V2FpdGluZ0NoaWxkcmVuS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6d2FpdGluZy1jaGlsZHJlblwiXG4gICAgbG9jYWwgcGFyZW50RGVsYXllZEtleSA9IHBhcmVudFF1ZXVlS2V5IC4uIFwiOmRlbGF5ZWRcIlxuICAgIGxvY2FsIHBhcmVudFByaW9yaXRpemVkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6cHJpb3JpdGl6ZWRcIlxuICAgIGxvY2FsIHBhcmVudFdhaXRpbmdDaGlsZHJlbk9yRGVsYXllZEtleVxuICAgIGxvY2FsIHByZXZTdGF0ZVxuICAgIGlmIHJjYWxsKFwiWlNDT1JFXCIsIHBhcmVudFdhaXRpbmdDaGlsZHJlbktleSwgcGFyZW50SWQpIHRoZW5cbiAgICAgIHBhcmVudFdhaXRpbmdDaGlsZHJlbk9yRGVsYXllZEtleSA9IHBhcmVudFdhaXRpbmdDaGlsZHJlbktleVxuICAgICAgcHJldlN0YXRlID0gXCJ3YWl0aW5nLWNoaWxkcmVuXCJcbiAgICBlbHNlaWYgcmNhbGwoXCJaU0NPUkVcIiwgcGFyZW50RGVsYXllZEtleSwgcGFyZW50SWQpIHRoZW5cbiAgICAgIHBhcmVudFdhaXRpbmdDaGlsZHJlbk9yRGVsYXllZEtleSA9IHBhcmVudERlbGF5ZWRLZXlcbiAgICAgIHByZXZTdGF0ZSA9IFwiZGVsYXllZFwiXG4gICAgICByY2FsbChcIkhTRVRcIiwgcGFyZW50S2V5LCBcImRlbGF5XCIsIDApXG4gICAgZW5kXG4gICAgaWYgcGFyZW50V2FpdGluZ0NoaWxkcmVuT3JEZWxheWVkS2V5IHRoZW5cbiAgICAgIHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRXYWl0aW5nQ2hpbGRyZW5PckRlbGF5ZWRLZXksIHBhcmVudElkKVxuICAgICAgbG9jYWwgcGFyZW50UXVldWVQcmVmaXggPSBwYXJlbnRRdWV1ZUtleSAuLiBcIjpcIlxuICAgICAgbG9jYWwgcGFyZW50RmFpbGVkS2V5ID0gcGFyZW50UXVldWVLZXkgLi4gXCI6ZmFpbGVkXCJcbiAgICAgIGxvY2FsIGRlZmVycmVkRmFpbHVyZSA9IFwiY2hpbGQgXCIgLi4gam9iSWRLZXkgLi4gXCIgZmFpbGVkXCJcbiAgICAgIHJjYWxsKFwiSFNFVFwiLCBwYXJlbnRLZXksIFwiZGVmYVwiLCBkZWZlcnJlZEZhaWx1cmUpXG4gICAgICBtb3ZlUGFyZW50VG9XYWl0KHBhcmVudFF1ZXVlS2V5LCBwYXJlbnRLZXksIHBhcmVudElkLCB0aW1lc3RhbXApXG4gICAgZWxzZVxuICAgICAgaWYgbm90IHJjYWxsKFwiWlNDT1JFXCIsIHBhcmVudFF1ZXVlS2V5IC4uIFwiOmZhaWxlZFwiLCBwYXJlbnRJZCkgdGhlblxuICAgICAgICBsb2NhbCBkZWZlcnJlZEZhaWx1cmUgPSBcImNoaWxkIFwiIC4uIGpvYklkS2V5IC4uIFwiIGZhaWxlZFwiXG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBwYXJlbnRLZXksIFwiZGVmYVwiLCBkZWZlcnJlZEZhaWx1cmUpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIG1vdmVDaGlsZEZyb21EZXBlbmRlbmNpZXNJZk5lZWRlZCA9IGZ1bmN0aW9uIChyYXdQYXJlbnREYXRhLCBjaGlsZEtleSwgZmFpbGVkUmVhc29uLCB0aW1lc3RhbXApXG4gIGlmIHJhd1BhcmVudERhdGEgdGhlblxuICAgIGxvY2FsIHBhcmVudERhdGEgPSBjanNvbi5kZWNvZGUocmF3UGFyZW50RGF0YSlcbiAgICBsb2NhbCBwYXJlbnRLZXkgPSBwYXJlbnREYXRhWydxdWV1ZUtleSddIC4uICc6JyAuLiBwYXJlbnREYXRhWydpZCddXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzQ2hpbGRyZW5LZXkgPSBwYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICBpZiBwYXJlbnREYXRhWydmcG9mJ10gdGhlblxuICAgICAgaWYgcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0NoaWxkcmVuS2V5LCBjaGlsZEtleSkgPT0gMSB0aGVuXG4gICAgICAgIGxvY2FsIHBhcmVudFVuc3VjY2Vzc3NmdWxDaGlsZHJlbktleSA9IHBhcmVudEtleSAuLiBcIjp1bnN1Y2Nlc3NmdWxcIlxuICAgICAgICByY2FsbChcIlpBRERcIiwgcGFyZW50VW5zdWNjZXNzc2Z1bENoaWxkcmVuS2V5LCB0aW1lc3RhbXAsIGNoaWxkS2V5KVxuICAgICAgICBtb3ZlUGFyZW50VG9GYWlsZWRJZk5lZWRlZChcbiAgICAgICAgICBwYXJlbnREYXRhWydxdWV1ZUtleSddLFxuICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICBwYXJlbnREYXRhWydpZCddLFxuICAgICAgICAgIGNoaWxkS2V5LFxuICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICApXG4gICAgICBlbmRcbiAgICBlbHNlaWYgcGFyZW50RGF0YVsnY3BvZiddIHRoZW5cbiAgICAgIGlmIHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNDaGlsZHJlbktleSwgY2hpbGRLZXkpID09IDEgdGhlblxuICAgICAgICBsb2NhbCBwYXJlbnRGYWlsZWRDaGlsZHJlbktleSA9IHBhcmVudEtleSAuLiBcIjpmYWlsZWRcIlxuICAgICAgICByY2FsbChcIkhTRVRcIiwgcGFyZW50RmFpbGVkQ2hpbGRyZW5LZXksIGNoaWxkS2V5LCBmYWlsZWRSZWFzb24pXG4gICAgICAgIG1vdmVQYXJlbnRUb1dhaXRJZk5lZWRlZChwYXJlbnREYXRhWydxdWV1ZUtleSddLCBwYXJlbnRLZXksIHBhcmVudERhdGFbJ2lkJ10sIHRpbWVzdGFtcClcbiAgICAgIGVuZFxuICAgIGVsc2VpZiBwYXJlbnREYXRhWydpZG9mJ10gb3IgcGFyZW50RGF0YVsncmRvZiddIHRoZW5cbiAgICAgIGlmIHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNDaGlsZHJlbktleSwgY2hpbGRLZXkpID09IDEgdGhlblxuICAgICAgICBtb3ZlUGFyZW50VG9XYWl0SWZOb1BlbmRpbmdEZXBlbmRlbmNpZXMocGFyZW50RGF0YVsncXVldWVLZXknXSwgcGFyZW50RGVwZW5kZW5jaWVzQ2hpbGRyZW5LZXksXG4gICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhWydpZCddLCB0aW1lc3RhbXApXG4gICAgICAgIGlmIHBhcmVudERhdGFbJ2lkb2YnXSB0aGVuXG4gICAgICAgICAgbG9jYWwgcGFyZW50RmFpbGVkQ2hpbGRyZW5LZXkgPSBwYXJlbnRLZXkgLi4gXCI6ZmFpbGVkXCJcbiAgICAgICAgICByY2FsbChcIkhTRVRcIiwgcGFyZW50RmFpbGVkQ2hpbGRyZW5LZXksIGNoaWxkS2V5LCBmYWlsZWRSZWFzb24pXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIG1vdmUgam9iIGZyb20gd2FpdCBzdGF0ZSB0byBhY3RpdmUuXG4gIElucHV0OlxuICAgIG9wdHMgLSB0b2tlbiAtIGxvY2sgdG9rZW5cbiAgICBvcHRzIC0gbG9ja0R1cmF0aW9uXG4gICAgb3B0cyAtIGxpbWl0ZXJcbl1dXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gcHJlcGFyZUpvYkZvclByb2Nlc3Npbmcoa2V5UHJlZml4LCByYXRlTGltaXRlcktleSwgZXZlbnRTdHJlYW1LZXksXG4gICAgam9iSWQsIHByb2Nlc3NlZE9uLCBtYXhKb2JzLCBsaW1pdGVyRHVyYXRpb24sIG1hcmtlcktleSwgb3B0cylcbiAgbG9jYWwgam9iS2V5ID0ga2V5UHJlZml4IC4uIGpvYklkXG4gIC0tIENoZWNrIGlmIHdlIG5lZWQgdG8gcGVyZm9ybSByYXRlIGxpbWl0aW5nLlxuICBpZiBtYXhKb2JzIHRoZW5cbiAgICBsb2NhbCBqb2JDb3VudGVyID0gdG9udW1iZXIocmNhbGwoXCJJTkNSXCIsIHJhdGVMaW1pdGVyS2V5KSlcbiAgICBpZiBqb2JDb3VudGVyID09IDEgdGhlblxuICAgICAgbG9jYWwgaW50ZWdlckR1cmF0aW9uID0gbWF0aC5mbG9vcihtYXRoLmFicyhsaW1pdGVyRHVyYXRpb24pKVxuICAgICAgcmNhbGwoXCJQRVhQSVJFXCIsIHJhdGVMaW1pdGVyS2V5LCBpbnRlZ2VyRHVyYXRpb24pXG4gICAgZW5kXG4gIGVuZFxuICAtLSBnZXQgYSBsb2NrXG4gIGlmIG9wdHNbJ3Rva2VuJ10gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIHJjYWxsKFwiU0VUXCIsIGxvY2tLZXksIG9wdHNbJ3Rva2VuJ10sIFwiUFhcIiwgb3B0c1snbG9ja0R1cmF0aW9uJ10pXG4gIGVuZFxuICBsb2NhbCBvcHRpb25hbFZhbHVlcyA9IHt9XG4gIGlmIG9wdHNbJ25hbWUnXSB0aGVuXG4gICAgLS0gU2V0IFwicHJvY2Vzc2VkQnlcIiBmaWVsZCB0byB0aGUgd29ya2VyIG5hbWVcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIFwicGJcIilcbiAgICB0YWJsZS5pbnNlcnQob3B0aW9uYWxWYWx1ZXMsIG9wdHNbJ25hbWUnXSlcbiAgZW5kXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJhY3RpdmVcIiwgXCJqb2JJZFwiLCBqb2JJZCwgXCJwcmV2XCIsIFwid2FpdGluZ1wiKVxuICByY2FsbChcIkhNU0VUXCIsIGpvYktleSwgXCJwcm9jZXNzZWRPblwiLCBwcm9jZXNzZWRPbiwgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbiAgcmNhbGwoXCJISU5DUkJZXCIsIGpvYktleSwgXCJhdHNcIiwgMSlcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZmFsc2UpXG4gIC0tIHJhdGUgbGltaXQgZGVsYXkgbXVzdCBiZSAwIGluIHRoaXMgY2FzZSB0byBwcmV2ZW50IGFkZGluZyBtb3JlIGRlbGF5XG4gIC0tIHdoZW4gam9iIHRoYXQgaXMgbW92ZWQgdG8gYWN0aXZlIG5lZWRzIHRvIGJlIHByb2Nlc3NlZFxuICByZXR1cm4ge3JjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkpLCBqb2JJZCwgMCwgMH0gLS0gZ2V0IGpvYiBkYXRhXG5lbmRcbi0tW1tcbiAgVXBkYXRlcyB0aGUgZGVsYXkgc2V0LCBieSBtb3ZpbmcgZGVsYXllZCBqb2JzIHRoYXQgc2hvdWxkXG4gIGJlIHByb2Nlc3NlZCBub3cgdG8gXCJ3YWl0XCIuXG4gICAgIEV2ZW50czpcbiAgICAgICd3YWl0aW5nJ1xuXV1cbi0tIEluY2x1ZGVzXG4tLSBUcnkgdG8gZ2V0IGFzIG11Y2ggYXMgMTAwMCBqb2JzIGF0IG9uY2VcbmxvY2FsIGZ1bmN0aW9uIHByb21vdGVEZWxheWVkSm9icyhkZWxheWVkS2V5LCBtYXJrZXJLZXksIHRhcmdldEtleSwgcHJpb3JpdGl6ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdHJlYW1LZXksIHByZWZpeCwgdGltZXN0YW1wLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICAgIGxvY2FsIGpvYnMgPSByY2FsbChcIlpSQU5HRUJZU0NPUkVcIiwgZGVsYXllZEtleSwgMCwgKHRpbWVzdGFtcCArIDEpICogMHgxMDAwIC0gMSwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuICAgIGlmICgjam9icyA+IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIHVucGFjayhqb2JzKSlcbiAgICAgICAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0eSA9XG4gICAgICAgICAgICAgICAgdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgIGpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgICAgIGVuZFxuICAgICAgICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgbW92ZWQgdG8gY29tcGxldGVkIG9yIGZhaWxlZCBzdGF0ZXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlRGVkdXBsaWNhdGlvbktleUlmTmVlZGVkT25GaW5hbGl6YXRpb24ocHJlZml4S2V5LFxuICBkZWR1cGxpY2F0aW9uSWQsIGpvYklkKVxuICBpZiBkZWR1cGxpY2F0aW9uSWQgdGhlblxuICAgIGxvY2FsIGRlZHVwbGljYXRpb25LZXkgPSBwcmVmaXhLZXkgLi4gXCJkZTpcIiAuLiBkZWR1cGxpY2F0aW9uSWRcbiAgICBsb2NhbCBwdHRsID0gcmNhbGwoXCJQVFRMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgcHR0bCA9PSAwIHRoZW5cbiAgICAgIHJldHVybiByY2FsbChcIkRFTFwiLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgIGVuZFxuICAgIGlmIHB0dGwgPT0gLTEgdGhlblxuICAgICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgICBpZiBjdXJyZW50Sm9iSWQgYW5kIGN1cnJlbnRKb2JJZCA9PSBqb2JJZCB0aGVuXG4gICAgICAgIHJldHVybiByY2FsbChcIkRFTFwiLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMb2NrKGpvYktleSwgc3RhbGxlZEtleSwgdG9rZW4sIGpvYklkKVxuICBpZiB0b2tlbiB+PSBcIjBcIiB0aGVuXG4gICAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gICAgbG9jYWwgbG9ja1Rva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICBpZiBsb2NrVG9rZW4gPT0gdG9rZW4gdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgbG9ja0tleSlcbiAgICAgIHJjYWxsKFwiU1JFTVwiLCBzdGFsbGVkS2V5LCBqb2JJZClcbiAgICBlbHNlXG4gICAgICBpZiBsb2NrVG9rZW4gdGhlblxuICAgICAgICAtLSBMb2NrIGV4aXN0cyBidXQgdG9rZW4gZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgcmV0dXJuIC02XG4gICAgICBlbHNlXG4gICAgICAgIC0tIExvY2sgaXMgbWlzc2luZyBjb21wbGV0ZWx5XG4gICAgICAgIHJldHVybiAtMlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gMFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHRyaW0gZXZlbnRzLCBkZWZhdWx0IDEwMDAwLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG5sb2NhbCBmdW5jdGlvbiB0cmltRXZlbnRzKG1ldGFLZXksIGV2ZW50U3RyZWFtS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBpZiBtYXhFdmVudHMgdGhlblxuICAgIHJjYWxsKFwiWFRSSU1cIiwgZXZlbnRTdHJlYW1LZXksIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMpXG4gIGVsc2VcbiAgICByY2FsbChcIlhUUklNXCIsIGV2ZW50U3RyZWFtS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgMTAwMDApXG4gIGVuZFxuZW5kXG4tLVtbXG4gIFZhbGlkYXRlIGFuZCBtb3ZlIG9yIGFkZCBkZXBlbmRlbmNpZXMgdG8gcGFyZW50LlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVQYXJlbnREZXBzSWZOZWVkZWQocGFyZW50S2V5LCBwYXJlbnRRdWV1ZUtleSwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LFxuICBwYXJlbnRJZCwgam9iSWRLZXksIHJldHVybnZhbHVlLCB0aW1lc3RhbXAgKVxuICBsb2NhbCBwcm9jZXNzZWRTZXQgPSBwYXJlbnRLZXkgLi4gXCI6cHJvY2Vzc2VkXCJcbiAgcmNhbGwoXCJIU0VUXCIsIHByb2Nlc3NlZFNldCwgam9iSWRLZXksIHJldHVybnZhbHVlKVxuICBtb3ZlUGFyZW50VG9XYWl0SWZOb1BlbmRpbmdEZXBlbmRlbmNpZXMocGFyZW50UXVldWVLZXksIHBhcmVudERlcGVuZGVuY2llc0tleSwgcGFyZW50S2V5LCBwYXJlbnRJZCwgdGltZXN0YW1wKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHVwZGF0ZSBhIGJ1bmNoIG9mIGZpZWxkcyBpbiBhIGpvYi5cbl1dXG5sb2NhbCBmdW5jdGlvbiB1cGRhdGVKb2JGaWVsZHMoam9iS2V5LCBtc2dwYWNrZWRGaWVsZHMpXG4gIGlmIG1zZ3BhY2tlZEZpZWxkcyBhbmQgI21zZ3BhY2tlZEZpZWxkcyA+IDAgdGhlblxuICAgIGxvY2FsIGZpZWxkc1RvVXBkYXRlID0gY21zZ3BhY2sudW5wYWNrKG1zZ3BhY2tlZEZpZWxkcylcbiAgICBpZiBmaWVsZHNUb1VwZGF0ZSB0aGVuXG4gICAgICByY2FsbChcIkhNU0VUXCIsIGpvYktleSwgdW5wYWNrKGZpZWxkc1RvVXBkYXRlKSlcbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGpvYklkS2V5ID0gS0VZU1sxMl1cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW4gLS0gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgICAtLSBNYWtlIHN1cmUgaXQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIGRlcGVuZGVuY2llc1xuICAgIC0tIEl0IG11c3QgaGFwcGVuIGJlZm9yZSByZW1vdmluZyBsb2NrXG4gICAgaWYgQVJHVls1XSA9PSBcImNvbXBsZXRlZFwiIHRoZW5cbiAgICAgICAgaWYgcmNhbGwoXCJTQ0FSRFwiLCBqb2JJZEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIikgfj0gMCB0aGVuXG4gICAgICAgICAgICByZXR1cm4gLTRcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIHJjYWxsKFwiWkNBUkRcIiwgam9iSWRLZXkgLi4gXCI6dW5zdWNjZXNzZnVsXCIpIH49IDAgdGhlblxuICAgICAgICAgICAgcmV0dXJuIC05XG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIGxvY2FsIG9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVls4XSlcbiAgICBsb2NhbCB0b2tlbiA9IG9wdHNbJ3Rva2VuJ11cbiAgICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKGpvYklkS2V5LCBLRVlTWzVdLCB0b2tlbiwgQVJHVlsxXSlcbiAgICBpZiBlcnJvckNvZGUgPCAwIHRoZW5cbiAgICAgICAgcmV0dXJuIGVycm9yQ29kZVxuICAgIGVuZFxuICAgIHVwZGF0ZUpvYkZpZWxkcyhqb2JJZEtleSwgQVJHVls5XSk7XG4gICAgbG9jYWwgYXR0ZW1wdHMgPSBvcHRzWydhdHRlbXB0cyddXG4gICAgbG9jYWwgbWF4TWV0cmljc1NpemUgPSBvcHRzWydtYXhNZXRyaWNzU2l6ZSddXG4gICAgbG9jYWwgbWF4Q291bnQgPSBvcHRzWydrZWVwSm9icyddWydjb3VudCddXG4gICAgbG9jYWwgbWF4QWdlID0gb3B0c1sna2VlcEpvYnMnXVsnYWdlJ11cbiAgICBsb2NhbCBqb2JBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JJZEtleSwgXCJwYXJlbnRLZXlcIiwgXCJwYXJlbnRcIiwgXCJkZWlkXCIpXG4gICAgbG9jYWwgcGFyZW50S2V5ID0gam9iQXR0cmlidXRlc1sxXSBvciBcIlwiXG4gICAgbG9jYWwgcGFyZW50SWQgPSBcIlwiXG4gICAgbG9jYWwgcGFyZW50UXVldWVLZXkgPSBcIlwiXG4gICAgaWYgam9iQXR0cmlidXRlc1syXSB0aGVuIC0tIFRPRE86IG5lZWQgdG8gcmV2aXNpdCB0aGlzIGxvZ2ljIGlmIGl0J3Mgc3RpbGwgbmVlZGVkXG4gICAgICAgIGxvY2FsIGpzb25EZWNvZGVkUGFyZW50ID0gY2pzb24uZGVjb2RlKGpvYkF0dHJpYnV0ZXNbMl0pXG4gICAgICAgIHBhcmVudElkID0ganNvbkRlY29kZWRQYXJlbnRbJ2lkJ11cbiAgICAgICAgcGFyZW50UXVldWVLZXkgPSBqc29uRGVjb2RlZFBhcmVudFsncXVldWVLZXknXVxuICAgIGVuZFxuICAgIGxvY2FsIGpvYklkID0gQVJHVlsxXVxuICAgIGxvY2FsIHRpbWVzdGFtcCA9IEFSR1ZbMl1cbiAgICAtLSBSZW1vdmUgZnJvbSBhY3RpdmUgbGlzdCAoaWYgbm90IGFjdGl2ZSB3ZSBzaGFsbCByZXR1cm4gZXJyb3IpXG4gICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJMUkVNXCIsIEtFWVNbMl0sIC0xLCBqb2JJZClcbiAgICBpZiAobnVtUmVtb3ZlZEVsZW1lbnRzIDwgMSkgdGhlblxuICAgICAgICByZXR1cm4gLTNcbiAgICBlbmRcbiAgICBsb2NhbCBldmVudFN0cmVhbUtleSA9IEtFWVNbNF1cbiAgICBsb2NhbCBtZXRhS2V5ID0gS0VZU1s5XVxuICAgIC0tIFRyaW0gZXZlbnRzIGJlZm9yZSBlbWl0aW5nIHRoZW0gdG8gYXZvaWQgdHJpbW1pbmcgZXZlbnRzIGVtaXR0ZWQgaW4gdGhpcyBzY3JpcHRcbiAgICB0cmltRXZlbnRzKG1ldGFLZXksIGV2ZW50U3RyZWFtS2V5KVxuICAgIGxvY2FsIHByZWZpeCA9IEFSR1ZbN11cbiAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPbkZpbmFsaXphdGlvbihwcmVmaXgsIGpvYkF0dHJpYnV0ZXNbM10sIGpvYklkKVxuICAgIC0tIElmIGpvYiBoYXMgYSBwYXJlbnQgd2UgbmVlZCB0b1xuICAgIC0tIDEpIHJlbW92ZSB0aGlzIGpvYiBpZCBmcm9tIHBhcmVudHMgZGVwZW5kZW5jaWVzXG4gICAgLS0gMikgbW92ZSB0aGUgam9iIElkIHRvIHBhcmVudCBcInByb2Nlc3NlZFwiIHNldFxuICAgIC0tIDMpIHB1c2ggdGhlIHJlc3VsdHMgaW50byBwYXJlbnQgXCJyZXN1bHRzXCIgbGlzdFxuICAgIC0tIDQpIGlmIHBhcmVudCdzIGRlcGVuZGVuY2llcyBpcyBlbXB0eSwgdGhlbiBtb3ZlIHBhcmVudCB0byBcIndhaXQvcGF1c2VkXCIuIE5vdGUgaXQgbWF5IGJlIGEgZGlmZmVyZW50IHF1ZXVlIS5cbiAgICBpZiBwYXJlbnRJZCA9PSBcIlwiIGFuZCBwYXJlbnRLZXkgfj0gXCJcIiB0aGVuXG4gICAgICAgIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KHBhcmVudEtleSlcbiAgICAgICAgcGFyZW50UXVldWVLZXkgPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBcIjpcIiAuLiBwYXJlbnRJZClcbiAgICBlbmRcbiAgICBpZiBwYXJlbnRJZCB+PSBcIlwiIHRoZW5cbiAgICAgICAgaWYgQVJHVls1XSA9PSBcImNvbXBsZXRlZFwiIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIGRlcGVuZGVuY2llc1NldCA9IHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIlxuICAgICAgICAgICAgaWYgcmNhbGwoXCJTUkVNXCIsIGRlcGVuZGVuY2llc1NldCwgam9iSWRLZXkpID09IDEgdGhlblxuICAgICAgICAgICAgICAgIHVwZGF0ZVBhcmVudERlcHNJZk5lZWRlZChwYXJlbnRLZXksIHBhcmVudFF1ZXVlS2V5LCBkZXBlbmRlbmNpZXNTZXQsIHBhcmVudElkLCBqb2JJZEtleSwgQVJHVls0XSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1vdmVDaGlsZEZyb21EZXBlbmRlbmNpZXNJZk5lZWRlZChqb2JBdHRyaWJ1dGVzWzJdLCBqb2JJZEtleSwgQVJHVls0XSwgdGltZXN0YW1wKVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBsb2NhbCBhdHRlbXB0c01hZGUgPSByY2FsbChcIkhJTkNSQllcIiwgam9iSWRLZXksIFwiYXRtXCIsIDEpXG4gICAgLS0gUmVtb3ZlIGpvYj9cbiAgICBpZiBtYXhDb3VudCB+PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgdGFyZ2V0U2V0ID0gS0VZU1sxMV1cbiAgICAgICAgLS0gQWRkIHRvIGNvbXBsZXRlL2ZhaWxlZCBzZXRcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHRhcmdldFNldCwgdGltZXN0YW1wLCBqb2JJZClcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIGpvYklkS2V5LCBBUkdWWzNdLCBBUkdWWzRdLCBcImZpbmlzaGVkT25cIiwgdGltZXN0YW1wKVxuICAgICAgICAtLSBcInJldHVybnZhbHVlXCIgLyBcImZhaWxlZFJlYXNvblwiIGFuZCBcImZpbmlzaGVkT25cIlxuICAgICAgICBpZiBBUkdWWzVdID09IFwiZmFpbGVkXCIgdGhlblxuICAgICAgICAgICAgcmNhbGwoXCJIREVMXCIsIGpvYklkS2V5LCBcImRlZmFcIilcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIFJlbW92ZSBvbGQgam9icz9cbiAgICAgICAgaWYgbWF4QWdlIH49IG5pbCB0aGVuXG4gICAgICAgICAgICByZW1vdmVKb2JzQnlNYXhBZ2UodGltZXN0YW1wLCBtYXhBZ2UsIHRhcmdldFNldCwgcHJlZml4KVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbWF4Q291bnQgfj0gbmlsIGFuZCBtYXhDb3VudCA+IDAgdGhlblxuICAgICAgICAgICAgcmVtb3ZlSm9ic0J5TWF4Q291bnQobWF4Q291bnQsIHRhcmdldFNldCwgcHJlZml4KVxuICAgICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAgIHJlbW92ZUpvYktleXMoam9iSWRLZXkpXG4gICAgICAgIGlmIHBhcmVudEtleSB+PSBcIlwiIHRoZW5cbiAgICAgICAgICAgIC0tIFRPRE86IHdoZW4gYSBjaGlsZCBpcyByZW1vdmVkIHdoZW4gZmluaXNoZWQsIHJlc3VsdCBvciBmYWlsdXJlIGluIHBhcmVudFxuICAgICAgICAgICAgLS0gbXVzdCBub3QgYmUgZGVsZXRlZCwgdGhvc2UgdmFsdWUgcmVmZXJlbmNlcyBzaG91bGQgYmUgZGVsZXRlZCB3aGVuIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC0tIGlzIGRlbGV0ZWRcbiAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iSWRLZXksIGZhbHNlLCBwYXJlbnRLZXksIGpvYkF0dHJpYnV0ZXNbM10pXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgQVJHVls1XSwgXCJqb2JJZFwiLCBqb2JJZCwgQVJHVlszXSwgQVJHVls0XSwgXCJwcmV2XCIsIFwiYWN0aXZlXCIpXG4gICAgaWYgQVJHVls1XSA9PSBcImZhaWxlZFwiIHRoZW5cbiAgICAgICAgaWYgdG9udW1iZXIoYXR0ZW1wdHNNYWRlKSA+PSB0b251bWJlcihhdHRlbXB0cykgdGhlblxuICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIGV2ZW50U3RyZWFtS2V5LCBcIipcIiwgXCJldmVudFwiLCBcInJldHJpZXMtZXhoYXVzdGVkXCIsIFwiam9iSWRcIiwgam9iSWQsIFwiYXR0ZW1wdHNNYWRlXCIsXG4gICAgICAgICAgICAgICAgYXR0ZW1wdHNNYWRlKVxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICAtLSBDb2xsZWN0IG1ldHJpY3NcbiAgICBpZiBtYXhNZXRyaWNzU2l6ZSB+PSBcIlwiIHRoZW5cbiAgICAgICAgY29sbGVjdE1ldHJpY3MoS0VZU1sxM10sIEtFWVNbMTNdIC4uICc6ZGF0YScsIG1heE1ldHJpY3NTaXplLCB0aW1lc3RhbXApXG4gICAgZW5kXG4gICAgLS0gVHJ5IHRvIGdldCBuZXh0IGpvYiB0byBhdm9pZCBhbiBleHRyYSByb3VuZHRyaXAgaWYgdGhlIHF1ZXVlIGlzIG5vdCBjbG9zaW5nLFxuICAgIC0tIGFuZCBub3QgcmF0ZSBsaW1pdGVkLlxuICAgIGlmIChBUkdWWzZdID09IFwiMVwiKSB0aGVuXG4gICAgICAgIGxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkLCByYXRlTGltaXRNYXgsIHJhdGVMaW1pdER1cmF0aW9uID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbMl0sXG4gICAgICAgICAgICBLRVlTWzFdLCBLRVlTWzhdKVxuICAgICAgICBsb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzE0XVxuICAgICAgICAtLSBDaGVjayBpZiB0aGVyZSBhcmUgZGVsYXllZCBqb2JzIHRoYXQgY2FuIGJlIHByb21vdGVkXG4gICAgICAgIHByb21vdGVEZWxheWVkSm9icyhLRVlTWzddLCBtYXJrZXJLZXksIHRhcmdldCwgS0VZU1szXSwgZXZlbnRTdHJlYW1LZXksIHByZWZpeCwgdGltZXN0YW1wLCBLRVlTWzEwXSxcbiAgICAgICAgICAgIGlzUGF1c2VkT3JNYXhlZClcbiAgICAgICAgbG9jYWwgbWF4Sm9icyA9IHRvbnVtYmVyKHJhdGVMaW1pdE1heCBvciAob3B0c1snbGltaXRlciddIGFuZCBvcHRzWydsaW1pdGVyJ11bJ21heCddKSlcbiAgICAgICAgLS0gQ2hlY2sgaWYgd2UgYXJlIHJhdGUgbGltaXRlZCBmaXJzdC5cbiAgICAgICAgbG9jYWwgZXhwaXJlVGltZSA9IGdldFJhdGVMaW1pdFRUTChtYXhKb2JzLCBLRVlTWzZdKVxuICAgICAgICBpZiBleHBpcmVUaW1lID4gMCB0aGVuXG4gICAgICAgICAgICByZXR1cm4gezAsIDAsIGV4cGlyZVRpbWUsIDB9XG4gICAgICAgIGVuZFxuICAgICAgICAtLSBwYXVzZWQgb3IgbWF4ZWQgcXVldWVcbiAgICAgICAgaWYgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICAgICAgICAgIHJldHVybiB7MCwgMCwgMCwgMH1cbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIGxpbWl0ZXJEdXJhdGlvbiA9IChvcHRzWydsaW1pdGVyJ10gYW5kIG9wdHNbJ2xpbWl0ZXInXVsnZHVyYXRpb24nXSkgb3IgcmF0ZUxpbWl0RHVyYXRpb25cbiAgICAgICAgam9iSWQgPSByY2FsbChcIlJQT1BMUFVTSFwiLCBLRVlTWzFdLCBLRVlTWzJdKVxuICAgICAgICBpZiBqb2JJZCB0aGVuXG4gICAgICAgICAgICAtLSBNYXJrZXJzIGluIHdhaXRsaXN0IERFUFJFQ0FURUQgaW4gdjU6IFJlbW92ZSBpbiB2Ni5cbiAgICAgICAgICAgIGlmIHN0cmluZy5zdWIoam9iSWQsIDEsIDIpID09IFwiMDpcIiB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUkVNXCIsIEtFWVNbMl0sIDEsIGpvYklkKVxuICAgICAgICAgICAgICAgIC0tIElmIGpvYklkIGlzIHNwZWNpYWwgSUQgMDpkZWxheSAoZGVsYXkgZ3JlYXRlciB0aGFuIDApLCB0aGVuIHRoZXJlIGlzIG5vIGpvYiB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLS0gYnV0IGlmIElEIGlzIDA6MCwgdGhlbiB0aGVyZSBpcyBhdCBsZWFzdCAxIHByaW9yaXRpemVkIGpvYiB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgaWYgam9iSWQgPT0gXCIwOjBcIiB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGpvYklkID0gbW92ZUpvYkZyb21Qcmlvcml0aXplZFRvQWN0aXZlKEtFWVNbM10sIEtFWVNbMl0sIEtFWVNbMTBdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZUpvYkZvclByb2Nlc3NpbmcocHJlZml4LCBLRVlTWzZdLCBldmVudFN0cmVhbUtleSwgam9iSWQsIHRpbWVzdGFtcCwgbWF4Sm9icyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ZXJEdXJhdGlvbiwgbWFya2VyS2V5LCBvcHRzKVxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlSm9iRm9yUHJvY2Vzc2luZyhwcmVmaXgsIEtFWVNbNl0sIGV2ZW50U3RyZWFtS2V5LCBqb2JJZCwgdGltZXN0YW1wLCBtYXhKb2JzLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdGVyRHVyYXRpb24sIG1hcmtlcktleSwgb3B0cylcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBqb2JJZCA9IG1vdmVKb2JGcm9tUHJpb3JpdGl6ZWRUb0FjdGl2ZShLRVlTWzNdLCBLRVlTWzJdLCBLRVlTWzEwXSlcbiAgICAgICAgICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZUpvYkZvclByb2Nlc3NpbmcocHJlZml4LCBLRVlTWzZdLCBldmVudFN0cmVhbUtleSwgam9iSWQsIHRpbWVzdGFtcCwgbWF4Sm9icyxcbiAgICAgICAgICAgICAgICAgICAgbGltaXRlckR1cmF0aW9uLCBtYXJrZXJLZXksIG9wdHMpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIFJldHVybiB0aGUgdGltZXN0YW1wIGZvciB0aGUgbmV4dCBkZWxheWVkIGpvYiBpZiBhbnkuXG4gICAgICAgIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChLRVlTWzddKVxuICAgICAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICAgICAgICAtLSBUaGUgcmVzdWx0IGlzIGd1YXJhbnRlZWQgdG8gYmUgcG9zaXRpdmUsIHNpbmNlIHRoZVxuICAgICAgICAgICAgLS0gWlJBTkdFQllTQ09SRSBjb21tYW5kIHdvdWxkIGhhdmUgcmV0dXJuIGEgam9iIG90aGVyd2lzZS5cbiAgICAgICAgICAgIHJldHVybiB7MCwgMCwgMCwgbmV4dFRpbWVzdGFtcH1cbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgbG9jYWwgd2FpdExlbiA9IHJjYWxsKFwiTExFTlwiLCBLRVlTWzFdKVxuICAgIGlmIHdhaXRMZW4gPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIGFjdGl2ZUxlbiA9IHJjYWxsKFwiTExFTlwiLCBLRVlTWzJdKVxuICAgICAgICBpZiBhY3RpdmVMZW4gPT0gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0aXplZExlbiA9IHJjYWxsKFwiWkNBUkRcIiwgS0VZU1szXSlcbiAgICAgICAgICAgIGlmIHByaW9yaXRpemVkTGVuID09IDAgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJkcmFpbmVkXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBtb3ZlVG9GaW5pc2hlZCA9IHtcbiAgICBuYW1lOiAnbW92ZVRvRmluaXNoZWQnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMTQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVRvRmluaXNoZWQtMTQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToFinished-14.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-7.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-7.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   moveToWaitingChildren: () => (/* binding */ moveToWaitingChildren)\n/* harmony export */ });\nconst content = `--[[\n  Moves job from active to waiting children set.\n  Input:\n    KEYS[1] active key\n    KEYS[2] wait-children key\n    KEYS[3] job key\n    KEYS[4] job dependencies key\n    KEYS[5] job unsuccessful key\n    KEYS[6] stalled key\n    KEYS[7] events key\n    ARGV[1] token\n    ARGV[2] child key\n    ARGV[3] timestamp\n    ARGV[4] jobId\n    ARGV[5] prefix\n  Output:\n    0 - OK\n    1 - There are not pending dependencies.\n   -1 - Missing job.\n   -2 - Missing lock\n   -3 - Job not in active set\n   -9 - Job has failed children\n]]\nlocal rcall = redis.call\nlocal activeKey = KEYS[1]\nlocal waitingChildrenKey = KEYS[2]\nlocal jobKey = KEYS[3]\nlocal jobDependenciesKey = KEYS[4]\nlocal jobUnsuccessfulKey = KEYS[5]\nlocal stalledKey = KEYS[6]\nlocal eventStreamKey = KEYS[7]\nlocal token = ARGV[1]\nlocal timestamp = ARGV[3]\nlocal jobId = ARGV[4]\n--- Includes\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nlocal function removeJobFromActive(activeKey, stalledKey, jobKey, jobId,\n    token)\n  local errorCode = removeLock(jobKey, stalledKey, token, jobId)\n  if errorCode < 0 then\n    return errorCode\n  end\n  local numRemovedElements = rcall(\"LREM\", activeKey, -1, jobId)\n  if numRemovedElements < 1 then\n    return -3\n  end\n  return 0\nend\nlocal function moveToWaitingChildren(activeKey, waitingChildrenKey, stalledKey, eventStreamKey,\n    jobKey, jobId, timestamp, token)\n  local errorCode = removeJobFromActive(activeKey, stalledKey, jobKey, jobId, token)\n  if errorCode < 0 then\n    return errorCode\n  end\n  local score = tonumber(timestamp)\n  rcall(\"ZADD\", waitingChildrenKey, score, jobId)\n  rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting-children\", \"jobId\", jobId, 'prev', 'active')\n  return 0\nend\nif rcall(\"EXISTS\", jobKey) == 1 then\n  if rcall(\"ZCARD\", jobUnsuccessfulKey) ~= 0 then\n    return -9\n  else\n    if ARGV[2] ~= \"\" then\n      if rcall(\"SISMEMBER\", jobDependenciesKey, ARGV[2]) ~= 0 then\n        return moveToWaitingChildren(activeKey, waitingChildrenKey, stalledKey, eventStreamKey,\n          jobKey, jobId, timestamp, token)\n      end\n      return 1\n    else\n      if rcall(\"SCARD\", jobDependenciesKey) ~= 0 then \n        return moveToWaitingChildren(activeKey, waitingChildrenKey, stalledKey, eventStreamKey,\n          jobKey, jobId, timestamp, token)\n      end\n      return 1\n    end    \n  end\nend\nreturn -1\n`;\nconst moveToWaitingChildren = {\n    name: 'moveToWaitingChildren',\n    content,\n    keys: 7,\n};\n//# sourceMappingURL=moveToWaitingChildren-7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvbW92ZVRvV2FpdGluZ0NoaWxkcmVuLTcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL21vdmVUb1dhaXRpbmdDaGlsZHJlbi03LmpzP2VhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIE1vdmVzIGpvYiBmcm9tIGFjdGl2ZSB0byB3YWl0aW5nIGNoaWxkcmVuIHNldC5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBhY3RpdmUga2V5XG4gICAgS0VZU1syXSB3YWl0LWNoaWxkcmVuIGtleVxuICAgIEtFWVNbM10gam9iIGtleVxuICAgIEtFWVNbNF0gam9iIGRlcGVuZGVuY2llcyBrZXlcbiAgICBLRVlTWzVdIGpvYiB1bnN1Y2Nlc3NmdWwga2V5XG4gICAgS0VZU1s2XSBzdGFsbGVkIGtleVxuICAgIEtFWVNbN10gZXZlbnRzIGtleVxuICAgIEFSR1ZbMV0gdG9rZW5cbiAgICBBUkdWWzJdIGNoaWxkIGtleVxuICAgIEFSR1ZbM10gdGltZXN0YW1wXG4gICAgQVJHVls0XSBqb2JJZFxuICAgIEFSR1ZbNV0gcHJlZml4XG4gIE91dHB1dDpcbiAgICAwIC0gT0tcbiAgICAxIC0gVGhlcmUgYXJlIG5vdCBwZW5kaW5nIGRlcGVuZGVuY2llcy5cbiAgIC0xIC0gTWlzc2luZyBqb2IuXG4gICAtMiAtIE1pc3NpbmcgbG9ja1xuICAgLTMgLSBKb2Igbm90IGluIGFjdGl2ZSBzZXRcbiAgIC05IC0gSm9iIGhhcyBmYWlsZWQgY2hpbGRyZW5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGFjdGl2ZUtleSA9IEtFWVNbMV1cbmxvY2FsIHdhaXRpbmdDaGlsZHJlbktleSA9IEtFWVNbMl1cbmxvY2FsIGpvYktleSA9IEtFWVNbM11cbmxvY2FsIGpvYkRlcGVuZGVuY2llc0tleSA9IEtFWVNbNF1cbmxvY2FsIGpvYlVuc3VjY2Vzc2Z1bEtleSA9IEtFWVNbNV1cbmxvY2FsIHN0YWxsZWRLZXkgPSBLRVlTWzZdXG5sb2NhbCBldmVudFN0cmVhbUtleSA9IEtFWVNbN11cbmxvY2FsIHRva2VuID0gQVJHVlsxXVxubG9jYWwgdGltZXN0YW1wID0gQVJHVlszXVxubG9jYWwgam9iSWQgPSBBUkdWWzRdXG4tLS0gSW5jbHVkZXNcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxvY2soam9iS2V5LCBzdGFsbGVkS2V5LCB0b2tlbiwgam9iSWQpXG4gIGlmIHRva2VuIH49IFwiMFwiIHRoZW5cbiAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICBsb2NhbCBsb2NrVG9rZW4gPSByY2FsbChcIkdFVFwiLCBsb2NrS2V5KVxuICAgIGlmIGxvY2tUb2tlbiA9PSB0b2tlbiB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCBsb2NrS2V5KVxuICAgICAgcmNhbGwoXCJTUkVNXCIsIHN0YWxsZWRLZXksIGpvYklkKVxuICAgIGVsc2VcbiAgICAgIGlmIGxvY2tUb2tlbiB0aGVuXG4gICAgICAgIC0tIExvY2sgZXhpc3RzIGJ1dCB0b2tlbiBkb2VzIG5vdCBtYXRjaFxuICAgICAgICByZXR1cm4gLTZcbiAgICAgIGVsc2VcbiAgICAgICAgLS0gTG9jayBpcyBtaXNzaW5nIGNvbXBsZXRlbHlcbiAgICAgICAgcmV0dXJuIC0yXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiAwXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYkZyb21BY3RpdmUoYWN0aXZlS2V5LCBzdGFsbGVkS2V5LCBqb2JLZXksIGpvYklkLFxuICAgIHRva2VuKVxuICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKGpvYktleSwgc3RhbGxlZEtleSwgdG9rZW4sIGpvYklkKVxuICBpZiBlcnJvckNvZGUgPCAwIHRoZW5cbiAgICByZXR1cm4gZXJyb3JDb2RlXG4gIGVuZFxuICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIkxSRU1cIiwgYWN0aXZlS2V5LCAtMSwgam9iSWQpXG4gIGlmIG51bVJlbW92ZWRFbGVtZW50cyA8IDEgdGhlblxuICAgIHJldHVybiAtM1xuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxubG9jYWwgZnVuY3Rpb24gbW92ZVRvV2FpdGluZ0NoaWxkcmVuKGFjdGl2ZUtleSwgd2FpdGluZ0NoaWxkcmVuS2V5LCBzdGFsbGVkS2V5LCBldmVudFN0cmVhbUtleSxcbiAgICBqb2JLZXksIGpvYklkLCB0aW1lc3RhbXAsIHRva2VuKVxuICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVKb2JGcm9tQWN0aXZlKGFjdGl2ZUtleSwgc3RhbGxlZEtleSwgam9iS2V5LCBqb2JJZCwgdG9rZW4pXG4gIGlmIGVycm9yQ29kZSA8IDAgdGhlblxuICAgIHJldHVybiBlcnJvckNvZGVcbiAgZW5kXG4gIGxvY2FsIHNjb3JlID0gdG9udW1iZXIodGltZXN0YW1wKVxuICByY2FsbChcIlpBRERcIiwgd2FpdGluZ0NoaWxkcmVuS2V5LCBzY29yZSwgam9iSWQpXG4gIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIFwiam9iSWRcIiwgam9iSWQsICdwcmV2JywgJ2FjdGl2ZScpXG4gIHJldHVybiAwXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgPT0gMSB0aGVuXG4gIGlmIHJjYWxsKFwiWkNBUkRcIiwgam9iVW5zdWNjZXNzZnVsS2V5KSB+PSAwIHRoZW5cbiAgICByZXR1cm4gLTlcbiAgZWxzZVxuICAgIGlmIEFSR1ZbMl0gfj0gXCJcIiB0aGVuXG4gICAgICBpZiByY2FsbChcIlNJU01FTUJFUlwiLCBqb2JEZXBlbmRlbmNpZXNLZXksIEFSR1ZbMl0pIH49IDAgdGhlblxuICAgICAgICByZXR1cm4gbW92ZVRvV2FpdGluZ0NoaWxkcmVuKGFjdGl2ZUtleSwgd2FpdGluZ0NoaWxkcmVuS2V5LCBzdGFsbGVkS2V5LCBldmVudFN0cmVhbUtleSxcbiAgICAgICAgICBqb2JLZXksIGpvYklkLCB0aW1lc3RhbXAsIHRva2VuKVxuICAgICAgZW5kXG4gICAgICByZXR1cm4gMVxuICAgIGVsc2VcbiAgICAgIGlmIHJjYWxsKFwiU0NBUkRcIiwgam9iRGVwZW5kZW5jaWVzS2V5KSB+PSAwIHRoZW4gXG4gICAgICAgIHJldHVybiBtb3ZlVG9XYWl0aW5nQ2hpbGRyZW4oYWN0aXZlS2V5LCB3YWl0aW5nQ2hpbGRyZW5LZXksIHN0YWxsZWRLZXksIGV2ZW50U3RyZWFtS2V5LFxuICAgICAgICAgIGpvYktleSwgam9iSWQsIHRpbWVzdGFtcCwgdG9rZW4pXG4gICAgICBlbmRcbiAgICAgIHJldHVybiAxXG4gICAgZW5kICAgIFxuICBlbmRcbmVuZFxucmV0dXJuIC0xXG5gO1xuZXhwb3J0IGNvbnN0IG1vdmVUb1dhaXRpbmdDaGlsZHJlbiA9IHtcbiAgICBuYW1lOiAnbW92ZVRvV2FpdGluZ0NoaWxkcmVuJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZVRvV2FpdGluZ0NoaWxkcmVuLTcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/moveToWaitingChildren-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/obliterate-2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   obliterate: () => (/* binding */ obliterate)\n/* harmony export */ });\nconst content = `--[[\n  Completely obliterates a queue and all of its contents\n  This command completely destroys a queue including all of its jobs, current or past \n  leaving no trace of its existence. Since this script needs to iterate to find all the job\n  keys, consider that this call may be slow for very large queues.\n  The queue needs to be \"paused\" or it will return an error\n  If the queue has currently active jobs then the script by default will return error,\n  however this behaviour can be overrided using the 'force' option.\n  Input:\n    KEYS[1] meta\n    KEYS[2] base\n    ARGV[1] count\n    ARGV[2] force\n]]\nlocal maxCount = tonumber(ARGV[1])\nlocal baseKey = KEYS[2]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to remove job.\n]]\n-- Includes\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal function removeJob(jobId, hard, baseKey, shouldRemoveDeduplicationKey)\n  local jobKey = baseKey .. jobId\n  removeParentDependencyKey(jobKey, hard, nil, baseKey)\n  if shouldRemoveDeduplicationKey then\n    removeDeduplicationKeyIfNeededOnRemoval(baseKey, jobKey, jobId)\n  end\n  removeJobKeys(jobKey)\nend\nlocal function removeJobs(keys, hard, baseKey, max)\n  for i, key in ipairs(keys) do\n    removeJob(key, hard, baseKey, true --[[remove debounce key]])\n  end\n  return max - #keys\nend\n--[[\n  Functions to remove jobs.\n]]\n-- Includes\n--[[\n  Function to filter out jobs to ignore from a table.\n]]\nlocal function filterOutJobsToIgnore(jobs, jobsToIgnore)\n  local filteredJobs = {}\n  for i = 1, #jobs do\n    if not jobsToIgnore[jobs[i]] then\n      table.insert(filteredJobs, jobs[i])\n    end\n  end\n  return filteredJobs\nend\nlocal function getListItems(keyName, max)\n  return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function removeListJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getListItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  rcall(\"LTRIM\", keyName, #jobs, -1)\n  return count\nend\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to get ZSet items.\n]]\nlocal function getZSetItems(keyName, max)\n  return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeZSetJobs(keyName, hard, baseKey, max, jobsToIgnore)\n  local jobs = getZSetItems(keyName, max)\n  if jobsToIgnore then\n    jobs = filterOutJobsToIgnore(jobs, jobsToIgnore)\n  end\n  local count = removeJobs(jobs, hard, baseKey, max)\n  if(#jobs > 0) then\n    for from, to in batches(#jobs, 7000) do\n      rcall(\"ZREM\", keyName, unpack(jobs, from, to))\n    end\n  end\n  return count\nend\nlocal function removeLockKeys(keys)\n  for i, key in ipairs(keys) do\n    rcall(\"DEL\", baseKey .. key .. ':lock')\n  end\nend\n-- 1) Check if paused, if not return with error.\nif rcall(\"HEXISTS\", KEYS[1], \"paused\") ~= 1 then\n  return -1 -- Error, NotPaused\nend\n-- 2) Check if there are active jobs, if there are and not \"force\" return error.\nlocal activeKey = baseKey .. 'active'\nlocal activeJobs = getListItems(activeKey, maxCount)\nif (#activeJobs > 0) then\n  if(ARGV[2] == \"\") then \n    return -2 -- Error, ExistActiveJobs\n  end\nend\nremoveLockKeys(activeJobs)\nmaxCount = removeJobs(activeJobs, true, baseKey, maxCount)\nrcall(\"LTRIM\", activeKey, #activeJobs, -1)\nif(maxCount <= 0) then\n  return 1\nend\nlocal delayedKey = baseKey .. 'delayed'\nmaxCount = removeZSetJobs(delayedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal repeatKey = baseKey .. 'repeat'\nlocal repeatJobsIds = getZSetItems(repeatKey, maxCount)\nfor i, key in ipairs(repeatJobsIds) do\n  local jobKey = repeatKey .. \":\" .. key\n  rcall(\"DEL\", jobKey)\nend\nif(#repeatJobsIds > 0) then\n  for from, to in batches(#repeatJobsIds, 7000) do\n    rcall(\"ZREM\", repeatKey, unpack(repeatJobsIds, from, to))\n  end\nend\nmaxCount = maxCount - #repeatJobsIds\nif(maxCount <= 0) then\n  return 1\nend\nlocal completedKey = baseKey .. 'completed'\nmaxCount = removeZSetJobs(completedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal waitKey = baseKey .. 'paused'\nmaxCount = removeListJobs(waitKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal prioritizedKey = baseKey .. 'prioritized'\nmaxCount = removeZSetJobs(prioritizedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nlocal failedKey = baseKey .. 'failed'\nmaxCount = removeZSetJobs(failedKey, true, baseKey, maxCount)\nif(maxCount <= 0) then\n  return 1\nend\nif(maxCount > 0) then\n  rcall(\"DEL\",\n    baseKey .. 'events',\n    baseKey .. 'delay', \n    baseKey .. 'stalled-check',\n    baseKey .. 'stalled',\n    baseKey .. 'id',\n    baseKey .. 'pc',\n    baseKey .. 'meta',\n    baseKey .. 'metrics:completed',\n    baseKey .. 'metrics:completed:data',\n    baseKey .. 'metrics:failed',\n    baseKey .. 'metrics:failed:data')\n  return 0\nelse\n  return 1\nend\n`;\nconst obliterate = {\n    name: 'obliterate',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=obliterate-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvb2JsaXRlcmF0ZS0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvb2JsaXRlcmF0ZS0yLmpzPzk2NDMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIENvbXBsZXRlbHkgb2JsaXRlcmF0ZXMgYSBxdWV1ZSBhbmQgYWxsIG9mIGl0cyBjb250ZW50c1xuICBUaGlzIGNvbW1hbmQgY29tcGxldGVseSBkZXN0cm95cyBhIHF1ZXVlIGluY2x1ZGluZyBhbGwgb2YgaXRzIGpvYnMsIGN1cnJlbnQgb3IgcGFzdCBcbiAgbGVhdmluZyBubyB0cmFjZSBvZiBpdHMgZXhpc3RlbmNlLiBTaW5jZSB0aGlzIHNjcmlwdCBuZWVkcyB0byBpdGVyYXRlIHRvIGZpbmQgYWxsIHRoZSBqb2JcbiAga2V5cywgY29uc2lkZXIgdGhhdCB0aGlzIGNhbGwgbWF5IGJlIHNsb3cgZm9yIHZlcnkgbGFyZ2UgcXVldWVzLlxuICBUaGUgcXVldWUgbmVlZHMgdG8gYmUgXCJwYXVzZWRcIiBvciBpdCB3aWxsIHJldHVybiBhbiBlcnJvclxuICBJZiB0aGUgcXVldWUgaGFzIGN1cnJlbnRseSBhY3RpdmUgam9icyB0aGVuIHRoZSBzY3JpcHQgYnkgZGVmYXVsdCB3aWxsIHJldHVybiBlcnJvcixcbiAgaG93ZXZlciB0aGlzIGJlaGF2aW91ciBjYW4gYmUgb3ZlcnJpZGVkIHVzaW5nIHRoZSAnZm9yY2UnIG9wdGlvbi5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBtZXRhXG4gICAgS0VZU1syXSBiYXNlXG4gICAgQVJHVlsxXSBjb3VudFxuICAgIEFSR1ZbMl0gZm9yY2Vcbl1dXG5sb2NhbCBtYXhDb3VudCA9IHRvbnVtYmVyKEFSR1ZbMV0pXG5sb2NhbCBiYXNlS2V5ID0gS0VZU1syXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYi5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb25zIHRvIGRlc3RydWN0dXJlIGpvYiBrZXkuXG4gIEp1c3QgYSBiaXQgb2Ygd2FybmluZywgdGhlc2UgZnVuY3Rpb25zIG1heSBiZSBhIGJpdCBzbG93IGFuZCBhZmZlY3QgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbl1dXG5sb2NhbCBnZXRKb2JJZEZyb21LZXkgPSBmdW5jdGlvbiAoam9iS2V5KVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKGpvYktleSwgXCIuKjooLiopXCIpXG5lbmRcbmxvY2FsIGdldEpvYktleVByZWZpeCA9IGZ1bmN0aW9uIChqb2JLZXksIGpvYklkKVxuICByZXR1cm4gc3RyaW5nLnN1Yihqb2JLZXksIDAsICNqb2JLZXkgLSAjam9iSWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYihqb2JJZCwgaGFyZCwgYmFzZUtleSwgc2hvdWxkUmVtb3ZlRGVkdXBsaWNhdGlvbktleSlcbiAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBqb2JJZFxuICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgaGFyZCwgbmlsLCBiYXNlS2V5KVxuICBpZiBzaG91bGRSZW1vdmVEZWR1cGxpY2F0aW9uS2V5IHRoZW5cbiAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwoYmFzZUtleSwgam9iS2V5LCBqb2JJZClcbiAgZW5kXG4gIHJlbW92ZUpvYktleXMoam9iS2V5KVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzKGtleXMsIGhhcmQsIGJhc2VLZXksIG1heClcbiAgZm9yIGksIGtleSBpbiBpcGFpcnMoa2V5cykgZG9cbiAgICByZW1vdmVKb2Ioa2V5LCBoYXJkLCBiYXNlS2V5LCB0cnVlIC0tW1tyZW1vdmUgZGVib3VuY2Uga2V5XV0pXG4gIGVuZFxuICByZXR1cm4gbWF4IC0gI2tleXNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gcmVtb3ZlIGpvYnMuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZmlsdGVyIG91dCBqb2JzIHRvIGlnbm9yZSBmcm9tIGEgdGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZmlsdGVyT3V0Sm9ic1RvSWdub3JlKGpvYnMsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgZmlsdGVyZWRKb2JzID0ge31cbiAgZm9yIGkgPSAxLCAjam9icyBkb1xuICAgIGlmIG5vdCBqb2JzVG9JZ25vcmVbam9ic1tpXV0gdGhlblxuICAgICAgdGFibGUuaW5zZXJ0KGZpbHRlcmVkSm9icywgam9ic1tpXSlcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiBmaWx0ZXJlZEpvYnNcbmVuZFxubG9jYWwgZnVuY3Rpb24gZ2V0TGlzdEl0ZW1zKGtleU5hbWUsIG1heClcbiAgcmV0dXJuIHJjYWxsKCdMUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMaXN0Sm9icyhrZXlOYW1lLCBoYXJkLCBiYXNlS2V5LCBtYXgsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgam9icyA9IGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGlmIGpvYnNUb0lnbm9yZSB0aGVuXG4gICAgam9icyA9IGZpbHRlck91dEpvYnNUb0lnbm9yZShqb2JzLCBqb2JzVG9JZ25vcmUpXG4gIGVuZFxuICBsb2NhbCBjb3VudCA9IHJlbW92ZUpvYnMoam9icywgaGFyZCwgYmFzZUtleSwgbWF4KVxuICByY2FsbChcIkxUUklNXCIsIGtleU5hbWUsICNqb2JzLCAtMSlcbiAgcmV0dXJuIGNvdW50XG5lbmRcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IFpTZXQgaXRlbXMuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0WlNldEl0ZW1zKGtleU5hbWUsIG1heClcbiAgcmV0dXJuIHJjYWxsKCdaUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVaU2V0Sm9icyhrZXlOYW1lLCBoYXJkLCBiYXNlS2V5LCBtYXgsIGpvYnNUb0lnbm9yZSlcbiAgbG9jYWwgam9icyA9IGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gIGlmIGpvYnNUb0lnbm9yZSB0aGVuXG4gICAgam9icyA9IGZpbHRlck91dEpvYnNUb0lnbm9yZShqb2JzLCBqb2JzVG9JZ25vcmUpXG4gIGVuZFxuICBsb2NhbCBjb3VudCA9IHJlbW92ZUpvYnMoam9icywgaGFyZCwgYmFzZUtleSwgbWF4KVxuICBpZigjam9icyA+IDApIHRoZW5cbiAgICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjam9icywgNzAwMCkgZG9cbiAgICAgIHJjYWxsKFwiWlJFTVwiLCBrZXlOYW1lLCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGNvdW50XG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxvY2tLZXlzKGtleXMpXG4gIGZvciBpLCBrZXkgaW4gaXBhaXJzKGtleXMpIGRvXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiBrZXkgLi4gJzpsb2NrJylcbiAgZW5kXG5lbmRcbi0tIDEpIENoZWNrIGlmIHBhdXNlZCwgaWYgbm90IHJldHVybiB3aXRoIGVycm9yLlxuaWYgcmNhbGwoXCJIRVhJU1RTXCIsIEtFWVNbMV0sIFwicGF1c2VkXCIpIH49IDEgdGhlblxuICByZXR1cm4gLTEgLS0gRXJyb3IsIE5vdFBhdXNlZFxuZW5kXG4tLSAyKSBDaGVjayBpZiB0aGVyZSBhcmUgYWN0aXZlIGpvYnMsIGlmIHRoZXJlIGFyZSBhbmQgbm90IFwiZm9yY2VcIiByZXR1cm4gZXJyb3IuXG5sb2NhbCBhY3RpdmVLZXkgPSBiYXNlS2V5IC4uICdhY3RpdmUnXG5sb2NhbCBhY3RpdmVKb2JzID0gZ2V0TGlzdEl0ZW1zKGFjdGl2ZUtleSwgbWF4Q291bnQpXG5pZiAoI2FjdGl2ZUpvYnMgPiAwKSB0aGVuXG4gIGlmKEFSR1ZbMl0gPT0gXCJcIikgdGhlbiBcbiAgICByZXR1cm4gLTIgLS0gRXJyb3IsIEV4aXN0QWN0aXZlSm9ic1xuICBlbmRcbmVuZFxucmVtb3ZlTG9ja0tleXMoYWN0aXZlSm9icylcbm1heENvdW50ID0gcmVtb3ZlSm9icyhhY3RpdmVKb2JzLCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbnJjYWxsKFwiTFRSSU1cIiwgYWN0aXZlS2V5LCAjYWN0aXZlSm9icywgLTEpXG5pZihtYXhDb3VudCA8PSAwKSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmxvY2FsIGRlbGF5ZWRLZXkgPSBiYXNlS2V5IC4uICdkZWxheWVkJ1xubWF4Q291bnQgPSByZW1vdmVaU2V0Sm9icyhkZWxheWVkS2V5LCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbmlmKG1heENvdW50IDw9IDApIHRoZW5cbiAgcmV0dXJuIDFcbmVuZFxubG9jYWwgcmVwZWF0S2V5ID0gYmFzZUtleSAuLiAncmVwZWF0J1xubG9jYWwgcmVwZWF0Sm9ic0lkcyA9IGdldFpTZXRJdGVtcyhyZXBlYXRLZXksIG1heENvdW50KVxuZm9yIGksIGtleSBpbiBpcGFpcnMocmVwZWF0Sm9ic0lkcykgZG9cbiAgbG9jYWwgam9iS2V5ID0gcmVwZWF0S2V5IC4uIFwiOlwiIC4uIGtleVxuICByY2FsbChcIkRFTFwiLCBqb2JLZXkpXG5lbmRcbmlmKCNyZXBlYXRKb2JzSWRzID4gMCkgdGhlblxuICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjcmVwZWF0Sm9ic0lkcywgNzAwMCkgZG9cbiAgICByY2FsbChcIlpSRU1cIiwgcmVwZWF0S2V5LCB1bnBhY2socmVwZWF0Sm9ic0lkcywgZnJvbSwgdG8pKVxuICBlbmRcbmVuZFxubWF4Q291bnQgPSBtYXhDb3VudCAtICNyZXBlYXRKb2JzSWRzXG5pZihtYXhDb3VudCA8PSAwKSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmxvY2FsIGNvbXBsZXRlZEtleSA9IGJhc2VLZXkgLi4gJ2NvbXBsZXRlZCdcbm1heENvdW50ID0gcmVtb3ZlWlNldEpvYnMoY29tcGxldGVkS2V5LCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbmlmKG1heENvdW50IDw9IDApIHRoZW5cbiAgcmV0dXJuIDFcbmVuZFxubG9jYWwgd2FpdEtleSA9IGJhc2VLZXkgLi4gJ3BhdXNlZCdcbm1heENvdW50ID0gcmVtb3ZlTGlzdEpvYnMod2FpdEtleSwgdHJ1ZSwgYmFzZUtleSwgbWF4Q291bnQpXG5pZihtYXhDb3VudCA8PSAwKSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmxvY2FsIHByaW9yaXRpemVkS2V5ID0gYmFzZUtleSAuLiAncHJpb3JpdGl6ZWQnXG5tYXhDb3VudCA9IHJlbW92ZVpTZXRKb2JzKHByaW9yaXRpemVkS2V5LCB0cnVlLCBiYXNlS2V5LCBtYXhDb3VudClcbmlmKG1heENvdW50IDw9IDApIHRoZW5cbiAgcmV0dXJuIDFcbmVuZFxubG9jYWwgZmFpbGVkS2V5ID0gYmFzZUtleSAuLiAnZmFpbGVkJ1xubWF4Q291bnQgPSByZW1vdmVaU2V0Sm9icyhmYWlsZWRLZXksIHRydWUsIGJhc2VLZXksIG1heENvdW50KVxuaWYobWF4Q291bnQgPD0gMCkgdGhlblxuICByZXR1cm4gMVxuZW5kXG5pZihtYXhDb3VudCA+IDApIHRoZW5cbiAgcmNhbGwoXCJERUxcIixcbiAgICBiYXNlS2V5IC4uICdldmVudHMnLFxuICAgIGJhc2VLZXkgLi4gJ2RlbGF5JywgXG4gICAgYmFzZUtleSAuLiAnc3RhbGxlZC1jaGVjaycsXG4gICAgYmFzZUtleSAuLiAnc3RhbGxlZCcsXG4gICAgYmFzZUtleSAuLiAnaWQnLFxuICAgIGJhc2VLZXkgLi4gJ3BjJyxcbiAgICBiYXNlS2V5IC4uICdtZXRhJyxcbiAgICBiYXNlS2V5IC4uICdtZXRyaWNzOmNvbXBsZXRlZCcsXG4gICAgYmFzZUtleSAuLiAnbWV0cmljczpjb21wbGV0ZWQ6ZGF0YScsXG4gICAgYmFzZUtleSAuLiAnbWV0cmljczpmYWlsZWQnLFxuICAgIGJhc2VLZXkgLi4gJ21ldHJpY3M6ZmFpbGVkOmRhdGEnKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gMVxuZW5kXG5gO1xuZXhwb3J0IGNvbnN0IG9ibGl0ZXJhdGUgPSB7XG4gICAgbmFtZTogJ29ibGl0ZXJhdGUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmxpdGVyYXRlLTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/obliterate-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/paginate-1.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paginate: () => (/* binding */ paginate)\n/* harmony export */ });\nconst content = `--[[\n    Paginate a set or hash\n    Input:\n      KEYS[1] key pointing to the set or hash to be paginated.\n      ARGV[1]  page start offset\n      ARGV[2]  page end offset (-1 for all the elements)\n      ARGV[3]  cursor\n      ARGV[4]  offset\n      ARGV[5]  max iterations\n      ARGV[6]  fetch jobs?\n    Output:\n      [cursor, offset, items, numItems]\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to achieve pagination for a set or hash.\n  This function simulates pagination in the most efficient way possible\n  for a set using sscan or hscan.\n  The main limitation is that sets are not order preserving, so the\n  pagination is not stable. This means that if the set is modified\n  between pages, the same element may appear in different pages.\n]] -- Maximum number of elements to be returned by sscan per iteration.\nlocal maxCount = 100\n-- Finds the cursor, and returns the first elements available for the requested page.\nlocal function findPage(key, command, pageStart, pageSize, cursor, offset,\n                        maxIterations, fetchJobs)\n    local items = {}\n    local jobs = {}\n    local iterations = 0\n    repeat\n        -- Iterate over the set using sscan/hscan.\n        local result = rcall(command, key, cursor, \"COUNT\", maxCount)\n        cursor = result[1]\n        local members = result[2]\n        local step = 1\n        if command == \"HSCAN\" then\n            step = 2\n        end\n        if #members == 0 then\n            -- If the result is empty, we can return the result.\n            return cursor, offset, items, jobs\n        end\n        local chunkStart = offset\n        local chunkEnd = offset + #members / step\n        local pageEnd = pageStart + pageSize\n        if chunkEnd < pageStart then\n            -- If the chunk is before the page, we can skip it.\n            offset = chunkEnd\n        elseif chunkStart > pageEnd then\n            -- If the chunk is after the page, we can return the result.\n            return cursor, offset, items, jobs\n        else\n            -- If the chunk is overlapping the page, we need to add the elements to the result.\n            for i = 1, #members, step do\n                if offset >= pageEnd then\n                    return cursor, offset, items, jobs\n                end\n                if offset >= pageStart then\n                    local index = #items + 1\n                    if fetchJobs ~= nil then\n                        jobs[#jobs+1] = rcall(\"HGETALL\", members[i])\n                    end\n                    if step == 2 then\n                        items[index] = {members[i], members[i + 1]}\n                    else\n                        items[index] = members[i]\n                    end\n                end\n                offset = offset + 1\n            end\n        end\n        iterations = iterations + 1\n    until cursor == \"0\" or iterations >= maxIterations\n    return cursor, offset, items, jobs\nend\nlocal key = KEYS[1]\nlocal scanCommand = \"SSCAN\"\nlocal countCommand = \"SCARD\"\nlocal type = rcall(\"TYPE\", key)[\"ok\"]\nif type == \"none\" then\n    return {0, 0, {}, 0}\nelseif type == \"hash\" then\n    scanCommand = \"HSCAN\"\n    countCommand = \"HLEN\"\nelseif type ~= \"set\" then\n    return\n        redis.error_reply(\"Pagination is only supported for sets and hashes.\")\nend\nlocal numItems = rcall(countCommand, key)\nlocal startOffset = tonumber(ARGV[1])\nlocal endOffset = tonumber(ARGV[2])\nif endOffset == -1 then \n  endOffset = numItems\nend\nlocal pageSize = (endOffset - startOffset) + 1\nlocal cursor, offset, items, jobs = findPage(key, scanCommand, startOffset,\n                                       pageSize, ARGV[3], tonumber(ARGV[4]),\n                                       tonumber(ARGV[5]), ARGV[6])\nreturn {cursor, offset, items, numItems, jobs}\n`;\nconst paginate = {\n    name: 'paginate',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=paginate-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGFnaW5hdGUtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGFnaW5hdGUtMS5qcz83YmExIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgIFBhZ2luYXRlIGEgc2V0IG9yIGhhc2hcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0ga2V5IHBvaW50aW5nIHRvIHRoZSBzZXQgb3IgaGFzaCB0byBiZSBwYWdpbmF0ZWQuXG4gICAgICBBUkdWWzFdICBwYWdlIHN0YXJ0IG9mZnNldFxuICAgICAgQVJHVlsyXSAgcGFnZSBlbmQgb2Zmc2V0ICgtMSBmb3IgYWxsIHRoZSBlbGVtZW50cylcbiAgICAgIEFSR1ZbM10gIGN1cnNvclxuICAgICAgQVJHVls0XSAgb2Zmc2V0XG4gICAgICBBUkdWWzVdICBtYXggaXRlcmF0aW9uc1xuICAgICAgQVJHVls2XSAgZmV0Y2ggam9icz9cbiAgICBPdXRwdXQ6XG4gICAgICBbY3Vyc29yLCBvZmZzZXQsIGl0ZW1zLCBudW1JdGVtc11cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFjaGlldmUgcGFnaW5hdGlvbiBmb3IgYSBzZXQgb3IgaGFzaC5cbiAgVGhpcyBmdW5jdGlvbiBzaW11bGF0ZXMgcGFnaW5hdGlvbiBpbiB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHBvc3NpYmxlXG4gIGZvciBhIHNldCB1c2luZyBzc2NhbiBvciBoc2Nhbi5cbiAgVGhlIG1haW4gbGltaXRhdGlvbiBpcyB0aGF0IHNldHMgYXJlIG5vdCBvcmRlciBwcmVzZXJ2aW5nLCBzbyB0aGVcbiAgcGFnaW5hdGlvbiBpcyBub3Qgc3RhYmxlLiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHNldCBpcyBtb2RpZmllZFxuICBiZXR3ZWVuIHBhZ2VzLCB0aGUgc2FtZSBlbGVtZW50IG1heSBhcHBlYXIgaW4gZGlmZmVyZW50IHBhZ2VzLlxuXV0gLS0gTWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcmV0dXJuZWQgYnkgc3NjYW4gcGVyIGl0ZXJhdGlvbi5cbmxvY2FsIG1heENvdW50ID0gMTAwXG4tLSBGaW5kcyB0aGUgY3Vyc29yLCBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudHMgYXZhaWxhYmxlIGZvciB0aGUgcmVxdWVzdGVkIHBhZ2UuXG5sb2NhbCBmdW5jdGlvbiBmaW5kUGFnZShrZXksIGNvbW1hbmQsIHBhZ2VTdGFydCwgcGFnZVNpemUsIGN1cnNvciwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SXRlcmF0aW9ucywgZmV0Y2hKb2JzKVxuICAgIGxvY2FsIGl0ZW1zID0ge31cbiAgICBsb2NhbCBqb2JzID0ge31cbiAgICBsb2NhbCBpdGVyYXRpb25zID0gMFxuICAgIHJlcGVhdFxuICAgICAgICAtLSBJdGVyYXRlIG92ZXIgdGhlIHNldCB1c2luZyBzc2Nhbi9oc2Nhbi5cbiAgICAgICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoY29tbWFuZCwga2V5LCBjdXJzb3IsIFwiQ09VTlRcIiwgbWF4Q291bnQpXG4gICAgICAgIGN1cnNvciA9IHJlc3VsdFsxXVxuICAgICAgICBsb2NhbCBtZW1iZXJzID0gcmVzdWx0WzJdXG4gICAgICAgIGxvY2FsIHN0ZXAgPSAxXG4gICAgICAgIGlmIGNvbW1hbmQgPT0gXCJIU0NBTlwiIHRoZW5cbiAgICAgICAgICAgIHN0ZXAgPSAyXG4gICAgICAgIGVuZFxuICAgICAgICBpZiAjbWVtYmVycyA9PSAwIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSByZXN1bHQgaXMgZW1wdHksIHdlIGNhbiByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnNcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIGNodW5rU3RhcnQgPSBvZmZzZXRcbiAgICAgICAgbG9jYWwgY2h1bmtFbmQgPSBvZmZzZXQgKyAjbWVtYmVycyAvIHN0ZXBcbiAgICAgICAgbG9jYWwgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplXG4gICAgICAgIGlmIGNodW5rRW5kIDwgcGFnZVN0YXJ0IHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBjaHVuayBpcyBiZWZvcmUgdGhlIHBhZ2UsIHdlIGNhbiBza2lwIGl0LlxuICAgICAgICAgICAgb2Zmc2V0ID0gY2h1bmtFbmRcbiAgICAgICAgZWxzZWlmIGNodW5rU3RhcnQgPiBwYWdlRW5kIHRoZW5cbiAgICAgICAgICAgIC0tIElmIHRoZSBjaHVuayBpcyBhZnRlciB0aGUgcGFnZSwgd2UgY2FuIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgcmV0dXJuIGN1cnNvciwgb2Zmc2V0LCBpdGVtcywgam9ic1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBJZiB0aGUgY2h1bmsgaXMgb3ZlcmxhcHBpbmcgdGhlIHBhZ2UsIHdlIG5lZWQgdG8gYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjbWVtYmVycywgc3RlcCBkb1xuICAgICAgICAgICAgICAgIGlmIG9mZnNldCA+PSBwYWdlRW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvciwgb2Zmc2V0LCBpdGVtcywgam9ic1xuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGlmIG9mZnNldCA+PSBwYWdlU3RhcnQgdGhlblxuICAgICAgICAgICAgICAgICAgICBsb2NhbCBpbmRleCA9ICNpdGVtcyArIDFcbiAgICAgICAgICAgICAgICAgICAgaWYgZmV0Y2hKb2JzIH49IG5pbCB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2JzWyNqb2JzKzFdID0gcmNhbGwoXCJIR0VUQUxMXCIsIG1lbWJlcnNbaV0pXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgICAgICBpZiBzdGVwID09IDIgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdID0ge21lbWJlcnNbaV0sIG1lbWJlcnNbaSArIDFdfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBtZW1iZXJzW2ldXG4gICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnMgKyAxXG4gICAgdW50aWwgY3Vyc29yID09IFwiMFwiIG9yIGl0ZXJhdGlvbnMgPj0gbWF4SXRlcmF0aW9uc1xuICAgIHJldHVybiBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnNcbmVuZFxubG9jYWwga2V5ID0gS0VZU1sxXVxubG9jYWwgc2NhbkNvbW1hbmQgPSBcIlNTQ0FOXCJcbmxvY2FsIGNvdW50Q29tbWFuZCA9IFwiU0NBUkRcIlxubG9jYWwgdHlwZSA9IHJjYWxsKFwiVFlQRVwiLCBrZXkpW1wib2tcIl1cbmlmIHR5cGUgPT0gXCJub25lXCIgdGhlblxuICAgIHJldHVybiB7MCwgMCwge30sIDB9XG5lbHNlaWYgdHlwZSA9PSBcImhhc2hcIiB0aGVuXG4gICAgc2NhbkNvbW1hbmQgPSBcIkhTQ0FOXCJcbiAgICBjb3VudENvbW1hbmQgPSBcIkhMRU5cIlxuZWxzZWlmIHR5cGUgfj0gXCJzZXRcIiB0aGVuXG4gICAgcmV0dXJuXG4gICAgICAgIHJlZGlzLmVycm9yX3JlcGx5KFwiUGFnaW5hdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc2V0cyBhbmQgaGFzaGVzLlwiKVxuZW5kXG5sb2NhbCBudW1JdGVtcyA9IHJjYWxsKGNvdW50Q29tbWFuZCwga2V5KVxubG9jYWwgc3RhcnRPZmZzZXQgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgZW5kT2Zmc2V0ID0gdG9udW1iZXIoQVJHVlsyXSlcbmlmIGVuZE9mZnNldCA9PSAtMSB0aGVuIFxuICBlbmRPZmZzZXQgPSBudW1JdGVtc1xuZW5kXG5sb2NhbCBwYWdlU2l6ZSA9IChlbmRPZmZzZXQgLSBzdGFydE9mZnNldCkgKyAxXG5sb2NhbCBjdXJzb3IsIG9mZnNldCwgaXRlbXMsIGpvYnMgPSBmaW5kUGFnZShrZXksIHNjYW5Db21tYW5kLCBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VTaXplLCBBUkdWWzNdLCB0b251bWJlcihBUkdWWzRdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvbnVtYmVyKEFSR1ZbNV0pLCBBUkdWWzZdKVxucmV0dXJuIHtjdXJzb3IsIG9mZnNldCwgaXRlbXMsIG51bUl0ZW1zLCBqb2JzfVxuYDtcbmV4cG9ydCBjb25zdCBwYWdpbmF0ZSA9IHtcbiAgICBuYW1lOiAncGFnaW5hdGUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdpbmF0ZS0xLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/paginate-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/pause-7.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pause: () => (/* binding */ pause)\n/* harmony export */ });\nconst content = `--[[\n  Pauses or resumes a queue globably.\n  Input:\n    KEYS[1] 'wait' or 'paused''\n    KEYS[2] 'paused' or 'wait'\n    KEYS[3] 'meta'\n    KEYS[4] 'prioritized'\n    KEYS[5] events stream key\n    KEYS[6] 'delayed'\n    KEYS|7] 'marker'\n    ARGV[1] 'paused' or 'resumed'\n  Event:\n    publish paused or resumed event.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\nlocal markerKey = KEYS[7]\nlocal hasJobs = rcall(\"EXISTS\", KEYS[1]) == 1\n--TODO: check this logic to be reused when changing a delay\nif hasJobs then rcall(\"RENAME\", KEYS[1], KEYS[2]) end\nif ARGV[1] == \"paused\" then\n    rcall(\"HSET\", KEYS[3], \"paused\", 1)\n    rcall(\"DEL\", markerKey)\nelse\n    rcall(\"HDEL\", KEYS[3], \"paused\")\n    if hasJobs or rcall(\"ZCARD\", KEYS[4]) > 0 then\n        -- Add marker if there are waiting or priority jobs\n        rcall(\"ZADD\", markerKey, 0, \"0\")\n    else\n        addDelayMarkerIfNeeded(markerKey, KEYS[6])\n    end\nend\nrcall(\"XADD\", KEYS[5], \"*\", \"event\", ARGV[1]);\n`;\nconst pause = {\n    name: 'pause',\n    content,\n    keys: 7,\n};\n//# sourceMappingURL=pause-7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcGF1c2UtNy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3BhdXNlLTcuanM/NjcyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUGF1c2VzIG9yIHJlc3VtZXMgYSBxdWV1ZSBnbG9iYWJseS5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAnd2FpdCcgb3IgJ3BhdXNlZCcnXG4gICAgS0VZU1syXSAncGF1c2VkJyBvciAnd2FpdCdcbiAgICBLRVlTWzNdICdtZXRhJ1xuICAgIEtFWVNbNF0gJ3ByaW9yaXRpemVkJ1xuICAgIEtFWVNbNV0gZXZlbnRzIHN0cmVhbSBrZXlcbiAgICBLRVlTWzZdICdkZWxheWVkJ1xuICAgIEtFWVN8N10gJ21hcmtlcidcbiAgICBBUkdWWzFdICdwYXVzZWQnIG9yICdyZXN1bWVkJ1xuICBFdmVudDpcbiAgICBwdWJsaXNoIHBhdXNlZCBvciByZXN1bWVkIGV2ZW50LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIGRlbGF5IG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBuZXh0IGRlbGF5ZWQgam9iIHRpbWVzdGFtcC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlpSQU5HRVwiLCBkZWxheWVkS2V5LCAwLCAwLCBcIldJVEhTQ09SRVNcIilcbiAgaWYgI3Jlc3VsdCB0aGVuXG4gICAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IHRvbnVtYmVyKHJlc3VsdFsyXSlcbiAgICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgICByZXR1cm4gbmV4dFRpbWVzdGFtcCAvIDB4MTAwMFxuICAgIGVuZFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkRGVsYXlNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGRlbGF5ZWRLZXkpXG4gIGxvY2FsIG5leHRUaW1lc3RhbXAgPSBnZXROZXh0RGVsYXllZFRpbWVzdGFtcChkZWxheWVkS2V5KVxuICBpZiBuZXh0VGltZXN0YW1wIH49IG5pbCB0aGVuXG4gICAgLS0gUmVwbGFjZSB0aGUgc2NvcmUgb2YgdGhlIG1hcmtlciB3aXRoIHRoZSBuZXdlc3Qga25vd25cbiAgICAtLSBuZXh0IHRpbWVzdGFtcC5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCBuZXh0VGltZXN0YW1wLCBcIjFcIilcbiAgZW5kXG5lbmRcbmxvY2FsIG1hcmtlcktleSA9IEtFWVNbN11cbmxvY2FsIGhhc0pvYnMgPSByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzFdKSA9PSAxXG4tLVRPRE86IGNoZWNrIHRoaXMgbG9naWMgdG8gYmUgcmV1c2VkIHdoZW4gY2hhbmdpbmcgYSBkZWxheVxuaWYgaGFzSm9icyB0aGVuIHJjYWxsKFwiUkVOQU1FXCIsIEtFWVNbMV0sIEtFWVNbMl0pIGVuZFxuaWYgQVJHVlsxXSA9PSBcInBhdXNlZFwiIHRoZW5cbiAgICByY2FsbChcIkhTRVRcIiwgS0VZU1szXSwgXCJwYXVzZWRcIiwgMSlcbiAgICByY2FsbChcIkRFTFwiLCBtYXJrZXJLZXkpXG5lbHNlXG4gICAgcmNhbGwoXCJIREVMXCIsIEtFWVNbM10sIFwicGF1c2VkXCIpXG4gICAgaWYgaGFzSm9icyBvciByY2FsbChcIlpDQVJEXCIsIEtFWVNbNF0pID4gMCB0aGVuXG4gICAgICAgIC0tIEFkZCBtYXJrZXIgaWYgdGhlcmUgYXJlIHdhaXRpbmcgb3IgcHJpb3JpdHkgam9ic1xuICAgICAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgICBlbHNlXG4gICAgICAgIGFkZERlbGF5TWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBLRVlTWzZdKVxuICAgIGVuZFxuZW5kXG5yY2FsbChcIlhBRERcIiwgS0VZU1s1XSwgXCIqXCIsIFwiZXZlbnRcIiwgQVJHVlsxXSk7XG5gO1xuZXhwb3J0IGNvbnN0IHBhdXNlID0ge1xuICAgIG5hbWU6ICdwYXVzZScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiA3LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdXNlLTcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/pause-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-9.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/promote-9.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   promote: () => (/* binding */ promote)\n/* harmony export */ });\nconst content = `--[[\n  Promotes a job that is currently \"delayed\" to the \"waiting\" state\n    Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'wait'\n      KEYS[3] 'paused'\n      KEYS[4] 'meta'\n      KEYS[5] 'prioritized'\n      KEYS[6] 'active'\n      KEYS[7] 'pc' priority counter\n      KEYS[8] 'event stream'\n      KEYS[9] 'marker'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  jobId\n    Output:\n       0 - OK\n      -3 - Job not in delayed zset.\n    Events:\n      'waiting'\n]]\nlocal rcall = redis.call\nlocal jobId = ARGV[2]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nif rcall(\"ZREM\", KEYS[1], jobId) == 1 then\n    local jobKey = ARGV[1] .. jobId\n    local priority = tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n    local metaKey = KEYS[4]\n    local markerKey = KEYS[9]\n    -- Remove delayed \"marker\" from the wait list if there is any.\n    -- Since we are adding a job we do not need the marker anymore.\n    -- Markers in waitlist DEPRECATED in v5: Remove in v6.\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, KEYS[6], KEYS[2], KEYS[3])\n    local marker = rcall(\"LINDEX\", target, 0)\n    if marker and string.sub(marker, 1, 2) == \"0:\" then rcall(\"LPOP\", target) end\n    if priority == 0 then\n        -- LIFO or FIFO\n        addJobInTargetList(target, markerKey, \"LPUSH\", isPausedOrMaxed, jobId)\n    else\n        addJobWithPriority(markerKey, KEYS[5], priority, jobId, KEYS[7], isPausedOrMaxed)\n    end\n    rcall(\"XADD\", KEYS[8], \"*\", \"event\", \"waiting\", \"jobId\", jobId, \"prev\",\n          \"delayed\");\n    rcall(\"HSET\", jobKey, \"delay\", 0)\n    return 0\nelse\n    return -3\nend\n`;\nconst promote = {\n    name: 'promote',\n    content,\n    keys: 9,\n};\n//# sourceMappingURL=promote-9.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcHJvbW90ZS05LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9wcm9tb3RlLTkuanM/NDYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUHJvbW90ZXMgYSBqb2IgdGhhdCBpcyBjdXJyZW50bHkgXCJkZWxheWVkXCIgdG8gdGhlIFwid2FpdGluZ1wiIHN0YXRlXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdkZWxheWVkJ1xuICAgICAgS0VZU1syXSAnd2FpdCdcbiAgICAgIEtFWVNbM10gJ3BhdXNlZCdcbiAgICAgIEtFWVNbNF0gJ21ldGEnXG4gICAgICBLRVlTWzVdICdwcmlvcml0aXplZCdcbiAgICAgIEtFWVNbNl0gJ2FjdGl2ZSdcbiAgICAgIEtFWVNbN10gJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgICBLRVlTWzhdICdldmVudCBzdHJlYW0nXG4gICAgICBLRVlTWzldICdtYXJrZXInXG4gICAgICBBUkdWWzFdICBxdWV1ZS50b0tleSgnJylcbiAgICAgIEFSR1ZbMl0gIGpvYklkXG4gICAgT3V0cHV0OlxuICAgICAgIDAgLSBPS1xuICAgICAgLTMgLSBKb2Igbm90IGluIGRlbGF5ZWQgenNldC5cbiAgICBFdmVudHM6XG4gICAgICAnd2FpdGluZydcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGpvYklkID0gQVJHVlsyXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgcHJpb3JpdHkgc2NvcmUuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICBsb2NhbCBwcmlvQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJldHVybiBwcmlvcml0eSAqIDB4MTAwMDAwMDAwICsgcHJpb0NvdW50ZXIgJSAweDEwMDAwMDAwMFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXJLZXksXG4gIGlzUGF1c2VkT3JNYXhlZClcbiAgbG9jYWwgc2NvcmUgPSBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxuaWYgcmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIGpvYklkKSA9PSAxIHRoZW5cbiAgICBsb2NhbCBqb2JLZXkgPSBBUkdWWzFdIC4uIGpvYklkXG4gICAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihyY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcInByaW9yaXR5XCIpKSBvciAwXG4gICAgbG9jYWwgbWV0YUtleSA9IEtFWVNbNF1cbiAgICBsb2NhbCBtYXJrZXJLZXkgPSBLRVlTWzldXG4gICAgLS0gUmVtb3ZlIGRlbGF5ZWQgXCJtYXJrZXJcIiBmcm9tIHRoZSB3YWl0IGxpc3QgaWYgdGhlcmUgaXMgYW55LlxuICAgIC0tIFNpbmNlIHdlIGFyZSBhZGRpbmcgYSBqb2Igd2UgZG8gbm90IG5lZWQgdGhlIG1hcmtlciBhbnltb3JlLlxuICAgIC0tIE1hcmtlcnMgaW4gd2FpdGxpc3QgREVQUkVDQVRFRCBpbiB2NTogUmVtb3ZlIGluIHY2LlxuICAgIGxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIEtFWVNbNl0sIEtFWVNbMl0sIEtFWVNbM10pXG4gICAgbG9jYWwgbWFya2VyID0gcmNhbGwoXCJMSU5ERVhcIiwgdGFyZ2V0LCAwKVxuICAgIGlmIG1hcmtlciBhbmQgc3RyaW5nLnN1YihtYXJrZXIsIDEsIDIpID09IFwiMDpcIiB0aGVuIHJjYWxsKFwiTFBPUFwiLCB0YXJnZXQpIGVuZFxuICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgICAtLSBMSUZPIG9yIEZJRk9cbiAgICAgICAgYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldCwgbWFya2VyS2V5LCBcIkxQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBLRVlTWzVdLCBwcmlvcml0eSwgam9iSWQsIEtFWVNbN10sIGlzUGF1c2VkT3JNYXhlZClcbiAgICBlbmRcbiAgICByY2FsbChcIlhBRERcIiwgS0VZU1s4XSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgam9iSWQsIFwicHJldlwiLFxuICAgICAgICAgIFwiZGVsYXllZFwiKTtcbiAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTNcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCBwcm9tb3RlID0ge1xuICAgIG5hbWU6ICdwcm9tb3RlJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbW90ZS05LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/promote-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   releaseLock: () => (/* binding */ releaseLock)\n/* harmony export */ });\nconst content = `--[[\n  Release lock\n    Input:\n      KEYS[1] 'lock',\n      ARGV[1]  token\n      ARGV[2]  lock duration in milliseconds\n    Output:\n      \"OK\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  return rcall(\"DEL\", KEYS[1])\nelse\n  return 0\nend\n`;\nconst releaseLock = {\n    name: 'releaseLock',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=releaseLock-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVsZWFzZUxvY2stMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbGVhc2VMb2NrLTEuanM/ZDNkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVsZWFzZSBsb2NrXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdsb2NrJyxcbiAgICAgIEFSR1ZbMV0gIHRva2VuXG4gICAgICBBUkdWWzJdICBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgIE91dHB1dDpcbiAgICAgIFwiT0tcIiBpZiBsb2NrIGV4dGVudGVkIHN1Y2Nlc2Z1bGx5LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJHRVRcIiwgS0VZU1sxXSkgPT0gQVJHVlsxXSB0aGVuXG4gIHJldHVybiByY2FsbChcIkRFTFwiLCBLRVlTWzFdKVxuZWxzZVxuICByZXR1cm4gMFxuZW5kXG5gO1xuZXhwb3J0IGNvbnN0IHJlbGVhc2VMb2NrID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlTG9jaycsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbGVhc2VMb2NrLTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/releaseLock-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeChildDependency: () => (/* binding */ removeChildDependency)\n/* harmony export */ });\nconst content = `--[[\n  Break parent-child dependency by removing\n  child reference from parent\n  Input:\n    KEYS[1] 'key' prefix,\n    ARGV[1] job key\n    ARGV[2] parent key\n    Output:\n       0  - OK\n       1  - There is not relationship.\n      -1  - Missing job key\n      -5  - Missing parent key\n]]\nlocal rcall = redis.call\nlocal jobKey = ARGV[1]\nlocal parentKey = ARGV[2]\n-- Includes\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nif rcall(\"EXISTS\", jobKey) ~= 1 then return -1 end\nif rcall(\"EXISTS\", parentKey) ~= 1 then return -5 end\nif removeParentDependencyKey(jobKey, false, parentKey, KEYS[1], nil) then\n  rcall(\"HDEL\", jobKey, \"parentKey\", \"parent\")\n  return 0\nelse\n  return 1\nend`;\nconst removeChildDependency = {\n    name: 'removeChildDependency',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=removeChildDependency-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlQ2hpbGREZXBlbmRlbmN5LTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlQ2hpbGREZXBlbmRlbmN5LTEuanM/MjlmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQnJlYWsgcGFyZW50LWNoaWxkIGRlcGVuZGVuY3kgYnkgcmVtb3ZpbmdcbiAgY2hpbGQgcmVmZXJlbmNlIGZyb20gcGFyZW50XG4gIElucHV0OlxuICAgIEtFWVNbMV0gJ2tleScgcHJlZml4LFxuICAgIEFSR1ZbMV0gam9iIGtleVxuICAgIEFSR1ZbMl0gcGFyZW50IGtleVxuICAgIE91dHB1dDpcbiAgICAgICAwICAtIE9LXG4gICAgICAgMSAgLSBUaGVyZSBpcyBub3QgcmVsYXRpb25zaGlwLlxuICAgICAgLTEgIC0gTWlzc2luZyBqb2Iga2V5XG4gICAgICAtNSAgLSBNaXNzaW5nIHBhcmVudCBrZXlcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIGpvYktleSA9IEFSR1ZbMV1cbmxvY2FsIHBhcmVudEtleSA9IEFSR1ZbMl1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIENoZWNrIGlmIHRoaXMgam9iIGhhcyBhIHBhcmVudC4gSWYgc28gd2Ugd2lsbCBqdXN0IHJlbW92ZSBpdCBmcm9tXG4gIHRoZSBwYXJlbnQgY2hpbGQgbGlzdCwgYnV0IGlmIGl0IGlzIHRoZSBsYXN0IGNoaWxkIHdlIHNob3VsZCBtb3ZlIHRoZSBwYXJlbnQgdG8gXCJ3YWl0L3BhdXNlZFwiXG4gIHdoaWNoIHJlcXVpcmVzIGNvZGUgZnJvbSBcIm1vdmVUb0ZpbmlzaGVkXCJcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbnMgdG8gZGVzdHJ1Y3R1cmUgam9iIGtleS5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCB0aGVzZSBmdW5jdGlvbnMgbWF5IGJlIGEgYml0IHNsb3cgYW5kIGFmZmVjdCBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuXV1cbmxvY2FsIGdldEpvYklkRnJvbUtleSA9IGZ1bmN0aW9uIChqb2JLZXkpXG4gIHJldHVybiBzdHJpbmcubWF0Y2goam9iS2V5LCBcIi4qOiguKilcIilcbmVuZFxubG9jYWwgZ2V0Sm9iS2V5UHJlZml4ID0gZnVuY3Rpb24gKGpvYktleSwgam9iSWQpXG4gIHJldHVybiBzdHJpbmcuc3ViKGpvYktleSwgMCwgI2pvYktleSAtICNqb2JJZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgfj0gMSB0aGVuIHJldHVybiAtMSBlbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgfj0gMSB0aGVuIHJldHVybiAtNSBlbmRcbmlmIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBmYWxzZSwgcGFyZW50S2V5LCBLRVlTWzFdLCBuaWwpIHRoZW5cbiAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIiwgXCJwYXJlbnRcIilcbiAgcmV0dXJuIDBcbmVsc2VcbiAgcmV0dXJuIDFcbmVuZGA7XG5leHBvcnQgY29uc3QgcmVtb3ZlQ2hpbGREZXBlbmRlbmN5ID0ge1xuICAgIG5hbWU6ICdyZW1vdmVDaGlsZERlcGVuZGVuY3knLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVDaGlsZERlcGVuZGVuY3ktMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeChildDependency-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-2.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeJob-2.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeJob: () => (/* binding */ removeJob)\n/* harmony export */ });\nconst content = `--[[\n    Remove a job from all the statuses it may be in as well as all its data.\n    In order to be able to remove a job, it cannot be active.\n    Input:\n      KEYS[1] jobKey\n      KEYS[2] repeat key\n      ARGV[1] jobId\n      ARGV[2] remove children\n      ARGV[3] queue prefix\n    Events:\n      'removed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall(\"HGET\", jobKey, \"rjk\")\n  if repeatJobKey  then\n    local prevMillis = rcall(\"ZSCORE\", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = \"repeat:\" .. repeatJobKey .. \":\" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to recursively check if there are no locks\n  on the jobs to be removed.\n  returns:\n    boolean\n]]\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\nlocal function isLocked( prefix, jobId, removeChildren)\n  local jobKey = prefix .. jobId;\n  -- Check if this job is locked\n  local lockKey = jobKey .. ':lock'\n  local lock = rcall(\"GET\", lockKey)\n  if not lock then\n    if removeChildren == \"1\" then\n      local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n      if (#dependencies > 0) then\n        for i, childJobKey in ipairs(dependencies) do\n          -- We need to get the jobId for this job.\n          local childJobId = getJobIdFromKey(childJobKey)\n          local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n          local result = isLocked( childJobPrefix, childJobId, removeChildren )\n          if result then\n            return true\n          end\n        end\n      end\n    end\n    return false\n  end\n  return true\nend\n--[[\n    Remove a job from all the statuses it may be in as well as all its data,\n    including its children. Active children can be ignored.\n    Events:\n      'removed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove from any state.\n  returns:\n    prev state\n]]\nlocal function removeJobFromAnyState( prefix, jobId)\n  -- We start with the ZSCORE checks, since they have O(1) complexity\n  if rcall(\"ZSCORE\", prefix .. \"completed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"completed\", jobId)\n    return \"completed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"waiting-children\", jobId) then\n    rcall(\"ZREM\", prefix .. \"waiting-children\", jobId)\n    return \"waiting-children\"\n  elseif rcall(\"ZSCORE\", prefix .. \"delayed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"delayed\", jobId)\n    return \"delayed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"failed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"failed\", jobId)\n    return \"failed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"prioritized\", jobId) then\n    rcall(\"ZREM\", prefix .. \"prioritized\", jobId)\n    return \"prioritized\"\n  -- We remove only 1 element from the list, since we assume they are not added multiple times\n  elseif rcall(\"LREM\", prefix .. \"wait\", 1, jobId) == 1 then\n    return \"wait\"\n  elseif rcall(\"LREM\", prefix .. \"paused\", 1, jobId) == 1 then\n    return \"paused\"\n  elseif rcall(\"LREM\", prefix .. \"active\", 1, jobId) == 1 then\n    return \"active\"\n  end\n  return \"unknown\"\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\nlocal removeJobChildren\nlocal removeJobWithChildren\nremoveJobChildren = function(prefix, jobKey, options)\n    -- Check if this job has children\n    -- If so, we are going to try to remove the children recursively in a depth-first way\n    -- because if some job is locked, we must exit with an error.\n    if not options.ignoreProcessed then\n        local processed = rcall(\"HGETALL\", jobKey .. \":processed\")\n        if #processed > 0 then\n            for i = 1, #processed, 2 do\n                local childJobId = getJobIdFromKey(processed[i])\n                local childJobPrefix = getJobKeyPrefix(processed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local failed = rcall(\"HGETALL\", jobKey .. \":failed\")\n        if #failed > 0 then\n            for i = 1, #failed, 2 do\n                local childJobId = getJobIdFromKey(failed[i])\n                local childJobPrefix = getJobKeyPrefix(failed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local unsuccessful = rcall(\"ZRANGE\", jobKey .. \":unsuccessful\", 0, -1)\n        if #unsuccessful > 0 then\n            for i = 1, #unsuccessful, 1 do\n                local childJobId = getJobIdFromKey(unsuccessful[i])\n                local childJobPrefix = getJobKeyPrefix(unsuccessful[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n    end\n    local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n    if #dependencies > 0 then\n        for i, childJobKey in ipairs(dependencies) do\n            local childJobId = getJobIdFromKey(childJobKey)\n            local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n            removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n        end\n    end\nend\nremoveJobWithChildren = function(prefix, jobId, parentKey, options)\n    local jobKey = prefix .. jobId\n    if options.ignoreLocked then\n        if isLocked(prefix, jobId) then\n            return\n        end\n    end\n    -- Check if job is in the failed zset\n    local failedSet = prefix .. \"failed\"\n    if not (options.ignoreProcessed and rcall(\"ZSCORE\", failedSet, jobId)) then\n        removeParentDependencyKey(jobKey, false, parentKey, nil)\n        if options.removeChildren then\n            removeJobChildren(prefix, jobKey, options)\n        end\n        local prev = removeJobFromAnyState(prefix, jobId)\n        removeDeduplicationKeyIfNeededOnRemoval(prefix, jobKey, jobId)\n        if removeJobKeys(jobKey) > 0 then\n            local metaKey = prefix .. \"meta\"\n            local maxEvents = getOrSetMaxEvents(metaKey)\n            rcall(\"XADD\", prefix .. \"events\", \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"removed\",\n                \"jobId\", jobId, \"prev\", prev)\n        end\n    end\nend\nlocal jobId = ARGV[1]\nlocal shouldRemoveChildren = ARGV[2]\nlocal prefix = ARGV[3]\nlocal jobKey = KEYS[1]\nlocal repeatKey = KEYS[2]\nif isJobSchedulerJob(jobId, jobKey, repeatKey) then\n    return -8\nend\nif not isLocked(prefix, jobId, shouldRemoveChildren) then\n    local options = {\n        removeChildren = shouldRemoveChildren == \"1\",\n        ignoreProcessed = false,\n        ignoreLocked = false\n    }\n    removeJobWithChildren(prefix, jobId, nil, options)\n    return 1\nend\nreturn 0\n`;\nconst removeJob = {\n    name: 'removeJob',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=removeJob-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlSm9iLTIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9yZW1vdmVKb2ItMi5qcz9kY2M0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgIFJlbW92ZSBhIGpvYiBmcm9tIGFsbCB0aGUgc3RhdHVzZXMgaXQgbWF5IGJlIGluIGFzIHdlbGwgYXMgYWxsIGl0cyBkYXRhLlxuICAgIEluIG9yZGVyIHRvIGJlIGFibGUgdG8gcmVtb3ZlIGEgam9iLCBpdCBjYW5ub3QgYmUgYWN0aXZlLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSBqb2JLZXlcbiAgICAgIEtFWVNbMl0gcmVwZWF0IGtleVxuICAgICAgQVJHVlsxXSBqb2JJZFxuICAgICAgQVJHVlsyXSByZW1vdmUgY2hpbGRyZW5cbiAgICAgIEFSR1ZbM10gcXVldWUgcHJlZml4XG4gICAgRXZlbnRzOlxuICAgICAgJ3JlbW92ZWQnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgam9iIGJlbG9uZ3MgdG8gYSBqb2Igc2NoZWR1bGVyIGFuZFxuICBjdXJyZW50IGRlbGF5ZWQgam9iIG1hdGNoZXMgd2l0aCBqb2JJZFxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzSm9iU2NoZWR1bGVySm9iKGpvYklkLCBqb2JLZXksIGpvYlNjaGVkdWxlcnNLZXkpXG4gIGxvY2FsIHJlcGVhdEpvYktleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicmprXCIpXG4gIGlmIHJlcGVhdEpvYktleSAgdGhlblxuICAgIGxvY2FsIHByZXZNaWxsaXMgPSByY2FsbChcIlpTQ09SRVwiLCBqb2JTY2hlZHVsZXJzS2V5LCByZXBlYXRKb2JLZXkpXG4gICAgaWYgcHJldk1pbGxpcyB0aGVuXG4gICAgICBsb2NhbCBjdXJyZW50RGVsYXllZEpvYklkID0gXCJyZXBlYXQ6XCIgLi4gcmVwZWF0Sm9iS2V5IC4uIFwiOlwiIC4uIHByZXZNaWxsaXNcbiAgICAgIHJldHVybiBqb2JJZCA9PSBjdXJyZW50RGVsYXllZEpvYklkXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZWN1cnNpdmVseSBjaGVjayBpZiB0aGVyZSBhcmUgbm8gbG9ja3NcbiAgb24gdGhlIGpvYnMgdG8gYmUgcmVtb3ZlZC5cbiAgcmV0dXJuczpcbiAgICBib29sZWFuXG5dXVxuLS1bW1xuICBGdW5jdGlvbnMgdG8gZGVzdHJ1Y3R1cmUgam9iIGtleS5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCB0aGVzZSBmdW5jdGlvbnMgbWF5IGJlIGEgYml0IHNsb3cgYW5kIGFmZmVjdCBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuXV1cbmxvY2FsIGdldEpvYklkRnJvbUtleSA9IGZ1bmN0aW9uIChqb2JLZXkpXG4gIHJldHVybiBzdHJpbmcubWF0Y2goam9iS2V5LCBcIi4qOiguKilcIilcbmVuZFxubG9jYWwgZ2V0Sm9iS2V5UHJlZml4ID0gZnVuY3Rpb24gKGpvYktleSwgam9iSWQpXG4gIHJldHVybiBzdHJpbmcuc3ViKGpvYktleSwgMCwgI2pvYktleSAtICNqb2JJZClcbmVuZFxubG9jYWwgZnVuY3Rpb24gaXNMb2NrZWQoIHByZWZpeCwgam9iSWQsIHJlbW92ZUNoaWxkcmVuKVxuICBsb2NhbCBqb2JLZXkgPSBwcmVmaXggLi4gam9iSWQ7XG4gIC0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGxvY2tlZFxuICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgbG9jYWwgbG9jayA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gIGlmIG5vdCBsb2NrIHRoZW5cbiAgICBpZiByZW1vdmVDaGlsZHJlbiA9PSBcIjFcIiB0aGVuXG4gICAgICBsb2NhbCBkZXBlbmRlbmNpZXMgPSByY2FsbChcIlNNRU1CRVJTXCIsIGpvYktleSAuLiBcIjpkZXBlbmRlbmNpZXNcIilcbiAgICAgIGlmICgjZGVwZW5kZW5jaWVzID4gMCkgdGhlblxuICAgICAgICBmb3IgaSwgY2hpbGRKb2JLZXkgaW4gaXBhaXJzKGRlcGVuZGVuY2llcykgZG9cbiAgICAgICAgICAtLSBXZSBuZWVkIHRvIGdldCB0aGUgam9iSWQgZm9yIHRoaXMgam9iLlxuICAgICAgICAgIGxvY2FsIGNoaWxkSm9iSWQgPSBnZXRKb2JJZEZyb21LZXkoY2hpbGRKb2JLZXkpXG4gICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgoY2hpbGRKb2JLZXksIGNoaWxkSm9iSWQpXG4gICAgICAgICAgbG9jYWwgcmVzdWx0ID0gaXNMb2NrZWQoIGNoaWxkSm9iUHJlZml4LCBjaGlsZEpvYklkLCByZW1vdmVDaGlsZHJlbiApXG4gICAgICAgICAgaWYgcmVzdWx0IHRoZW5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG4gIGVuZFxuICByZXR1cm4gdHJ1ZVxuZW5kXG4tLVtbXG4gICAgUmVtb3ZlIGEgam9iIGZyb20gYWxsIHRoZSBzdGF0dXNlcyBpdCBtYXkgYmUgaW4gYXMgd2VsbCBhcyBhbGwgaXRzIGRhdGEsXG4gICAgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbi4gQWN0aXZlIGNoaWxkcmVuIGNhbiBiZSBpZ25vcmVkLlxuICAgIEV2ZW50czpcbiAgICAgICdyZW1vdmVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IG1heCBldmVudHMgdmFsdWUgb3Igc2V0IGJ5IGRlZmF1bHQgMTAwMDAuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0T3JTZXRNYXhFdmVudHMobWV0YUtleSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIilcbiAgaWYgbm90IG1heEV2ZW50cyB0aGVuXG4gICAgbWF4RXZlbnRzID0gMTAwMDBcbiAgICByY2FsbChcIkhTRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiLCBtYXhFdmVudHMpXG4gIGVuZFxuICByZXR1cm4gbWF4RXZlbnRzXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGRlZHVwbGljYXRpb24ga2V5IGlmIG5lZWRlZFxuICB3aGVuIGEgam9iIGlzIGJlaW5nIHJlbW92ZWQuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlRGVkdXBsaWNhdGlvbktleUlmTmVlZGVkT25SZW1vdmFsKHByZWZpeEtleSxcbiAgam9iS2V5LCBqb2JJZClcbiAgbG9jYWwgZGVkdXBsaWNhdGlvbklkID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJkZWlkXCIpXG4gIGlmIGRlZHVwbGljYXRpb25JZCB0aGVuXG4gICAgbG9jYWwgZGVkdXBsaWNhdGlvbktleSA9IHByZWZpeEtleSAuLiBcImRlOlwiIC4uIGRlZHVwbGljYXRpb25JZFxuICAgIGxvY2FsIGN1cnJlbnRKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgIGlmIGN1cnJlbnRKb2JJZCBhbmQgY3VycmVudEpvYklkID09IGpvYklkIHRoZW5cbiAgICAgIHJldHVybiByY2FsbChcIkRFTFwiLCBkZWR1cGxpY2F0aW9uS2V5KVxuICAgIGVuZFxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZnJvbSBhbnkgc3RhdGUuXG4gIHJldHVybnM6XG4gICAgcHJldiBzdGF0ZVxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYkZyb21BbnlTdGF0ZSggcHJlZml4LCBqb2JJZClcbiAgLS0gV2Ugc3RhcnQgd2l0aCB0aGUgWlNDT1JFIGNoZWNrcywgc2luY2UgdGhleSBoYXZlIE8oMSkgY29tcGxleGl0eVxuICBpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJjb21wbGV0ZWRcIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwiY29tcGxldGVkXCIsIGpvYklkKVxuICAgIHJldHVybiBcImNvbXBsZXRlZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIGpvYklkKSB0aGVuXG4gICAgcmNhbGwoXCJaUkVNXCIsIHByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgam9iSWQpXG4gICAgcmV0dXJuIFwid2FpdGluZy1jaGlsZHJlblwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJkZWxheWVkXCIsIGpvYklkKSB0aGVuXG4gICAgcmNhbGwoXCJaUkVNXCIsIHByZWZpeCAuLiBcImRlbGF5ZWRcIiwgam9iSWQpXG4gICAgcmV0dXJuIFwiZGVsYXllZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJmYWlsZWRcIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwiZmFpbGVkXCIsIGpvYklkKVxuICAgIHJldHVybiBcImZhaWxlZFwiXG4gIGVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCBwcmVmaXggLi4gXCJwcmlvcml0aXplZFwiLCBqb2JJZCkgdGhlblxuICAgIHJjYWxsKFwiWlJFTVwiLCBwcmVmaXggLi4gXCJwcmlvcml0aXplZFwiLCBqb2JJZClcbiAgICByZXR1cm4gXCJwcmlvcml0aXplZFwiXG4gIC0tIFdlIHJlbW92ZSBvbmx5IDEgZWxlbWVudCBmcm9tIHRoZSBsaXN0LCBzaW5jZSB3ZSBhc3N1bWUgdGhleSBhcmUgbm90IGFkZGVkIG11bHRpcGxlIHRpbWVzXG4gIGVsc2VpZiByY2FsbChcIkxSRU1cIiwgcHJlZml4IC4uIFwid2FpdFwiLCAxLCBqb2JJZCkgPT0gMSB0aGVuXG4gICAgcmV0dXJuIFwid2FpdFwiXG4gIGVsc2VpZiByY2FsbChcIkxSRU1cIiwgcHJlZml4IC4uIFwicGF1c2VkXCIsIDEsIGpvYklkKSA9PSAxIHRoZW5cbiAgICByZXR1cm4gXCJwYXVzZWRcIlxuICBlbHNlaWYgcmNhbGwoXCJMUkVNXCIsIHByZWZpeCAuLiBcImFjdGl2ZVwiLCAxLCBqb2JJZCkgPT0gMSB0aGVuXG4gICAgcmV0dXJuIFwiYWN0aXZlXCJcbiAgZW5kXG4gIHJldHVybiBcInVua25vd25cIlxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS1bW1xuICBDaGVjayBpZiB0aGlzIGpvYiBoYXMgYSBwYXJlbnQuIElmIHNvIHdlIHdpbGwganVzdCByZW1vdmUgaXQgZnJvbVxuICB0aGUgcGFyZW50IGNoaWxkIGxpc3QsIGJ1dCBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZCB3ZSBzaG91bGQgbW92ZSB0aGUgcGFyZW50IHRvIFwid2FpdC9wYXVzZWRcIlxuICB3aGljaCByZXF1aXJlcyBjb2RlIGZyb20gXCJtb3ZlVG9GaW5pc2hlZFwiXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBpbiB0YXJnZXQgbGlzdCBhbmQgYWRkIG1hcmtlciBpZiBuZWVkZWQuXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgQWRkIG1hcmtlciBpZiBuZWVkZWQgd2hlbiBhIGpvYiBpcyBhdmFpbGFibGUuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuICBpZiBub3QgaXNQYXVzZWRPck1heGVkIHRoZW5cbiAgICByY2FsbChcIlpBRERcIiwgbWFya2VyS2V5LCAwLCBcIjBcIilcbiAgZW5kICBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldEtleSwgbWFya2VyS2V5LCBwdXNoQ21kLCBpc1BhdXNlZE9yTWF4ZWQsIGpvYklkKVxuICByY2FsbChwdXNoQ21kLCB0YXJnZXRLZXksIGpvYklkKVxuICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCBhY3RpdmVLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgbG9jYWwgcXVldWVBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBxdWV1ZU1ldGFLZXksIFwicGF1c2VkXCIsIFwiY29uY3VycmVuY3lcIiwgXCJtYXhcIiwgXCJkdXJhdGlvblwiKVxuICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMV0gdGhlblxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gIGVsc2VcbiAgICBpZiBxdWV1ZUF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgbG9jYWwgYWN0aXZlQ291bnQgPSByY2FsbChcIkxMRU5cIiwgYWN0aXZlS2V5KVxuICAgICAgaWYgYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKSB0aGVuXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbmVuZFxubG9jYWwgZnVuY3Rpb24gX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgZW1pdEV2ZW50KVxuICBsb2NhbCBwYXJlbnRUYXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChwYXJlbnRQcmVmaXggLi4gXCJtZXRhXCIsIHBhcmVudFByZWZpeCAuLiBcImFjdGl2ZVwiLFxuICAgIHBhcmVudFByZWZpeCAuLiBcIndhaXRcIiwgcGFyZW50UHJlZml4IC4uIFwicGF1c2VkXCIpXG4gIGFkZEpvYkluVGFyZ2V0TGlzdChwYXJlbnRUYXJnZXQsIHBhcmVudFByZWZpeCAuLiBcIm1hcmtlclwiLCBcIlJQVVNIXCIsIGlzUGF1c2VkT3JNYXhlZCwgcGFyZW50SWQpXG4gIGlmIGVtaXRFdmVudCB0aGVuXG4gICAgbG9jYWwgcGFyZW50RXZlbnRTdHJlYW0gPSBwYXJlbnRQcmVmaXggLi4gXCJldmVudHNcIlxuICAgIHJjYWxsKFwiWEFERFwiLCBwYXJlbnRFdmVudFN0cmVhbSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgcGFyZW50SWQsIFwicHJldlwiLCBcIndhaXRpbmctY2hpbGRyZW5cIilcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkoam9iS2V5LCBoYXJkLCBwYXJlbnRLZXksIGJhc2VLZXksIGRlYm91bmNlSWQpXG4gIGlmIHBhcmVudEtleSB0aGVuXG4gICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gcGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgbG9jYWwgcmVzdWx0ID0gcmNhbGwoXCJTUkVNXCIsIHBhcmVudERlcGVuZGVuY2llc0tleSwgam9iS2V5KVxuICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgaWYgcGVuZGluZ0RlcGVuZGVuY2llcyA9PSAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkocGFyZW50S2V5KVxuICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJaUkVNXCIsIHBhcmVudFByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgcGFyZW50SWQpXG4gICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICBpZiBoYXJkIHRoZW4gLS0gcmVtb3ZlIHBhcmVudCBpbiBzYW1lIHF1ZXVlXG4gICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkocGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgcmVtb3ZlSm9iS2V5cyhwYXJlbnRLZXkpXG4gICAgICAgICAgICAgIGlmIGRlYm91bmNlSWQgdGhlblxuICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZW5kXG4gIGVsc2VcbiAgICBsb2NhbCBwYXJlbnRBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBqb2JLZXksIFwicGFyZW50S2V5XCIsIFwiZGVpZFwiKVxuICAgIGxvY2FsIG1pc3NlZFBhcmVudEtleSA9IHBhcmVudEF0dHJpYnV0ZXNbMV1cbiAgICBpZiggKHR5cGUobWlzc2VkUGFyZW50S2V5KSA9PSBcInN0cmluZ1wiKSBhbmQgbWlzc2VkUGFyZW50S2V5IH49IFwiXCJcbiAgICAgIGFuZCAocmNhbGwoXCJFWElTVFNcIiwgbWlzc2VkUGFyZW50S2V5KSA9PSAxKSkgdGhlblxuICAgICAgbG9jYWwgcGFyZW50RGVwZW5kZW5jaWVzS2V5ID0gbWlzc2VkUGFyZW50S2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiXG4gICAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgICBpZiByZXN1bHQgPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHJjYWxsKFwiU0NBUkRcIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5KVxuICAgICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICAgIGxvY2FsIHBhcmVudElkID0gZ2V0Sm9iSWRGcm9tS2V5KG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICBsb2NhbCBwYXJlbnRQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgobWlzc2VkUGFyZW50S2V5LCBwYXJlbnRJZClcbiAgICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPT0gMSB0aGVuXG4gICAgICAgICAgICBpZiBoYXJkIHRoZW5cbiAgICAgICAgICAgICAgaWYgcGFyZW50UHJlZml4ID09IGJhc2VLZXkgdGhlblxuICAgICAgICAgICAgICAgIHJlbW92ZVBhcmVudERlcGVuZGVuY3lLZXkobWlzc2VkUGFyZW50S2V5LCBoYXJkLCBuaWwsIGJhc2VLZXksIG5pbClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKG1pc3NlZFBhcmVudEtleSlcbiAgICAgICAgICAgICAgICBpZiBwYXJlbnRBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgICAgICAgICAgICAgIHJjYWxsKFwiREVMXCIsIHBhcmVudFByZWZpeCAuLiBcImRlOlwiIC4uIHBhcmVudEF0dHJpYnV0ZXNbMl0pXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgX21vdmVQYXJlbnRUb1dhaXQocGFyZW50UHJlZml4LCBwYXJlbnRJZCwgdHJ1ZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbmxvY2FsIHJlbW92ZUpvYkNoaWxkcmVuXG5sb2NhbCByZW1vdmVKb2JXaXRoQ2hpbGRyZW5cbnJlbW92ZUpvYkNoaWxkcmVuID0gZnVuY3Rpb24ocHJlZml4LCBqb2JLZXksIG9wdGlvbnMpXG4gICAgLS0gQ2hlY2sgaWYgdGhpcyBqb2IgaGFzIGNoaWxkcmVuXG4gICAgLS0gSWYgc28sIHdlIGFyZSBnb2luZyB0byB0cnkgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiByZWN1cnNpdmVseSBpbiBhIGRlcHRoLWZpcnN0IHdheVxuICAgIC0tIGJlY2F1c2UgaWYgc29tZSBqb2IgaXMgbG9ja2VkLCB3ZSBtdXN0IGV4aXQgd2l0aCBhbiBlcnJvci5cbiAgICBpZiBub3Qgb3B0aW9ucy5pZ25vcmVQcm9jZXNzZWQgdGhlblxuICAgICAgICBsb2NhbCBwcm9jZXNzZWQgPSByY2FsbChcIkhHRVRBTExcIiwgam9iS2V5IC4uIFwiOnByb2Nlc3NlZFwiKVxuICAgICAgICBpZiAjcHJvY2Vzc2VkID4gMCB0aGVuXG4gICAgICAgICAgICBmb3IgaSA9IDEsICNwcm9jZXNzZWQsIDIgZG9cbiAgICAgICAgICAgICAgICBsb2NhbCBjaGlsZEpvYklkID0gZ2V0Sm9iSWRGcm9tS2V5KHByb2Nlc3NlZFtpXSlcbiAgICAgICAgICAgICAgICBsb2NhbCBjaGlsZEpvYlByZWZpeCA9IGdldEpvYktleVByZWZpeChwcm9jZXNzZWRbaV0sIGNoaWxkSm9iSWQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iV2l0aENoaWxkcmVuKGNoaWxkSm9iUHJlZml4LCBjaGlsZEpvYklkLCBqb2JLZXksIG9wdGlvbnMpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIGZhaWxlZCA9IHJjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkgLi4gXCI6ZmFpbGVkXCIpXG4gICAgICAgIGlmICNmYWlsZWQgPiAwIHRoZW5cbiAgICAgICAgICAgIGZvciBpID0gMSwgI2ZhaWxlZCwgMiBkb1xuICAgICAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iSWQgPSBnZXRKb2JJZEZyb21LZXkoZmFpbGVkW2ldKVxuICAgICAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iUHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KGZhaWxlZFtpXSwgY2hpbGRKb2JJZClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JXaXRoQ2hpbGRyZW4oY2hpbGRKb2JQcmVmaXgsIGNoaWxkSm9iSWQsIGpvYktleSwgb3B0aW9ucylcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgbG9jYWwgdW5zdWNjZXNzZnVsID0gcmNhbGwoXCJaUkFOR0VcIiwgam9iS2V5IC4uIFwiOnVuc3VjY2Vzc2Z1bFwiLCAwLCAtMSlcbiAgICAgICAgaWYgI3Vuc3VjY2Vzc2Z1bCA+IDAgdGhlblxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjdW5zdWNjZXNzZnVsLCAxIGRvXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JJZCA9IGdldEpvYklkRnJvbUtleSh1bnN1Y2Nlc3NmdWxbaV0pXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgodW5zdWNjZXNzZnVsW2ldLCBjaGlsZEpvYklkKVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYldpdGhDaGlsZHJlbihjaGlsZEpvYlByZWZpeCwgY2hpbGRKb2JJZCwgam9iS2V5LCBvcHRpb25zKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIGxvY2FsIGRlcGVuZGVuY2llcyA9IHJjYWxsKFwiU01FTUJFUlNcIiwgam9iS2V5IC4uIFwiOmRlcGVuZGVuY2llc1wiKVxuICAgIGlmICNkZXBlbmRlbmNpZXMgPiAwIHRoZW5cbiAgICAgICAgZm9yIGksIGNoaWxkSm9iS2V5IGluIGlwYWlycyhkZXBlbmRlbmNpZXMpIGRvXG4gICAgICAgICAgICBsb2NhbCBjaGlsZEpvYklkID0gZ2V0Sm9iSWRGcm9tS2V5KGNoaWxkSm9iS2V5KVxuICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgoY2hpbGRKb2JLZXksIGNoaWxkSm9iSWQpXG4gICAgICAgICAgICByZW1vdmVKb2JXaXRoQ2hpbGRyZW4oY2hpbGRKb2JQcmVmaXgsIGNoaWxkSm9iSWQsIGpvYktleSwgb3B0aW9ucylcbiAgICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbnJlbW92ZUpvYldpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uKHByZWZpeCwgam9iSWQsIHBhcmVudEtleSwgb3B0aW9ucylcbiAgICBsb2NhbCBqb2JLZXkgPSBwcmVmaXggLi4gam9iSWRcbiAgICBpZiBvcHRpb25zLmlnbm9yZUxvY2tlZCB0aGVuXG4gICAgICAgIGlmIGlzTG9ja2VkKHByZWZpeCwgam9iSWQpIHRoZW5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICAtLSBDaGVjayBpZiBqb2IgaXMgaW4gdGhlIGZhaWxlZCB6c2V0XG4gICAgbG9jYWwgZmFpbGVkU2V0ID0gcHJlZml4IC4uIFwiZmFpbGVkXCJcbiAgICBpZiBub3QgKG9wdGlvbnMuaWdub3JlUHJvY2Vzc2VkIGFuZCByY2FsbChcIlpTQ09SRVwiLCBmYWlsZWRTZXQsIGpvYklkKSkgdGhlblxuICAgICAgICByZW1vdmVQYXJlbnREZXBlbmRlbmN5S2V5KGpvYktleSwgZmFsc2UsIHBhcmVudEtleSwgbmlsKVxuICAgICAgICBpZiBvcHRpb25zLnJlbW92ZUNoaWxkcmVuIHRoZW5cbiAgICAgICAgICAgIHJlbW92ZUpvYkNoaWxkcmVuKHByZWZpeCwgam9iS2V5LCBvcHRpb25zKVxuICAgICAgICBlbmRcbiAgICAgICAgbG9jYWwgcHJldiA9IHJlbW92ZUpvYkZyb21BbnlTdGF0ZShwcmVmaXgsIGpvYklkKVxuICAgICAgICByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4LCBqb2JLZXksIGpvYklkKVxuICAgICAgICBpZiByZW1vdmVKb2JLZXlzKGpvYktleSkgPiAwIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIG1ldGFLZXkgPSBwcmVmaXggLi4gXCJtZXRhXCJcbiAgICAgICAgICAgIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgcHJlZml4IC4uIFwiZXZlbnRzXCIsIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLFxuICAgICAgICAgICAgICAgIFwiam9iSWRcIiwgam9iSWQsIFwicHJldlwiLCBwcmV2KVxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxubG9jYWwgam9iSWQgPSBBUkdWWzFdXG5sb2NhbCBzaG91bGRSZW1vdmVDaGlsZHJlbiA9IEFSR1ZbMl1cbmxvY2FsIHByZWZpeCA9IEFSR1ZbM11cbmxvY2FsIGpvYktleSA9IEtFWVNbMV1cbmxvY2FsIHJlcGVhdEtleSA9IEtFWVNbMl1cbmlmIGlzSm9iU2NoZWR1bGVySm9iKGpvYklkLCBqb2JLZXksIHJlcGVhdEtleSkgdGhlblxuICAgIHJldHVybiAtOFxuZW5kXG5pZiBub3QgaXNMb2NrZWQocHJlZml4LCBqb2JJZCwgc2hvdWxkUmVtb3ZlQ2hpbGRyZW4pIHRoZW5cbiAgICBsb2NhbCBvcHRpb25zID0ge1xuICAgICAgICByZW1vdmVDaGlsZHJlbiA9IHNob3VsZFJlbW92ZUNoaWxkcmVuID09IFwiMVwiLFxuICAgICAgICBpZ25vcmVQcm9jZXNzZWQgPSBmYWxzZSxcbiAgICAgICAgaWdub3JlTG9ja2VkID0gZmFsc2VcbiAgICB9XG4gICAgcmVtb3ZlSm9iV2l0aENoaWxkcmVuKHByZWZpeCwgam9iSWQsIG5pbCwgb3B0aW9ucylcbiAgICByZXR1cm4gMVxuZW5kXG5yZXR1cm4gMFxuYDtcbmV4cG9ydCBjb25zdCByZW1vdmVKb2IgPSB7XG4gICAgbmFtZTogJ3JlbW92ZUpvYicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZUpvYi0yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJob-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJobScheduler-3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeJobScheduler-3.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeJobScheduler: () => (/* binding */ removeJobScheduler)\n/* harmony export */ });\nconst content = `--[[\n  Removes a job scheduler and its next scheduled job.\n  Input:\n    KEYS[1] job schedulers key\n    KEYS[2] delayed jobs key\n    KEYS[3] events key\n    ARGV[1] job scheduler id\n    ARGV[2] prefix key\n  Output:\n    0 - OK\n    1 - Missing repeat job\n  Events:\n    'removed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\nlocal jobSchedulerId = ARGV[1]\nlocal prefix = ARGV[2]\nlocal millis = rcall(\"ZSCORE\", KEYS[1], jobSchedulerId)\nif millis then\n  -- Delete next programmed job.\n  local delayedJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. millis\n  if(rcall(\"ZREM\", KEYS[2], delayedJobId) == 1) then\n    removeJobKeys(prefix .. delayedJobId)\n    rcall(\"XADD\", KEYS[3], \"*\", \"event\", \"removed\", \"jobId\", delayedJobId, \"prev\", \"delayed\")\n  end\nend\nif(rcall(\"ZREM\", KEYS[1], jobSchedulerId) == 1) then\n  rcall(\"DEL\", KEYS[1] .. \":\" .. jobSchedulerId)\n  return 0\nend\nreturn 1\n`;\nconst removeJobScheduler = {\n    name: 'removeJobScheduler',\n    content,\n    keys: 3,\n};\n//# sourceMappingURL=removeJobScheduler-3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlSm9iU2NoZWR1bGVyLTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9yZW1vdmVKb2JTY2hlZHVsZXItMy5qcz84YzMxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZW1vdmVzIGEgam9iIHNjaGVkdWxlciBhbmQgaXRzIG5leHQgc2NoZWR1bGVkIGpvYi5cbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2Igc2NoZWR1bGVycyBrZXlcbiAgICBLRVlTWzJdIGRlbGF5ZWQgam9icyBrZXlcbiAgICBLRVlTWzNdIGV2ZW50cyBrZXlcbiAgICBBUkdWWzFdIGpvYiBzY2hlZHVsZXIgaWRcbiAgICBBUkdWWzJdIHByZWZpeCBrZXlcbiAgT3V0cHV0OlxuICAgIDAgLSBPS1xuICAgIDEgLSBNaXNzaW5nIHJlcGVhdCBqb2JcbiAgRXZlbnRzOlxuICAgICdyZW1vdmVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYiBrZXlzLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYktleXMoam9iS2V5KVxuICByZXR1cm4gcmNhbGwoXCJERUxcIiwgam9iS2V5LCBqb2JLZXkgLi4gJzpsb2dzJywgam9iS2V5IC4uICc6ZGVwZW5kZW5jaWVzJyxcbiAgICBqb2JLZXkgLi4gJzpwcm9jZXNzZWQnLCBqb2JLZXkgLi4gJzpmYWlsZWQnLCBqb2JLZXkgLi4gJzp1bnN1Y2Nlc3NmdWwnKVxuZW5kXG5sb2NhbCBqb2JTY2hlZHVsZXJJZCA9IEFSR1ZbMV1cbmxvY2FsIHByZWZpeCA9IEFSR1ZbMl1cbmxvY2FsIG1pbGxpcyA9IHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMV0sIGpvYlNjaGVkdWxlcklkKVxuaWYgbWlsbGlzIHRoZW5cbiAgLS0gRGVsZXRlIG5leHQgcHJvZ3JhbW1lZCBqb2IuXG4gIGxvY2FsIGRlbGF5ZWRKb2JJZCA9IFwicmVwZWF0OlwiIC4uIGpvYlNjaGVkdWxlcklkIC4uIFwiOlwiIC4uIG1pbGxpc1xuICBpZihyY2FsbChcIlpSRU1cIiwgS0VZU1syXSwgZGVsYXllZEpvYklkKSA9PSAxKSB0aGVuXG4gICAgcmVtb3ZlSm9iS2V5cyhwcmVmaXggLi4gZGVsYXllZEpvYklkKVxuICAgIHJjYWxsKFwiWEFERFwiLCBLRVlTWzNdLCBcIipcIiwgXCJldmVudFwiLCBcInJlbW92ZWRcIiwgXCJqb2JJZFwiLCBkZWxheWVkSm9iSWQsIFwicHJldlwiLCBcImRlbGF5ZWRcIilcbiAgZW5kXG5lbmRcbmlmKHJjYWxsKFwiWlJFTVwiLCBLRVlTWzFdLCBqb2JTY2hlZHVsZXJJZCkgPT0gMSkgdGhlblxuICByY2FsbChcIkRFTFwiLCBLRVlTWzFdIC4uIFwiOlwiIC4uIGpvYlNjaGVkdWxlcklkKVxuICByZXR1cm4gMFxuZW5kXG5yZXR1cm4gMVxuYDtcbmV4cG9ydCBjb25zdCByZW1vdmVKb2JTY2hlZHVsZXIgPSB7XG4gICAgbmFtZTogJ3JlbW92ZUpvYlNjaGVkdWxlcicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAzLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZUpvYlNjaGVkdWxlci0zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeJobScheduler-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-3.js":
/*!********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeRepeatable-3.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeRepeatable: () => (/* binding */ removeRepeatable)\n/* harmony export */ });\nconst content = `--[[\n  Removes a repeatable job\n  Input:\n    KEYS[1] repeat jobs key\n    KEYS[2] delayed jobs key\n    KEYS[3] events key\n    ARGV[1] old repeat job id\n    ARGV[2] options concat\n    ARGV[3] repeat job key\n    ARGV[4] prefix key\n  Output:\n    0 - OK\n    1 - Missing repeat job\n  Events:\n    'removed'\n]]\nlocal rcall = redis.call\nlocal millis = rcall(\"ZSCORE\", KEYS[1], ARGV[2])\n-- Includes\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n-- legacy removal TODO: remove in next breaking change\nif millis then\n  -- Delete next programmed job.\n  local repeatJobId = ARGV[1] .. millis\n  if(rcall(\"ZREM\", KEYS[2], repeatJobId) == 1) then\n    removeJobKeys(ARGV[4] .. repeatJobId)\n    rcall(\"XADD\", KEYS[3], \"*\", \"event\", \"removed\", \"jobId\", repeatJobId, \"prev\", \"delayed\");\n  end\nend\nif(rcall(\"ZREM\", KEYS[1], ARGV[2]) == 1) then\n  return 0\nend\n-- new removal\nmillis = rcall(\"ZSCORE\", KEYS[1], ARGV[3])\nif millis then\n  -- Delete next programmed job.\n  local repeatJobId = \"repeat:\" .. ARGV[3] .. \":\" .. millis\n  if(rcall(\"ZREM\", KEYS[2], repeatJobId) == 1) then\n    removeJobKeys(ARGV[4] .. repeatJobId)\n    rcall(\"XADD\", KEYS[3], \"*\", \"event\", \"removed\", \"jobId\", repeatJobId, \"prev\", \"delayed\")\n  end\nend\nif(rcall(\"ZREM\", KEYS[1], ARGV[3]) == 1) then\n  rcall(\"DEL\", KEYS[1] .. \":\" .. ARGV[3])\n  return 0\nend\nreturn 1\n`;\nconst removeRepeatable = {\n    name: 'removeRepeatable',\n    content,\n    keys: 3,\n};\n//# sourceMappingURL=removeRepeatable-3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlUmVwZWF0YWJsZS0zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbW92ZVJlcGVhdGFibGUtMy5qcz8xYjBmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZW1vdmVzIGEgcmVwZWF0YWJsZSBqb2JcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSByZXBlYXQgam9icyBrZXlcbiAgICBLRVlTWzJdIGRlbGF5ZWQgam9icyBrZXlcbiAgICBLRVlTWzNdIGV2ZW50cyBrZXlcbiAgICBBUkdWWzFdIG9sZCByZXBlYXQgam9iIGlkXG4gICAgQVJHVlsyXSBvcHRpb25zIGNvbmNhdFxuICAgIEFSR1ZbM10gcmVwZWF0IGpvYiBrZXlcbiAgICBBUkdWWzRdIHByZWZpeCBrZXlcbiAgT3V0cHV0OlxuICAgIDAgLSBPS1xuICAgIDEgLSBNaXNzaW5nIHJlcGVhdCBqb2JcbiAgRXZlbnRzOlxuICAgICdyZW1vdmVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgbWlsbGlzID0gcmNhbGwoXCJaU0NPUkVcIiwgS0VZU1sxXSwgQVJHVlsyXSlcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBqb2Iga2V5cy5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JLZXlzKGpvYktleSlcbiAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycsIGpvYktleSAuLiAnOmRlcGVuZGVuY2llcycsXG4gICAgam9iS2V5IC4uICc6cHJvY2Vzc2VkJywgam9iS2V5IC4uICc6ZmFpbGVkJywgam9iS2V5IC4uICc6dW5zdWNjZXNzZnVsJylcbmVuZFxuLS0gbGVnYWN5IHJlbW92YWwgVE9ETzogcmVtb3ZlIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG5pZiBtaWxsaXMgdGhlblxuICAtLSBEZWxldGUgbmV4dCBwcm9ncmFtbWVkIGpvYi5cbiAgbG9jYWwgcmVwZWF0Sm9iSWQgPSBBUkdWWzFdIC4uIG1pbGxpc1xuICBpZihyY2FsbChcIlpSRU1cIiwgS0VZU1syXSwgcmVwZWF0Sm9iSWQpID09IDEpIHRoZW5cbiAgICByZW1vdmVKb2JLZXlzKEFSR1ZbNF0gLi4gcmVwZWF0Sm9iSWQpXG4gICAgcmNhbGwoXCJYQUREXCIsIEtFWVNbM10sIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLCBcImpvYklkXCIsIHJlcGVhdEpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpO1xuICBlbmRcbmVuZFxuaWYocmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIEFSR1ZbMl0pID09IDEpIHRoZW5cbiAgcmV0dXJuIDBcbmVuZFxuLS0gbmV3IHJlbW92YWxcbm1pbGxpcyA9IHJjYWxsKFwiWlNDT1JFXCIsIEtFWVNbMV0sIEFSR1ZbM10pXG5pZiBtaWxsaXMgdGhlblxuICAtLSBEZWxldGUgbmV4dCBwcm9ncmFtbWVkIGpvYi5cbiAgbG9jYWwgcmVwZWF0Sm9iSWQgPSBcInJlcGVhdDpcIiAuLiBBUkdWWzNdIC4uIFwiOlwiIC4uIG1pbGxpc1xuICBpZihyY2FsbChcIlpSRU1cIiwgS0VZU1syXSwgcmVwZWF0Sm9iSWQpID09IDEpIHRoZW5cbiAgICByZW1vdmVKb2JLZXlzKEFSR1ZbNF0gLi4gcmVwZWF0Sm9iSWQpXG4gICAgcmNhbGwoXCJYQUREXCIsIEtFWVNbM10sIFwiKlwiLCBcImV2ZW50XCIsIFwicmVtb3ZlZFwiLCBcImpvYklkXCIsIHJlcGVhdEpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gIGVuZFxuZW5kXG5pZihyY2FsbChcIlpSRU1cIiwgS0VZU1sxXSwgQVJHVlszXSkgPT0gMSkgdGhlblxuICByY2FsbChcIkRFTFwiLCBLRVlTWzFdIC4uIFwiOlwiIC4uIEFSR1ZbM10pXG4gIHJldHVybiAwXG5lbmRcbnJldHVybiAxXG5gO1xuZXhwb3J0IGNvbnN0IHJlbW92ZVJlcGVhdGFibGUgPSB7XG4gICAgbmFtZTogJ3JlbW92ZVJlcGVhdGFibGUnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVSZXBlYXRhYmxlLTMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeRepeatable-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/removeUnprocessedChildren-2.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/removeUnprocessedChildren-2.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeUnprocessedChildren: () => (/* binding */ removeUnprocessedChildren)\n/* harmony export */ });\nconst content = `--[[\n    Remove a job from all the statuses it may be in as well as all its data.\n    In order to be able to remove a job, it cannot be active.\n    Input:\n      KEYS[1] jobKey\n      KEYS[2] meta key\n      ARGV[1] prefix\n      ARGV[2] jobId\n    Events:\n      'removed' for every children removed\n]]\n-- Includes\n--[[\n    Remove a job from all the statuses it may be in as well as all its data,\n    including its children. Active children can be ignored.\n    Events:\n      'removed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to destructure job key.\n  Just a bit of warning, these functions may be a bit slow and affect performance significantly.\n]]\nlocal getJobIdFromKey = function (jobKey)\n  return string.match(jobKey, \".*:(.*)\")\nend\nlocal getJobKeyPrefix = function (jobKey, jobId)\n  return string.sub(jobKey, 0, #jobKey - #jobId)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check if the job belongs to a job scheduler and\n  current delayed job matches with jobId\n]]\nlocal function isJobSchedulerJob(jobId, jobKey, jobSchedulersKey)\n  local repeatJobKey = rcall(\"HGET\", jobKey, \"rjk\")\n  if repeatJobKey  then\n    local prevMillis = rcall(\"ZSCORE\", jobSchedulersKey, repeatJobKey)\n    if prevMillis then\n      local currentDelayedJobId = \"repeat:\" .. repeatJobKey .. \":\" .. prevMillis\n      return jobId == currentDelayedJobId\n    end\n  end\n  return false\nend\n--[[\n  Function to remove deduplication key if needed\n  when a job is being removed.\n]]\nlocal function removeDeduplicationKeyIfNeededOnRemoval(prefixKey,\n  jobKey, jobId)\n  local deduplicationId = rcall(\"HGET\", jobKey, \"deid\")\n  if deduplicationId then\n    local deduplicationKey = prefixKey .. \"de:\" .. deduplicationId\n    local currentJobId = rcall('GET', deduplicationKey)\n    if currentJobId and currentJobId == jobId then\n      return rcall(\"DEL\", deduplicationKey)\n    end\n  end\nend\n--[[\n  Function to remove from any state.\n  returns:\n    prev state\n]]\nlocal function removeJobFromAnyState( prefix, jobId)\n  -- We start with the ZSCORE checks, since they have O(1) complexity\n  if rcall(\"ZSCORE\", prefix .. \"completed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"completed\", jobId)\n    return \"completed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"waiting-children\", jobId) then\n    rcall(\"ZREM\", prefix .. \"waiting-children\", jobId)\n    return \"waiting-children\"\n  elseif rcall(\"ZSCORE\", prefix .. \"delayed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"delayed\", jobId)\n    return \"delayed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"failed\", jobId) then\n    rcall(\"ZREM\", prefix .. \"failed\", jobId)\n    return \"failed\"\n  elseif rcall(\"ZSCORE\", prefix .. \"prioritized\", jobId) then\n    rcall(\"ZREM\", prefix .. \"prioritized\", jobId)\n    return \"prioritized\"\n  -- We remove only 1 element from the list, since we assume they are not added multiple times\n  elseif rcall(\"LREM\", prefix .. \"wait\", 1, jobId) == 1 then\n    return \"wait\"\n  elseif rcall(\"LREM\", prefix .. \"paused\", 1, jobId) == 1 then\n    return \"paused\"\n  elseif rcall(\"LREM\", prefix .. \"active\", 1, jobId) == 1 then\n    return \"active\"\n  end\n  return \"unknown\"\nend\n--[[\n  Function to remove job keys.\n]]\nlocal function removeJobKeys(jobKey)\n  return rcall(\"DEL\", jobKey, jobKey .. ':logs', jobKey .. ':dependencies',\n    jobKey .. ':processed', jobKey .. ':failed', jobKey .. ':unsuccessful')\nend\n--[[\n  Check if this job has a parent. If so we will just remove it from\n  the parent child list, but if it is the last child we should move the parent to \"wait/paused\"\n  which requires code from \"moveToFinished\"\n]]\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal function _moveParentToWait(parentPrefix, parentId, emitEvent)\n  local parentTarget, isPausedOrMaxed = getTargetQueueList(parentPrefix .. \"meta\", parentPrefix .. \"active\",\n    parentPrefix .. \"wait\", parentPrefix .. \"paused\")\n  addJobInTargetList(parentTarget, parentPrefix .. \"marker\", \"RPUSH\", isPausedOrMaxed, parentId)\n  if emitEvent then\n    local parentEventStream = parentPrefix .. \"events\"\n    rcall(\"XADD\", parentEventStream, \"*\", \"event\", \"waiting\", \"jobId\", parentId, \"prev\", \"waiting-children\")\n  end\nend\nlocal function removeParentDependencyKey(jobKey, hard, parentKey, baseKey, debounceId)\n  if parentKey then\n    local parentDependenciesKey = parentKey .. \":dependencies\"\n    local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n    if result > 0 then\n      local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n      if pendingDependencies == 0 then\n        local parentId = getJobIdFromKey(parentKey)\n        local parentPrefix = getJobKeyPrefix(parentKey, parentId)\n        local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n        if numRemovedElements == 1 then\n          if hard then -- remove parent in same queue\n            if parentPrefix == baseKey then\n              removeParentDependencyKey(parentKey, hard, nil, baseKey, nil)\n              removeJobKeys(parentKey)\n              if debounceId then\n                rcall(\"DEL\", parentPrefix .. \"de:\" .. debounceId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId)\n            end\n          else\n            _moveParentToWait(parentPrefix, parentId, true)\n          end\n        end\n      end\n      return true\n    end\n  else\n    local parentAttributes = rcall(\"HMGET\", jobKey, \"parentKey\", \"deid\")\n    local missedParentKey = parentAttributes[1]\n    if( (type(missedParentKey) == \"string\") and missedParentKey ~= \"\"\n      and (rcall(\"EXISTS\", missedParentKey) == 1)) then\n      local parentDependenciesKey = missedParentKey .. \":dependencies\"\n      local result = rcall(\"SREM\", parentDependenciesKey, jobKey)\n      if result > 0 then\n        local pendingDependencies = rcall(\"SCARD\", parentDependenciesKey)\n        if pendingDependencies == 0 then\n          local parentId = getJobIdFromKey(missedParentKey)\n          local parentPrefix = getJobKeyPrefix(missedParentKey, parentId)\n          local numRemovedElements = rcall(\"ZREM\", parentPrefix .. \"waiting-children\", parentId)\n          if numRemovedElements == 1 then\n            if hard then\n              if parentPrefix == baseKey then\n                removeParentDependencyKey(missedParentKey, hard, nil, baseKey, nil)\n                removeJobKeys(missedParentKey)\n                if parentAttributes[2] then\n                  rcall(\"DEL\", parentPrefix .. \"de:\" .. parentAttributes[2])\n                end\n              else\n                _moveParentToWait(parentPrefix, parentId)\n              end\n            else\n              _moveParentToWait(parentPrefix, parentId, true)\n            end\n          end\n        end\n        return true\n      end\n    end\n  end\n  return false\nend\n--[[\n  Function to recursively check if there are no locks\n  on the jobs to be removed.\n  returns:\n    boolean\n]]\nlocal function isLocked( prefix, jobId, removeChildren)\n  local jobKey = prefix .. jobId;\n  -- Check if this job is locked\n  local lockKey = jobKey .. ':lock'\n  local lock = rcall(\"GET\", lockKey)\n  if not lock then\n    if removeChildren == \"1\" then\n      local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n      if (#dependencies > 0) then\n        for i, childJobKey in ipairs(dependencies) do\n          -- We need to get the jobId for this job.\n          local childJobId = getJobIdFromKey(childJobKey)\n          local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n          local result = isLocked( childJobPrefix, childJobId, removeChildren )\n          if result then\n            return true\n          end\n        end\n      end\n    end\n    return false\n  end\n  return true\nend\nlocal removeJobChildren\nlocal removeJobWithChildren\nremoveJobChildren = function(prefix, jobKey, options)\n    -- Check if this job has children\n    -- If so, we are going to try to remove the children recursively in a depth-first way\n    -- because if some job is locked, we must exit with an error.\n    if not options.ignoreProcessed then\n        local processed = rcall(\"HGETALL\", jobKey .. \":processed\")\n        if #processed > 0 then\n            for i = 1, #processed, 2 do\n                local childJobId = getJobIdFromKey(processed[i])\n                local childJobPrefix = getJobKeyPrefix(processed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local failed = rcall(\"HGETALL\", jobKey .. \":failed\")\n        if #failed > 0 then\n            for i = 1, #failed, 2 do\n                local childJobId = getJobIdFromKey(failed[i])\n                local childJobPrefix = getJobKeyPrefix(failed[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n        local unsuccessful = rcall(\"ZRANGE\", jobKey .. \":unsuccessful\", 0, -1)\n        if #unsuccessful > 0 then\n            for i = 1, #unsuccessful, 1 do\n                local childJobId = getJobIdFromKey(unsuccessful[i])\n                local childJobPrefix = getJobKeyPrefix(unsuccessful[i], childJobId)\n                removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n            end\n        end\n    end\n    local dependencies = rcall(\"SMEMBERS\", jobKey .. \":dependencies\")\n    if #dependencies > 0 then\n        for i, childJobKey in ipairs(dependencies) do\n            local childJobId = getJobIdFromKey(childJobKey)\n            local childJobPrefix = getJobKeyPrefix(childJobKey, childJobId)\n            removeJobWithChildren(childJobPrefix, childJobId, jobKey, options)\n        end\n    end\nend\nremoveJobWithChildren = function(prefix, jobId, parentKey, options)\n    local jobKey = prefix .. jobId\n    if options.ignoreLocked then\n        if isLocked(prefix, jobId) then\n            return\n        end\n    end\n    -- Check if job is in the failed zset\n    local failedSet = prefix .. \"failed\"\n    if not (options.ignoreProcessed and rcall(\"ZSCORE\", failedSet, jobId)) then\n        removeParentDependencyKey(jobKey, false, parentKey, nil)\n        if options.removeChildren then\n            removeJobChildren(prefix, jobKey, options)\n        end\n        local prev = removeJobFromAnyState(prefix, jobId)\n        removeDeduplicationKeyIfNeededOnRemoval(prefix, jobKey, jobId)\n        if removeJobKeys(jobKey) > 0 then\n            local metaKey = prefix .. \"meta\"\n            local maxEvents = getOrSetMaxEvents(metaKey)\n            rcall(\"XADD\", prefix .. \"events\", \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"removed\",\n                \"jobId\", jobId, \"prev\", prev)\n        end\n    end\nend\nlocal prefix = ARGV[1]\nlocal jobId = ARGV[2]\nlocal jobKey = KEYS[1]\nlocal metaKey = KEYS[2]\nlocal options = {\n  removeChildren = \"1\",\n  ignoreProcessed = true,\n  ignoreLocked = true\n}\nremoveJobChildren(prefix, jobKey, options) \n`;\nconst removeUnprocessedChildren = {\n    name: 'removeUnprocessedChildren',\n    content,\n    keys: 2,\n};\n//# sourceMappingURL=removeUnprocessedChildren-2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbi0yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlbW92ZVVucHJvY2Vzc2VkQ2hpbGRyZW4tMi5qcz9hNTE4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgIFJlbW92ZSBhIGpvYiBmcm9tIGFsbCB0aGUgc3RhdHVzZXMgaXQgbWF5IGJlIGluIGFzIHdlbGwgYXMgYWxsIGl0cyBkYXRhLlxuICAgIEluIG9yZGVyIHRvIGJlIGFibGUgdG8gcmVtb3ZlIGEgam9iLCBpdCBjYW5ub3QgYmUgYWN0aXZlLlxuICAgIElucHV0OlxuICAgICAgS0VZU1sxXSBqb2JLZXlcbiAgICAgIEtFWVNbMl0gbWV0YSBrZXlcbiAgICAgIEFSR1ZbMV0gcHJlZml4XG4gICAgICBBUkdWWzJdIGpvYklkXG4gICAgRXZlbnRzOlxuICAgICAgJ3JlbW92ZWQnIGZvciBldmVyeSBjaGlsZHJlbiByZW1vdmVkXG5dXVxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgICBSZW1vdmUgYSBqb2IgZnJvbSBhbGwgdGhlIHN0YXR1c2VzIGl0IG1heSBiZSBpbiBhcyB3ZWxsIGFzIGFsbCBpdHMgZGF0YSxcbiAgICBpbmNsdWRpbmcgaXRzIGNoaWxkcmVuLiBBY3RpdmUgY2hpbGRyZW4gY2FuIGJlIGlnbm9yZWQuXG4gICAgRXZlbnRzOlxuICAgICAgJ3JlbW92ZWQnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gZGVzdHJ1Y3R1cmUgam9iIGtleS5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCB0aGVzZSBmdW5jdGlvbnMgbWF5IGJlIGEgYml0IHNsb3cgYW5kIGFmZmVjdCBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuXV1cbmxvY2FsIGdldEpvYklkRnJvbUtleSA9IGZ1bmN0aW9uIChqb2JLZXkpXG4gIHJldHVybiBzdHJpbmcubWF0Y2goam9iS2V5LCBcIi4qOiguKilcIilcbmVuZFxubG9jYWwgZ2V0Sm9iS2V5UHJlZml4ID0gZnVuY3Rpb24gKGpvYktleSwgam9iSWQpXG4gIHJldHVybiBzdHJpbmcuc3ViKGpvYktleSwgMCwgI2pvYktleSAtICNqb2JJZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgam9iIGJlbG9uZ3MgdG8gYSBqb2Igc2NoZWR1bGVyIGFuZFxuICBjdXJyZW50IGRlbGF5ZWQgam9iIG1hdGNoZXMgd2l0aCBqb2JJZFxuXV1cbmxvY2FsIGZ1bmN0aW9uIGlzSm9iU2NoZWR1bGVySm9iKGpvYklkLCBqb2JLZXksIGpvYlNjaGVkdWxlcnNLZXkpXG4gIGxvY2FsIHJlcGVhdEpvYktleSA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicmprXCIpXG4gIGlmIHJlcGVhdEpvYktleSAgdGhlblxuICAgIGxvY2FsIHByZXZNaWxsaXMgPSByY2FsbChcIlpTQ09SRVwiLCBqb2JTY2hlZHVsZXJzS2V5LCByZXBlYXRKb2JLZXkpXG4gICAgaWYgcHJldk1pbGxpcyB0aGVuXG4gICAgICBsb2NhbCBjdXJyZW50RGVsYXllZEpvYklkID0gXCJyZXBlYXQ6XCIgLi4gcmVwZWF0Sm9iS2V5IC4uIFwiOlwiIC4uIHByZXZNaWxsaXNcbiAgICAgIHJldHVybiBqb2JJZCA9PSBjdXJyZW50RGVsYXllZEpvYklkXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVkdXBsaWNhdGlvbiBrZXkgaWYgbmVlZGVkXG4gIHdoZW4gYSBqb2IgaXMgYmVpbmcgcmVtb3ZlZC5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWR1cGxpY2F0aW9uS2V5SWZOZWVkZWRPblJlbW92YWwocHJlZml4S2V5LFxuICBqb2JLZXksIGpvYklkKVxuICBsb2NhbCBkZWR1cGxpY2F0aW9uSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVkdXBsaWNhdGlvbklkIHRoZW5cbiAgICBsb2NhbCBkZWR1cGxpY2F0aW9uS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVkdXBsaWNhdGlvbklkXG4gICAgbG9jYWwgY3VycmVudEpvYklkID0gcmNhbGwoJ0dFVCcsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgaWYgY3VycmVudEpvYklkIGFuZCBjdXJyZW50Sm9iSWQgPT0gam9iSWQgdGhlblxuICAgICAgcmV0dXJuIHJjYWxsKFwiREVMXCIsIGRlZHVwbGljYXRpb25LZXkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIGFueSBzdGF0ZS5cbiAgcmV0dXJuczpcbiAgICBwcmV2IHN0YXRlXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iRnJvbUFueVN0YXRlKCBwcmVmaXgsIGpvYklkKVxuICAtLSBXZSBzdGFydCB3aXRoIHRoZSBaU0NPUkUgY2hlY2tzLCBzaW5jZSB0aGV5IGhhdmUgTygxKSBjb21wbGV4aXR5XG4gIGlmIHJjYWxsKFwiWlNDT1JFXCIsIHByZWZpeCAuLiBcImNvbXBsZXRlZFwiLCBqb2JJZCkgdGhlblxuICAgIHJjYWxsKFwiWlJFTVwiLCBwcmVmaXggLi4gXCJjb21wbGV0ZWRcIiwgam9iSWQpXG4gICAgcmV0dXJuIFwiY29tcGxldGVkXCJcbiAgZWxzZWlmIHJjYWxsKFwiWlNDT1JFXCIsIHByZWZpeCAuLiBcIndhaXRpbmctY2hpbGRyZW5cIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBqb2JJZClcbiAgICByZXR1cm4gXCJ3YWl0aW5nLWNoaWxkcmVuXCJcbiAgZWxzZWlmIHJjYWxsKFwiWlNDT1JFXCIsIHByZWZpeCAuLiBcImRlbGF5ZWRcIiwgam9iSWQpIHRoZW5cbiAgICByY2FsbChcIlpSRU1cIiwgcHJlZml4IC4uIFwiZGVsYXllZFwiLCBqb2JJZClcbiAgICByZXR1cm4gXCJkZWxheWVkXCJcbiAgZWxzZWlmIHJjYWxsKFwiWlNDT1JFXCIsIHByZWZpeCAuLiBcImZhaWxlZFwiLCBqb2JJZCkgdGhlblxuICAgIHJjYWxsKFwiWlJFTVwiLCBwcmVmaXggLi4gXCJmYWlsZWRcIiwgam9iSWQpXG4gICAgcmV0dXJuIFwiZmFpbGVkXCJcbiAgZWxzZWlmIHJjYWxsKFwiWlNDT1JFXCIsIHByZWZpeCAuLiBcInByaW9yaXRpemVkXCIsIGpvYklkKSB0aGVuXG4gICAgcmNhbGwoXCJaUkVNXCIsIHByZWZpeCAuLiBcInByaW9yaXRpemVkXCIsIGpvYklkKVxuICAgIHJldHVybiBcInByaW9yaXRpemVkXCJcbiAgLS0gV2UgcmVtb3ZlIG9ubHkgMSBlbGVtZW50IGZyb20gdGhlIGxpc3QsIHNpbmNlIHdlIGFzc3VtZSB0aGV5IGFyZSBub3QgYWRkZWQgbXVsdGlwbGUgdGltZXNcbiAgZWxzZWlmIHJjYWxsKFwiTFJFTVwiLCBwcmVmaXggLi4gXCJ3YWl0XCIsIDEsIGpvYklkKSA9PSAxIHRoZW5cbiAgICByZXR1cm4gXCJ3YWl0XCJcbiAgZWxzZWlmIHJjYWxsKFwiTFJFTVwiLCBwcmVmaXggLi4gXCJwYXVzZWRcIiwgMSwgam9iSWQpID09IDEgdGhlblxuICAgIHJldHVybiBcInBhdXNlZFwiXG4gIGVsc2VpZiByY2FsbChcIkxSRU1cIiwgcHJlZml4IC4uIFwiYWN0aXZlXCIsIDEsIGpvYklkKSA9PSAxIHRoZW5cbiAgICByZXR1cm4gXCJhY3RpdmVcIlxuICBlbmRcbiAgcmV0dXJuIFwidW5rbm93blwiXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGpvYiBrZXlzLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYktleXMoam9iS2V5KVxuICByZXR1cm4gcmNhbGwoXCJERUxcIiwgam9iS2V5LCBqb2JLZXkgLi4gJzpsb2dzJywgam9iS2V5IC4uICc6ZGVwZW5kZW5jaWVzJyxcbiAgICBqb2JLZXkgLi4gJzpwcm9jZXNzZWQnLCBqb2JLZXkgLi4gJzpmYWlsZWQnLCBqb2JLZXkgLi4gJzp1bnN1Y2Nlc3NmdWwnKVxuZW5kXG4tLVtbXG4gIENoZWNrIGlmIHRoaXMgam9iIGhhcyBhIHBhcmVudC4gSWYgc28gd2Ugd2lsbCBqdXN0IHJlbW92ZSBpdCBmcm9tXG4gIHRoZSBwYXJlbnQgY2hpbGQgbGlzdCwgYnV0IGlmIGl0IGlzIHRoZSBsYXN0IGNoaWxkIHdlIHNob3VsZCBtb3ZlIHRoZSBwYXJlbnQgdG8gXCJ3YWl0L3BhdXNlZFwiXG4gIHdoaWNoIHJlcXVpcmVzIGNvZGUgZnJvbSBcIm1vdmVUb0ZpbmlzaGVkXCJcbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG5sb2NhbCBmdW5jdGlvbiBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCBlbWl0RXZlbnQpXG4gIGxvY2FsIHBhcmVudFRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KHBhcmVudFByZWZpeCAuLiBcIm1ldGFcIiwgcGFyZW50UHJlZml4IC4uIFwiYWN0aXZlXCIsXG4gICAgcGFyZW50UHJlZml4IC4uIFwid2FpdFwiLCBwYXJlbnRQcmVmaXggLi4gXCJwYXVzZWRcIilcbiAgYWRkSm9iSW5UYXJnZXRMaXN0KHBhcmVudFRhcmdldCwgcGFyZW50UHJlZml4IC4uIFwibWFya2VyXCIsIFwiUlBVU0hcIiwgaXNQYXVzZWRPck1heGVkLCBwYXJlbnRJZClcbiAgaWYgZW1pdEV2ZW50IHRoZW5cbiAgICBsb2NhbCBwYXJlbnRFdmVudFN0cmVhbSA9IHBhcmVudFByZWZpeCAuLiBcImV2ZW50c1wiXG4gICAgcmNhbGwoXCJYQUREXCIsIHBhcmVudEV2ZW50U3RyZWFtLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIiwgXCJqb2JJZFwiLCBwYXJlbnRJZCwgXCJwcmV2XCIsIFwid2FpdGluZy1jaGlsZHJlblwiKVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGhhcmQsIHBhcmVudEtleSwgYmFzZUtleSwgZGVib3VuY2VJZClcbiAgaWYgcGFyZW50S2V5IHRoZW5cbiAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBwYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICBsb2NhbCByZXN1bHQgPSByY2FsbChcIlNSRU1cIiwgcGFyZW50RGVwZW5kZW5jaWVzS2V5LCBqb2JLZXkpXG4gICAgaWYgcmVzdWx0ID4gMCB0aGVuXG4gICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICBpZiBwZW5kaW5nRGVwZW5kZW5jaWVzID09IDAgdGhlblxuICAgICAgICBsb2NhbCBwYXJlbnRJZCA9IGdldEpvYklkRnJvbUtleShwYXJlbnRLZXkpXG4gICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChwYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICBsb2NhbCBudW1SZW1vdmVkRWxlbWVudHMgPSByY2FsbChcIlpSRU1cIiwgcGFyZW50UHJlZml4IC4uIFwid2FpdGluZy1jaGlsZHJlblwiLCBwYXJlbnRJZClcbiAgICAgICAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzID09IDEgdGhlblxuICAgICAgICAgIGlmIGhhcmQgdGhlbiAtLSByZW1vdmUgcGFyZW50IGluIHNhbWUgcXVldWVcbiAgICAgICAgICAgIGlmIHBhcmVudFByZWZpeCA9PSBiYXNlS2V5IHRoZW5cbiAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShwYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSwgbmlsKVxuICAgICAgICAgICAgICByZW1vdmVKb2JLZXlzKHBhcmVudEtleSlcbiAgICAgICAgICAgICAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJERUxcIiwgcGFyZW50UHJlZml4IC4uIFwiZGU6XCIgLi4gZGVib3VuY2VJZClcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCB0cnVlKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbmRcbiAgZWxzZVxuICAgIGxvY2FsIHBhcmVudEF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIiwgXCJkZWlkXCIpXG4gICAgbG9jYWwgbWlzc2VkUGFyZW50S2V5ID0gcGFyZW50QXR0cmlidXRlc1sxXVxuICAgIGlmKCAodHlwZShtaXNzZWRQYXJlbnRLZXkpID09IFwic3RyaW5nXCIpIGFuZCBtaXNzZWRQYXJlbnRLZXkgfj0gXCJcIlxuICAgICAgYW5kIChyY2FsbChcIkVYSVNUU1wiLCBtaXNzZWRQYXJlbnRLZXkpID09IDEpKSB0aGVuXG4gICAgICBsb2NhbCBwYXJlbnREZXBlbmRlbmNpZXNLZXkgPSBtaXNzZWRQYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCJcbiAgICAgIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU1JFTVwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXksIGpvYktleSlcbiAgICAgIGlmIHJlc3VsdCA+IDAgdGhlblxuICAgICAgICBsb2NhbCBwZW5kaW5nRGVwZW5kZW5jaWVzID0gcmNhbGwoXCJTQ0FSRFwiLCBwYXJlbnREZXBlbmRlbmNpZXNLZXkpXG4gICAgICAgIGlmIHBlbmRpbmdEZXBlbmRlbmNpZXMgPT0gMCB0aGVuXG4gICAgICAgICAgbG9jYWwgcGFyZW50SWQgPSBnZXRKb2JJZEZyb21LZXkobWlzc2VkUGFyZW50S2V5KVxuICAgICAgICAgIGxvY2FsIHBhcmVudFByZWZpeCA9IGdldEpvYktleVByZWZpeChtaXNzZWRQYXJlbnRLZXksIHBhcmVudElkKVxuICAgICAgICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiWlJFTVwiLCBwYXJlbnRQcmVmaXggLi4gXCJ3YWl0aW5nLWNoaWxkcmVuXCIsIHBhcmVudElkKVxuICAgICAgICAgIGlmIG51bVJlbW92ZWRFbGVtZW50cyA9PSAxIHRoZW5cbiAgICAgICAgICAgIGlmIGhhcmQgdGhlblxuICAgICAgICAgICAgICBpZiBwYXJlbnRQcmVmaXggPT0gYmFzZUtleSB0aGVuXG4gICAgICAgICAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShtaXNzZWRQYXJlbnRLZXksIGhhcmQsIG5pbCwgYmFzZUtleSwgbmlsKVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYktleXMobWlzc2VkUGFyZW50S2V5KVxuICAgICAgICAgICAgICAgIGlmIHBhcmVudEF0dHJpYnV0ZXNbMl0gdGhlblxuICAgICAgICAgICAgICAgICAgcmNhbGwoXCJERUxcIiwgcGFyZW50UHJlZml4IC4uIFwiZGU6XCIgLi4gcGFyZW50QXR0cmlidXRlc1syXSlcbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIF9tb3ZlUGFyZW50VG9XYWl0KHBhcmVudFByZWZpeCwgcGFyZW50SWQpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBfbW92ZVBhcmVudFRvV2FpdChwYXJlbnRQcmVmaXgsIHBhcmVudElkLCB0cnVlKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gZmFsc2VcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byByZWN1cnNpdmVseSBjaGVjayBpZiB0aGVyZSBhcmUgbm8gbG9ja3NcbiAgb24gdGhlIGpvYnMgdG8gYmUgcmVtb3ZlZC5cbiAgcmV0dXJuczpcbiAgICBib29sZWFuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNMb2NrZWQoIHByZWZpeCwgam9iSWQsIHJlbW92ZUNoaWxkcmVuKVxuICBsb2NhbCBqb2JLZXkgPSBwcmVmaXggLi4gam9iSWQ7XG4gIC0tIENoZWNrIGlmIHRoaXMgam9iIGlzIGxvY2tlZFxuICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgbG9jYWwgbG9jayA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gIGlmIG5vdCBsb2NrIHRoZW5cbiAgICBpZiByZW1vdmVDaGlsZHJlbiA9PSBcIjFcIiB0aGVuXG4gICAgICBsb2NhbCBkZXBlbmRlbmNpZXMgPSByY2FsbChcIlNNRU1CRVJTXCIsIGpvYktleSAuLiBcIjpkZXBlbmRlbmNpZXNcIilcbiAgICAgIGlmICgjZGVwZW5kZW5jaWVzID4gMCkgdGhlblxuICAgICAgICBmb3IgaSwgY2hpbGRKb2JLZXkgaW4gaXBhaXJzKGRlcGVuZGVuY2llcykgZG9cbiAgICAgICAgICAtLSBXZSBuZWVkIHRvIGdldCB0aGUgam9iSWQgZm9yIHRoaXMgam9iLlxuICAgICAgICAgIGxvY2FsIGNoaWxkSm9iSWQgPSBnZXRKb2JJZEZyb21LZXkoY2hpbGRKb2JLZXkpXG4gICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgoY2hpbGRKb2JLZXksIGNoaWxkSm9iSWQpXG4gICAgICAgICAgbG9jYWwgcmVzdWx0ID0gaXNMb2NrZWQoIGNoaWxkSm9iUHJlZml4LCBjaGlsZEpvYklkLCByZW1vdmVDaGlsZHJlbiApXG4gICAgICAgICAgaWYgcmVzdWx0IHRoZW5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgcmV0dXJuIGZhbHNlXG4gIGVuZFxuICByZXR1cm4gdHJ1ZVxuZW5kXG5sb2NhbCByZW1vdmVKb2JDaGlsZHJlblxubG9jYWwgcmVtb3ZlSm9iV2l0aENoaWxkcmVuXG5yZW1vdmVKb2JDaGlsZHJlbiA9IGZ1bmN0aW9uKHByZWZpeCwgam9iS2V5LCBvcHRpb25zKVxuICAgIC0tIENoZWNrIGlmIHRoaXMgam9iIGhhcyBjaGlsZHJlblxuICAgIC0tIElmIHNvLCB3ZSBhcmUgZ29pbmcgdG8gdHJ5IHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gcmVjdXJzaXZlbHkgaW4gYSBkZXB0aC1maXJzdCB3YXlcbiAgICAtLSBiZWNhdXNlIGlmIHNvbWUgam9iIGlzIGxvY2tlZCwgd2UgbXVzdCBleGl0IHdpdGggYW4gZXJyb3IuXG4gICAgaWYgbm90IG9wdGlvbnMuaWdub3JlUHJvY2Vzc2VkIHRoZW5cbiAgICAgICAgbG9jYWwgcHJvY2Vzc2VkID0gcmNhbGwoXCJIR0VUQUxMXCIsIGpvYktleSAuLiBcIjpwcm9jZXNzZWRcIilcbiAgICAgICAgaWYgI3Byb2Nlc3NlZCA+IDAgdGhlblxuICAgICAgICAgICAgZm9yIGkgPSAxLCAjcHJvY2Vzc2VkLCAyIGRvXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JJZCA9IGdldEpvYklkRnJvbUtleShwcm9jZXNzZWRbaV0pXG4gICAgICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JQcmVmaXggPSBnZXRKb2JLZXlQcmVmaXgocHJvY2Vzc2VkW2ldLCBjaGlsZEpvYklkKVxuICAgICAgICAgICAgICAgIHJlbW92ZUpvYldpdGhDaGlsZHJlbihjaGlsZEpvYlByZWZpeCwgY2hpbGRKb2JJZCwgam9iS2V5LCBvcHRpb25zKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBsb2NhbCBmYWlsZWQgPSByY2FsbChcIkhHRVRBTExcIiwgam9iS2V5IC4uIFwiOmZhaWxlZFwiKVxuICAgICAgICBpZiAjZmFpbGVkID4gMCB0aGVuXG4gICAgICAgICAgICBmb3IgaSA9IDEsICNmYWlsZWQsIDIgZG9cbiAgICAgICAgICAgICAgICBsb2NhbCBjaGlsZEpvYklkID0gZ2V0Sm9iSWRGcm9tS2V5KGZhaWxlZFtpXSlcbiAgICAgICAgICAgICAgICBsb2NhbCBjaGlsZEpvYlByZWZpeCA9IGdldEpvYktleVByZWZpeChmYWlsZWRbaV0sIGNoaWxkSm9iSWQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlSm9iV2l0aENoaWxkcmVuKGNoaWxkSm9iUHJlZml4LCBjaGlsZEpvYklkLCBqb2JLZXksIG9wdGlvbnMpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIHVuc3VjY2Vzc2Z1bCA9IHJjYWxsKFwiWlJBTkdFXCIsIGpvYktleSAuLiBcIjp1bnN1Y2Nlc3NmdWxcIiwgMCwgLTEpXG4gICAgICAgIGlmICN1bnN1Y2Nlc3NmdWwgPiAwIHRoZW5cbiAgICAgICAgICAgIGZvciBpID0gMSwgI3Vuc3VjY2Vzc2Z1bCwgMSBkb1xuICAgICAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iSWQgPSBnZXRKb2JJZEZyb21LZXkodW5zdWNjZXNzZnVsW2ldKVxuICAgICAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iUHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KHVuc3VjY2Vzc2Z1bFtpXSwgY2hpbGRKb2JJZClcbiAgICAgICAgICAgICAgICByZW1vdmVKb2JXaXRoQ2hpbGRyZW4oY2hpbGRKb2JQcmVmaXgsIGNoaWxkSm9iSWQsIGpvYktleSwgb3B0aW9ucylcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgICBsb2NhbCBkZXBlbmRlbmNpZXMgPSByY2FsbChcIlNNRU1CRVJTXCIsIGpvYktleSAuLiBcIjpkZXBlbmRlbmNpZXNcIilcbiAgICBpZiAjZGVwZW5kZW5jaWVzID4gMCB0aGVuXG4gICAgICAgIGZvciBpLCBjaGlsZEpvYktleSBpbiBpcGFpcnMoZGVwZW5kZW5jaWVzKSBkb1xuICAgICAgICAgICAgbG9jYWwgY2hpbGRKb2JJZCA9IGdldEpvYklkRnJvbUtleShjaGlsZEpvYktleSlcbiAgICAgICAgICAgIGxvY2FsIGNoaWxkSm9iUHJlZml4ID0gZ2V0Sm9iS2V5UHJlZml4KGNoaWxkSm9iS2V5LCBjaGlsZEpvYklkKVxuICAgICAgICAgICAgcmVtb3ZlSm9iV2l0aENoaWxkcmVuKGNoaWxkSm9iUHJlZml4LCBjaGlsZEpvYklkLCBqb2JLZXksIG9wdGlvbnMpXG4gICAgICAgIGVuZFxuICAgIGVuZFxuZW5kXG5yZW1vdmVKb2JXaXRoQ2hpbGRyZW4gPSBmdW5jdGlvbihwcmVmaXgsIGpvYklkLCBwYXJlbnRLZXksIG9wdGlvbnMpXG4gICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgaWYgb3B0aW9ucy5pZ25vcmVMb2NrZWQgdGhlblxuICAgICAgICBpZiBpc0xvY2tlZChwcmVmaXgsIGpvYklkKSB0aGVuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgLS0gQ2hlY2sgaWYgam9iIGlzIGluIHRoZSBmYWlsZWQgenNldFxuICAgIGxvY2FsIGZhaWxlZFNldCA9IHByZWZpeCAuLiBcImZhaWxlZFwiXG4gICAgaWYgbm90IChvcHRpb25zLmlnbm9yZVByb2Nlc3NlZCBhbmQgcmNhbGwoXCJaU0NPUkVcIiwgZmFpbGVkU2V0LCBqb2JJZCkpIHRoZW5cbiAgICAgICAgcmVtb3ZlUGFyZW50RGVwZW5kZW5jeUtleShqb2JLZXksIGZhbHNlLCBwYXJlbnRLZXksIG5pbClcbiAgICAgICAgaWYgb3B0aW9ucy5yZW1vdmVDaGlsZHJlbiB0aGVuXG4gICAgICAgICAgICByZW1vdmVKb2JDaGlsZHJlbihwcmVmaXgsIGpvYktleSwgb3B0aW9ucylcbiAgICAgICAgZW5kXG4gICAgICAgIGxvY2FsIHByZXYgPSByZW1vdmVKb2JGcm9tQW55U3RhdGUocHJlZml4LCBqb2JJZClcbiAgICAgICAgcmVtb3ZlRGVkdXBsaWNhdGlvbktleUlmTmVlZGVkT25SZW1vdmFsKHByZWZpeCwgam9iS2V5LCBqb2JJZClcbiAgICAgICAgaWYgcmVtb3ZlSm9iS2V5cyhqb2JLZXkpID4gMCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBtZXRhS2V5ID0gcHJlZml4IC4uIFwibWV0YVwiXG4gICAgICAgICAgICBsb2NhbCBtYXhFdmVudHMgPSBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICAgICAgICAgICAgcmNhbGwoXCJYQUREXCIsIHByZWZpeCAuLiBcImV2ZW50c1wiLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcInJlbW92ZWRcIixcbiAgICAgICAgICAgICAgICBcImpvYklkXCIsIGpvYklkLCBcInByZXZcIiwgcHJldilcbiAgICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbmxvY2FsIHByZWZpeCA9IEFSR1ZbMV1cbmxvY2FsIGpvYklkID0gQVJHVlsyXVxubG9jYWwgam9iS2V5ID0gS0VZU1sxXVxubG9jYWwgbWV0YUtleSA9IEtFWVNbMl1cbmxvY2FsIG9wdGlvbnMgPSB7XG4gIHJlbW92ZUNoaWxkcmVuID0gXCIxXCIsXG4gIGlnbm9yZVByb2Nlc3NlZCA9IHRydWUsXG4gIGlnbm9yZUxvY2tlZCA9IHRydWVcbn1cbnJlbW92ZUpvYkNoaWxkcmVuKHByZWZpeCwgam9iS2V5LCBvcHRpb25zKSBcbmA7XG5leHBvcnQgY29uc3QgcmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbiA9IHtcbiAgICBuYW1lOiAncmVtb3ZlVW5wcm9jZXNzZWRDaGlsZHJlbicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZVVucHJvY2Vzc2VkQ2hpbGRyZW4tMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/removeUnprocessedChildren-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-8.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/reprocessJob-8.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reprocessJob: () => (/* binding */ reprocessJob)\n/* harmony export */ });\nconst content = `--[[\n  Attempts to reprocess a job\n  Input:\n    KEYS[1] job key\n    KEYS[2] events stream\n    KEYS[3] job state\n    KEYS[4] wait key\n    KEYS[5] meta\n    KEYS[6] paused key\n    KEYS[7] active key\n    KEYS[8] marker key\n    ARGV[1] job.id\n    ARGV[2] (job.opts.lifo ? 'R' : 'L') + 'PUSH'\n    ARGV[3] propVal - failedReason/returnvalue\n    ARGV[4] prev state - failed/completed\n  Output:\n     1 means the operation was a success\n    -1 means the job does not exist\n    -3 means the job was not found in the expected set.\n]]\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\nlocal jobKey = KEYS[1]\nif rcall(\"EXISTS\", jobKey) == 1 then\n  local jobId = ARGV[1]\n  if (rcall(\"ZREM\", KEYS[3], jobId) == 1) then\n    rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", ARGV[3])\n    local target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[7], KEYS[4], KEYS[6])\n    addJobInTargetList(target, KEYS[8], ARGV[2], isPausedOrMaxed, jobId)\n    local parentKey = rcall(\"HGET\", jobKey, \"parentKey\")\n    if parentKey and rcall(\"EXISTS\", parentKey) == 1 then\n      if ARGV[4] == \"failed\" then\n        if rcall(\"ZREM\", parentKey .. \":unsuccessful\", jobKey) == 1 or\n          rcall(\"ZREM\", parentKey .. \":failed\", jobKey) == 1 then\n          rcall(\"SADD\", parentKey .. \":dependencies\", jobKey)\n        end\n      else\n        if rcall(\"HDEL\", parentKey .. \":processed\", jobKey) == 1 then\n          rcall(\"SADD\", parentKey .. \":dependencies\", jobKey)\n        end\n      end\n    end\n    local maxEvents = getOrSetMaxEvents(KEYS[5])\n    -- Emit waiting event\n    rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n      \"jobId\", jobId, \"prev\", ARGV[4]);\n    return 1\n  else\n    return -3\n  end\nelse\n  return -1\nend\n`;\nconst reprocessJob = {\n    name: 'reprocessJob',\n    content,\n    keys: 8,\n};\n//# sourceMappingURL=reprocessJob-8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmVwcm9jZXNzSm9iLTguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3JlcHJvY2Vzc0pvYi04LmpzPzEzNmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIEF0dGVtcHRzIHRvIHJlcHJvY2VzcyBhIGpvYlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGpvYiBrZXlcbiAgICBLRVlTWzJdIGV2ZW50cyBzdHJlYW1cbiAgICBLRVlTWzNdIGpvYiBzdGF0ZVxuICAgIEtFWVNbNF0gd2FpdCBrZXlcbiAgICBLRVlTWzVdIG1ldGFcbiAgICBLRVlTWzZdIHBhdXNlZCBrZXlcbiAgICBLRVlTWzddIGFjdGl2ZSBrZXlcbiAgICBLRVlTWzhdIG1hcmtlciBrZXlcbiAgICBBUkdWWzFdIGpvYi5pZFxuICAgIEFSR1ZbMl0gKGpvYi5vcHRzLmxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnXG4gICAgQVJHVlszXSBwcm9wVmFsIC0gZmFpbGVkUmVhc29uL3JldHVybnZhbHVlXG4gICAgQVJHVls0XSBwcmV2IHN0YXRlIC0gZmFpbGVkL2NvbXBsZXRlZFxuICBPdXRwdXQ6XG4gICAgIDEgbWVhbnMgdGhlIG9wZXJhdGlvbiB3YXMgYSBzdWNjZXNzXG4gICAgLTEgbWVhbnMgdGhlIGpvYiBkb2VzIG5vdCBleGlzdFxuICAgIC0zIG1lYW5zIHRoZSBqb2Igd2FzIG5vdCBmb3VuZCBpbiB0aGUgZXhwZWN0ZWQgc2V0LlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbDtcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbiAgaWYgbm90IGlzUGF1c2VkT3JNYXhlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXRLZXksIG1hcmtlcktleSwgcHVzaENtZCwgaXNQYXVzZWRPck1heGVkLCBqb2JJZClcbiAgcmNhbGwocHVzaENtZCwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgYWN0aXZlS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIsIFwibWF4XCIsIFwiZHVyYXRpb25cIilcbiAgaWYgcXVldWVBdHRyaWJ1dGVzWzFdIHRoZW5cbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICBlbHNlXG4gICAgaWYgcXVldWVBdHRyaWJ1dGVzWzJdIHRoZW5cbiAgICAgIGxvY2FsIGFjdGl2ZUNvdW50ID0gcmNhbGwoXCJMTEVOXCIsIGFjdGl2ZUtleSlcbiAgICAgIGlmIGFjdGl2ZUNvdW50ID49IHRvbnVtYmVyKHF1ZXVlQXR0cmlidXRlc1syXSkgdGhlblxuICAgICAgICByZXR1cm4gd2FpdEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gd2FpdEtleSwgZmFsc2UsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG5lbmRcbmxvY2FsIGpvYktleSA9IEtFWVNbMV1cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgPT0gMSB0aGVuXG4gIGxvY2FsIGpvYklkID0gQVJHVlsxXVxuICBpZiAocmNhbGwoXCJaUkVNXCIsIEtFWVNbM10sIGpvYklkKSA9PSAxKSB0aGVuXG4gICAgcmNhbGwoXCJIREVMXCIsIGpvYktleSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgQVJHVlszXSlcbiAgICBsb2NhbCB0YXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzVdLCBLRVlTWzddLCBLRVlTWzRdLCBLRVlTWzZdKVxuICAgIGFkZEpvYkluVGFyZ2V0TGlzdCh0YXJnZXQsIEtFWVNbOF0sIEFSR1ZbMl0sIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gICAgbG9jYWwgcGFyZW50S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwYXJlbnRLZXlcIilcbiAgICBpZiBwYXJlbnRLZXkgYW5kIHJjYWxsKFwiRVhJU1RTXCIsIHBhcmVudEtleSkgPT0gMSB0aGVuXG4gICAgICBpZiBBUkdWWzRdID09IFwiZmFpbGVkXCIgdGhlblxuICAgICAgICBpZiByY2FsbChcIlpSRU1cIiwgcGFyZW50S2V5IC4uIFwiOnVuc3VjY2Vzc2Z1bFwiLCBqb2JLZXkpID09IDEgb3JcbiAgICAgICAgICByY2FsbChcIlpSRU1cIiwgcGFyZW50S2V5IC4uIFwiOmZhaWxlZFwiLCBqb2JLZXkpID09IDEgdGhlblxuICAgICAgICAgIHJjYWxsKFwiU0FERFwiLCBwYXJlbnRLZXkgLi4gXCI6ZGVwZW5kZW5jaWVzXCIsIGpvYktleSlcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGlmIHJjYWxsKFwiSERFTFwiLCBwYXJlbnRLZXkgLi4gXCI6cHJvY2Vzc2VkXCIsIGpvYktleSkgPT0gMSB0aGVuXG4gICAgICAgICAgcmNhbGwoXCJTQUREXCIsIHBhcmVudEtleSAuLiBcIjpkZXBlbmRlbmNpZXNcIiwgam9iS2V5KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKEtFWVNbNV0pXG4gICAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50XG4gICAgcmNhbGwoXCJYQUREXCIsIEtFWVNbMl0sIFwiTUFYTEVOXCIsIFwiflwiLCBtYXhFdmVudHMsIFwiKlwiLCBcImV2ZW50XCIsIFwid2FpdGluZ1wiLFxuICAgICAgXCJqb2JJZFwiLCBqb2JJZCwgXCJwcmV2XCIsIEFSR1ZbNF0pO1xuICAgIHJldHVybiAxXG4gIGVsc2VcbiAgICByZXR1cm4gLTNcbiAgZW5kXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xuZXhwb3J0IGNvbnN0IHJlcHJvY2Vzc0pvYiA9IHtcbiAgICBuYW1lOiAncmVwcm9jZXNzSm9iJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDgsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwcm9jZXNzSm9iLTguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/reprocessJob-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-11.js":
/*!*************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/retryJob-11.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   retryJob: () => (/* binding */ retryJob)\n/* harmony export */ });\nconst content = `--[[\n  Retries a failed job by moving it back to the wait queue.\n    Input:\n      KEYS[1]  'active',\n      KEYS[2]  'wait'\n      KEYS[3]  'paused'\n      KEYS[4]  job key\n      KEYS[5]  'meta'\n      KEYS[6]  events stream\n      KEYS[7]  delayed key\n      KEYS[8]  prioritized key\n      KEYS[9]  'pc' priority counter\n      KEYS[10] 'marker'\n      KEYS[11] 'stalled'\n      ARGV[1]  key prefix\n      ARGV[2]  timestamp\n      ARGV[3]  pushCmd\n      ARGV[4]  jobId\n      ARGV[5]  token\n      ARGV[6]  optional job fields to update\n    Events:\n      'waiting'\n    Output:\n     0  - OK\n     -1 - Missing key\n     -2 - Missing lock\n     -3 - Job not in active set\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to check if queue is paused or maxed\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePausedOrMaxed(queueMetaKey, activeKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\")\n  if queueAttributes[1] then\n    return true\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      return activeCount >= tonumber(queueAttributes[2])\n    end\n  end\n  return false\nend\n--[[\n  Updates the delay set, by moving delayed jobs that should\n  be processed now to \"wait\".\n     Events:\n      'waiting'\n]]\n-- Includes\n-- Try to get as much as 1000 jobs at once\nlocal function promoteDelayedJobs(delayedKey, markerKey, targetKey, prioritizedKey,\n                                  eventStreamKey, prefix, timestamp, priorityCounterKey, isPaused)\n    local jobs = rcall(\"ZRANGEBYSCORE\", delayedKey, 0, (timestamp + 1) * 0x1000 - 1, \"LIMIT\", 0, 1000)\n    if (#jobs > 0) then\n        rcall(\"ZREM\", delayedKey, unpack(jobs))\n        for _, jobId in ipairs(jobs) do\n            local jobKey = prefix .. jobId\n            local priority =\n                tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n            if priority == 0 then\n                -- LIFO or FIFO\n                rcall(\"LPUSH\", targetKey, jobId)\n            else\n                local score = getPriorityScore(priority, priorityCounterKey)\n                rcall(\"ZADD\", prioritizedKey, score, jobId)\n            end\n            -- Emit waiting event\n            rcall(\"XADD\", eventStreamKey, \"*\", \"event\", \"waiting\", \"jobId\",\n                  jobId, \"prev\", \"delayed\")\n            rcall(\"HSET\", jobKey, \"delay\", 0)\n        end\n        addBaseMarkerIfNeeded(markerKey, isPaused)\n    end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to update a bunch of fields in a job.\n]]\nlocal function updateJobFields(jobKey, msgpackedFields)\n  if msgpackedFields and #msgpackedFields > 0 then\n    local fieldsToUpdate = cmsgpack.unpack(msgpackedFields)\n    if fieldsToUpdate then\n      rcall(\"HMSET\", jobKey, unpack(fieldsToUpdate))\n    end\n  end\nend\nlocal target, isPausedOrMaxed = getTargetQueueList(KEYS[5], KEYS[1], KEYS[2], KEYS[3])\nlocal markerKey = KEYS[10]\n-- Check if there are delayed jobs that we can move to wait.\n-- test example: when there are delayed jobs between retries\npromoteDelayedJobs(KEYS[7], markerKey, target, KEYS[8], KEYS[6], ARGV[1], ARGV[2], KEYS[9], isPausedOrMaxed)\nlocal jobKey = KEYS[4]\nif rcall(\"EXISTS\", jobKey) == 1 then\n  local errorCode = removeLock(jobKey, KEYS[11], ARGV[5], ARGV[4]) \n  if errorCode < 0 then\n    return errorCode\n  end\n  updateJobFields(jobKey, ARGV[6])\n  local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[4])\n  if (numRemovedElements < 1) then return -3 end\n  local priority = tonumber(rcall(\"HGET\", jobKey, \"priority\")) or 0\n  --need to re-evaluate after removing job from active\n  isPausedOrMaxed = isQueuePausedOrMaxed(KEYS[5], KEYS[1])\n  -- Standard or priority add\n  if priority == 0 then\n    addJobInTargetList(target, markerKey, ARGV[3], isPausedOrMaxed, ARGV[4])\n  else\n    addJobWithPriority(markerKey, KEYS[8], priority, ARGV[4], KEYS[9], isPausedOrMaxed)\n  end\n  rcall(\"HINCRBY\", jobKey, \"atm\", 1)\n  local maxEvents = getOrSetMaxEvents(KEYS[5])\n  -- Emit waiting event\n  rcall(\"XADD\", KEYS[6], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"waiting\",\n    \"jobId\", ARGV[4], \"prev\", \"active\")\n  return 0\nelse\n  return -1\nend\n`;\nconst retryJob = {\n    name: 'retryJob',\n    content,\n    keys: 11,\n};\n//# sourceMappingURL=retryJob-11.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvcmV0cnlKb2ItMTEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9yZXRyeUpvYi0xMS5qcz83YmIyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZXRyaWVzIGEgZmFpbGVkIGpvYiBieSBtb3ZpbmcgaXQgYmFjayB0byB0aGUgd2FpdCBxdWV1ZS5cbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gICdhY3RpdmUnLFxuICAgICAgS0VZU1syXSAgJ3dhaXQnXG4gICAgICBLRVlTWzNdICAncGF1c2VkJ1xuICAgICAgS0VZU1s0XSAgam9iIGtleVxuICAgICAgS0VZU1s1XSAgJ21ldGEnXG4gICAgICBLRVlTWzZdICBldmVudHMgc3RyZWFtXG4gICAgICBLRVlTWzddICBkZWxheWVkIGtleVxuICAgICAgS0VZU1s4XSAgcHJpb3JpdGl6ZWQga2V5XG4gICAgICBLRVlTWzldICAncGMnIHByaW9yaXR5IGNvdW50ZXJcbiAgICAgIEtFWVNbMTBdICdtYXJrZXInXG4gICAgICBLRVlTWzExXSAnc3RhbGxlZCdcbiAgICAgIEFSR1ZbMV0gIGtleSBwcmVmaXhcbiAgICAgIEFSR1ZbMl0gIHRpbWVzdGFtcFxuICAgICAgQVJHVlszXSAgcHVzaENtZFxuICAgICAgQVJHVls0XSAgam9iSWRcbiAgICAgIEFSR1ZbNV0gIHRva2VuXG4gICAgICBBUkdWWzZdICBvcHRpb25hbCBqb2IgZmllbGRzIHRvIHVwZGF0ZVxuICAgIEV2ZW50czpcbiAgICAgICd3YWl0aW5nJ1xuICAgIE91dHB1dDpcbiAgICAgMCAgLSBPS1xuICAgICAtMSAtIE1pc3Npbmcga2V5XG4gICAgIC0yIC0gTWlzc2luZyBsb2NrXG4gICAgIC0zIC0gSm9iIG5vdCBpbiBhY3RpdmUgc2V0XG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGluIHRhcmdldCBsaXN0IGFuZCBhZGQgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgbWFya2VyIGlmIG5lZWRlZCB3aGVuIGEgam9iIGlzIGF2YWlsYWJsZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZE9yTWF4ZWQpXG4gIGlmIG5vdCBpc1BhdXNlZE9yTWF4ZWQgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIDAsIFwiMFwiKVxuICBlbmQgIFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBwcmlvcml0eSBzY29yZS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRQcmlvcml0eVNjb3JlKHByaW9yaXR5LCBwcmlvcml0eUNvdW50ZXJLZXkpXG4gIGxvY2FsIHByaW9Db3VudGVyID0gcmNhbGwoXCJJTkNSXCIsIHByaW9yaXR5Q291bnRlcktleSlcbiAgcmV0dXJuIHByaW9yaXR5ICogMHgxMDAwMDAwMDAgKyBwcmlvQ291bnRlciAlIDB4MTAwMDAwMDAwXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShtYXJrZXJLZXksIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eSwgam9iSWQsIHByaW9yaXR5Q291bnRlcktleSxcbiAgaXNQYXVzZWRPck1heGVkKVxuICBsb2NhbCBzY29yZSA9IGdldFByaW9yaXR5U2NvcmUocHJpb3JpdHksIHByaW9yaXR5Q291bnRlcktleSlcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXRpemVkS2V5LCBzY29yZSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIHF1ZXVlIGlzIHBhdXNlZCBvciBtYXhlZFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNRdWV1ZVBhdXNlZE9yTWF4ZWQocXVldWVNZXRhS2V5LCBhY3RpdmVLZXkpXG4gIGxvY2FsIHF1ZXVlQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiLCBcImNvbmN1cnJlbmN5XCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHRydWVcbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICByZXR1cm4gYWN0aXZlQ291bnQgPj0gdG9udW1iZXIocXVldWVBdHRyaWJ1dGVzWzJdKVxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIGZhbHNlXG5lbmRcbi0tW1tcbiAgVXBkYXRlcyB0aGUgZGVsYXkgc2V0LCBieSBtb3ZpbmcgZGVsYXllZCBqb2JzIHRoYXQgc2hvdWxkXG4gIGJlIHByb2Nlc3NlZCBub3cgdG8gXCJ3YWl0XCIuXG4gICAgIEV2ZW50czpcbiAgICAgICd3YWl0aW5nJ1xuXV1cbi0tIEluY2x1ZGVzXG4tLSBUcnkgdG8gZ2V0IGFzIG11Y2ggYXMgMTAwMCBqb2JzIGF0IG9uY2VcbmxvY2FsIGZ1bmN0aW9uIHByb21vdGVEZWxheWVkSm9icyhkZWxheWVkS2V5LCBtYXJrZXJLZXksIHRhcmdldEtleSwgcHJpb3JpdGl6ZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdHJlYW1LZXksIHByZWZpeCwgdGltZXN0YW1wLCBwcmlvcml0eUNvdW50ZXJLZXksIGlzUGF1c2VkKVxuICAgIGxvY2FsIGpvYnMgPSByY2FsbChcIlpSQU5HRUJZU0NPUkVcIiwgZGVsYXllZEtleSwgMCwgKHRpbWVzdGFtcCArIDEpICogMHgxMDAwIC0gMSwgXCJMSU1JVFwiLCAwLCAxMDAwKVxuICAgIGlmICgjam9icyA+IDApIHRoZW5cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIGRlbGF5ZWRLZXksIHVucGFjayhqb2JzKSlcbiAgICAgICAgZm9yIF8sIGpvYklkIGluIGlwYWlycyhqb2JzKSBkb1xuICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gcHJlZml4IC4uIGpvYklkXG4gICAgICAgICAgICBsb2NhbCBwcmlvcml0eSA9XG4gICAgICAgICAgICAgICAgdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICAgICAgICAgICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTElGTyBvciBGSUZPXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJMUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0aXplZEtleSwgc2NvcmUsIGpvYklkKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICAgICAgICAgIHJjYWxsKFwiWEFERFwiLCBldmVudFN0cmVhbUtleSwgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIixcbiAgICAgICAgICAgICAgICAgIGpvYklkLCBcInByZXZcIiwgXCJkZWxheWVkXCIpXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcImRlbGF5XCIsIDApXG4gICAgICAgIGVuZFxuICAgICAgICBhZGRCYXNlTWFya2VySWZOZWVkZWQobWFya2VyS2V5LCBpc1BhdXNlZClcbiAgICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTG9jayhqb2JLZXksIHN0YWxsZWRLZXksIHRva2VuLCBqb2JJZClcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIGxvY2FsIGxvY2tUb2tlbiA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgLS0gTG9jayBleGlzdHMgYnV0IHRva2VuIGRvZXMgbm90IG1hdGNoXG4gICAgICAgIHJldHVybiAtNlxuICAgICAgZWxzZVxuICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICByZXR1cm4gLTJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byB1cGRhdGUgYSBidW5jaCBvZiBmaWVsZHMgaW4gYSBqb2IuXG5dXVxubG9jYWwgZnVuY3Rpb24gdXBkYXRlSm9iRmllbGRzKGpvYktleSwgbXNncGFja2VkRmllbGRzKVxuICBpZiBtc2dwYWNrZWRGaWVsZHMgYW5kICNtc2dwYWNrZWRGaWVsZHMgPiAwIHRoZW5cbiAgICBsb2NhbCBmaWVsZHNUb1VwZGF0ZSA9IGNtc2dwYWNrLnVucGFjayhtc2dwYWNrZWRGaWVsZHMpXG4gICAgaWYgZmllbGRzVG9VcGRhdGUgdGhlblxuICAgICAgcmNhbGwoXCJITVNFVFwiLCBqb2JLZXksIHVucGFjayhmaWVsZHNUb1VwZGF0ZSkpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCB0YXJnZXQsIGlzUGF1c2VkT3JNYXhlZCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzVdLCBLRVlTWzFdLCBLRVlTWzJdLCBLRVlTWzNdKVxubG9jYWwgbWFya2VyS2V5ID0gS0VZU1sxMF1cbi0tIENoZWNrIGlmIHRoZXJlIGFyZSBkZWxheWVkIGpvYnMgdGhhdCB3ZSBjYW4gbW92ZSB0byB3YWl0LlxuLS0gdGVzdCBleGFtcGxlOiB3aGVuIHRoZXJlIGFyZSBkZWxheWVkIGpvYnMgYmV0d2VlbiByZXRyaWVzXG5wcm9tb3RlRGVsYXllZEpvYnMoS0VZU1s3XSwgbWFya2VyS2V5LCB0YXJnZXQsIEtFWVNbOF0sIEtFWVNbNl0sIEFSR1ZbMV0sIEFSR1ZbMl0sIEtFWVNbOV0sIGlzUGF1c2VkT3JNYXhlZClcbmxvY2FsIGpvYktleSA9IEtFWVNbNF1cbmlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSkgPT0gMSB0aGVuXG4gIGxvY2FsIGVycm9yQ29kZSA9IHJlbW92ZUxvY2soam9iS2V5LCBLRVlTWzExXSwgQVJHVls1XSwgQVJHVls0XSkgXG4gIGlmIGVycm9yQ29kZSA8IDAgdGhlblxuICAgIHJldHVybiBlcnJvckNvZGVcbiAgZW5kXG4gIHVwZGF0ZUpvYkZpZWxkcyhqb2JLZXksIEFSR1ZbNl0pXG4gIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAtMSwgQVJHVls0XSlcbiAgaWYgKG51bVJlbW92ZWRFbGVtZW50cyA8IDEpIHRoZW4gcmV0dXJuIC0zIGVuZFxuICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgLS1uZWVkIHRvIHJlLWV2YWx1YXRlIGFmdGVyIHJlbW92aW5nIGpvYiBmcm9tIGFjdGl2ZVxuICBpc1BhdXNlZE9yTWF4ZWQgPSBpc1F1ZXVlUGF1c2VkT3JNYXhlZChLRVlTWzVdLCBLRVlTWzFdKVxuICAtLSBTdGFuZGFyZCBvciBwcmlvcml0eSBhZGRcbiAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgYWRkSm9iSW5UYXJnZXRMaXN0KHRhcmdldCwgbWFya2VyS2V5LCBBUkdWWzNdLCBpc1BhdXNlZE9yTWF4ZWQsIEFSR1ZbNF0pXG4gIGVsc2VcbiAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBLRVlTWzhdLCBwcmlvcml0eSwgQVJHVls0XSwgS0VZU1s5XSwgaXNQYXVzZWRPck1heGVkKVxuICBlbmRcbiAgcmNhbGwoXCJISU5DUkJZXCIsIGpvYktleSwgXCJhdG1cIiwgMSlcbiAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMoS0VZU1s1XSlcbiAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50XG4gIHJjYWxsKFwiWEFERFwiLCBLRVlTWzZdLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcIndhaXRpbmdcIixcbiAgICBcImpvYklkXCIsIEFSR1ZbNF0sIFwicHJldlwiLCBcImFjdGl2ZVwiKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCByZXRyeUpvYiA9IHtcbiAgICBuYW1lOiAncmV0cnlKb2InLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMTEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlKb2ItMTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/retryJob-11.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   saveStacktrace: () => (/* binding */ saveStacktrace)\n/* harmony export */ });\nconst content = `--[[\n  Save stacktrace and failedReason.\n  Input:\n    KEYS[1] job key\n    ARGV[1]  stacktrace\n    ARGV[2]  failedReason\n  Output:\n     0 - OK\n    -1 - Missing key\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"HMSET\", KEYS[1], \"stacktrace\", ARGV[1], \"failedReason\", ARGV[2])\n  return 0\nelse\n  return -1\nend\n`;\nconst saveStacktrace = {\n    name: 'saveStacktrace',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=saveStacktrace-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvc2F2ZVN0YWNrdHJhY2UtMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy9zYXZlU3RhY2t0cmFjZS0xLmpzPzFkYWUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFNhdmUgc3RhY2t0cmFjZSBhbmQgZmFpbGVkUmVhc29uLlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGpvYiBrZXlcbiAgICBBUkdWWzFdICBzdGFja3RyYWNlXG4gICAgQVJHVlsyXSAgZmFpbGVkUmVhc29uXG4gIE91dHB1dDpcbiAgICAgMCAtIE9LXG4gICAgLTEgLSBNaXNzaW5nIGtleVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuXG4gIHJjYWxsKFwiSE1TRVRcIiwgS0VZU1sxXSwgXCJzdGFja3RyYWNlXCIsIEFSR1ZbMV0sIFwiZmFpbGVkUmVhc29uXCIsIEFSR1ZbMl0pXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xuZXhwb3J0IGNvbnN0IHNhdmVTdGFja3RyYWNlID0ge1xuICAgIG5hbWU6ICdzYXZlU3RhY2t0cmFjZScsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhdmVTdGFja3RyYWNlLTEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/saveStacktrace-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateData-1.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateData: () => (/* binding */ updateData)\n/* harmony export */ });\nconst content = `--[[\n  Update job data\n  Input:\n    KEYS[1] Job id key\n    ARGV[1] data\n  Output:\n    0 - OK\n   -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\",KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"data\", ARGV[1])\n  return 0\nelse\n  return -1\nend\n`;\nconst updateData = {\n    name: 'updateData',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=updateData-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlRGF0YS0xLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vc2NyaXB0cy91cGRhdGVEYXRhLTEuanM/MDk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBkYXRhXG4gIElucHV0OlxuICAgIEtFWVNbMV0gSm9iIGlkIGtleVxuICAgIEFSR1ZbMV0gZGF0YVxuICBPdXRwdXQ6XG4gICAgMCAtIE9LXG4gICAtMSAtIE1pc3Npbmcgam9iLlxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIixLRVlTWzFdKSA9PSAxIHRoZW4gLS0gLy8gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwiZGF0YVwiLCBBUkdWWzFdKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCB1cGRhdGVEYXRhID0ge1xuICAgIG5hbWU6ICd1cGRhdGVEYXRhJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlRGF0YS0xLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateData-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateJobScheduler-12.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateJobScheduler-12.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateJobScheduler: () => (/* binding */ updateJobScheduler)\n/* harmony export */ });\nconst content = `--[[\n  Updates a job scheduler and adds next delayed job\n  Input:\n    KEYS[1]  'repeat' key\n    KEYS[2]  'delayed'\n    KEYS[3]  'wait' key\n    KEYS[4]  'paused' key\n    KEYS[5]  'meta'\n    KEYS[6]  'prioritized' key\n    KEYS[7]  'marker',\n    KEYS[8]  'id'\n    KEYS[9]  events stream key\n    KEYS[10] 'pc' priority counter\n    KEYS[11] producer key\n    KEYS[12] 'active' key\n    ARGV[1] next milliseconds\n    ARGV[2] jobs scheduler id\n    ARGV[3] Json stringified delayed data\n    ARGV[4] msgpacked delayed opts\n    ARGV[5] timestamp\n    ARGV[6] prefix key\n    ARGV[7] producer id\n    Output:\n      next delayed job id  - OK\n]] local rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal delayedKey = KEYS[2]\nlocal waitKey = KEYS[3]\nlocal pausedKey = KEYS[4]\nlocal metaKey = KEYS[5]\nlocal prioritizedKey = KEYS[6]\nlocal nextMillis = tonumber(ARGV[1])\nlocal jobSchedulerId = ARGV[2]\nlocal timestamp = tonumber(ARGV[5])\nlocal prefixKey = ARGV[6]\nlocal producerId = ARGV[7]\nlocal jobOpts = cmsgpack.unpack(ARGV[4])\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Adds a delayed job to the queue by doing the following:\n    - Creates a new job key with the job data.\n    - adds to delayed zset.\n    - Emits a global event 'delayed' if the job is delayed.\n]]\n-- Includes\n--[[\n  Add delay marker if needed.\n]]\n-- Includes\n--[[\n  Function to return the next delayed job timestamp.\n]]\nlocal function getNextDelayedTimestamp(delayedKey)\n  local result = rcall(\"ZRANGE\", delayedKey, 0, 0, \"WITHSCORES\")\n  if #result then\n    local nextTimestamp = tonumber(result[2])\n    if nextTimestamp ~= nil then\n      return nextTimestamp / 0x1000\n    end\n  end\nend\nlocal function addDelayMarkerIfNeeded(markerKey, delayedKey)\n  local nextTimestamp = getNextDelayedTimestamp(delayedKey)\n  if nextTimestamp ~= nil then\n    -- Replace the score of the marker with the newest known\n    -- next timestamp.\n    rcall(\"ZADD\", markerKey, nextTimestamp, \"1\")\n  end\nend\n--[[\n  Bake in the job id first 12 bits into the timestamp\n  to guarantee correct execution order of delayed jobs\n  (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n  WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n]]\nlocal function getDelayedScore(delayedKey, timestamp, delay)\n  local delayedTimestamp = (delay > 0 and (tonumber(timestamp) + delay)) or tonumber(timestamp)\n  local minScore = delayedTimestamp * 0x1000\n  local maxScore = (delayedTimestamp + 1 ) * 0x1000 - 1\n  local result = rcall(\"ZREVRANGEBYSCORE\", delayedKey, maxScore,\n    minScore, \"WITHSCORES\",\"LIMIT\", 0, 1)\n  if #result then\n    local currentMaxScore = tonumber(result[2])\n    if currentMaxScore ~= nil then\n      if currentMaxScore >= maxScore then\n        return maxScore, delayedTimestamp\n      else\n        return currentMaxScore + 1, delayedTimestamp\n      end\n    end\n  end\n  return minScore, delayedTimestamp\nend\nlocal function addDelayedJob(jobId, delayedKey, eventsKey, timestamp,\n  maxEvents, markerKey, delay)\n  local score, delayedTimestamp = getDelayedScore(delayedKey, timestamp, tonumber(delay))\n  rcall(\"ZADD\", delayedKey, score, jobId)\n  rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"delayed\",\n    \"jobId\", jobId, \"delay\", delayedTimestamp)\n  -- mark that a delayed job is available\n  addDelayMarkerIfNeeded(markerKey, delayedKey)\nend\n--[[\n  Function to add job considering priority.\n]]\n-- Includes\n--[[\n  Add marker if needed when a job is available.\n]]\nlocal function addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\n  if not isPausedOrMaxed then\n    rcall(\"ZADD\", markerKey, 0, \"0\")\n  end  \nend\n--[[\n  Function to get priority score.\n]]\nlocal function getPriorityScore(priority, priorityCounterKey)\n  local prioCounter = rcall(\"INCR\", priorityCounterKey)\n  return priority * 0x100000000 + prioCounter % 0x100000000\nend\nlocal function addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounterKey,\n  isPausedOrMaxed)\n  local score = getPriorityScore(priority, priorityCounterKey)\n  rcall(\"ZADD\", prioritizedKey, score, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function isQueuePaused(queueMetaKey)\n  return rcall(\"HEXISTS\", queueMetaKey, \"paused\") == 1\nend\n--[[\n  Function to store a job\n]]\nlocal function storeJob(eventsKey, jobIdKey, jobId, name, data, opts, timestamp,\n                        parentKey, parentData, repeatJobKey)\n    local jsonOpts = cjson.encode(opts)\n    local delay = opts['delay'] or 0\n    local priority = opts['priority'] or 0\n    local debounceId = opts['de'] and opts['de']['id']\n    local optionalValues = {}\n    if parentKey ~= nil then\n        table.insert(optionalValues, \"parentKey\")\n        table.insert(optionalValues, parentKey)\n        table.insert(optionalValues, \"parent\")\n        table.insert(optionalValues, parentData)\n    end\n    if repeatJobKey then\n        table.insert(optionalValues, \"rjk\")\n        table.insert(optionalValues, repeatJobKey)\n    end\n    if debounceId then\n        table.insert(optionalValues, \"deid\")\n        table.insert(optionalValues, debounceId)\n    end\n    rcall(\"HMSET\", jobIdKey, \"name\", name, \"data\", data, \"opts\", jsonOpts,\n          \"timestamp\", timestamp, \"delay\", delay, \"priority\", priority,\n          unpack(optionalValues))\n    rcall(\"XADD\", eventsKey, \"*\", \"event\", \"added\", \"jobId\", jobId, \"name\", name)\n    return delay, priority\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, activeKey, waitKey, pausedKey)\n  local queueAttributes = rcall(\"HMGET\", queueMetaKey, \"paused\", \"concurrency\", \"max\", \"duration\")\n  if queueAttributes[1] then\n    return pausedKey, true, queueAttributes[3], queueAttributes[4]\n  else\n    if queueAttributes[2] then\n      local activeCount = rcall(\"LLEN\", activeKey)\n      if activeCount >= tonumber(queueAttributes[2]) then\n        return waitKey, true, queueAttributes[3], queueAttributes[4]\n      else\n        return waitKey, false, queueAttributes[3], queueAttributes[4]\n      end\n    end\n  end\n  return waitKey, false, queueAttributes[3], queueAttributes[4]\nend\n--[[\n  Function to add job in target list and add marker if needed.\n]]\n-- Includes\nlocal function addJobInTargetList(targetKey, markerKey, pushCmd, isPausedOrMaxed, jobId)\n  rcall(pushCmd, targetKey, jobId)\n  addBaseMarkerIfNeeded(markerKey, isPausedOrMaxed)\nend\nlocal function addJobFromScheduler(jobKey, jobId, opts, waitKey, pausedKey, activeKey, metaKey, \n  prioritizedKey, priorityCounter, delayedKey, markerKey, eventsKey, name, maxEvents, timestamp,\n  data, jobSchedulerId, repeatDelay)\n  opts['delay'] = repeatDelay\n  opts['jobId'] = jobId\n  local delay, priority = storeJob(eventsKey, jobKey, jobId, name, data,\n    opts, timestamp, nil, nil, jobSchedulerId)\n  if delay ~= 0 then\n    addDelayedJob(jobId, delayedKey, eventsKey, timestamp, maxEvents, markerKey, delay)\n  else\n    local target, isPausedOrMaxed = getTargetQueueList(metaKey, activeKey, waitKey, pausedKey)\n    -- Standard or priority add\n    if priority == 0 then\n      local pushCmd = opts['lifo'] and 'RPUSH' or 'LPUSH'\n      addJobInTargetList(target, markerKey, pushCmd, isPausedOrMaxed, jobId)\n    else\n      -- Priority add\n      addJobWithPriority(markerKey, prioritizedKey, priority, jobId, priorityCounter, isPausedOrMaxed)\n    end\n    -- Emit waiting event\n    rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents,  \"*\", \"event\", \"waiting\", \"jobId\", jobId)\n  end\nend\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nlocal function getJobSchedulerEveryNextMillis(prevMillis, every, now, offset, startDate)\n    local nextMillis\n    if not prevMillis then\n        if startDate then\n            -- Assuming startDate is passed as milliseconds from JavaScript\n            nextMillis = tonumber(startDate)\n            nextMillis = nextMillis > now and nextMillis or now\n        else\n            nextMillis = now\n        end\n    else\n        nextMillis = prevMillis + every\n        -- check if we may have missed some iterations\n        if nextMillis < now then\n            nextMillis = math.floor(now / every) * every + every + (offset or 0)\n        end\n    end\n    if not offset or offset == 0 then\n        local timeSlot = math.floor(nextMillis / every) * every;\n        offset = nextMillis - timeSlot;\n    end\n    -- Return a tuple nextMillis, offset\n    return math.floor(nextMillis), math.floor(offset)\nend\nlocal prevMillis = rcall(\"ZSCORE\", repeatKey, jobSchedulerId)\n-- Validate that scheduler exists.\n-- If it does not exist we should not iterate anymore.\nif prevMillis then\n    prevMillis = tonumber(prevMillis)\n    local schedulerKey = repeatKey .. \":\" .. jobSchedulerId\n    local schedulerAttributes = rcall(\"HMGET\", schedulerKey, \"name\", \"data\", \"every\", \"startDate\", \"offset\")\n    local every = tonumber(schedulerAttributes[3])\n    local now = tonumber(timestamp)\n    -- If every is not found in scheduler attributes, try to get it from job options\n    if not every and jobOpts['repeat'] and jobOpts['repeat']['every'] then\n        every = tonumber(jobOpts['repeat']['every'])\n    end\n    if every then\n        local startDate = schedulerAttributes[4]\n        local jobOptsOffset = jobOpts['repeat'] and jobOpts['repeat']['offset'] or 0\n        local offset = schedulerAttributes[5] or jobOptsOffset or 0\n        local newOffset\n        nextMillis, newOffset = getJobSchedulerEveryNextMillis(prevMillis, every, now, offset, startDate)\n        if not offset then\n            rcall(\"HSET\", schedulerKey, \"offset\", newOffset)\n            jobOpts['repeat']['offset'] = newOffset\n        end\n    end\n    local nextDelayedJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. nextMillis\n    local nextDelayedJobKey = schedulerKey .. \":\" .. nextMillis\n    local currentDelayedJobId = \"repeat:\" .. jobSchedulerId .. \":\" .. prevMillis\n    if producerId == currentDelayedJobId then\n        local eventsKey = KEYS[9]\n        local maxEvents = getOrSetMaxEvents(metaKey)\n        if rcall(\"EXISTS\", nextDelayedJobKey) ~= 1 then\n            rcall(\"ZADD\", repeatKey, nextMillis, jobSchedulerId)\n            rcall(\"HINCRBY\", schedulerKey, \"ic\", 1)\n            rcall(\"INCR\", KEYS[8])\n            -- TODO: remove this workaround in next breaking change,\n            -- all job-schedulers must save job data\n            local templateData = schedulerAttributes[2] or ARGV[3]\n            if templateData and templateData ~= '{}' then\n                rcall(\"HSET\", schedulerKey, \"data\", templateData)\n            end\n            local delay = nextMillis - now\n            -- Fast Clamp delay to minimum of 0\n            if delay < 0 then\n                delay = 0\n            end\n            jobOpts[\"delay\"] = delay\n            addJobFromScheduler(nextDelayedJobKey, nextDelayedJobId, jobOpts, waitKey, pausedKey, KEYS[12], metaKey,\n                prioritizedKey, KEYS[10], delayedKey, KEYS[7], eventsKey, schedulerAttributes[1], maxEvents, ARGV[5],\n                templateData or '{}', jobSchedulerId, delay)\n            -- TODO: remove this workaround in next breaking change\n            if KEYS[11] ~= \"\" then\n                rcall(\"HSET\", KEYS[11], \"nrjid\", nextDelayedJobId)\n            end\n            return nextDelayedJobId .. \"\" -- convert to string\n        else\n            rcall(\"XADD\", eventsKey, \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"duplicated\", \"jobId\", nextDelayedJobId)\n        end\n    end\nend\n`;\nconst updateJobScheduler = {\n    name: 'updateJobScheduler',\n    content,\n    keys: 12,\n};\n//# sourceMappingURL=updateJobScheduler-12.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlSm9iU2NoZWR1bGVyLTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlSm9iU2NoZWR1bGVyLTEyLmpzP2UwYmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFVwZGF0ZXMgYSBqb2Igc2NoZWR1bGVyIGFuZCBhZGRzIG5leHQgZGVsYXllZCBqb2JcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSAgJ3JlcGVhdCcga2V5XG4gICAgS0VZU1syXSAgJ2RlbGF5ZWQnXG4gICAgS0VZU1szXSAgJ3dhaXQnIGtleVxuICAgIEtFWVNbNF0gICdwYXVzZWQnIGtleVxuICAgIEtFWVNbNV0gICdtZXRhJ1xuICAgIEtFWVNbNl0gICdwcmlvcml0aXplZCcga2V5XG4gICAgS0VZU1s3XSAgJ21hcmtlcicsXG4gICAgS0VZU1s4XSAgJ2lkJ1xuICAgIEtFWVNbOV0gIGV2ZW50cyBzdHJlYW0ga2V5XG4gICAgS0VZU1sxMF0gJ3BjJyBwcmlvcml0eSBjb3VudGVyXG4gICAgS0VZU1sxMV0gcHJvZHVjZXIga2V5XG4gICAgS0VZU1sxMl0gJ2FjdGl2ZScga2V5XG4gICAgQVJHVlsxXSBuZXh0IG1pbGxpc2Vjb25kc1xuICAgIEFSR1ZbMl0gam9icyBzY2hlZHVsZXIgaWRcbiAgICBBUkdWWzNdIEpzb24gc3RyaW5naWZpZWQgZGVsYXllZCBkYXRhXG4gICAgQVJHVls0XSBtc2dwYWNrZWQgZGVsYXllZCBvcHRzXG4gICAgQVJHVls1XSB0aW1lc3RhbXBcbiAgICBBUkdWWzZdIHByZWZpeCBrZXlcbiAgICBBUkdWWzddIHByb2R1Y2VyIGlkXG4gICAgT3V0cHV0OlxuICAgICAgbmV4dCBkZWxheWVkIGpvYiBpZCAgLSBPS1xuXV0gbG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5sb2NhbCByZXBlYXRLZXkgPSBLRVlTWzFdXG5sb2NhbCBkZWxheWVkS2V5ID0gS0VZU1syXVxubG9jYWwgd2FpdEtleSA9IEtFWVNbM11cbmxvY2FsIHBhdXNlZEtleSA9IEtFWVNbNF1cbmxvY2FsIG1ldGFLZXkgPSBLRVlTWzVdXG5sb2NhbCBwcmlvcml0aXplZEtleSA9IEtFWVNbNl1cbmxvY2FsIG5leHRNaWxsaXMgPSB0b251bWJlcihBUkdWWzFdKVxubG9jYWwgam9iU2NoZWR1bGVySWQgPSBBUkdWWzJdXG5sb2NhbCB0aW1lc3RhbXAgPSB0b251bWJlcihBUkdWWzVdKVxubG9jYWwgcHJlZml4S2V5ID0gQVJHVls2XVxubG9jYWwgcHJvZHVjZXJJZCA9IEFSR1ZbN11cbmxvY2FsIGpvYk9wdHMgPSBjbXNncGFjay51bnBhY2soQVJHVls0XSlcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBkZWxheSBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZHMgYSBkZWxheWVkIGpvYiB0byB0aGUgcXVldWUgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAgICAtIENyZWF0ZXMgYSBuZXcgam9iIGtleSB3aXRoIHRoZSBqb2IgZGF0YS5cbiAgICAtIGFkZHMgdG8gZGVsYXllZCB6c2V0LlxuICAgIC0gRW1pdHMgYSBnbG9iYWwgZXZlbnQgJ2RlbGF5ZWQnIGlmIHRoZSBqb2IgaXMgZGVsYXllZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBBZGQgZGVsYXkgbWFya2VyIGlmIG5lZWRlZC5cbl1dXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZXR1cm4gdGhlIG5leHQgZGVsYXllZCBqb2IgdGltZXN0YW1wLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJBTkdFXCIsIGRlbGF5ZWRLZXksIDAsIDAsIFwiV0lUSFNDT1JFU1wiKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBuZXh0VGltZXN0YW1wID0gdG9udW1iZXIocmVzdWx0WzJdKVxuICAgIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAgIHJldHVybiBuZXh0VGltZXN0YW1wIC8gMHgxMDAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbiAgbG9jYWwgbmV4dFRpbWVzdGFtcCA9IGdldE5leHREZWxheWVkVGltZXN0YW1wKGRlbGF5ZWRLZXkpXG4gIGlmIG5leHRUaW1lc3RhbXAgfj0gbmlsIHRoZW5cbiAgICAtLSBSZXBsYWNlIHRoZSBzY29yZSBvZiB0aGUgbWFya2VyIHdpdGggdGhlIG5ld2VzdCBrbm93blxuICAgIC0tIG5leHQgdGltZXN0YW1wLlxuICAgIHJjYWxsKFwiWkFERFwiLCBtYXJrZXJLZXksIG5leHRUaW1lc3RhbXAsIFwiMVwiKVxuICBlbmRcbmVuZFxuLS1bW1xuICBCYWtlIGluIHRoZSBqb2IgaWQgZmlyc3QgMTIgYml0cyBpbnRvIHRoZSB0aW1lc3RhbXBcbiAgdG8gZ3VhcmFudGVlIGNvcnJlY3QgZXhlY3V0aW9uIG9yZGVyIG9mIGRlbGF5ZWQgam9ic1xuICAodXAgdG8gNDA5NiBqb2JzIHBlciBnaXZlbiB0aW1lc3RhbXAgb3IgNDA5NiBqb2JzIGFwYXJ0IHBlciB0aW1lc3RhbXApXG4gIFdBUk5JTkc6IEpvYnMgdGhhdCBhcmUgc28gZmFyIGFwYXJ0IHRoYXQgdGhleSB3cmFwIGFyb3VuZCB3aWxsIGNhdXNlIEZJRk8gdG8gZmFpbFxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldERlbGF5ZWRTY29yZShkZWxheWVkS2V5LCB0aW1lc3RhbXAsIGRlbGF5KVxuICBsb2NhbCBkZWxheWVkVGltZXN0YW1wID0gKGRlbGF5ID4gMCBhbmQgKHRvbnVtYmVyKHRpbWVzdGFtcCkgKyBkZWxheSkpIG9yIHRvbnVtYmVyKHRpbWVzdGFtcClcbiAgbG9jYWwgbWluU2NvcmUgPSBkZWxheWVkVGltZXN0YW1wICogMHgxMDAwXG4gIGxvY2FsIG1heFNjb3JlID0gKGRlbGF5ZWRUaW1lc3RhbXAgKyAxICkgKiAweDEwMDAgLSAxXG4gIGxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiWlJFVlJBTkdFQllTQ09SRVwiLCBkZWxheWVkS2V5LCBtYXhTY29yZSxcbiAgICBtaW5TY29yZSwgXCJXSVRIU0NPUkVTXCIsXCJMSU1JVFwiLCAwLCAxKVxuICBpZiAjcmVzdWx0IHRoZW5cbiAgICBsb2NhbCBjdXJyZW50TWF4U2NvcmUgPSB0b251bWJlcihyZXN1bHRbMl0pXG4gICAgaWYgY3VycmVudE1heFNjb3JlIH49IG5pbCB0aGVuXG4gICAgICBpZiBjdXJyZW50TWF4U2NvcmUgPj0gbWF4U2NvcmUgdGhlblxuICAgICAgICByZXR1cm4gbWF4U2NvcmUsIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRNYXhTY29yZSArIDEsIGRlbGF5ZWRUaW1lc3RhbXBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIG1pblNjb3JlLCBkZWxheWVkVGltZXN0YW1wXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGFkZERlbGF5ZWRKb2Ioam9iSWQsIGRlbGF5ZWRLZXksIGV2ZW50c0tleSwgdGltZXN0YW1wLFxuICBtYXhFdmVudHMsIG1hcmtlcktleSwgZGVsYXkpXG4gIGxvY2FsIHNjb3JlLCBkZWxheWVkVGltZXN0YW1wID0gZ2V0RGVsYXllZFNjb3JlKGRlbGF5ZWRLZXksIHRpbWVzdGFtcCwgdG9udW1iZXIoZGVsYXkpKVxuICByY2FsbChcIlpBRERcIiwgZGVsYXllZEtleSwgc2NvcmUsIGpvYklkKVxuICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImRlbGF5ZWRcIixcbiAgICBcImpvYklkXCIsIGpvYklkLCBcImRlbGF5XCIsIGRlbGF5ZWRUaW1lc3RhbXApXG4gIC0tIG1hcmsgdGhhdCBhIGRlbGF5ZWQgam9iIGlzIGF2YWlsYWJsZVxuICBhZGREZWxheU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgZGVsYXllZEtleSlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEFkZCBtYXJrZXIgaWYgbmVlZGVkIHdoZW4gYSBqb2IgaXMgYXZhaWxhYmxlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbiAgaWYgbm90IGlzUGF1c2VkT3JNYXhlZCB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIG1hcmtlcktleSwgMCwgXCIwXCIpXG4gIGVuZCAgXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZ2V0IHByaW9yaXR5IHNjb3JlLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFByaW9yaXR5U2NvcmUocHJpb3JpdHksIHByaW9yaXR5Q291bnRlcktleSlcbiAgbG9jYWwgcHJpb0NvdW50ZXIgPSByY2FsbChcIklOQ1JcIiwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByZXR1cm4gcHJpb3JpdHkgKiAweDEwMDAwMDAwMCArIHByaW9Db3VudGVyICUgMHgxMDAwMDAwMDBcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KG1hcmtlcktleSwgcHJpb3JpdGl6ZWRLZXksIHByaW9yaXR5LCBqb2JJZCwgcHJpb3JpdHlDb3VudGVyS2V5LFxuICBpc1BhdXNlZE9yTWF4ZWQpXG4gIGxvY2FsIHNjb3JlID0gZ2V0UHJpb3JpdHlTY29yZShwcmlvcml0eSwgcHJpb3JpdHlDb3VudGVyS2V5KVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdGl6ZWRLZXksIHNjb3JlLCBqb2JJZClcbiAgYWRkQmFzZU1hcmtlcklmTmVlZGVkKG1hcmtlcktleSwgaXNQYXVzZWRPck1heGVkKVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gaXNRdWV1ZVBhdXNlZChxdWV1ZU1ldGFLZXkpXG4gIHJldHVybiByY2FsbChcIkhFWElTVFNcIiwgcXVldWVNZXRhS2V5LCBcInBhdXNlZFwiKSA9PSAxXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gc3RvcmUgYSBqb2Jcbl1dXG5sb2NhbCBmdW5jdGlvbiBzdG9yZUpvYihldmVudHNLZXksIGpvYklkS2V5LCBqb2JJZCwgbmFtZSwgZGF0YSwgb3B0cywgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5LCBwYXJlbnREYXRhLCByZXBlYXRKb2JLZXkpXG4gICAgbG9jYWwganNvbk9wdHMgPSBjanNvbi5lbmNvZGUob3B0cylcbiAgICBsb2NhbCBkZWxheSA9IG9wdHNbJ2RlbGF5J10gb3IgMFxuICAgIGxvY2FsIHByaW9yaXR5ID0gb3B0c1sncHJpb3JpdHknXSBvciAwXG4gICAgbG9jYWwgZGVib3VuY2VJZCA9IG9wdHNbJ2RlJ10gYW5kIG9wdHNbJ2RlJ11bJ2lkJ11cbiAgICBsb2NhbCBvcHRpb25hbFZhbHVlcyA9IHt9XG4gICAgaWYgcGFyZW50S2V5IH49IG5pbCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRLZXlcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnRLZXkpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJwYXJlbnRcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBwYXJlbnREYXRhKVxuICAgIGVuZFxuICAgIGlmIHJlcGVhdEpvYktleSB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJyamtcIilcbiAgICAgICAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCByZXBlYXRKb2JLZXkpXG4gICAgZW5kXG4gICAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgXCJkZWlkXCIpXG4gICAgICAgIHRhYmxlLmluc2VydChvcHRpb25hbFZhbHVlcywgZGVib3VuY2VJZClcbiAgICBlbmRcbiAgICByY2FsbChcIkhNU0VUXCIsIGpvYklkS2V5LCBcIm5hbWVcIiwgbmFtZSwgXCJkYXRhXCIsIGRhdGEsIFwib3B0c1wiLCBqc29uT3B0cyxcbiAgICAgICAgICBcInRpbWVzdGFtcFwiLCB0aW1lc3RhbXAsIFwiZGVsYXlcIiwgZGVsYXksIFwicHJpb3JpdHlcIiwgcHJpb3JpdHksXG4gICAgICAgICAgdW5wYWNrKG9wdGlvbmFsVmFsdWVzKSlcbiAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIipcIiwgXCJldmVudFwiLCBcImFkZGVkXCIsIFwiam9iSWRcIiwgam9iSWQsIFwibmFtZVwiLCBuYW1lKVxuICAgIHJldHVybiBkZWxheSwgcHJpb3JpdHlcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBsb2NhbCBxdWV1ZUF0dHJpYnV0ZXMgPSByY2FsbChcIkhNR0VUXCIsIHF1ZXVlTWV0YUtleSwgXCJwYXVzZWRcIiwgXCJjb25jdXJyZW5jeVwiLCBcIm1heFwiLCBcImR1cmF0aW9uXCIpXG4gIGlmIHF1ZXVlQXR0cmlidXRlc1sxXSB0aGVuXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgZWxzZVxuICAgIGlmIHF1ZXVlQXR0cmlidXRlc1syXSB0aGVuXG4gICAgICBsb2NhbCBhY3RpdmVDb3VudCA9IHJjYWxsKFwiTExFTlwiLCBhY3RpdmVLZXkpXG4gICAgICBpZiBhY3RpdmVDb3VudCA+PSB0b251bWJlcihxdWV1ZUF0dHJpYnV0ZXNbMl0pIHRoZW5cbiAgICAgICAgcmV0dXJuIHdhaXRLZXksIHRydWUsIHF1ZXVlQXR0cmlidXRlc1szXSwgcXVldWVBdHRyaWJ1dGVzWzRdXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZSwgcXVldWVBdHRyaWJ1dGVzWzNdLCBxdWV1ZUF0dHJpYnV0ZXNbNF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIHdhaXRLZXksIGZhbHNlLCBxdWV1ZUF0dHJpYnV0ZXNbM10sIHF1ZXVlQXR0cmlidXRlc1s0XVxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgaW4gdGFyZ2V0IGxpc3QgYW5kIGFkZCBtYXJrZXIgaWYgbmVlZGVkLlxuXV1cbi0tIEluY2x1ZGVzXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0S2V5LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gIHJjYWxsKHB1c2hDbWQsIHRhcmdldEtleSwgam9iSWQpXG4gIGFkZEJhc2VNYXJrZXJJZk5lZWRlZChtYXJrZXJLZXksIGlzUGF1c2VkT3JNYXhlZClcbmVuZFxubG9jYWwgZnVuY3Rpb24gYWRkSm9iRnJvbVNjaGVkdWxlcihqb2JLZXksIGpvYklkLCBvcHRzLCB3YWl0S2V5LCBwYXVzZWRLZXksIGFjdGl2ZUtleSwgbWV0YUtleSwgXG4gIHByaW9yaXRpemVkS2V5LCBwcmlvcml0eUNvdW50ZXIsIGRlbGF5ZWRLZXksIG1hcmtlcktleSwgZXZlbnRzS2V5LCBuYW1lLCBtYXhFdmVudHMsIHRpbWVzdGFtcCxcbiAgZGF0YSwgam9iU2NoZWR1bGVySWQsIHJlcGVhdERlbGF5KVxuICBvcHRzWydkZWxheSddID0gcmVwZWF0RGVsYXlcbiAgb3B0c1snam9iSWQnXSA9IGpvYklkXG4gIGxvY2FsIGRlbGF5LCBwcmlvcml0eSA9IHN0b3JlSm9iKGV2ZW50c0tleSwgam9iS2V5LCBqb2JJZCwgbmFtZSwgZGF0YSxcbiAgICBvcHRzLCB0aW1lc3RhbXAsIG5pbCwgbmlsLCBqb2JTY2hlZHVsZXJJZClcbiAgaWYgZGVsYXkgfj0gMCB0aGVuXG4gICAgYWRkRGVsYXllZEpvYihqb2JJZCwgZGVsYXllZEtleSwgZXZlbnRzS2V5LCB0aW1lc3RhbXAsIG1heEV2ZW50cywgbWFya2VyS2V5LCBkZWxheSlcbiAgZWxzZVxuICAgIGxvY2FsIHRhcmdldCwgaXNQYXVzZWRPck1heGVkID0gZ2V0VGFyZ2V0UXVldWVMaXN0KG1ldGFLZXksIGFjdGl2ZUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICAgIC0tIFN0YW5kYXJkIG9yIHByaW9yaXR5IGFkZFxuICAgIGlmIHByaW9yaXR5ID09IDAgdGhlblxuICAgICAgbG9jYWwgcHVzaENtZCA9IG9wdHNbJ2xpZm8nXSBhbmQgJ1JQVVNIJyBvciAnTFBVU0gnXG4gICAgICBhZGRKb2JJblRhcmdldExpc3QodGFyZ2V0LCBtYXJrZXJLZXksIHB1c2hDbWQsIGlzUGF1c2VkT3JNYXhlZCwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgLS0gUHJpb3JpdHkgYWRkXG4gICAgICBhZGRKb2JXaXRoUHJpb3JpdHkobWFya2VyS2V5LCBwcmlvcml0aXplZEtleSwgcHJpb3JpdHksIGpvYklkLCBwcmlvcml0eUNvdW50ZXIsIGlzUGF1c2VkT3JNYXhlZClcbiAgICBlbmRcbiAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnRcbiAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCAgXCIqXCIsIFwiZXZlbnRcIiwgXCJ3YWl0aW5nXCIsIFwiam9iSWRcIiwgam9iSWQpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGdldCBtYXggZXZlbnRzIHZhbHVlIG9yIHNldCBieSBkZWZhdWx0IDEwMDAwLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gIGxvY2FsIG1heEV2ZW50cyA9IHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIpXG4gIGlmIG5vdCBtYXhFdmVudHMgdGhlblxuICAgIG1heEV2ZW50cyA9IDEwMDAwXG4gICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwib3B0cy5tYXhMZW5FdmVudHNcIiwgbWF4RXZlbnRzKVxuICBlbmRcbiAgcmV0dXJuIG1heEV2ZW50c1xuZW5kXG5sb2NhbCBmdW5jdGlvbiBnZXRKb2JTY2hlZHVsZXJFdmVyeU5leHRNaWxsaXMocHJldk1pbGxpcywgZXZlcnksIG5vdywgb2Zmc2V0LCBzdGFydERhdGUpXG4gICAgbG9jYWwgbmV4dE1pbGxpc1xuICAgIGlmIG5vdCBwcmV2TWlsbGlzIHRoZW5cbiAgICAgICAgaWYgc3RhcnREYXRlIHRoZW5cbiAgICAgICAgICAgIC0tIEFzc3VtaW5nIHN0YXJ0RGF0ZSBpcyBwYXNzZWQgYXMgbWlsbGlzZWNvbmRzIGZyb20gSmF2YVNjcmlwdFxuICAgICAgICAgICAgbmV4dE1pbGxpcyA9IHRvbnVtYmVyKHN0YXJ0RGF0ZSlcbiAgICAgICAgICAgIG5leHRNaWxsaXMgPSBuZXh0TWlsbGlzID4gbm93IGFuZCBuZXh0TWlsbGlzIG9yIG5vd1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXh0TWlsbGlzID0gbm93XG4gICAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICAgbmV4dE1pbGxpcyA9IHByZXZNaWxsaXMgKyBldmVyeVxuICAgICAgICAtLSBjaGVjayBpZiB3ZSBtYXkgaGF2ZSBtaXNzZWQgc29tZSBpdGVyYXRpb25zXG4gICAgICAgIGlmIG5leHRNaWxsaXMgPCBub3cgdGhlblxuICAgICAgICAgICAgbmV4dE1pbGxpcyA9IG1hdGguZmxvb3Iobm93IC8gZXZlcnkpICogZXZlcnkgKyBldmVyeSArIChvZmZzZXQgb3IgMClcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgaWYgbm90IG9mZnNldCBvciBvZmZzZXQgPT0gMCB0aGVuXG4gICAgICAgIGxvY2FsIHRpbWVTbG90ID0gbWF0aC5mbG9vcihuZXh0TWlsbGlzIC8gZXZlcnkpICogZXZlcnk7XG4gICAgICAgIG9mZnNldCA9IG5leHRNaWxsaXMgLSB0aW1lU2xvdDtcbiAgICBlbmRcbiAgICAtLSBSZXR1cm4gYSB0dXBsZSBuZXh0TWlsbGlzLCBvZmZzZXRcbiAgICByZXR1cm4gbWF0aC5mbG9vcihuZXh0TWlsbGlzKSwgbWF0aC5mbG9vcihvZmZzZXQpXG5lbmRcbmxvY2FsIHByZXZNaWxsaXMgPSByY2FsbChcIlpTQ09SRVwiLCByZXBlYXRLZXksIGpvYlNjaGVkdWxlcklkKVxuLS0gVmFsaWRhdGUgdGhhdCBzY2hlZHVsZXIgZXhpc3RzLlxuLS0gSWYgaXQgZG9lcyBub3QgZXhpc3Qgd2Ugc2hvdWxkIG5vdCBpdGVyYXRlIGFueW1vcmUuXG5pZiBwcmV2TWlsbGlzIHRoZW5cbiAgICBwcmV2TWlsbGlzID0gdG9udW1iZXIocHJldk1pbGxpcylcbiAgICBsb2NhbCBzY2hlZHVsZXJLZXkgPSByZXBlYXRLZXkgLi4gXCI6XCIgLi4gam9iU2NoZWR1bGVySWRcbiAgICBsb2NhbCBzY2hlZHVsZXJBdHRyaWJ1dGVzID0gcmNhbGwoXCJITUdFVFwiLCBzY2hlZHVsZXJLZXksIFwibmFtZVwiLCBcImRhdGFcIiwgXCJldmVyeVwiLCBcInN0YXJ0RGF0ZVwiLCBcIm9mZnNldFwiKVxuICAgIGxvY2FsIGV2ZXJ5ID0gdG9udW1iZXIoc2NoZWR1bGVyQXR0cmlidXRlc1szXSlcbiAgICBsb2NhbCBub3cgPSB0b251bWJlcih0aW1lc3RhbXApXG4gICAgLS0gSWYgZXZlcnkgaXMgbm90IGZvdW5kIGluIHNjaGVkdWxlciBhdHRyaWJ1dGVzLCB0cnkgdG8gZ2V0IGl0IGZyb20gam9iIG9wdGlvbnNcbiAgICBpZiBub3QgZXZlcnkgYW5kIGpvYk9wdHNbJ3JlcGVhdCddIGFuZCBqb2JPcHRzWydyZXBlYXQnXVsnZXZlcnknXSB0aGVuXG4gICAgICAgIGV2ZXJ5ID0gdG9udW1iZXIoam9iT3B0c1sncmVwZWF0J11bJ2V2ZXJ5J10pXG4gICAgZW5kXG4gICAgaWYgZXZlcnkgdGhlblxuICAgICAgICBsb2NhbCBzdGFydERhdGUgPSBzY2hlZHVsZXJBdHRyaWJ1dGVzWzRdXG4gICAgICAgIGxvY2FsIGpvYk9wdHNPZmZzZXQgPSBqb2JPcHRzWydyZXBlYXQnXSBhbmQgam9iT3B0c1sncmVwZWF0J11bJ29mZnNldCddIG9yIDBcbiAgICAgICAgbG9jYWwgb2Zmc2V0ID0gc2NoZWR1bGVyQXR0cmlidXRlc1s1XSBvciBqb2JPcHRzT2Zmc2V0IG9yIDBcbiAgICAgICAgbG9jYWwgbmV3T2Zmc2V0XG4gICAgICAgIG5leHRNaWxsaXMsIG5ld09mZnNldCA9IGdldEpvYlNjaGVkdWxlckV2ZXJ5TmV4dE1pbGxpcyhwcmV2TWlsbGlzLCBldmVyeSwgbm93LCBvZmZzZXQsIHN0YXJ0RGF0ZSlcbiAgICAgICAgaWYgbm90IG9mZnNldCB0aGVuXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgc2NoZWR1bGVyS2V5LCBcIm9mZnNldFwiLCBuZXdPZmZzZXQpXG4gICAgICAgICAgICBqb2JPcHRzWydyZXBlYXQnXVsnb2Zmc2V0J10gPSBuZXdPZmZzZXRcbiAgICAgICAgZW5kXG4gICAgZW5kXG4gICAgbG9jYWwgbmV4dERlbGF5ZWRKb2JJZCA9IFwicmVwZWF0OlwiIC4uIGpvYlNjaGVkdWxlcklkIC4uIFwiOlwiIC4uIG5leHRNaWxsaXNcbiAgICBsb2NhbCBuZXh0RGVsYXllZEpvYktleSA9IHNjaGVkdWxlcktleSAuLiBcIjpcIiAuLiBuZXh0TWlsbGlzXG4gICAgbG9jYWwgY3VycmVudERlbGF5ZWRKb2JJZCA9IFwicmVwZWF0OlwiIC4uIGpvYlNjaGVkdWxlcklkIC4uIFwiOlwiIC4uIHByZXZNaWxsaXNcbiAgICBpZiBwcm9kdWNlcklkID09IGN1cnJlbnREZWxheWVkSm9iSWQgdGhlblxuICAgICAgICBsb2NhbCBldmVudHNLZXkgPSBLRVlTWzldXG4gICAgICAgIGxvY2FsIG1heEV2ZW50cyA9IGdldE9yU2V0TWF4RXZlbnRzKG1ldGFLZXkpXG4gICAgICAgIGlmIHJjYWxsKFwiRVhJU1RTXCIsIG5leHREZWxheWVkSm9iS2V5KSB+PSAxIHRoZW5cbiAgICAgICAgICAgIHJjYWxsKFwiWkFERFwiLCByZXBlYXRLZXksIG5leHRNaWxsaXMsIGpvYlNjaGVkdWxlcklkKVxuICAgICAgICAgICAgcmNhbGwoXCJISU5DUkJZXCIsIHNjaGVkdWxlcktleSwgXCJpY1wiLCAxKVxuICAgICAgICAgICAgcmNhbGwoXCJJTkNSXCIsIEtFWVNbOF0pXG4gICAgICAgICAgICAtLSBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlLFxuICAgICAgICAgICAgLS0gYWxsIGpvYi1zY2hlZHVsZXJzIG11c3Qgc2F2ZSBqb2IgZGF0YVxuICAgICAgICAgICAgbG9jYWwgdGVtcGxhdGVEYXRhID0gc2NoZWR1bGVyQXR0cmlidXRlc1syXSBvciBBUkdWWzNdXG4gICAgICAgICAgICBpZiB0ZW1wbGF0ZURhdGEgYW5kIHRlbXBsYXRlRGF0YSB+PSAne30nIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgc2NoZWR1bGVyS2V5LCBcImRhdGFcIiwgdGVtcGxhdGVEYXRhKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBsb2NhbCBkZWxheSA9IG5leHRNaWxsaXMgLSBub3dcbiAgICAgICAgICAgIC0tIEZhc3QgQ2xhbXAgZGVsYXkgdG8gbWluaW11bSBvZiAwXG4gICAgICAgICAgICBpZiBkZWxheSA8IDAgdGhlblxuICAgICAgICAgICAgICAgIGRlbGF5ID0gMFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBqb2JPcHRzW1wiZGVsYXlcIl0gPSBkZWxheVxuICAgICAgICAgICAgYWRkSm9iRnJvbVNjaGVkdWxlcihuZXh0RGVsYXllZEpvYktleSwgbmV4dERlbGF5ZWRKb2JJZCwgam9iT3B0cywgd2FpdEtleSwgcGF1c2VkS2V5LCBLRVlTWzEyXSwgbWV0YUtleSxcbiAgICAgICAgICAgICAgICBwcmlvcml0aXplZEtleSwgS0VZU1sxMF0sIGRlbGF5ZWRLZXksIEtFWVNbN10sIGV2ZW50c0tleSwgc2NoZWR1bGVyQXR0cmlidXRlc1sxXSwgbWF4RXZlbnRzLCBBUkdWWzVdLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlRGF0YSBvciAne30nLCBqb2JTY2hlZHVsZXJJZCwgZGVsYXkpXG4gICAgICAgICAgICAtLSBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIGluIG5leHQgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgICAgICBpZiBLRVlTWzExXSB+PSBcIlwiIHRoZW5cbiAgICAgICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgS0VZU1sxMV0sIFwibnJqaWRcIiwgbmV4dERlbGF5ZWRKb2JJZClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgcmV0dXJuIG5leHREZWxheWVkSm9iSWQgLi4gXCJcIiAtLSBjb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByY2FsbChcIlhBRERcIiwgZXZlbnRzS2V5LCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcImR1cGxpY2F0ZWRcIiwgXCJqb2JJZFwiLCBuZXh0RGVsYXllZEpvYklkKVxuICAgICAgICBlbmRcbiAgICBlbmRcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCB1cGRhdGVKb2JTY2hlZHVsZXIgPSB7XG4gICAgbmFtZTogJ3VwZGF0ZUpvYlNjaGVkdWxlcicsXG4gICAgY29udGVudCxcbiAgICBrZXlzOiAxMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVKb2JTY2hlZHVsZXItMTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateJobScheduler-12.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js":
/*!******************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateProgress: () => (/* binding */ updateProgress)\n/* harmony export */ });\nconst content = `--[[\n  Update job progress\n  Input:\n    KEYS[1] Job id key\n    KEYS[2] event stream key\n    KEYS[3] meta key\n    ARGV[1] id\n    ARGV[2] progress\n  Output:\n     0 - OK\n    -1 - Missing job.\n  Event:\n    progress(jobId, progress)\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to get max events value or set by default 10000.\n]]\nlocal function getOrSetMaxEvents(metaKey)\n  local maxEvents = rcall(\"HGET\", metaKey, \"opts.maxLenEvents\")\n  if not maxEvents then\n    maxEvents = 10000\n    rcall(\"HSET\", metaKey, \"opts.maxLenEvents\", maxEvents)\n  end\n  return maxEvents\nend\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n    local maxEvents = getOrSetMaxEvents(KEYS[3])\n    rcall(\"HSET\", KEYS[1], \"progress\", ARGV[2])\n    rcall(\"XADD\", KEYS[2], \"MAXLEN\", \"~\", maxEvents, \"*\", \"event\", \"progress\",\n          \"jobId\", ARGV[1], \"data\", ARGV[2]);\n    return 0\nelse\n    return -1\nend\n`;\nconst updateProgress = {\n    name: 'updateProgress',\n    content,\n    keys: 3,\n};\n//# sourceMappingURL=updateProgress-3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlUHJvZ3Jlc3MtMy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3VwZGF0ZVByb2dyZXNzLTMuanM/NTZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVXBkYXRlIGpvYiBwcm9ncmVzc1xuICBJbnB1dDpcbiAgICBLRVlTWzFdIEpvYiBpZCBrZXlcbiAgICBLRVlTWzJdIGV2ZW50IHN0cmVhbSBrZXlcbiAgICBLRVlTWzNdIG1ldGEga2V5XG4gICAgQVJHVlsxXSBpZFxuICAgIEFSR1ZbMl0gcHJvZ3Jlc3NcbiAgT3V0cHV0OlxuICAgICAwIC0gT0tcbiAgICAtMSAtIE1pc3Npbmcgam9iLlxuICBFdmVudDpcbiAgICBwcm9ncmVzcyhqb2JJZCwgcHJvZ3Jlc3MpXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBnZXQgbWF4IGV2ZW50cyB2YWx1ZSBvciBzZXQgYnkgZGVmYXVsdCAxMDAwMC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRPclNldE1heEV2ZW50cyhtZXRhS2V5KVxuICBsb2NhbCBtYXhFdmVudHMgPSByY2FsbChcIkhHRVRcIiwgbWV0YUtleSwgXCJvcHRzLm1heExlbkV2ZW50c1wiKVxuICBpZiBub3QgbWF4RXZlbnRzIHRoZW5cbiAgICBtYXhFdmVudHMgPSAxMDAwMFxuICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcIm9wdHMubWF4TGVuRXZlbnRzXCIsIG1heEV2ZW50cylcbiAgZW5kXG4gIHJldHVybiBtYXhFdmVudHNcbmVuZFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuIC0tIC8vIE1ha2Ugc3VyZSBqb2IgZXhpc3RzXG4gICAgbG9jYWwgbWF4RXZlbnRzID0gZ2V0T3JTZXRNYXhFdmVudHMoS0VZU1szXSlcbiAgICByY2FsbChcIkhTRVRcIiwgS0VZU1sxXSwgXCJwcm9ncmVzc1wiLCBBUkdWWzJdKVxuICAgIHJjYWxsKFwiWEFERFwiLCBLRVlTWzJdLCBcIk1BWExFTlwiLCBcIn5cIiwgbWF4RXZlbnRzLCBcIipcIiwgXCJldmVudFwiLCBcInByb2dyZXNzXCIsXG4gICAgICAgICAgXCJqb2JJZFwiLCBBUkdWWzFdLCBcImRhdGFcIiwgQVJHVlsyXSk7XG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gLTFcbmVuZFxuYDtcbmV4cG9ydCBjb25zdCB1cGRhdGVQcm9ncmVzcyA9IHtcbiAgICBuYW1lOiAndXBkYXRlUHJvZ3Jlc3MnLFxuICAgIGNvbnRlbnQsXG4gICAga2V5czogMyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVQcm9ncmVzcy0zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateProgress-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/scripts/updateRepeatableJobMillis-1.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/scripts/updateRepeatableJobMillis-1.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   updateRepeatableJobMillis: () => (/* binding */ updateRepeatableJobMillis)\n/* harmony export */ });\nconst content = `--[[\n  Adds a repeatable job\n    Input:\n      KEYS[1] 'repeat' key\n      ARGV[1] next milliseconds\n      ARGV[2] custom key\n      ARGV[3] legacy custom key TODO: remove this logic in next breaking change\n      Output:\n        repeatableKey  - OK\n]]\nlocal rcall = redis.call\nlocal repeatKey = KEYS[1]\nlocal nextMillis = ARGV[1]\nlocal customKey = ARGV[2]\nlocal legacyCustomKey = ARGV[3]\nif rcall(\"ZSCORE\", repeatKey, customKey) then\n    rcall(\"ZADD\", repeatKey, nextMillis, customKey)\n    return customKey\nelseif rcall(\"ZSCORE\", repeatKey, legacyCustomKey) ~= false then\n    rcall(\"ZADD\", repeatKey, nextMillis, legacyCustomKey)\n    return legacyCustomKey\nend\nreturn ''\n`;\nconst updateRepeatableJobMillis = {\n    name: 'updateRepeatableJobMillis',\n    content,\n    keys: 1,\n};\n//# sourceMappingURL=updateRepeatableJobMillis-1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3NjcmlwdHMvdXBkYXRlUmVwZWF0YWJsZUpvYk1pbGxpcy0xLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS9zY3JpcHRzL3VwZGF0ZVJlcGVhdGFibGVKb2JNaWxsaXMtMS5qcz9jZWUwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgcmVwZWF0YWJsZSBqb2JcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ3JlcGVhdCcga2V5XG4gICAgICBBUkdWWzFdIG5leHQgbWlsbGlzZWNvbmRzXG4gICAgICBBUkdWWzJdIGN1c3RvbSBrZXlcbiAgICAgIEFSR1ZbM10gbGVnYWN5IGN1c3RvbSBrZXkgVE9ETzogcmVtb3ZlIHRoaXMgbG9naWMgaW4gbmV4dCBicmVha2luZyBjaGFuZ2VcbiAgICAgIE91dHB1dDpcbiAgICAgICAgcmVwZWF0YWJsZUtleSAgLSBPS1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgcmVwZWF0S2V5ID0gS0VZU1sxXVxubG9jYWwgbmV4dE1pbGxpcyA9IEFSR1ZbMV1cbmxvY2FsIGN1c3RvbUtleSA9IEFSR1ZbMl1cbmxvY2FsIGxlZ2FjeUN1c3RvbUtleSA9IEFSR1ZbM11cbmlmIHJjYWxsKFwiWlNDT1JFXCIsIHJlcGVhdEtleSwgY3VzdG9tS2V5KSB0aGVuXG4gICAgcmNhbGwoXCJaQUREXCIsIHJlcGVhdEtleSwgbmV4dE1pbGxpcywgY3VzdG9tS2V5KVxuICAgIHJldHVybiBjdXN0b21LZXlcbmVsc2VpZiByY2FsbChcIlpTQ09SRVwiLCByZXBlYXRLZXksIGxlZ2FjeUN1c3RvbUtleSkgfj0gZmFsc2UgdGhlblxuICAgIHJjYWxsKFwiWkFERFwiLCByZXBlYXRLZXksIG5leHRNaWxsaXMsIGxlZ2FjeUN1c3RvbUtleSlcbiAgICByZXR1cm4gbGVnYWN5Q3VzdG9tS2V5XG5lbmRcbnJldHVybiAnJ1xuYDtcbmV4cG9ydCBjb25zdCB1cGRhdGVSZXBlYXRhYmxlSm9iTWlsbGlzID0ge1xuICAgIG5hbWU6ICd1cGRhdGVSZXBlYXRhYmxlSm9iTWlsbGlzJyxcbiAgICBjb250ZW50LFxuICAgIGtleXM6IDEsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlUmVwZWF0YWJsZUpvYk1pbGxpcy0xLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/scripts/updateRepeatableJobMillis-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/backoff-strategy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=backoff-strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2JhY2tvZmYtc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS90eXBlcy9iYWNrb2ZmLXN0cmF0ZWd5LmpzPzcyNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi1zdHJhdGVneS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/deduplication-options.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/deduplication-options.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=deduplication-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2RlZHVwbGljYXRpb24tb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2RlZHVwbGljYXRpb24tb3B0aW9ucy5qcz9mZDkyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZHVwbGljYXRpb24tb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/deduplication-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/finished-status.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=finished-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2ZpbmlzaGVkLXN0YXR1cy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2ZpbmlzaGVkLXN0YXR1cy5qcz81NjcxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmlzaGVkLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _backoff_strategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backoff-strategy */ \"(rsc)/./node_modules/bullmq/dist/esm/types/backoff-strategy.js\");\n/* harmony import */ var _deduplication_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deduplication-options */ \"(rsc)/./node_modules/bullmq/dist/esm/types/deduplication-options.js\");\n/* harmony import */ var _finished_status__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./finished-status */ \"(rsc)/./node_modules/bullmq/dist/esm/types/finished-status.js\");\n/* harmony import */ var _job_json_sandbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./job-json-sandbox */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js\");\n/* harmony import */ var _job_options__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./job-options */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js\");\n/* harmony import */ var _job_scheduler_template_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./job-scheduler-template-options */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-scheduler-template-options.js\");\n/* harmony import */ var _job_type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./job-type */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js\");\n/* harmony import */ var _job_progress__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./job-progress */ \"(rsc)/./node_modules/bullmq/dist/esm/types/job-progress.js\");\n/* harmony import */ var _repeat_strategy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./repeat-strategy */ \"(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js\");\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNOO0FBQ0M7QUFDTDtBQUNtQjtBQUN0QjtBQUNJO0FBQ0c7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS90eXBlcy9pbmRleC5qcz85ZDFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYmFja29mZi1zdHJhdGVneSc7XG5leHBvcnQgKiBmcm9tICcuL2RlZHVwbGljYXRpb24tb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2ZpbmlzaGVkLXN0YXR1cyc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi1qc29uLXNhbmRib3gnO1xuZXhwb3J0ICogZnJvbSAnLi9qb2Itb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi1zY2hlZHVsZXItdGVtcGxhdGUtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2pvYi10eXBlJztcbmV4cG9ydCAqIGZyb20gJy4vam9iLXByb2dyZXNzJztcbmV4cG9ydCAqIGZyb20gJy4vcmVwZWF0LXN0cmF0ZWd5Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js":
/*!****************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-json-sandbox.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-json-sandbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1qc29uLXNhbmRib3guanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS90eXBlcy9qb2ItanNvbi1zYW5kYm94LmpzPzQ1ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9iLWpzb24tc2FuZGJveC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-json-sandbox.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js":
/*!***********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-options.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdHlwZXMvam9iLW9wdGlvbnMuanM/NjEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qb2Itb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-progress.js":
/*!************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-progress.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-progress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1wcm9ncmVzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1wcm9ncmVzcy5qcz82YmJiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi1wcm9ncmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-progress.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-scheduler-template-options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-scheduler-template-options.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-scheduler-template-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1zY2hlZHVsZXItdGVtcGxhdGUtb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi1zY2hlZHVsZXItdGVtcGxhdGUtb3B0aW9ucy5qcz8yYTYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpvYi1zY2hlZHVsZXItdGVtcGxhdGUtb3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-scheduler-template-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js":
/*!********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/job-type.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=job-type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL2pvYi10eXBlLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veXQtc2hvcnRzbWl0aC8uL25vZGVfbW9kdWxlcy9idWxsbXEvZGlzdC9lc20vdHlwZXMvam9iLXR5cGUuanM/OGQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qb2ItdHlwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/job-type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/processor.js":
/*!*********************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/processor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL3Byb2Nlc3Nvci5qcz8xYTkyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js":
/*!***************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/types/repeat-strategy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=repeat-strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL3JlcGVhdC1zdHJhdGVneS5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3R5cGVzL3JlcGVhdC1zdHJhdGVneS5qcz8zMTI5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdC1zdHJhdGVneS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/types/repeat-strategy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/utils/create-scripts.js":
/*!**************************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/utils/create-scripts.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createScripts: () => (/* binding */ createScripts)\n/* harmony export */ });\n/* harmony import */ var _classes_scripts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/scripts */ \"(rsc)/./node_modules/bullmq/dist/esm/classes/scripts.js\");\n\n/*\n * Factory method to create a Scripts object.\n */\nconst createScripts = (queue) => {\n    return new _classes_scripts__WEBPACK_IMPORTED_MODULE_0__.Scripts({\n        keys: queue.keys,\n        client: queue.client,\n        get redisVersion() {\n            return queue.redisVersion;\n        },\n        toKey: queue.toKey,\n        opts: queue.opts,\n        closing: queue.closing,\n    });\n};\n//# sourceMappingURL=create-scripts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3V0aWxzL2NyZWF0ZS1zY3JpcHRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSxxREFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3l0LXNob3J0c21pdGgvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3V0aWxzL2NyZWF0ZS1zY3JpcHRzLmpzPzljOTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NyaXB0cyB9IGZyb20gJy4uL2NsYXNzZXMvc2NyaXB0cyc7XG4vKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgU2NyaXB0cyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTY3JpcHRzID0gKHF1ZXVlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTY3JpcHRzKHtcbiAgICAgICAga2V5czogcXVldWUua2V5cyxcbiAgICAgICAgY2xpZW50OiBxdWV1ZS5jbGllbnQsXG4gICAgICAgIGdldCByZWRpc1ZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVldWUucmVkaXNWZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICB0b0tleTogcXVldWUudG9LZXksXG4gICAgICAgIG9wdHM6IHF1ZXVlLm9wdHMsXG4gICAgICAgIGNsb3Npbmc6IHF1ZXVlLmNsb3NpbmcsXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLXNjcmlwdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/utils/create-scripts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/utils/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/utils/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELAY_TIME_1: () => (/* binding */ DELAY_TIME_1),\n/* harmony export */   DELAY_TIME_5: () => (/* binding */ DELAY_TIME_5),\n/* harmony export */   QUEUE_EVENT_SUFFIX: () => (/* binding */ QUEUE_EVENT_SUFFIX),\n/* harmony export */   array2obj: () => (/* binding */ array2obj),\n/* harmony export */   asyncSend: () => (/* binding */ asyncSend),\n/* harmony export */   childSend: () => (/* binding */ childSend),\n/* harmony export */   clientCommandMessageReg: () => (/* binding */ clientCommandMessageReg),\n/* harmony export */   decreaseMaxListeners: () => (/* binding */ decreaseMaxListeners),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   errorObject: () => (/* binding */ errorObject),\n/* harmony export */   errorToJSON: () => (/* binding */ errorToJSON),\n/* harmony export */   getParentKey: () => (/* binding */ getParentKey),\n/* harmony export */   increaseMaxListeners: () => (/* binding */ increaseMaxListeners),\n/* harmony export */   invertObject: () => (/* binding */ invertObject),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isNotConnectionError: () => (/* binding */ isNotConnectionError),\n/* harmony export */   isRedisCluster: () => (/* binding */ isRedisCluster),\n/* harmony export */   isRedisInstance: () => (/* binding */ isRedisInstance),\n/* harmony export */   isRedisVersionLowerThan: () => (/* binding */ isRedisVersionLowerThan),\n/* harmony export */   lengthInUtf8Bytes: () => (/* binding */ lengthInUtf8Bytes),\n/* harmony export */   objectToFlatArray: () => (/* binding */ objectToFlatArray),\n/* harmony export */   optsDecodeMap: () => (/* binding */ optsDecodeMap),\n/* harmony export */   optsEncodeMap: () => (/* binding */ optsEncodeMap),\n/* harmony export */   parseObjectValues: () => (/* binding */ parseObjectValues),\n/* harmony export */   removeAllQueueData: () => (/* binding */ removeAllQueueData),\n/* harmony export */   removeUndefinedFields: () => (/* binding */ removeUndefinedFields),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trace: () => (/* binding */ trace),\n/* harmony export */   tryCatch: () => (/* binding */ tryCatch)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"(rsc)/./node_modules/ioredis/built/index.js\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ioredis_built_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ioredis/built/utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums */ \"(rsc)/./node_modules/bullmq/dist/esm/enums/index.js\");\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\n\nconst errorObject = { value: null };\nfunction tryCatch(fn, ctx, args) {\n    try {\n        return fn.apply(ctx, args);\n    }\n    catch (e) {\n        errorObject.value = e;\n        return errorObject;\n    }\n}\n/**\n * Checks the size of string for ascii/non-ascii characters\n * @see https://stackoverflow.com/a/23318053/1347170\n * @param str -\n */\nfunction lengthInUtf8Bytes(str) {\n    return Buffer.byteLength(str, 'utf8');\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction array2obj(arr) {\n    const obj = {};\n    for (let i = 0; i < arr.length; i += 2) {\n        obj[arr[i]] = arr[i + 1];\n    }\n    return obj;\n}\nfunction objectToFlatArray(obj) {\n    const arr = [];\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) &&\n            obj[key] !== undefined) {\n            arr[arr.length] = key;\n            arr[arr.length] = obj[key];\n        }\n    }\n    return arr;\n}\nfunction delay(ms, abortController) {\n    return new Promise(resolve => {\n        // eslint-disable-next-line prefer-const\n        let timeout;\n        const callback = () => {\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', callback);\n            clearTimeout(timeout);\n            resolve();\n        };\n        timeout = setTimeout(callback, ms);\n        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', callback);\n    });\n}\nfunction increaseMaxListeners(emitter, count) {\n    const maxListeners = emitter.getMaxListeners();\n    emitter.setMaxListeners(maxListeners + count);\n}\nfunction invertObject(obj) {\n    return Object.entries(obj).reduce((result, [key, value]) => {\n        result[value] = key;\n        return result;\n    }, {});\n}\nconst optsDecodeMap = {\n    de: 'deduplication',\n    fpof: 'failParentOnFailure',\n    cpof: 'continueParentOnFailure',\n    idof: 'ignoreDependencyOnFailure',\n    kl: 'keepLogs',\n    rdof: 'removeDependencyOnFailure',\n};\nconst optsEncodeMap = Object.assign(Object.assign({}, invertObject(optsDecodeMap)), { \n    /*/ Legacy for backwards compatibility */ debounce: 'de' });\nfunction isRedisInstance(obj) {\n    if (!obj) {\n        return false;\n    }\n    const redisApi = ['connect', 'disconnect', 'duplicate'];\n    return redisApi.every(name => typeof obj[name] === 'function');\n}\nfunction isRedisCluster(obj) {\n    return isRedisInstance(obj) && obj.isCluster;\n}\nfunction decreaseMaxListeners(emitter, count) {\n    increaseMaxListeners(emitter, -count);\n}\nasync function removeAllQueueData(client, queueName, prefix = process.env.BULLMQ_TEST_PREFIX || 'bull') {\n    if (client instanceof ioredis__WEBPACK_IMPORTED_MODULE_0__.Cluster) {\n        // todo compat with cluster ?\n        // @see https://github.com/luin/ioredis/issues/175\n        return Promise.resolve(false);\n    }\n    const pattern = `${prefix}:${queueName}:*`;\n    const removing = await new Promise((resolve, reject) => {\n        const stream = client.scanStream({\n            match: pattern,\n        });\n        stream.on('data', (keys) => {\n            if (keys.length) {\n                const pipeline = client.pipeline();\n                keys.forEach(key => {\n                    pipeline.del(key);\n                });\n                pipeline.exec().catch(error => {\n                    reject(error);\n                });\n            }\n        });\n        stream.on('end', () => resolve());\n        stream.on('error', error => reject(error));\n    });\n    await removing;\n    await client.quit();\n}\nfunction getParentKey(opts) {\n    if (opts) {\n        return `${opts.queue}:${opts.id}`;\n    }\n}\nconst clientCommandMessageReg = /ERR unknown command ['`]\\s*client\\s*['`]/;\nconst DELAY_TIME_5 = 5000;\nconst DELAY_TIME_1 = 100;\nfunction isNotConnectionError(error) {\n    const errorMessage = `${error.message}`;\n    return (errorMessage !== ioredis_built_utils__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_CLOSED_ERROR_MSG &&\n        !errorMessage.includes('ECONNREFUSED'));\n}\nconst asyncSend = (proc, msg) => {\n    return new Promise((resolve, reject) => {\n        if (typeof proc.send === 'function') {\n            proc.send(msg, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n        }\n        else if (typeof proc.postMessage === 'function') {\n            resolve(proc.postMessage(msg));\n        }\n        else {\n            resolve();\n        }\n    });\n};\nconst childSend = (proc, msg) => asyncSend(proc, msg);\nconst isRedisVersionLowerThan = (currentVersion, minimumVersion) => {\n    const version = semver__WEBPACK_IMPORTED_MODULE_2__.valid(semver__WEBPACK_IMPORTED_MODULE_2__.coerce(currentVersion));\n    return semver__WEBPACK_IMPORTED_MODULE_2__.lt(version, minimumVersion);\n};\nconst parseObjectValues = (obj) => {\n    const accumulator = {};\n    for (const value of Object.entries(obj)) {\n        accumulator[value[0]] = JSON.parse(value[1]);\n    }\n    return accumulator;\n};\nconst getCircularReplacer = (rootReference) => {\n    const references = new WeakSet();\n    references.add(rootReference);\n    return (_, value) => {\n        if (typeof value === 'object' && value !== null) {\n            if (references.has(value)) {\n                return '[Circular]';\n            }\n            references.add(value);\n        }\n        return value;\n    };\n};\nconst errorToJSON = (value) => {\n    const error = {};\n    Object.getOwnPropertyNames(value).forEach(function (propName) {\n        error[propName] = value[propName];\n    });\n    return JSON.parse(JSON.stringify(error, getCircularReplacer(value)));\n};\nconst INFINITY = 1 / 0;\nconst toString = (value) => {\n    if (value == null) {\n        return '';\n    }\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value === 'string') {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return `${value.map(other => (other == null ? other : toString(other)))}`;\n    }\n    if (typeof value == 'symbol' ||\n        Object.prototype.toString.call(value) == '[object Symbol]') {\n        return value.toString();\n    }\n    const result = `${value}`;\n    return result === '0' && 1 / value === -INFINITY ? '-0' : result;\n};\nconst QUEUE_EVENT_SUFFIX = ':qe';\nfunction removeUndefinedFields(obj) {\n    const newObj = {};\n    for (const key in obj) {\n        if (obj[key] !== undefined) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\n/**\n * Wraps the code with telemetry and provides a span for configuration.\n *\n * @param telemetry - telemetry configuration. If undefined, the callback will be executed without telemetry.\n * @param spanKind - kind of the span: Producer, Consumer, Internal\n * @param queueName - queue name\n * @param operation - operation name (such as add, process, etc)\n * @param destination - destination name (normally the queue name)\n * @param callback - code to wrap with telemetry\n * @param srcPropagationMedatada -\n * @returns\n */\nasync function trace(telemetry, spanKind, queueName, operation, destination, callback, srcPropagationMetadata) {\n    if (!telemetry) {\n        return callback();\n    }\n    else {\n        const { tracer, contextManager } = telemetry;\n        const currentContext = contextManager.active();\n        let parentContext;\n        if (srcPropagationMetadata) {\n            parentContext = contextManager.fromMetadata(currentContext, srcPropagationMetadata);\n        }\n        const spanName = destination ? `${operation} ${destination}` : operation;\n        const span = tracer.startSpan(spanName, {\n            kind: spanKind,\n        }, parentContext);\n        try {\n            span.setAttributes({\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueName]: queueName,\n                [_enums__WEBPACK_IMPORTED_MODULE_3__.TelemetryAttributes.QueueOperation]: operation,\n            });\n            let messageContext;\n            let dstPropagationMetadata;\n            if (spanKind === _enums__WEBPACK_IMPORTED_MODULE_3__.SpanKind.CONSUMER && parentContext) {\n                messageContext = span.setSpanOnContext(parentContext);\n            }\n            else {\n                messageContext = span.setSpanOnContext(currentContext);\n            }\n            if (callback.length == 2) {\n                dstPropagationMetadata = contextManager.getMetadata(messageContext);\n            }\n            return await contextManager.with(messageContext, () => callback(span, dstPropagationMetadata));\n        }\n        catch (err) {\n            span.recordException(err);\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ2xDO0FBQ0E7QUFDa0U7QUFDakM7QUFDd0I7QUFDbEQsc0JBQXNCO0FBQ3RCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxvREFBb0Q7QUFDM0QsOERBQThEO0FBQ3ZEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCwwQkFBMEIsNENBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxHQUFHLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsV0FBVyxHQUFHLFFBQVE7QUFDeEM7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1AsNEJBQTRCLGNBQWM7QUFDMUMsNkJBQTZCLDRFQUEyQjtBQUN4RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNBO0FBQ1Asb0JBQW9CLHlDQUFZLENBQUMsMENBQWE7QUFDOUMsV0FBVyxzQ0FBUztBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBOEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxFQUFFLFlBQVk7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFtQjtBQUNwQyxpQkFBaUIsdURBQW1CO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLDRDQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS91dGlscy9pbmRleC5qcz85ODI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsdXN0ZXIgfSBmcm9tICdpb3JlZGlzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyB9IGZyb20gJ2lvcmVkaXMvYnVpbHQvdXRpbHMnO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBTcGFuS2luZCwgVGVsZW1ldHJ5QXR0cmlidXRlcyB9IGZyb20gJy4uL2VudW1zJztcbmV4cG9ydCBjb25zdCBlcnJvck9iamVjdCA9IHsgdmFsdWU6IG51bGwgfTtcbmV4cG9ydCBmdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0LnZhbHVlID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIHRoZSBzaXplIG9mIHN0cmluZyBmb3IgYXNjaWkvbm9uLWFzY2lpIGNoYXJhY3RlcnNcbiAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzMzE4MDUzLzEzNDcxNzBcbiAqIEBwYXJhbSBzdHIgLVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoSW5VdGY4Qnl0ZXMoc3RyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5Mm9iaihhcnIpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBvYmpbYXJyW2ldXSA9IGFycltpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0VG9GbGF0QXJyYXkob2JqKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmXG4gICAgICAgICAgICBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBrZXk7XG4gICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KG1zLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIG1zKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGNhbGxiYWNrKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZWFzZU1heExpc3RlbmVycyhlbWl0dGVyLCBjb3VudCkge1xuICAgIGNvbnN0IG1heExpc3RlbmVycyA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gICAgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMobWF4TGlzdGVuZXJzICsgY291bnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludmVydE9iamVjdChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoKHJlc3VsdCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufVxuZXhwb3J0IGNvbnN0IG9wdHNEZWNvZGVNYXAgPSB7XG4gICAgZGU6ICdkZWR1cGxpY2F0aW9uJyxcbiAgICBmcG9mOiAnZmFpbFBhcmVudE9uRmFpbHVyZScsXG4gICAgY3BvZjogJ2NvbnRpbnVlUGFyZW50T25GYWlsdXJlJyxcbiAgICBpZG9mOiAnaWdub3JlRGVwZW5kZW5jeU9uRmFpbHVyZScsXG4gICAga2w6ICdrZWVwTG9ncycsXG4gICAgcmRvZjogJ3JlbW92ZURlcGVuZGVuY3lPbkZhaWx1cmUnLFxufTtcbmV4cG9ydCBjb25zdCBvcHRzRW5jb2RlTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnZlcnRPYmplY3Qob3B0c0RlY29kZU1hcCkpLCB7IFxuICAgIC8qLyBMZWdhY3kgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICovIGRlYm91bmNlOiAnZGUnIH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVkaXNJbnN0YW5jZShvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlzQXBpID0gWydjb25uZWN0JywgJ2Rpc2Nvbm5lY3QnLCAnZHVwbGljYXRlJ107XG4gICAgcmV0dXJuIHJlZGlzQXBpLmV2ZXJ5KG5hbWUgPT4gdHlwZW9mIG9ialtuYW1lXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZWRpc0NsdXN0ZXIob2JqKSB7XG4gICAgcmV0dXJuIGlzUmVkaXNJbnN0YW5jZShvYmopICYmIG9iai5pc0NsdXN0ZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjcmVhc2VNYXhMaXN0ZW5lcnMoZW1pdHRlciwgY291bnQpIHtcbiAgICBpbmNyZWFzZU1heExpc3RlbmVycyhlbWl0dGVyLCAtY291bnQpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZUFsbFF1ZXVlRGF0YShjbGllbnQsIHF1ZXVlTmFtZSwgcHJlZml4ID0gcHJvY2Vzcy5lbnYuQlVMTE1RX1RFU1RfUFJFRklYIHx8ICdidWxsJykge1xuICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBDbHVzdGVyKSB7XG4gICAgICAgIC8vIHRvZG8gY29tcGF0IHdpdGggY2x1c3RlciA/XG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy9pc3N1ZXMvMTc1XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBwYXR0ZXJuID0gYCR7cHJlZml4fToke3F1ZXVlTmFtZX06KmA7XG4gICAgY29uc3QgcmVtb3ZpbmcgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNsaWVudC5zY2FuU3RyZWFtKHtcbiAgICAgICAgICAgIG1hdGNoOiBwYXR0ZXJuLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgKGtleXMpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBpcGVsaW5lLmRlbChrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBpcGVsaW5lLmV4ZWMoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCBlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9KTtcbiAgICBhd2FpdCByZW1vdmluZztcbiAgICBhd2FpdCBjbGllbnQucXVpdCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudEtleShvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGAke29wdHMucXVldWV9OiR7b3B0cy5pZH1gO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBjbGllbnRDb21tYW5kTWVzc2FnZVJlZyA9IC9FUlIgdW5rbm93biBjb21tYW5kIFsnYF1cXHMqY2xpZW50XFxzKlsnYF0vO1xuZXhwb3J0IGNvbnN0IERFTEFZX1RJTUVfNSA9IDUwMDA7XG5leHBvcnQgY29uc3QgREVMQVlfVElNRV8xID0gMTAwO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm90Q29ubmVjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7ZXJyb3IubWVzc2FnZX1gO1xuICAgIHJldHVybiAoZXJyb3JNZXNzYWdlICE9PSBDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgJiZcbiAgICAgICAgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRUNPTk5SRUZVU0VEJykpO1xufVxuZXhwb3J0IGNvbnN0IGFzeW5jU2VuZCA9IChwcm9jLCBtc2cpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Muc2VuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvYy5zZW5kKG1zZywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb2MucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc29sdmUocHJvYy5wb3N0TWVzc2FnZShtc2cpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBjaGlsZFNlbmQgPSAocHJvYywgbXNnKSA9PiBhc3luY1NlbmQocHJvYywgbXNnKTtcbmV4cG9ydCBjb25zdCBpc1JlZGlzVmVyc2lvbkxvd2VyVGhhbiA9IChjdXJyZW50VmVyc2lvbiwgbWluaW11bVZlcnNpb24pID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLnZhbGlkKHNlbXZlci5jb2VyY2UoY3VycmVudFZlcnNpb24pKTtcbiAgICByZXR1cm4gc2VtdmVyLmx0KHZlcnNpb24sIG1pbmltdW1WZXJzaW9uKTtcbn07XG5leHBvcnQgY29uc3QgcGFyc2VPYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgYWNjdW11bGF0b3JbdmFsdWVbMF1dID0gSlNPTi5wYXJzZSh2YWx1ZVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn07XG5jb25zdCBnZXRDaXJjdWxhclJlcGxhY2VyID0gKHJvb3RSZWZlcmVuY2UpID0+IHtcbiAgICBjb25zdCByZWZlcmVuY2VzID0gbmV3IFdlYWtTZXQoKTtcbiAgICByZWZlcmVuY2VzLmFkZChyb290UmVmZXJlbmNlKTtcbiAgICByZXR1cm4gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZmVyZW5jZXMuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgZXJyb3JUb0pTT04gPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IHt9O1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBlcnJvcltwcm9wTmFtZV0gPSB2YWx1ZVtwcm9wTmFtZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IsIGdldENpcmN1bGFyUmVwbGFjZXIodmFsdWUpKSk7XG59O1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmV4cG9ydCBjb25zdCB0b1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYCR7dmFsdWUubWFwKG90aGVyID0+IChvdGhlciA9PSBudWxsID8gb3RoZXIgOiB0b1N0cmluZyhvdGhlcikpKX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAke3ZhbHVlfWA7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gJzAnICYmIDEgLyB2YWx1ZSA9PT0gLUlORklOSVRZID8gJy0wJyA6IHJlc3VsdDtcbn07XG5leHBvcnQgY29uc3QgUVVFVUVfRVZFTlRfU1VGRklYID0gJzpxZSc7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRmllbGRzKG9iaikge1xuICAgIGNvbnN0IG5ld09iaiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuLyoqXG4gKiBXcmFwcyB0aGUgY29kZSB3aXRoIHRlbGVtZXRyeSBhbmQgcHJvdmlkZXMgYSBzcGFuIGZvciBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSB0ZWxlbWV0cnkgLSB0ZWxlbWV0cnkgY29uZmlndXJhdGlvbi4gSWYgdW5kZWZpbmVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCB3aXRob3V0IHRlbGVtZXRyeS5cbiAqIEBwYXJhbSBzcGFuS2luZCAtIGtpbmQgb2YgdGhlIHNwYW46IFByb2R1Y2VyLCBDb25zdW1lciwgSW50ZXJuYWxcbiAqIEBwYXJhbSBxdWV1ZU5hbWUgLSBxdWV1ZSBuYW1lXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG5hbWUgKHN1Y2ggYXMgYWRkLCBwcm9jZXNzLCBldGMpXG4gKiBAcGFyYW0gZGVzdGluYXRpb24gLSBkZXN0aW5hdGlvbiBuYW1lIChub3JtYWxseSB0aGUgcXVldWUgbmFtZSlcbiAqIEBwYXJhbSBjYWxsYmFjayAtIGNvZGUgdG8gd3JhcCB3aXRoIHRlbGVtZXRyeVxuICogQHBhcmFtIHNyY1Byb3BhZ2F0aW9uTWVkYXRhZGEgLVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNlKHRlbGVtZXRyeSwgc3BhbktpbmQsIHF1ZXVlTmFtZSwgb3BlcmF0aW9uLCBkZXN0aW5hdGlvbiwgY2FsbGJhY2ssIHNyY1Byb3BhZ2F0aW9uTWV0YWRhdGEpIHtcbiAgICBpZiAoIXRlbGVtZXRyeSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdHJhY2VyLCBjb250ZXh0TWFuYWdlciB9ID0gdGVsZW1ldHJ5O1xuICAgICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IGNvbnRleHRNYW5hZ2VyLmFjdGl2ZSgpO1xuICAgICAgICBsZXQgcGFyZW50Q29udGV4dDtcbiAgICAgICAgaWYgKHNyY1Byb3BhZ2F0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQgPSBjb250ZXh0TWFuYWdlci5mcm9tTWV0YWRhdGEoY3VycmVudENvbnRleHQsIHNyY1Byb3BhZ2F0aW9uTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYW5OYW1lID0gZGVzdGluYXRpb24gPyBgJHtvcGVyYXRpb259ICR7ZGVzdGluYXRpb259YCA6IG9wZXJhdGlvbjtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRyYWNlci5zdGFydFNwYW4oc3Bhbk5hbWUsIHtcbiAgICAgICAgICAgIGtpbmQ6IHNwYW5LaW5kLFxuICAgICAgICB9LCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgW1RlbGVtZXRyeUF0dHJpYnV0ZXMuUXVldWVOYW1lXTogcXVldWVOYW1lLFxuICAgICAgICAgICAgICAgIFtUZWxlbWV0cnlBdHRyaWJ1dGVzLlF1ZXVlT3BlcmF0aW9uXTogb3BlcmF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgZHN0UHJvcGFnYXRpb25NZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChzcGFuS2luZCA9PT0gU3BhbktpbmQuQ09OU1VNRVIgJiYgcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VDb250ZXh0ID0gc3Bhbi5zZXRTcGFuT25Db250ZXh0KHBhcmVudENvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUNvbnRleHQgPSBzcGFuLnNldFNwYW5PbkNvbnRleHQoY3VycmVudENvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgZHN0UHJvcGFnYXRpb25NZXRhZGF0YSA9IGNvbnRleHRNYW5hZ2VyLmdldE1ldGFkYXRhKG1lc3NhZ2VDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb250ZXh0TWFuYWdlci53aXRoKG1lc3NhZ2VDb250ZXh0LCAoKSA9PiBjYWxsYmFjayhzcGFuLCBkc3RQcm9wYWdhdGlvbk1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bullmq/dist/esm/version.js":
/*!*************************************************!*\
  !*** ./node_modules/bullmq/dist/esm/version.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = '5.60.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbG1xL2Rpc3QvZXNtL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95dC1zaG9ydHNtaXRoLy4vbm9kZV9tb2R1bGVzL2J1bGxtcS9kaXN0L2VzbS92ZXJzaW9uLmpzP2ZkYzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnNS42MC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bullmq/dist/esm/version.js\n");

/***/ })

};
;